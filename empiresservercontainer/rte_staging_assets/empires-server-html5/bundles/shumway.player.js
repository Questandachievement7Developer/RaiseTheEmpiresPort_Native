/**
 * @license
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Manifest player
console.time('Load Player Dependencies');
console.time('Load Shared Dependencies');
var Shumway;
(function (Shumway) {
    Shumway.version = '0.11.622';
    Shumway.build = '16451d883';
}(Shumway || (Shumway = {})));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='references.ts' />
var jsGlobal = function () {
    return this || (1, eval)('this//# sourceURL=jsGlobal-getter');
}();
// Our polyfills for some DOM things make testing this slightly more onerous than it ought to be.
var inBrowser = typeof window !== 'undefined' && 'document' in window && 'plugins' in window.document;
var inFirefox = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Firefox') >= 0;
// declare var print;
// declare var console;
// declare var performance;
// declare var XMLHttpRequest;
// declare var document;
// declare var getComputedStyle;
/** @define {boolean} */
var release = false;
/** @define {boolean} */
var profile = false;
function dumpLine(line) {
    if (!release && typeof dump !== 'undefined') {
        dump(line + '\n');
    }
}
if (!jsGlobal.performance) {
    jsGlobal.performance = {};
}
if (!jsGlobal.performance.now) {
    jsGlobal.performance.now = function () {
        return Date.now();
    };
}
var START_TIME = performance.now();
var Shumway;
(function (Shumway) {
    /**
     * The buffer length required to contain any unsigned 32-bit integer.
     */
    /** @const */
    Shumway.UINT32_CHAR_BUFFER_LENGTH = 10;
    // "4294967295".length;
    /** @const */
    Shumway.UINT32_MAX = 4294967295;
    /** @const */
    Shumway.UINT32_MAX_DIV_10 = 429496729;
    // UINT32_MAX / 10;
    /** @const */
    Shumway.UINT32_MAX_MOD_10 = 5;
    // UINT32_MAX % 10
    function isString(value) {
        return typeof value === 'string';
    }
    Shumway.isString = isString;
    function isFunction(value) {
        return typeof value === 'function';
    }
    Shumway.isFunction = isFunction;
    function isNumber(value) {
        return typeof value === 'number';
    }
    Shumway.isNumber = isNumber;
    function isInteger(value) {
        return (value | 0) === value;
    }
    Shumway.isInteger = isInteger;
    function isArray(value) {
        return value instanceof Array;
    }
    Shumway.isArray = isArray;
    function isNumberOrString(value) {
        return typeof value === 'number' || typeof value === 'string';
    }
    Shumway.isNumberOrString = isNumberOrString;
    function isObject(value) {
        return typeof value === 'object' || typeof value === 'function';
    }
    Shumway.isObject = isObject;
    function toNumber(x) {
        return +x;
    }
    Shumway.toNumber = toNumber;
    function isNumericString(value) {
        // ECMAScript 5.1 - 9.8.1 Note 1, this expression is true for all
        // numbers x other than -0.
        return String(Number(value)) === value;
    }
    Shumway.isNumericString = isNumericString;
    /**
     * Whether the specified |value| is a number or the string representation of a number.
     */
    function isNumeric(value) {
        if (typeof value === 'number') {
            return true;
        }
        if (typeof value === 'string') {
            // |value| is rarely numeric (it's usually an identifier), and the
            // isIndex()/isNumericString() pair is slow and expensive, so we do a
            // quick check for obvious non-numericalness first. Just checking if the
            // first char is a 7-bit identifier char catches most cases.
            var c = value.charCodeAt(0);
            if (65 <= c && c <= 90 || 97 <= c && c <= 122 || c === 36 || c === 95) {
                return false;
            }
            return isIndex(value) || isNumericString(value);
        }
        return false;
    }
    Shumway.isNumeric = isNumeric;
    /**
     * Whether the specified |value| is an unsigned 32 bit number expressed as a number
     * or string.
     */
    function isIndex(value) {
        // js/src/vm/String.cpp JSFlatString::isIndexSlow
        // http://dxr.mozilla.org/mozilla-central/source/js/src/vm/String.cpp#474
        var index = 0;
        if (typeof value === 'number') {
            index = value | 0;
            if (value === index && index >= 0) {
                return true;
            }
            return value >>> 0 === value;
        }
        if (typeof value !== 'string') {
            return false;
        }
        var length = value.length;
        if (length === 0) {
            return false;
        }
        if (value === '0') {
            return true;
        }
        // Is there any way this will fit?
        if (length > Shumway.UINT32_CHAR_BUFFER_LENGTH) {
            return false;
        }
        var i = 0;
        index = value.charCodeAt(i++) - 48    /* _0 */;
        if (index < 1 || index > 9) {
            return false;
        }
        var oldIndex = 0;
        var c = 0;
        while (i < length) {
            c = value.charCodeAt(i++) - 48    /* _0 */;
            if (c < 0 || c > 9) {
                return false;
            }
            oldIndex = index;
            index = 10 * index + c;
        }
        /*
         * Look out for "4294967296" and larger-number strings that fit in UINT32_CHAR_BUFFER_LENGTH.
         * Only unsigned 32-bit integers shall pass.
         */
        if (oldIndex < Shumway.UINT32_MAX_DIV_10 || oldIndex === Shumway.UINT32_MAX_DIV_10 && c <= Shumway.UINT32_MAX_MOD_10) {
            return true;
        }
        return false;
    }
    Shumway.isIndex = isIndex;
    function isNullOrUndefined(value) {
        return value == undefined;
    }
    Shumway.isNullOrUndefined = isNullOrUndefined;
    function argumentsToString(args) {
        var resultList = [];
        for (var i = 0; i < args.length; i++) {
            var arg = args[i];
            try {
                var argStr;
                if (typeof arg !== 'object' || !arg) {
                    argStr = arg + '';
                } else if ('toString' in arg) {
                    argStr = arg.toString();
                } else {
                    argStr = Object.prototype.toString.call(arg);
                }
                resultList.push(argStr);
            } catch (e) {
                resultList.push('<unprintable value>');
            }
        }
        return resultList.join(', ');
    }
    Shumway.argumentsToString = argumentsToString;
    var Debug;
    (function (Debug) {
        function error(message) {
            console.error(message);
            throw new Error(message);
        }
        Debug.error = error;
        function assert(condition, message) {
            if (message === void 0) {
                message = 'assertion failed';
            }
            if (condition === '') {
                condition = true;
            }
            if (!condition) {
                if (typeof console !== 'undefined' && 'assert' in console) {
                    console.assert(false, message);
                    throw new Error(message);
                } else {
                    Debug.error(message.toString());
                }
            }
        }
        Debug.assert = assert;
        function assertUnreachable(msg) {
            var location = new Error().stack.split('\n')[1];
            throw new Error('Reached unreachable location ' + location + msg);
        }
        Debug.assertUnreachable = assertUnreachable;
        function assertNotImplemented(condition, message) {
            if (!condition) {
                Debug.error('notImplemented: ' + message);
            }
        }
        Debug.assertNotImplemented = assertNotImplemented;
        var _warnedCounts = Object.create(null);
        function warning(message, arg1, arg2) {
            if (release) {
                return;
            }
            var key = argumentsToString(arguments);
            if (_warnedCounts[key]) {
                _warnedCounts[key]++;
                if (Shumway.omitRepeatedWarnings.value) {
                    return;
                }
            }
            _warnedCounts[key] = 1;
            console.warn.apply(console, arguments);
        }
        Debug.warning = warning;
        function warnCounts() {
            var list = [];
            for (var key in _warnedCounts) {
                list.push({
                    key: key,
                    count: _warnedCounts[key]
                });
            }
            list.sort(function (entry, prev) {
                return prev.count - entry.count;
            });
            return list.reduce(function (result, entry) {
                return result += '\n' + entry.count + '\t' + entry.key;
            }, '');
        }
        Debug.warnCounts = warnCounts;
        function notImplemented(message) {
            release || Debug.assert(false, 'Not Implemented ' + message);
        }
        Debug.notImplemented = notImplemented;
        function dummyConstructor(message) {
            release || Debug.assert(false, 'Dummy Constructor: ' + message);
        }
        Debug.dummyConstructor = dummyConstructor;
        function abstractMethod(message) {
            release || Debug.assert(false, 'Abstract Method ' + message);
        }
        Debug.abstractMethod = abstractMethod;
        var somewhatImplementedCache = {};
        function somewhatImplemented(message) {
            if (somewhatImplementedCache[message]) {
                return;
            }
            somewhatImplementedCache[message] = true;
            Debug.warning('somewhatImplemented: ' + message);
        }
        Debug.somewhatImplemented = somewhatImplemented;
        function unexpected(message) {
            Debug.assert(false, 'Unexpected: ' + message);
        }
        Debug.unexpected = unexpected;
        function unexpectedCase(message) {
            Debug.assert(false, 'Unexpected Case: ' + message);
        }
        Debug.unexpectedCase = unexpectedCase;
    }(Debug = Shumway.Debug || (Shumway.Debug = {})));
    function getTicks() {
        return performance.now();
    }
    Shumway.getTicks = getTicks;
    var ArrayUtilities;
    (function (ArrayUtilities) {
        var assert = Shumway.Debug.assert;
        /**
         * Pops elements from a source array into a destination array. This avoids
         * allocations and should be faster. The elements in the destination array
         * are pushed in the same order as they appear in the source array:
         *
         * popManyInto([1, 2, 3], 2, dst) => dst = [2, 3]
         */
        function popManyInto(src, count, dst) {
            release || assert(src.length >= count);
            for (var i = count - 1; i >= 0; i--) {
                dst[i] = src.pop();
            }
            dst.length = count;
        }
        ArrayUtilities.popManyInto = popManyInto;
        function popMany(array, count) {
            release || assert(array.length >= count);
            var start = array.length - count;
            var result = array.slice(start, this.length);
            array.length = start;
            return result;
        }
        ArrayUtilities.popMany = popMany;
        /**
         * Just deletes several array elements from the end of the list.
         */
        function popManyIntoVoid(array, count) {
            release || assert(array.length >= count);
            array.length = array.length - count;
        }
        ArrayUtilities.popManyIntoVoid = popManyIntoVoid;
        function pushMany(dst, src) {
            for (var i = 0; i < src.length; i++) {
                dst.push(src[i]);
            }
        }
        ArrayUtilities.pushMany = pushMany;
        function top(array) {
            return array.length && array[array.length - 1];
        }
        ArrayUtilities.top = top;
        function last(array) {
            return array.length && array[array.length - 1];
        }
        ArrayUtilities.last = last;
        function peek(array) {
            release || assert(array.length > 0);
            return array[array.length - 1];
        }
        ArrayUtilities.peek = peek;
        function indexOf(array, value) {
            for (var i = 0, j = array.length; i < j; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }
        ArrayUtilities.indexOf = indexOf;
        function equals(a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        ArrayUtilities.equals = equals;
        function pushUnique(array, value) {
            for (var i = 0, j = array.length; i < j; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            array.push(value);
            return array.length - 1;
        }
        ArrayUtilities.pushUnique = pushUnique;
        function unique(array) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                pushUnique(result, array[i]);
            }
            return result;
        }
        ArrayUtilities.unique = unique;
        function copyFrom(dst, src) {
            dst.length = 0;
            ArrayUtilities.pushMany(dst, src);
        }
        ArrayUtilities.copyFrom = copyFrom;
        /**
         * Makes sure that a typed array has the requested capacity. If required, it creates a new
         * instance of the array's class with a power-of-two capacity at least as large as required.
         */
        function ensureTypedArrayCapacity(array, capacity) {
            if (array.length < capacity) {
                var oldArray = array;
                array = new array.constructor(Shumway.IntegerUtilities.nearestPowerOfTwo(capacity));
                array.set(oldArray, 0);
            }
            return array;
        }
        ArrayUtilities.ensureTypedArrayCapacity = ensureTypedArrayCapacity;
        function memCopy(destination, source, doffset, soffset, length) {
            if (doffset === void 0) {
                doffset = 0;
            }
            if (soffset === void 0) {
                soffset = 0;
            }
            if (length === void 0) {
                length = 0;
            }
            if (soffset > 0 || length > 0 && length < source.length) {
                if (length <= 0) {
                    length = source.length - soffset;
                }
                destination.set(source.subarray(soffset, soffset + length), doffset);
            } else {
                destination.set(source, doffset);
            }
        }
        ArrayUtilities.memCopy = memCopy;
    }(ArrayUtilities = Shumway.ArrayUtilities || (Shumway.ArrayUtilities = {})));
    var ObjectUtilities;
    (function (ObjectUtilities) {
        function boxValue(value) {
            if (isNullOrUndefined(value) || isObject(value)) {
                return value;
            }
            return Object(value);
        }
        ObjectUtilities.boxValue = boxValue;
        function toKeyValueArray(object) {
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var array = [];
            for (var k in object) {
                if (hasOwnProperty.call(object, k)) {
                    array.push([
                        k,
                        object[k]
                    ]);
                }
            }
            return array;
        }
        ObjectUtilities.toKeyValueArray = toKeyValueArray;
        function isPrototypeWriteable(object) {
            return Object.getOwnPropertyDescriptor(object, 'prototype').writable;
        }
        ObjectUtilities.isPrototypeWriteable = isPrototypeWriteable;
        function hasOwnProperty(object, name) {
            return Object.prototype.hasOwnProperty.call(object, name);
        }
        ObjectUtilities.hasOwnProperty = hasOwnProperty;
        function propertyIsEnumerable(object, name) {
            return Object.prototype.propertyIsEnumerable.call(object, name);
        }
        ObjectUtilities.propertyIsEnumerable = propertyIsEnumerable;
        /**
         * Returns a property descriptor for the own or inherited property with the given name, or
         * null if one doesn't exist.
         */
        function getPropertyDescriptor(object, name) {
            do {
                var propDesc = Object.getOwnPropertyDescriptor(object, name);
                if (propDesc) {
                    return propDesc;
                }
                object = Object.getPrototypeOf(object);
            } while (object);
            return null;
        }
        ObjectUtilities.getPropertyDescriptor = getPropertyDescriptor;
        function hasOwnGetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return !!(d && d.get);
        }
        ObjectUtilities.hasOwnGetter = hasOwnGetter;
        function getOwnGetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return d ? d.get : null;
        }
        ObjectUtilities.getOwnGetter = getOwnGetter;
        function hasOwnSetter(object, name) {
            var d = Object.getOwnPropertyDescriptor(object, name);
            return !!(d && !!d.set);
        }
        ObjectUtilities.hasOwnSetter = hasOwnSetter;
        function createMap() {
            return Object.create(null);
        }
        ObjectUtilities.createMap = createMap;
        function createArrayMap() {
            return [];
        }
        ObjectUtilities.createArrayMap = createArrayMap;
        function defineReadOnlyProperty(object, name, value) {
            Object.defineProperty(object, name, {
                value: value,
                writable: false,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineReadOnlyProperty = defineReadOnlyProperty;
        function copyProperties(object, template) {
            for (var property in template) {
                object[property] = template[property];
            }
        }
        ObjectUtilities.copyProperties = copyProperties;
        function copyOwnProperties(object, template) {
            for (var property in template) {
                if (hasOwnProperty(template, property)) {
                    object[property] = template[property];
                }
            }
        }
        ObjectUtilities.copyOwnProperties = copyOwnProperties;
        function copyOwnPropertyDescriptors(object, template, filter, overwrite, makeWritable) {
            if (filter === void 0) {
                filter = null;
            }
            if (overwrite === void 0) {
                overwrite = true;
            }
            if (makeWritable === void 0) {
                makeWritable = false;
            }
            for (var property in template) {
                if (hasOwnProperty(template, property) && (!filter || filter(property))) {
                    var descriptor = Object.getOwnPropertyDescriptor(template, property);
                    if (!overwrite && hasOwnProperty(object, property)) {
                        continue;
                    }
                    release || Debug.assert(descriptor);
                    try {
                        if (makeWritable && descriptor.writable === false) {
                            descriptor.writable = true;
                        }
                        Object.defineProperty(object, property, descriptor);
                    } catch (e) {
                        Debug.assert('Can\'t define: ' + property);
                    }
                }
            }
        }
        ObjectUtilities.copyOwnPropertyDescriptors = copyOwnPropertyDescriptors;
        function copyPropertiesByList(object, template, propertyList) {
            for (var i = 0; i < propertyList.length; i++) {
                var property = propertyList[i];
                object[property] = template[property];
            }
        }
        ObjectUtilities.copyPropertiesByList = copyPropertiesByList;
        function defineNonEnumerableGetter(obj, name, getter) {
            Object.defineProperty(obj, name, {
                get: getter,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineNonEnumerableGetter = defineNonEnumerableGetter;
        function defineNonEnumerableProperty(obj, name, value) {
            Object.defineProperty(obj, name, {
                value: value,
                writable: true,
                configurable: true,
                enumerable: false
            });
        }
        ObjectUtilities.defineNonEnumerableProperty = defineNonEnumerableProperty;
    }(ObjectUtilities = Shumway.ObjectUtilities || (Shumway.ObjectUtilities = {})));
    var FunctionUtilities;
    (function (FunctionUtilities) {
        function makeForwardingGetter(target) {
            return new Function('return this["' + target + '"]//# sourceURL=fwd-get-' + target + '.as');
        }
        FunctionUtilities.makeForwardingGetter = makeForwardingGetter;
        function makeForwardingSetter(target) {
            return new Function('value', 'this["' + target + '"] = value;' + '//# sourceURL=fwd-set-' + target + '.as');
        }
        FunctionUtilities.makeForwardingSetter = makeForwardingSetter;
    }(FunctionUtilities = Shumway.FunctionUtilities || (Shumway.FunctionUtilities = {})));
    var StringUtilities;
    (function (StringUtilities) {
        var assert = Shumway.Debug.assert;
        function repeatString(c, n) {
            var s = '';
            for (var i = 0; i < n; i++) {
                s += c;
            }
            return s;
        }
        StringUtilities.repeatString = repeatString;
        function memorySizeToString(value) {
            value |= 0;
            var K = 1024;
            var M = K * K;
            if (value < K) {
                return value + ' B';
            } else if (value < M) {
                return (value / K).toFixed(2) + 'KB';
            } else {
                return (value / M).toFixed(2) + 'MB';
            }
        }
        StringUtilities.memorySizeToString = memorySizeToString;
        /**
         * Returns a reasonably sized description of the |value|, to be used for debugging purposes.
         */
        function toSafeString(value) {
            if (typeof value === 'string') {
                return '"' + value + '"';
            }
            if (typeof value === 'number' || typeof value === 'boolean') {
                return String(value);
            }
            if (value instanceof Array) {
                return '[] ' + value.length;
            }
            return typeof value;
        }
        StringUtilities.toSafeString = toSafeString;
        function toSafeArrayString(array) {
            var str = [];
            for (var i = 0; i < array.length; i++) {
                str.push(toSafeString(array[i]));
            }
            return str.join(', ');
        }
        StringUtilities.toSafeArrayString = toSafeArrayString;
        function utf8decode(str) {
            var bytes = new Uint8Array(str.length * 4);
            var b = 0;
            for (var i = 0, j = str.length; i < j; i++) {
                var code = str.charCodeAt(i);
                if (code <= 127) {
                    bytes[b++] = code;
                    continue;
                }
                if (55296 <= code && code <= 56319) {
                    var codeLow = str.charCodeAt(i + 1);
                    if (56320 <= codeLow && codeLow <= 57343) {
                        // convert only when both high and low surrogates are present
                        code = ((code & 1023) << 10) + (codeLow & 1023) + 65536;
                        ++i;
                    }
                }
                if ((code & 4292870144) !== 0) {
                    bytes[b++] = 248 | code >>> 24 & 3;
                    bytes[b++] = 128 | code >>> 18 & 63;
                    bytes[b++] = 128 | code >>> 12 & 63;
                    bytes[b++] = 128 | code >>> 6 & 63;
                    bytes[b++] = 128 | code & 63;
                } else if ((code & 4294901760) !== 0) {
                    bytes[b++] = 240 | code >>> 18 & 7;
                    bytes[b++] = 128 | code >>> 12 & 63;
                    bytes[b++] = 128 | code >>> 6 & 63;
                    bytes[b++] = 128 | code & 63;
                } else if ((code & 4294965248) !== 0) {
                    bytes[b++] = 224 | code >>> 12 & 15;
                    bytes[b++] = 128 | code >>> 6 & 63;
                    bytes[b++] = 128 | code & 63;
                } else {
                    bytes[b++] = 192 | code >>> 6 & 31;
                    bytes[b++] = 128 | code & 63;
                }
            }
            return bytes.subarray(0, b);
        }
        StringUtilities.utf8decode = utf8decode;
        function utf8encode(bytes) {
            var j = 0, str = '';
            while (j < bytes.length) {
                var b1 = bytes[j++] & 255;
                if (b1 <= 127) {
                    str += String.fromCharCode(b1);
                } else {
                    var currentPrefix = 192;
                    var validBits = 5;
                    do {
                        var mask = currentPrefix >> 1 | 128;
                        if ((b1 & mask) === currentPrefix)
                            break;
                        currentPrefix = currentPrefix >> 1 | 128;
                        --validBits;
                    } while (validBits >= 0);
                    if (validBits <= 0) {
                        // Invalid UTF8 character -- copying as is
                        str += String.fromCharCode(b1);
                        continue;
                    }
                    var code = b1 & (1 << validBits) - 1;
                    var invalid = false;
                    for (var i = 5; i >= validBits; --i) {
                        var bi = bytes[j++];
                        if ((bi & 192) != 128) {
                            // Invalid UTF8 character sequence
                            invalid = true;
                            break;
                        }
                        code = code << 6 | bi & 63;
                    }
                    if (invalid) {
                        // Copying invalid sequence as is
                        for (var k = j - (7 - i); k < j; ++k) {
                            str += String.fromCharCode(bytes[k] & 255);
                        }
                        continue;
                    }
                    if (code >= 65536) {
                        str += String.fromCharCode(code - 65536 >> 10 & 1023 | 55296, code & 1023 | 56320);
                    } else {
                        str += String.fromCharCode(code);
                    }
                }
            }
            return str;
        }
        StringUtilities.utf8encode = utf8encode;
        // https://gist.github.com/958841
        function base64EncodeBytes(bytes) {
            var base64 = '';
            var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
            var byteLength = bytes.byteLength;
            var byteRemainder = byteLength % 3;
            var mainLength = byteLength - byteRemainder;
            var a, b, c, d;
            var chunk;
            // Main loop deals with bytes in chunks of 3
            for (var i = 0; i < mainLength; i = i + 3) {
                // Combine the three bytes into a single integer
                chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                // Use bitmasks to extract 6-bit segments from the triplet
                a = (chunk & 16515072) >> 18;
                // 16515072 = (2^6 - 1) << 18
                b = (chunk & 258048) >> 12;
                // 258048 = (2^6 - 1) << 12
                c = (chunk & 4032) >> 6;
                // 4032 = (2^6 - 1) << 6
                d = chunk & 63;
                // 63 = 2^6 - 1
                // Convert the raw binary segments to the appropriate ASCII encoding
                base64 += concat4(encodings[a], encodings[b], encodings[c], encodings[d]);
            }
            // Deal with the remaining bytes and padding
            if (byteRemainder == 1) {
                chunk = bytes[mainLength];
                a = (chunk & 252) >> 2;
                // 252 = (2^6 - 1) << 2
                // Set the 4 least significant bits to zero
                b = (chunk & 3) << 4;
                // 3 = 2^2 - 1
                base64 += concat3(encodings[a], encodings[b], '==');
            } else if (byteRemainder == 2) {
                chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];
                a = (chunk & 64512) >> 10;
                // 64512 = (2^6 - 1) << 10
                b = (chunk & 1008) >> 4;
                // 1008 = (2^6 - 1) << 4
                // Set the 2 least significant bits to zero
                c = (chunk & 15) << 2;
                // 15 = 2^4 - 1
                base64 += concat4(encodings[a], encodings[b], encodings[c], '=');
            }
            return base64;
        }
        StringUtilities.base64EncodeBytes = base64EncodeBytes;
        var base64DecodeMap = [
            62,
            0,
            0,
            0,
            63,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            0,
            0,
            0,
            0,
            0,
            0,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51
        ];
        var base64DecodeMapOffset = 43;
        var base64EOF = 61;
        /**
         * Decodes the result of encoding with base64EncodeBytes, but not necessarily any other
         * base64-encoded data. Note that this also doesn't do any error checking.
         */
        function decodeRestrictedBase64ToBytes(encoded) {
            var ch;
            var code;
            var code2;
            var len = encoded.length;
            var padding = encoded.charAt(len - 2) === '=' ? 2 : encoded.charAt(len - 1) === '=' ? 1 : 0;
            release || assert(encoded.length % 4 === 0);
            var decoded = new Uint8Array((encoded.length >> 2) * 3 - padding);
            for (var i = 0, j = 0; i < encoded.length;) {
                ch = encoded.charCodeAt(i++);
                code = base64DecodeMap[ch - base64DecodeMapOffset];
                ch = encoded.charCodeAt(i++);
                code2 = base64DecodeMap[ch - base64DecodeMapOffset];
                decoded[j++] = code << 2 | (code2 & 48) >> 4;
                ch = encoded.charCodeAt(i++);
                if (ch == base64EOF) {
                    return decoded;
                }
                code = base64DecodeMap[ch - base64DecodeMapOffset];
                decoded[j++] = (code2 & 15) << 4 | (code & 60) >> 2;
                ch = encoded.charCodeAt(i++);
                if (ch == base64EOF) {
                    return decoded;
                }
                code2 = base64DecodeMap[ch - base64DecodeMapOffset];
                decoded[j++] = (code & 3) << 6 | code2;
            }
            return decoded;
        }
        StringUtilities.decodeRestrictedBase64ToBytes = decodeRestrictedBase64ToBytes;
        function escapeString(str) {
            if (str !== undefined) {
                str = str.replace(/[^\w$]/gi, '$');
                /* No dots, colons, dashes and /s */
                if (/^\d/.test(str)) {
                    str = '$' + str;
                }
            }
            return str;
        }
        StringUtilities.escapeString = escapeString;
        /**
         * Workaround for max stack size limit.
         */
        function fromCharCodeArray(buffer) {
            var str = '', SLICE = 1024 * 16;
            for (var i = 0; i < buffer.length; i += SLICE) {
                var chunk = Math.min(buffer.length - i, SLICE);
                str += String.fromCharCode.apply(null, buffer.subarray(i, i + chunk));
            }
            return str;
        }
        StringUtilities.fromCharCodeArray = fromCharCodeArray;
        var _encoding = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_';
        function variableLengthEncodeInt32(n) {
            var e = _encoding;
            var bitCount = 32 - Math.clz32(n);
            release || assert(bitCount <= 32, bitCount);
            var l = Math.ceil(bitCount / 6);
            // Encode length followed by six bit chunks.
            var s = e[l];
            for (var i = l - 1; i >= 0; i--) {
                var offset = i * 6;
                s += e[n >> offset & 63];
            }
            release || assert(StringUtilities.variableLengthDecodeInt32(s) === n, n + ' : ' + s + ' - ' + l + ' bits: ' + bitCount);
            return s;
        }
        StringUtilities.variableLengthEncodeInt32 = variableLengthEncodeInt32;
        function toEncoding(n) {
            return _encoding[n];
        }
        StringUtilities.toEncoding = toEncoding;
        function fromEncoding(c) {
            if (c >= 65 && c <= 90) {
                return c - 65;
            } else if (c >= 97 && c <= 122) {
                return c - 71;
            } else if (c >= 48 && c <= 57) {
                return c + 4;
            } else if (c === 36) {
                return 62;
            } else if (c === 95) {
                return 63;
            }
            release || assert(false, 'Invalid Encoding');
        }
        StringUtilities.fromEncoding = fromEncoding;
        function variableLengthDecodeInt32(s) {
            var l = StringUtilities.fromEncoding(s.charCodeAt(0));
            var n = 0;
            for (var i = 0; i < l; i++) {
                var offset = (l - i - 1) * 6;
                n |= StringUtilities.fromEncoding(s.charCodeAt(1 + i)) << offset;
            }
            return n;
        }
        StringUtilities.variableLengthDecodeInt32 = variableLengthDecodeInt32;
        function trimMiddle(s, maxLength) {
            if (s.length <= maxLength) {
                return s;
            }
            var leftHalf = maxLength >> 1;
            var rightHalf = maxLength - leftHalf - 1;
            return s.substr(0, leftHalf) + '\u2026' + s.substr(s.length - rightHalf, rightHalf);
        }
        StringUtilities.trimMiddle = trimMiddle;
        function multiple(s, count) {
            var o = '';
            for (var i = 0; i < count; i++) {
                o += s;
            }
            return o;
        }
        StringUtilities.multiple = multiple;
        function indexOfAny(s, chars, position) {
            var index = s.length;
            for (var i = 0; i < chars.length; i++) {
                var j = s.indexOf(chars[i], position);
                if (j >= 0) {
                    index = Math.min(index, j);
                }
            }
            return index === s.length ? -1 : index;
        }
        StringUtilities.indexOfAny = indexOfAny;
        var _concat3array = new Array(3);
        var _concat4array = new Array(4);
        var _concat9array = new Array(9);
        /**
         * The concatN() functions concatenate multiple strings in a way that
         * avoids creating intermediate strings, unlike String.prototype.concat().
         *
         * Note that these functions don't have identical behaviour to using '+',
         * because they will ignore any arguments that are |undefined| or |null|.
         * This usually doesn't matter.
         */
        function concat3(s0, s1, s2) {
            _concat3array[0] = s0;
            _concat3array[1] = s1;
            _concat3array[2] = s2;
            return _concat3array.join('');
        }
        StringUtilities.concat3 = concat3;
        function concat4(s0, s1, s2, s3) {
            _concat4array[0] = s0;
            _concat4array[1] = s1;
            _concat4array[2] = s2;
            _concat4array[3] = s3;
            return _concat4array.join('');
        }
        StringUtilities.concat4 = concat4;
        function concat9(s0, s1, s2, s3, s4, s5, s6, s7, s8) {
            _concat9array[0] = s0;
            _concat9array[1] = s1;
            _concat9array[2] = s2;
            _concat9array[3] = s3;
            _concat9array[4] = s4;
            _concat9array[5] = s5;
            _concat9array[6] = s6;
            _concat9array[7] = s7;
            _concat9array[8] = s8;
            return _concat9array.join('');
        }
        StringUtilities.concat9 = concat9;
    }(StringUtilities = Shumway.StringUtilities || (Shumway.StringUtilities = {})));
    var HashUtilities;
    (function (HashUtilities) {
        var _md5R = new Uint8Array([
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21
        ]);
        var _md5K = new Int32Array([
            -680876936,
            -389564586,
            606105819,
            -1044525330,
            -176418897,
            1200080426,
            -1473231341,
            -45705983,
            1770035416,
            -1958414417,
            -42063,
            -1990404162,
            1804603682,
            -40341101,
            -1502002290,
            1236535329,
            -165796510,
            -1069501632,
            643717713,
            -373897302,
            -701558691,
            38016083,
            -660478335,
            -405537848,
            568446438,
            -1019803690,
            -187363961,
            1163531501,
            -1444681467,
            -51403784,
            1735328473,
            -1926607734,
            -378558,
            -2022574463,
            1839030562,
            -35309556,
            -1530992060,
            1272893353,
            -155497632,
            -1094730640,
            681279174,
            -358537222,
            -722521979,
            76029189,
            -640364487,
            -421815835,
            530742520,
            -995338651,
            -198630844,
            1126891415,
            -1416354905,
            -57434055,
            1700485571,
            -1894986606,
            -1051523,
            -2054922799,
            1873313359,
            -30611744,
            -1560198380,
            1309151649,
            -145523070,
            -1120210379,
            718787259,
            -343485551
        ]);
        function hashBytesTo32BitsMD5(data, offset, length) {
            var r = _md5R;
            var k = _md5K;
            var h0 = 1732584193, h1 = -271733879, h2 = -1732584194, h3 = 271733878;
            // pre-processing
            var paddedLength = length + 72 & ~63;
            // data + 9 extra bytes
            var padded = new Uint8Array(paddedLength);
            var i, j, n;
            for (i = 0; i < length; ++i) {
                padded[i] = data[offset++];
            }
            padded[i++] = 128;
            n = paddedLength - 8;
            while (i < n) {
                padded[i++] = 0;
            }
            padded[i++] = length << 3 & 255;
            padded[i++] = length >> 5 & 255;
            padded[i++] = length >> 13 & 255;
            padded[i++] = length >> 21 & 255;
            padded[i++] = length >>> 29 & 255;
            padded[i++] = 0;
            padded[i++] = 0;
            padded[i++] = 0;
            // chunking
            // TODO ArrayBuffer ?
            var w = new Int32Array(16);
            for (i = 0; i < paddedLength;) {
                for (j = 0; j < 16; ++j, i += 4) {
                    w[j] = padded[i] | padded[i + 1] << 8 | padded[i + 2] << 16 | padded[i + 3] << 24;
                }
                var a = h0, b = h1, c = h2, d = h3, f, g;
                for (j = 0; j < 64; ++j) {
                    if (j < 16) {
                        f = b & c | ~b & d;
                        g = j;
                    } else if (j < 32) {
                        f = d & b | ~d & c;
                        g = 5 * j + 1 & 15;
                    } else if (j < 48) {
                        f = b ^ c ^ d;
                        g = 3 * j + 5 & 15;
                    } else {
                        f = c ^ (b | ~d);
                        g = 7 * j & 15;
                    }
                    var tmp = d, rotateArg = a + f + k[j] + w[g] | 0, rotate = r[j];
                    d = c;
                    c = b;
                    b = b + (rotateArg << rotate | rotateArg >>> 32 - rotate) | 0;
                    a = tmp;
                }
                h0 = h0 + a | 0;
                h1 = h1 + b | 0;
                h2 = h2 + c | 0;
                h3 = h3 + d | 0;
            }
            return h0;
        }
        HashUtilities.hashBytesTo32BitsMD5 = hashBytesTo32BitsMD5;
        function mixHash(a, b) {
            return (31 * a | 0) + b | 0;
        }
        HashUtilities.mixHash = mixHash;
    }(HashUtilities = Shumway.HashUtilities || (Shumway.HashUtilities = {})));
    /**
     * An extremely naive cache with a maximum size.
     * TODO: LRU
     */
    var Cache = function () {
        function Cache(maxSize) {
            this._data = Object.create(null);
            this._size = 0;
            this._maxSize = maxSize;
        }
        Cache.prototype.get = function (key) {
            return this._data[key];
        };
        Cache.prototype.set = function (key, value) {
            release || Debug.assert(!(key in this._data));
            // Cannot mutate cache entries.
            if (this._size >= this._maxSize) {
                return false;
            }
            this._data[key] = value;
            this._size++;
            return true;
        };
        return Cache;
    }();
    Shumway.Cache = Cache;
    /**
     * Marsaglia's algorithm, adapted from V8. Use this if you want a deterministic random number.
     */
    var Random = function () {
        function Random() {
        }
        Random.seed = function (seed) {
            Random._state[0] = seed;
            Random._state[1] = seed;
        };
        Random.reset = function () {
            Random._state[0] = 57005;
            Random._state[1] = 48879;
        };
        Random.next = function () {
            var s = this._state;
            var r0 = Math.imul(18273, s[0] & 65535) + (s[0] >>> 16) | 0;
            s[0] = r0;
            var r1 = Math.imul(36969, s[1] & 65535) + (s[1] >>> 16) | 0;
            s[1] = r1;
            var x = (r0 << 16) + (r1 & 65535) | 0;
            // Division by 0x100000000 through multiplication by reciprocal.
            return (x < 0 ? x + 4294967296 : x) * 2.3283064365386963e-10;
        };
        Random._state = new Uint32Array([
            57005,
            48879
        ]);
        return Random;
    }();
    Shumway.Random = Random;
    Math.random = function random() {
        return Random.next();
    };
    /**
     * This should only be called if you need fake time.
     */
    function installTimeWarper() {
        var RealDate = Date;
        // Go back in time.
        var fakeTime = 1428107694580;
        // 3-Apr-2015
        // Overload
        jsGlobal.Date = function (yearOrTimevalue, month, date, hour, minute, second, millisecond) {
            switch (arguments.length) {
            case 0:
                return new RealDate(fakeTime);
            case 1:
                return new RealDate(yearOrTimevalue);
            case 2:
                return new RealDate(yearOrTimevalue, month);
            case 3:
                return new RealDate(yearOrTimevalue, month, date);
            case 4:
                return new RealDate(yearOrTimevalue, month, date, hour);
            case 5:
                return new RealDate(yearOrTimevalue, month, date, hour, minute);
            case 6:
                return new RealDate(yearOrTimevalue, month, date, hour, minute, second);
            default:
                return new RealDate(yearOrTimevalue, month, date, hour, minute, second, millisecond);
            }
        };
        // Make date now deterministic.
        jsGlobal.Date.now = function () {
            return fakeTime += 10;    // Advance time.
        };
        jsGlobal.Date.UTC = function () {
            return RealDate.UTC.apply(RealDate, arguments);
        };
    }
    Shumway.installTimeWarper = installTimeWarper;
    function polyfillWeakMap() {
        if (typeof jsGlobal.WeakMap === 'function') {
            return;    // weak map is supported
        }
        var id = 0;
        function WeakMap() {
            this.id = '$weakmap' + id++;
        }
        ;
        WeakMap.prototype = {
            has: function (obj) {
                return obj.hasOwnProperty(this.id);
            },
            get: function (obj, defaultValue) {
                return obj.hasOwnProperty(this.id) ? obj[this.id] : defaultValue;
            },
            set: function (obj, value) {
                Object.defineProperty(obj, this.id, {
                    value: value,
                    enumerable: false,
                    configurable: true
                });
            },
            delete: function (obj) {
                delete obj[this.id];
            }
        };
        jsGlobal.WeakMap = WeakMap;
    }
    polyfillWeakMap();
    var useReferenceCounting = true;
    var WeakList = function () {
        function WeakList() {
            if (typeof ShumwayCom !== 'undefined' && ShumwayCom.getWeakMapKeys) {
                this._map = new WeakMap();
                this._id = 0;
                this._newAdditions = [];
            } else {
                this._list = [];
            }
        }
        WeakList.prototype.clear = function () {
            if (this._map) {
                this._map.clear();
            } else {
                this._list.length = 0;
            }
        };
        WeakList.prototype.push = function (value) {
            if (this._map) {
                release || Debug.assert(!this._map.has(value));
                // We store an increasing id as the value so that keys can be sorted by it.
                this._map.set(value, this._id++);
                this._newAdditions.forEach(function (additions) {
                    additions.push(value);
                });
            } else {
                release || Debug.assert(this._list.indexOf(value) === -1);
                this._list.push(value);
            }
        };
        WeakList.prototype.remove = function (value) {
            if (this._map) {
                release || Debug.assert(this._map.has(value));
                this._map.delete(value);
            } else {
                release || Debug.assert(this._list.indexOf(value) > -1);
                this._list[this._list.indexOf(value)] = null;
                release || Debug.assert(this._list.indexOf(value) === -1);
            }
        };
        WeakList.prototype.forEach = function (callback) {
            if (this._map) {
                var newAdditionsToKeys = [];
                this._newAdditions.push(newAdditionsToKeys);
                var map = this._map;
                var keys = ShumwayCom.getWeakMapKeys(map);
                // The keys returned by ShumwayCom.getWeakMapKeys are not guaranteed to
                // be in insertion order. Therefore we have to sort them manually.
                keys.sort(function (a, b) {
                    return map.get(a) - map.get(b);
                });
                keys.forEach(function (value) {
                    if (value._referenceCount !== 0) {
                        callback(value);
                    }
                });
                // ShumwayCom.getWeakMapKeys take snapshot of the keys, but we are also
                // interested in new added keys while keys.forEach was run.
                newAdditionsToKeys.forEach(function (value) {
                    if (value._referenceCount !== 0) {
                        callback(value);
                    }
                });
                this._newAdditions.splice(this._newAdditions.indexOf(newAdditionsToKeys), 1);
                return;
            }
            var list = this._list;
            var zeroCount = 0;
            for (var i = 0; i < list.length; i++) {
                var value = list[i];
                if (!value) {
                    continue;
                }
                if (useReferenceCounting && value._referenceCount === 0) {
                    list[i] = null;
                    zeroCount++;
                } else {
                    callback(value);
                }
            }
            if (zeroCount > 16 && zeroCount > list.length >> 2) {
                var newList = [];
                for (var i = 0; i < list.length; i++) {
                    var value = list[i];
                    if (value && value._referenceCount > 0) {
                        newList.push(value);
                    }
                }
                this._list = newList;
            }
        };
        Object.defineProperty(WeakList.prototype, 'length', {
            get: function () {
                if (this._map) {
                    // TODO: Implement this.
                    return -1;
                } else {
                    return this._list.length;
                }
            },
            enumerable: true,
            configurable: true
        });
        return WeakList;
    }();
    Shumway.WeakList = WeakList;
    var NumberUtilities;
    (function (NumberUtilities) {
        function pow2(exponent) {
            if (exponent === (exponent | 0)) {
                if (exponent < 0) {
                    return 1 / (1 << -exponent);
                }
                return 1 << exponent;
            }
            return Math.pow(2, exponent);
        }
        NumberUtilities.pow2 = pow2;
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        NumberUtilities.clamp = clamp;
        /**
         * Rounds *.5 to the nearest even number.
         * See https://en.wikipedia.org/wiki/Rounding#Round_half_to_even for details.
         */
        function roundHalfEven(value) {
            if (Math.abs(value % 1) === 0.5) {
                var floor = Math.floor(value);
                return floor % 2 === 0 ? floor : Math.ceil(value);
            }
            return Math.round(value);
        }
        NumberUtilities.roundHalfEven = roundHalfEven;
        /**
         * Rounds *.5 up on even occurrences, down on odd occurrences.
         * See https://en.wikipedia.org/wiki/Rounding#Alternating_tie-breaking for details.
         */
        function altTieBreakRound(value, even) {
            if (Math.abs(value % 1) === 0.5 && !even) {
                return value | 0;
            }
            return Math.round(value);
        }
        NumberUtilities.altTieBreakRound = altTieBreakRound;
        function epsilonEquals(value, other) {
            return Math.abs(value - other) < 1e-7;
        }
        NumberUtilities.epsilonEquals = epsilonEquals;
    }(NumberUtilities = Shumway.NumberUtilities || (Shumway.NumberUtilities = {})));
    var IntegerUtilities;
    (function (IntegerUtilities) {
        var sharedBuffer = new ArrayBuffer(8);
        IntegerUtilities.i8 = new Int8Array(sharedBuffer);
        IntegerUtilities.u8 = new Uint8Array(sharedBuffer);
        IntegerUtilities.i32 = new Int32Array(sharedBuffer);
        IntegerUtilities.f32 = new Float32Array(sharedBuffer);
        IntegerUtilities.f64 = new Float64Array(sharedBuffer);
        IntegerUtilities.nativeLittleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;
        /**
         * Convert a float into 32 bits.
         */
        function floatToInt32(v) {
            IntegerUtilities.f32[0] = v;
            return IntegerUtilities.i32[0];
        }
        IntegerUtilities.floatToInt32 = floatToInt32;
        /**
         * Convert 32 bits into a float.
         */
        function int32ToFloat(i) {
            IntegerUtilities.i32[0] = i;
            return IntegerUtilities.f32[0];
        }
        IntegerUtilities.int32ToFloat = int32ToFloat;
        /**
         * Swap the bytes of a 16 bit number.
         */
        function swap16(i) {
            return (i & 255) << 8 | i >> 8 & 255;
        }
        IntegerUtilities.swap16 = swap16;
        /**
         * Swap the bytes of a 32 bit number.
         */
        function swap32(i) {
            return (i & 255) << 24 | (i & 65280) << 8 | i >> 8 & 65280 | i >> 24 & 255;
        }
        IntegerUtilities.swap32 = swap32;
        /**
         * Converts a number to s8.u8 fixed point representation.
         */
        function toS8U8(v) {
            return v * 256 << 16 >> 16;
        }
        IntegerUtilities.toS8U8 = toS8U8;
        /**
         * Converts a number from s8.u8 fixed point representation.
         */
        function fromS8U8(i) {
            return i / 256;
        }
        IntegerUtilities.fromS8U8 = fromS8U8;
        /**
         * Round trips a number through s8.u8 conversion.
         */
        function clampS8U8(v) {
            return fromS8U8(toS8U8(v));
        }
        IntegerUtilities.clampS8U8 = clampS8U8;
        /**
         * Converts a number to signed 16 bits.
         */
        function toS16(v) {
            return v << 16 >> 16;
        }
        IntegerUtilities.toS16 = toS16;
        function bitCount(i) {
            i = i - (i >> 1 & 1431655765);
            i = (i & 858993459) + (i >> 2 & 858993459);
            return (i + (i >> 4) & 252645135) * 16843009 >> 24;
        }
        IntegerUtilities.bitCount = bitCount;
        function ones(i) {
            i = i - (i >> 1 & 1431655765);
            i = (i & 858993459) + (i >> 2 & 858993459);
            return (i + (i >> 4) & 252645135) * 16843009 >> 24;
        }
        IntegerUtilities.ones = ones;
        function trailingZeros(i) {
            return IntegerUtilities.ones((i & -i) - 1);
        }
        IntegerUtilities.trailingZeros = trailingZeros;
        function getFlags(i, flags) {
            var str = '';
            for (var i = 0; i < flags.length; i++) {
                if (i & 1 << i) {
                    str += flags[i] + ' ';
                }
            }
            if (str.length === 0) {
                return '';
            }
            return str.trim();
        }
        IntegerUtilities.getFlags = getFlags;
        function isPowerOfTwo(x) {
            return x && (x & x - 1) === 0;
        }
        IntegerUtilities.isPowerOfTwo = isPowerOfTwo;
        function roundToMultipleOfFour(x) {
            return x + 3 & ~3;
        }
        IntegerUtilities.roundToMultipleOfFour = roundToMultipleOfFour;
        function nearestPowerOfTwo(x) {
            x--;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            x++;
            return x;
        }
        IntegerUtilities.nearestPowerOfTwo = nearestPowerOfTwo;
        function roundToMultipleOfPowerOfTwo(i, powerOfTwo) {
            var x = (1 << powerOfTwo) - 1;
            return i + x & ~x;    // Round up to multiple of power of two.
        }
        IntegerUtilities.roundToMultipleOfPowerOfTwo = roundToMultipleOfPowerOfTwo;
        function toHEX(i) {
            var i = i < 0 ? 4294967295 + i + 1 : i;
            return '0x' + ('00000000' + i.toString(16)).substr(-8);
        }
        IntegerUtilities.toHEX = toHEX;
        /**
         * Polyfill imul.
         */
        if (!Math.imul) {
            Math.imul = function imul(a, b) {
                var ah = a >>> 16 & 65535;
                var al = a & 65535;
                var bh = b >>> 16 & 65535;
                var bl = b & 65535;
                // the shift by 0 fixes the sign on the high part
                // the final |0 converts the unsigned value into a signed value
                return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
            };
        }
        /**
         * Polyfill clz32.
         */
        if (!Math.clz32) {
            Math.clz32 = function clz32(i) {
                i |= i >> 1;
                i |= i >> 2;
                i |= i >> 4;
                i |= i >> 8;
                i |= i >> 16;
                return 32 - IntegerUtilities.ones(i);
            };
        }
    }(IntegerUtilities = Shumway.IntegerUtilities || (Shumway.IntegerUtilities = {})));
    var IndentingWriter = function () {
        function IndentingWriter(suppressOutput, out) {
            if (suppressOutput === void 0) {
                suppressOutput = false;
            }
            this._tab = '  ';
            this._padding = '';
            this._suppressOutput = suppressOutput;
            this._out = out || IndentingWriter._consoleOut;
            this._outNoNewline = out || IndentingWriter._consoleOutNoNewline;
        }
        Object.defineProperty(IndentingWriter.prototype, 'suppressOutput', {
            get: function () {
                return this._suppressOutput;
            },
            set: function (val) {
                this._suppressOutput = val;
            },
            enumerable: true,
            configurable: true
        });
        IndentingWriter.prototype.write = function (str, writePadding) {
            if (str === void 0) {
                str = '';
            }
            if (writePadding === void 0) {
                writePadding = false;
            }
            if (!this._suppressOutput) {
                this._outNoNewline((writePadding ? this._padding : '') + str);
            }
        };
        IndentingWriter.prototype.writeLn = function (str) {
            if (str === void 0) {
                str = '';
            }
            if (!this._suppressOutput) {
                this._out(this._padding + str);
            }
        };
        IndentingWriter.prototype.writeObject = function (str, object) {
            if (str === void 0) {
                str = '';
            }
            if (!this._suppressOutput) {
                this._out(this._padding + str, object);
            }
        };
        IndentingWriter.prototype.writeTimeLn = function (str) {
            if (str === void 0) {
                str = '';
            }
            if (!this._suppressOutput) {
                this._out(this._padding + performance.now().toFixed(2) + ' ' + str);
            }
        };
        IndentingWriter.prototype.writeComment = function (str) {
            var lines = (str || '').split('\n');
            if (lines.length === 1) {
                this.writeLn('// ' + lines[0]);
            } else {
                this.writeLn('/**');
                for (var i = 0; i < lines.length; i++) {
                    this.writeLn(' * ' + lines[i]);
                }
                this.writeLn(' */');
            }
        };
        IndentingWriter.prototype.writeLns = function (str) {
            var lines = (str || '').split('\n');
            for (var i = 0; i < lines.length; i++) {
                this.writeLn(lines[i]);
            }
        };
        IndentingWriter.prototype.errorLn = function (str) {
            if (IndentingWriter.logLevel & 1    /* Error */) {
                this.boldRedLn(str);
            }
        };
        IndentingWriter.prototype.warnLn = function (str) {
            if (IndentingWriter.logLevel & 2    /* Warn */) {
                this.yellowLn(str);
            }
        };
        IndentingWriter.prototype.debugLn = function (str) {
            if (IndentingWriter.logLevel & 4    /* Debug */) {
                this.purpleLn(str);
            }
        };
        IndentingWriter.prototype.logLn = function (str) {
            if (IndentingWriter.logLevel & 8    /* Log */) {
                this.writeLn(str);
            }
        };
        IndentingWriter.prototype.infoLn = function (str) {
            if (IndentingWriter.logLevel & 16    /* Info */) {
                this.writeLn(str);
            }
        };
        IndentingWriter.prototype.yellowLn = function (str) {
            this.colorLn(IndentingWriter.YELLOW, str);
        };
        IndentingWriter.prototype.greenLn = function (str) {
            this.colorLn(IndentingWriter.GREEN, str);
        };
        IndentingWriter.prototype.boldRedLn = function (str) {
            this.colorLn(IndentingWriter.BOLD_RED, str);
        };
        IndentingWriter.prototype.redLn = function (str) {
            this.colorLn(IndentingWriter.RED, str);
        };
        IndentingWriter.prototype.purpleLn = function (str) {
            this.colorLn(IndentingWriter.PURPLE, str);
        };
        IndentingWriter.prototype.colorLn = function (color, str) {
            if (!this._suppressOutput) {
                if (!inBrowser) {
                    this._out(this._padding + color + str + IndentingWriter.ENDC);
                } else {
                    this._out(this._padding + str);
                }
            }
        };
        IndentingWriter.prototype.redLns = function (str) {
            this.colorLns(IndentingWriter.RED, str);
        };
        IndentingWriter.prototype.colorLns = function (color, str) {
            var lines = (str || '').split('\n');
            for (var i = 0; i < lines.length; i++) {
                this.colorLn(color, lines[i]);
            }
        };
        IndentingWriter.prototype.enter = function (str) {
            if (!this._suppressOutput) {
                this._out(this._padding + str);
            }
            this.indent();
        };
        IndentingWriter.prototype.leaveAndEnter = function (str) {
            this.leave(str);
            this.indent();
        };
        IndentingWriter.prototype.leave = function (str) {
            this.outdent();
            if (!this._suppressOutput && str) {
                this._out(this._padding + str);
            }
        };
        IndentingWriter.prototype.indent = function () {
            this._padding += this._tab;
        };
        IndentingWriter.prototype.outdent = function () {
            if (this._padding.length > 0) {
                this._padding = this._padding.substring(0, this._padding.length - this._tab.length);
            }
        };
        IndentingWriter.prototype.writeArray = function (arr, detailed, noNumbers) {
            if (detailed === void 0) {
                detailed = false;
            }
            if (noNumbers === void 0) {
                noNumbers = false;
            }
            detailed = detailed || false;
            for (var i = 0, j = arr.length; i < j; i++) {
                var prefix = '';
                if (detailed) {
                    if (arr[i] === null) {
                        prefix = 'null';
                    } else if (arr[i] === undefined) {
                        prefix = 'undefined';
                    } else {
                        prefix = arr[i].constructor.name;
                    }
                    prefix += ' ';
                }
                var number = noNumbers ? '' : ('' + i).padRight(' ', 4);
                this.writeLn(number + prefix + arr[i]);
            }
        };
        IndentingWriter.PURPLE = '\x1B[94m';
        IndentingWriter.YELLOW = '\x1B[93m';
        IndentingWriter.GREEN = '\x1B[92m';
        IndentingWriter.RED = '\x1B[91m';
        IndentingWriter.BOLD_RED = '\x1B[1;91m';
        IndentingWriter.ENDC = '\x1B[0m';
        IndentingWriter.logLevel = 31    /* All */;
        IndentingWriter._consoleOut = console.log.bind(console);
        IndentingWriter._consoleOutNoNewline = console.log.bind(console);
        return IndentingWriter;
    }();
    Shumway.IndentingWriter = IndentingWriter;
    var CircularBuffer = function () {
        function CircularBuffer(Type, sizeInBits) {
            if (sizeInBits === void 0) {
                sizeInBits = 12;
            }
            this.index = 0;
            this.start = 0;
            this._size = 1 << sizeInBits;
            this._mask = this._size - 1;
            this.array = new Type(this._size);
        }
        CircularBuffer.prototype.get = function (i) {
            return this.array[i];
        };
        CircularBuffer.prototype.forEachInReverse = function (visitor) {
            if (this.isEmpty()) {
                return;
            }
            var i = this.index === 0 ? this._size - 1 : this.index - 1;
            var end = this.start - 1 & this._mask;
            while (i !== end) {
                if (visitor(this.array[i], i)) {
                    break;
                }
                i = i === 0 ? this._size - 1 : i - 1;
            }
        };
        CircularBuffer.prototype.write = function (value) {
            this.array[this.index] = value;
            this.index = this.index + 1 & this._mask;
            if (this.index === this.start) {
                this.start = this.start + 1 & this._mask;
            }
        };
        CircularBuffer.prototype.isFull = function () {
            return (this.index + 1 & this._mask) === this.start;
        };
        CircularBuffer.prototype.isEmpty = function () {
            return this.index === this.start;
        };
        CircularBuffer.prototype.reset = function () {
            this.index = 0;
            this.start = 0;
        };
        return CircularBuffer;
    }();
    Shumway.CircularBuffer = CircularBuffer;
    var ColorStyle = function () {
        function ColorStyle() {
        }
        ColorStyle.randomStyle = function () {
            if (!ColorStyle._randomStyleCache) {
                ColorStyle._randomStyleCache = [
                    '#ff5e3a',
                    '#ff9500',
                    '#ffdb4c',
                    '#87fc70',
                    '#52edc7',
                    '#1ad6fd',
                    '#c644fc',
                    '#ef4db6',
                    '#4a4a4a',
                    '#dbddde',
                    '#ff3b30',
                    '#ff9500',
                    '#ffcc00',
                    '#4cd964',
                    '#34aadc',
                    '#007aff',
                    '#5856d6',
                    '#ff2d55',
                    '#8e8e93',
                    '#c7c7cc',
                    '#5ad427',
                    '#c86edf',
                    '#d1eefc',
                    '#e0f8d8',
                    '#fb2b69',
                    '#f7f7f7',
                    '#1d77ef',
                    '#d6cec3',
                    '#55efcb',
                    '#ff4981',
                    '#ffd3e0',
                    '#f7f7f7',
                    '#ff1300',
                    '#1f1f21',
                    '#bdbec2',
                    '#ff3a2d'
                ];
            }
            return ColorStyle._randomStyleCache[ColorStyle._nextStyle++ % ColorStyle._randomStyleCache.length];
        };
        ColorStyle.gradientColor = function (value) {
            return ColorStyle._gradient[ColorStyle._gradient.length * NumberUtilities.clamp(value, 0, 1) | 0];
        };
        ColorStyle.contrastStyle = function (rgb) {
            // http://www.w3.org/TR/AERT#color-contrast
            var c = parseInt(rgb.substr(1), 16);
            var yiq = ((c >> 16) * 299 + (c >> 8 & 255) * 587 + (c & 255) * 114) / 1000;
            return yiq >= 128 ? '#000000' : '#ffffff';
        };
        ColorStyle.reset = function () {
            ColorStyle._nextStyle = 0;
        };
        ColorStyle.TabToolbar = '#252c33';
        ColorStyle.Toolbars = '#343c45';
        ColorStyle.HighlightBlue = '#1d4f73';
        ColorStyle.LightText = '#f5f7fa';
        ColorStyle.ForegroundText = '#b6babf';
        ColorStyle.Black = '#000000';
        ColorStyle.VeryDark = '#14171a';
        ColorStyle.Dark = '#181d20';
        ColorStyle.Light = '#a9bacb';
        ColorStyle.Grey = '#8fa1b2';
        ColorStyle.DarkGrey = '#5f7387';
        ColorStyle.Blue = '#46afe3';
        ColorStyle.Purple = '#6b7abb';
        ColorStyle.Pink = '#df80ff';
        ColorStyle.Red = '#eb5368';
        ColorStyle.Orange = '#d96629';
        ColorStyle.LightOrange = '#d99b28';
        ColorStyle.Green = '#70bf53';
        ColorStyle.BlueGrey = '#5e88b0';
        ColorStyle._nextStyle = 0;
        ColorStyle._gradient = [
            '#FF0000',
            '#FF1100',
            '#FF2300',
            '#FF3400',
            '#FF4600',
            '#FF5700',
            '#FF6900',
            '#FF7B00',
            '#FF8C00',
            '#FF9E00',
            '#FFAF00',
            '#FFC100',
            '#FFD300',
            '#FFE400',
            '#FFF600',
            '#F7FF00',
            '#E5FF00',
            '#D4FF00',
            '#C2FF00',
            '#B0FF00',
            '#9FFF00',
            '#8DFF00',
            '#7CFF00',
            '#6AFF00',
            '#58FF00',
            '#47FF00',
            '#35FF00',
            '#24FF00',
            '#12FF00',
            '#00FF00'    // Green
        ];
        return ColorStyle;
    }();
    Shumway.ColorStyle = ColorStyle;
    /**
     * Faster release version of bounds.
     */
    var Bounds = function () {
        function Bounds(xMin, yMin, xMax, yMax) {
            this.xMin = xMin | 0;
            this.yMin = yMin | 0;
            this.xMax = xMax | 0;
            this.yMax = yMax | 0;
        }
        Bounds.FromUntyped = function (source) {
            return new Bounds(source.xMin, source.yMin, source.xMax, source.yMax);
        };
        Bounds.FromRectangle = function (source) {
            return new Bounds(source.x * 20 | 0, source.y * 20 | 0, (source.x + source.width) * 20 | 0, (source.y + source.height) * 20 | 0);
        };
        Bounds.prototype.setElements = function (xMin, yMin, xMax, yMax) {
            this.xMin = xMin;
            this.yMin = yMin;
            this.xMax = xMax;
            this.yMax = yMax;
        };
        Bounds.prototype.copyFrom = function (source) {
            this.setElements(source.xMin, source.yMin, source.xMax, source.yMax);
        };
        Bounds.prototype.contains = function (x, y) {
            return x < this.xMin !== x < this.xMax && y < this.yMin !== y < this.yMax;
        };
        Bounds.prototype.unionInPlace = function (other) {
            if (other.isEmpty()) {
                return;
            }
            this.extendByPoint(other.xMin, other.yMin);
            this.extendByPoint(other.xMax, other.yMax);
        };
        Bounds.prototype.extendByPoint = function (x, y) {
            this.extendByX(x);
            this.extendByY(y);
        };
        Bounds.prototype.extendByX = function (x) {
            // Exclude default values.
            if (this.xMin === 134217728) {
                this.xMin = this.xMax = x;
                return;
            }
            this.xMin = Math.min(this.xMin, x);
            this.xMax = Math.max(this.xMax, x);
        };
        Bounds.prototype.extendByY = function (y) {
            // Exclude default values.
            if (this.yMin === 134217728) {
                this.yMin = this.yMax = y;
                return;
            }
            this.yMin = Math.min(this.yMin, y);
            this.yMax = Math.max(this.yMax, y);
        };
        Bounds.prototype.intersects = function (toIntersect) {
            return this.contains(toIntersect.xMin, toIntersect.yMin) || this.contains(toIntersect.xMax, toIntersect.yMax);
        };
        Bounds.prototype.isEmpty = function () {
            return this.xMax <= this.xMin || this.yMax <= this.yMin;
        };
        Object.defineProperty(Bounds.prototype, 'width', {
            get: function () {
                return this.xMax - this.xMin;
            },
            set: function (value) {
                this.xMax = this.xMin + value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Bounds.prototype, 'height', {
            get: function () {
                return this.yMax - this.yMin;
            },
            set: function (value) {
                this.yMax = this.yMin + value;
            },
            enumerable: true,
            configurable: true
        });
        Bounds.prototype.getBaseWidth = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return u * (this.xMax - this.xMin) + v * (this.yMax - this.yMin);
        };
        Bounds.prototype.getBaseHeight = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return v * (this.xMax - this.xMin) + u * (this.yMax - this.yMin);
        };
        Bounds.prototype.setEmpty = function () {
            this.xMin = this.yMin = this.xMax = this.yMax = 0;
        };
        /**
         * Set all fields to the sentinel value 0x8000000.
         *
         * This is what Flash uses to indicate uninitialized bounds. Important for bounds calculation
         * in `Graphics` instances, which start out with empty bounds but must not just extend them
         * from an 0,0 origin.
         */
        Bounds.prototype.setToSentinels = function () {
            this.xMin = this.yMin = this.xMax = this.yMax = 134217728;
        };
        Bounds.prototype.clone = function () {
            return new Bounds(this.xMin, this.yMin, this.xMax, this.yMax);
        };
        Bounds.prototype.toString = function () {
            return '{ ' + 'xMin: ' + this.xMin + ', ' + 'xMin: ' + this.yMin + ', ' + 'xMax: ' + this.xMax + ', ' + 'xMax: ' + this.yMax + ' }';
        };
        return Bounds;
    }();
    Shumway.Bounds = Bounds;
    /**
     * Slower debug version of bounds, makes sure that all points have integer coordinates.
     */
    var DebugBounds = function () {
        function DebugBounds(xMin, yMin, xMax, yMax) {
            Debug.assert(isInteger(xMin));
            Debug.assert(isInteger(yMin));
            Debug.assert(isInteger(xMax));
            Debug.assert(isInteger(yMax));
            this._xMin = xMin | 0;
            this._yMin = yMin | 0;
            this._xMax = xMax | 0;
            this._yMax = yMax | 0;
            this.assertValid();
        }
        DebugBounds.FromUntyped = function (source) {
            return new DebugBounds(source.xMin, source.yMin, source.xMax, source.yMax);
        };
        DebugBounds.FromRectangle = function (source) {
            return new DebugBounds(source.x * 20 | 0, source.y * 20 | 0, (source.x + source.width) * 20 | 0, (source.y + source.height) * 20 | 0);
        };
        DebugBounds.prototype.setElements = function (xMin, yMin, xMax, yMax) {
            this.xMin = xMin;
            this.yMin = yMin;
            this.xMax = xMax;
            this.yMax = yMax;
        };
        DebugBounds.prototype.copyFrom = function (source) {
            this.setElements(source.xMin, source.yMin, source.xMax, source.yMax);
        };
        DebugBounds.prototype.contains = function (x, y) {
            return x < this.xMin !== x < this.xMax && y < this.yMin !== y < this.yMax;
        };
        DebugBounds.prototype.unionInPlace = function (other) {
            if (other.isEmpty()) {
                return;
            }
            this.extendByPoint(other.xMin, other.yMin);
            this.extendByPoint(other.xMax, other.yMax);
        };
        DebugBounds.prototype.extendByPoint = function (x, y) {
            this.extendByX(x);
            this.extendByY(y);
        };
        DebugBounds.prototype.extendByX = function (x) {
            if (this.xMin === 134217728) {
                this.xMin = this.xMax = x;
                return;
            }
            this.xMin = Math.min(this.xMin, x);
            this.xMax = Math.max(this.xMax, x);
        };
        DebugBounds.prototype.extendByY = function (y) {
            if (this.yMin === 134217728) {
                this.yMin = this.yMax = y;
                return;
            }
            this.yMin = Math.min(this.yMin, y);
            this.yMax = Math.max(this.yMax, y);
        };
        DebugBounds.prototype.intersects = function (toIntersect) {
            return this.contains(toIntersect._xMin, toIntersect._yMin) || this.contains(toIntersect._xMax, toIntersect._yMax);
        };
        DebugBounds.prototype.isEmpty = function () {
            return this._xMax <= this._xMin || this._yMax <= this._yMin;
        };
        Object.defineProperty(DebugBounds.prototype, 'xMin', {
            get: function () {
                return this._xMin;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._xMin = value;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, 'yMin', {
            get: function () {
                return this._yMin;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._yMin = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, 'xMax', {
            get: function () {
                return this._xMax;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._xMax = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, 'width', {
            get: function () {
                return this._xMax - this._xMin;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, 'yMax', {
            get: function () {
                return this._yMax;
            },
            set: function (value) {
                Debug.assert(isInteger(value));
                this._yMax = value | 0;
                this.assertValid();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DebugBounds.prototype, 'height', {
            get: function () {
                return this._yMax - this._yMin;
            },
            enumerable: true,
            configurable: true
        });
        DebugBounds.prototype.getBaseWidth = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return u * (this._xMax - this._xMin) + v * (this._yMax - this._yMin);
        };
        DebugBounds.prototype.getBaseHeight = function (angle) {
            var u = Math.abs(Math.cos(angle));
            var v = Math.abs(Math.sin(angle));
            return v * (this._xMax - this._xMin) + u * (this._yMax - this._yMin);
        };
        DebugBounds.prototype.setEmpty = function () {
            this._xMin = this._yMin = this._xMax = this._yMax = 0;
        };
        DebugBounds.prototype.clone = function () {
            return new DebugBounds(this.xMin, this.yMin, this.xMax, this.yMax);
        };
        DebugBounds.prototype.toString = function () {
            return '{ ' + 'xMin: ' + this._xMin + ', ' + 'yMin: ' + this._yMin + ', ' + 'xMax: ' + this._xMax + ', ' + 'yMax: ' + this._yMax + ' }';
        };
        DebugBounds.prototype.assertValid = function () {
        };
        return DebugBounds;
    }();
    Shumway.DebugBounds = DebugBounds;
    /**
     * Override Bounds with a slower by safer version, don't do this in release mode.
     */
    // Shumway.Bounds = DebugBounds;
    var Color = function () {
        function Color(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        Color.FromARGB = function (argb) {
            return new Color((argb >> 16 & 255) / 255, (argb >> 8 & 255) / 255, (argb >> 0 & 255) / 255, (argb >> 24 & 255) / 255);
        };
        Color.FromRGBA = function (rgba) {
            return Color.FromARGB(ColorUtilities.RGBAToARGB(rgba));
        };
        Color.prototype.toRGBA = function () {
            return this.r * 255 << 24 | this.g * 255 << 16 | this.b * 255 << 8 | this.a * 255;
        };
        Color.prototype.toCSSStyle = function () {
            return ColorUtilities.rgbaToCSSStyle(this.toRGBA());
        };
        Color.prototype.set = function (other) {
            this.r = other.r;
            this.g = other.g;
            this.b = other.b;
            this.a = other.a;
        };
        Color.randomColor = function (alpha) {
            if (alpha === void 0) {
                alpha = 1;
            }
            return new Color(Math.random(), Math.random(), Math.random(), alpha);
        };
        Color.parseColor = function (color) {
            if (!Color.colorCache) {
                Color.colorCache = Object.create(null);
            }
            if (Color.colorCache[color]) {
                return Color.colorCache[color];
            }
            // TODO: Obviously slow, but it will do for now.
            var span = document.createElement('span');
            document.body.appendChild(span);
            span.style.backgroundColor = color;
            var rgb = getComputedStyle(span).backgroundColor;
            document.body.removeChild(span);
            var m = /^rgb\((\d+), (\d+), (\d+)\)$/.exec(rgb);
            if (!m)
                m = /^rgba\((\d+), (\d+), (\d+), ([\d.]+)\)$/.exec(rgb);
            var result = new Color(0, 0, 0, 0);
            result.r = parseFloat(m[1]) / 255;
            result.g = parseFloat(m[2]) / 255;
            result.b = parseFloat(m[3]) / 255;
            result.a = m[4] ? parseFloat(m[4]) / 255 : 1;
            return Color.colorCache[color] = result;
        };
        Color.Red = new Color(1, 0, 0, 1);
        Color.Green = new Color(0, 1, 0, 1);
        Color.Blue = new Color(0, 0, 1, 1);
        Color.None = new Color(0, 0, 0, 0);
        Color.White = new Color(1, 1, 1, 1);
        Color.Black = new Color(0, 0, 0, 1);
        Color.colorCache = {};
        return Color;
    }();
    Shumway.Color = Color;
    var ColorUtilities;
    (function (ColorUtilities) {
        function RGBAToARGB(rgba) {
            return rgba >> 8 & 16777215 | (rgba & 255) << 24;
        }
        ColorUtilities.RGBAToARGB = RGBAToARGB;
        function ARGBToRGBA(argb) {
            return argb << 8 | argb >> 24 & 255;
        }
        ColorUtilities.ARGBToRGBA = ARGBToRGBA;
        /**
         * Cache frequently used rgba -> css style conversions.
         */
        var rgbaToCSSStyleCache = new Cache(1024);
        function rgbaToCSSStyle(rgba) {
            var result = rgbaToCSSStyleCache.get(rgba);
            if (typeof result === 'string') {
                return result;
            }
            result = Shumway.StringUtilities.concat9('rgba(', rgba >> 24 & 255, ',', rgba >> 16 & 255, ',', rgba >> 8 & 255, ',', (rgba & 255) / 255, ')');
            rgbaToCSSStyleCache.set(rgba, result);
            return result;
        }
        ColorUtilities.rgbaToCSSStyle = rgbaToCSSStyle;
        /**
         * Cache frequently used css -> rgba styles conversions.
         */
        var cssStyleToRGBACache = new Cache(1024);
        function cssStyleToRGBA(style) {
            var result = cssStyleToRGBACache.get(style);
            if (typeof result === 'number') {
                return result;
            }
            result = 4278190335;
            // Red
            if (style[0] === '#') {
                if (style.length === 7) {
                    result = parseInt(style.substring(1), 16) << 8 | 255;
                }
            } else if (style[0] === 'r') {
                // We don't parse all types of rgba(....) color styles. We only handle the
                // ones we generate ourselves.
                var values = style.substring(5, style.length - 1).split(',');
                var r = parseInt(values[0]);
                var g = parseInt(values[1]);
                var b = parseInt(values[2]);
                var a = parseFloat(values[3]);
                result = (r & 255) << 24 | (g & 255) << 16 | (b & 255) << 8 | a * 255 & 255;
            }
            cssStyleToRGBACache.set(style, result);
            return result;
        }
        ColorUtilities.cssStyleToRGBA = cssStyleToRGBA;
        function hexToRGB(color) {
            return parseInt(color.slice(1), 16);
        }
        ColorUtilities.hexToRGB = hexToRGB;
        function rgbToHex(color) {
            return '#' + ('000000' + (color >>> 0).toString(16)).slice(-6);
        }
        ColorUtilities.rgbToHex = rgbToHex;
        function isValidHexColor(value) {
            return /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value);
        }
        ColorUtilities.isValidHexColor = isValidHexColor;
        function clampByte(value) {
            return Math.max(0, Math.min(255, value));
        }
        ColorUtilities.clampByte = clampByte;
        /**
         * Unpremultiplies the given |pARGB| color value.
         */
        function unpremultiplyARGB(pARGB) {
            var b = pARGB >> 0 & 255;
            var g = pARGB >> 8 & 255;
            var r = pARGB >> 16 & 255;
            var a = pARGB >> 24 & 255;
            r = Math.imul(255, r) / a & 255;
            g = Math.imul(255, g) / a & 255;
            b = Math.imul(255, b) / a & 255;
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.unpremultiplyARGB = unpremultiplyARGB;
        /**
         * Premultiplies the given |pARGB| color value.
         */
        function premultiplyARGB(uARGB) {
            var b = uARGB >> 0 & 255;
            var g = uARGB >> 8 & 255;
            var r = uARGB >> 16 & 255;
            var a = uARGB >> 24 & 255;
            r = (Math.imul(r, a) + 127) / 255 | 0;
            g = (Math.imul(g, a) + 127) / 255 | 0;
            b = (Math.imul(b, a) + 127) / 255 | 0;
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.premultiplyARGB = premultiplyARGB;
        var premultiplyTable;
        /**
         * All possible alpha values and colors 256 * 256 = 65536 entries. Experiments
         * indicate that doing unpremultiplication this way is roughly 5x faster.
         *
         * To lookup a color |c| in the table at a given alpha value |a| use:
         * |(a << 8) + c| to compute the index. This layout order was chosen to make
         * table lookups cache friendly, it actually makes a difference.
         *
         * TODO: Figure out if memory / speed tradeoff is worth it.
         */
        var unpremultiplyTable;
        /**
         * Make sure to call this before using the |unpremultiplyARGBUsingTableLookup| or
         * |premultiplyARGBUsingTableLookup| functions. We want to execute this lazily so
         * we don't incur any startup overhead.
         */
        function ensureUnpremultiplyTable() {
            if (!unpremultiplyTable) {
                unpremultiplyTable = new Uint8Array(256 * 256);
                for (var c = 0; c < 256; c++) {
                    for (var a = 0; a < 256; a++) {
                        unpremultiplyTable[(a << 8) + c] = Math.imul(255, c) / a;
                    }
                }
            }
        }
        ColorUtilities.ensureUnpremultiplyTable = ensureUnpremultiplyTable;
        function getUnpremultiplyTable() {
            ensureUnpremultiplyTable();
            return unpremultiplyTable;
        }
        ColorUtilities.getUnpremultiplyTable = getUnpremultiplyTable;
        function tableLookupUnpremultiplyARGB(pARGB) {
            pARGB = pARGB | 0;
            var a = pARGB >> 24 & 255;
            if (a === 0) {
                return 0;
            } else if (a === 255) {
                return pARGB;
            }
            var b = pARGB >> 0 & 255;
            var g = pARGB >> 8 & 255;
            var r = pARGB >> 16 & 255;
            var o = a << 8;
            var T = unpremultiplyTable;
            r = T[o + r];
            g = T[o + g];
            b = T[o + b];
            return a << 24 | r << 16 | g << 8 | b;
        }
        ColorUtilities.tableLookupUnpremultiplyARGB = tableLookupUnpremultiplyARGB;
        /**
         * The blending equation for unpremultiplied alpha is:
         *
         *   (src.rgb * src.a) + (dst.rgb * (1 - src.a))
         *
         * For premultiplied alpha src.rgb and dst.rgb are already
         * premultiplied by alpha, so the equation becomes:
         *
         *   src.rgb + (dst.rgb * (1 - src.a))
         *
         * TODO: Not sure what to do about the dst.rgb which is
         * premultiplied by its alpah, but this appears to work.
         *
         * We use the "double blend trick" (http://stereopsis.com/doubleblend.html) to
         * compute GA and BR without unpacking them.
         */
        function blendPremultipliedBGRA(tpBGRA, spBGRA) {
            var sA = spBGRA & 255;
            var sGA = spBGRA & 16711935;
            var sBR = spBGRA >> 8 & 16711935;
            var tGA = tpBGRA & 16711935;
            var tBR = tpBGRA >> 8 & 16711935;
            var A = 256 - sA;
            tGA = Math.imul(tGA, A) >> 8;
            tBR = Math.imul(tBR, A) >> 8;
            return (sBR + tBR & 16711935) << 8 | sGA + tGA & 16711935;
        }
        ColorUtilities.blendPremultipliedBGRA = blendPremultipliedBGRA;
        var swap32 = IntegerUtilities.swap32;
        function convertImage(sourceFormat, targetFormat, source, target) {
            if (source !== target) {
                release || Debug.assert(source.buffer !== target.buffer, 'Can\'t handle overlapping views.');
            }
            var length = source.length;
            if (sourceFormat === targetFormat) {
                if (source === target) {
                    return;
                }
                for (var i = 0; i < length; i++) {
                    target[i] = source[i];
                }
                return;
            }
            // enterTimeline("convertImage", ImageType[sourceFormat] + " to " + ImageType[targetFormat] + " (" + memorySizeToString(source.length));
            if (sourceFormat === ImageType.PremultipliedAlphaARGB && targetFormat === ImageType.StraightAlphaRGBA) {
                Shumway.ColorUtilities.ensureUnpremultiplyTable();
                for (var i = 0; i < length; i++) {
                    var pBGRA = source[i];
                    var a = pBGRA & 255;
                    if (a === 0) {
                        target[i] = 0;
                    } else if (a === 255) {
                        target[i] = 4278190080 | pBGRA >> 8 & 16777215;
                    } else {
                        var b = pBGRA >> 24 & 255;
                        var g = pBGRA >> 16 & 255;
                        var r = pBGRA >> 8 & 255;
                        var o = a << 8;
                        var T = unpremultiplyTable;
                        r = T[o + r];
                        g = T[o + g];
                        b = T[o + b];
                        target[i] = a << 24 | b << 16 | g << 8 | r;
                    }
                }
            } else if (sourceFormat === ImageType.StraightAlphaARGB && targetFormat === ImageType.StraightAlphaRGBA) {
                for (var i = 0; i < length; i++) {
                    target[i] = swap32(source[i]);
                }
            } else if (sourceFormat === ImageType.StraightAlphaRGBA && targetFormat === ImageType.PremultipliedAlphaARGB) {
                for (var i = 0; i < length; i++) {
                    var uABGR = source[i];
                    var uARGB = uABGR & 4278255360 | uABGR >> 16 & 255 | (uABGR & 255) << 16;
                    // ARGR
                    target[i] = swap32(premultiplyARGB(uARGB));
                }
            } else {
                release || Debug.somewhatImplemented('Image Format Conversion: ' + ImageType[sourceFormat] + ' -> ' + ImageType[targetFormat]);
                // Copy the buffer over for now, we should at least get some image output.
                for (var i = 0; i < length; i++) {
                    target[i] = source[i];
                }
            }    // leaveTimeline("convertImage");
        }
        ColorUtilities.convertImage = convertImage;
    }(ColorUtilities = Shumway.ColorUtilities || (Shumway.ColorUtilities = {})));
    /**
     * Simple pool allocator for ArrayBuffers. This reduces memory usage in data structures
     * that resize buffers.
     */
    var ArrayBufferPool = function () {
        /**
         * Creates a pool that manages a pool of a |maxSize| number of array buffers.
         */
        function ArrayBufferPool(maxSize) {
            if (maxSize === void 0) {
                maxSize = 32;
            }
            this._list = [];
            this._maxSize = maxSize;
        }
        /**
         * Creates or reuses an existing array buffer that is at least the
         * specified |length|.
         */
        ArrayBufferPool.prototype.acquire = function (length) {
            if (ArrayBufferPool._enabled) {
                var list = this._list;
                for (var i = 0; i < list.length; i++) {
                    var buffer = list[i];
                    if (buffer.byteLength >= length) {
                        list.splice(i, 1);
                        return buffer;
                    }
                }
            }
            return new ArrayBuffer(length);
        };
        /**
         * Releases an array buffer that is no longer needed back to the pool.
         */
        ArrayBufferPool.prototype.release = function (buffer) {
            if (ArrayBufferPool._enabled) {
                var list = this._list;
                release || Debug.assert(ArrayUtilities.indexOf(list, buffer) < 0);
                if (list.length === this._maxSize) {
                    list.shift();
                }
                list.push(buffer);
            }
        };
        /**
         * Resizes a Uint8Array to have the given length.
         */
        ArrayBufferPool.prototype.ensureUint8ArrayLength = function (array, length) {
            if (array.length >= length) {
                return array;
            }
            var newLength = Math.max(array.length + length, (array.length * 3 >> 1) + 1);
            var newArray = new Uint8Array(this.acquire(newLength), 0, newLength);
            newArray.set(array);
            this.release(array.buffer);
            return newArray;
        };
        /**
         * Resizes a Float64Array to have the given length.
         */
        ArrayBufferPool.prototype.ensureFloat64ArrayLength = function (array, length) {
            if (array.length >= length) {
                return array;
            }
            var newLength = Math.max(array.length + length, (array.length * 3 >> 1) + 1);
            var newArray = new Float64Array(this.acquire(newLength * Float64Array.BYTES_PER_ELEMENT), 0, newLength);
            newArray.set(array);
            this.release(array.buffer);
            return newArray;
        };
        ArrayBufferPool._enabled = true;
        return ArrayBufferPool;
    }();
    Shumway.ArrayBufferPool = ArrayBufferPool;
    var Telemetry;
    (function (Telemetry) {
        Telemetry.instance;
    }(Telemetry = Shumway.Telemetry || (Shumway.Telemetry = {})));
    var FileLoadingService;
    (function (FileLoadingService) {
        FileLoadingService.instance;
    }(FileLoadingService = Shumway.FileLoadingService || (Shumway.FileLoadingService = {})));
    var SystemResourcesLoadingService;
    (function (SystemResourcesLoadingService) {
        SystemResourcesLoadingService.instance;
    }(SystemResourcesLoadingService = Shumway.SystemResourcesLoadingService || (Shumway.SystemResourcesLoadingService = {})));
    function registerCSSFont(id, data, forceFontInit) {
        if (!inBrowser) {
            Debug.warning('Cannot register CSS font outside the browser');
            return;
        }
        var head = document.head;
        head.insertBefore(document.createElement('style'), head.firstChild);
        var style = document.styleSheets[0];
        var rule = '@font-face{font-family:swffont' + id + ';src:url(data:font/opentype;base64,' + Shumway.StringUtilities.base64EncodeBytes(data) + ')' + '}';
        style.insertRule(rule, style.cssRules.length);
        // In at least Chrome, the browser only decodes a font once it's used in the page at all.
        // Because it still does so asynchronously, we create a with some text using the font, take
        // some measurement from it (which will turn out wrong because the font isn't yet available),
        // and then remove the node again. Then, magic happens. After a bit of time for said magic to
        // take hold, the font is available for actual use on canvas.
        // TODO: remove the need for magic by implementing this in terms of the font loading API.
        if (forceFontInit) {
            var node = document.createElement('div');
            node.style.fontFamily = 'swffont' + id;
            node.innerHTML = 'hello';
            document.body.appendChild(node);
            var dummyHeight = node.clientHeight;
            document.body.removeChild(node);
        }
    }
    Shumway.registerCSSFont = registerCSSFont;
    var ExternalInterfaceService;
    (function (ExternalInterfaceService) {
        ExternalInterfaceService.instance = {
            enabled: false,
            initJS: function (callback) {
            },
            registerCallback: function (functionName) {
            },
            unregisterCallback: function (functionName) {
            },
            eval: function (expression) {
            },
            call: function (request) {
            },
            getId: function () {
                return null;
            }
        };
    }(ExternalInterfaceService = Shumway.ExternalInterfaceService || (Shumway.ExternalInterfaceService = {})));
    var LocalConnectionService;
    (function (LocalConnectionService) {
        LocalConnectionService.instance;
    }(LocalConnectionService = Shumway.LocalConnectionService || (Shumway.LocalConnectionService = {})));
    var ClipboardService;
    (function (ClipboardService) {
        ClipboardService.instance = {
            setClipboard: function (data) {
                Debug.notImplemented('setClipboard');
            }
        };
    }(ClipboardService = Shumway.ClipboardService || (Shumway.ClipboardService = {})));
    var Callback = function () {
        function Callback() {
            this._queues = {};
        }
        Callback.prototype.register = function (type, callback) {
            Debug.assert(type);
            Debug.assert(callback);
            var queue = this._queues[type];
            if (queue) {
                if (queue.indexOf(callback) > -1) {
                    return;
                }
            } else {
                queue = this._queues[type] = [];
            }
            queue.push(callback);
        };
        Callback.prototype.unregister = function (type, callback) {
            Debug.assert(type);
            Debug.assert(callback);
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            var i = queue.indexOf(callback);
            if (i !== -1) {
                queue.splice(i, 1);
            }
            if (queue.length === 0) {
                this._queues[type] = null;
            }
        };
        Callback.prototype.notify = function (type, args) {
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            queue = queue.slice();
            var args = Array.prototype.slice.call(arguments, 0);
            for (var i = 0; i < queue.length; i++) {
                var callback = queue[i];
                callback.apply(null, args);
            }
        };
        Callback.prototype.notify1 = function (type, value) {
            var queue = this._queues[type];
            if (!queue) {
                return;
            }
            queue = queue.slice();
            for (var i = 0; i < queue.length; i++) {
                var callback = queue[i];
                callback(type, value);
            }
        };
        return Callback;
    }();
    Shumway.Callback = Callback;
    (function (ImageType) {
        ImageType[ImageType['None'] = 0] = 'None';
        /**
         * Premultiplied ARGB (byte-order).
         */
        ImageType[ImageType['PremultipliedAlphaARGB'] = 1] = 'PremultipliedAlphaARGB';
        /**
         * Unpremultiplied ARGB (byte-order).
         */
        ImageType[ImageType['StraightAlphaARGB'] = 2] = 'StraightAlphaARGB';
        /**
         * Unpremultiplied RGBA (byte-order), this is what putImageData expects.
         */
        ImageType[ImageType['StraightAlphaRGBA'] = 3] = 'StraightAlphaRGBA';
        ImageType[ImageType['JPEG'] = 4] = 'JPEG';
        ImageType[ImageType['PNG'] = 5] = 'PNG';
        ImageType[ImageType['GIF'] = 6] = 'GIF';
    }(Shumway.ImageType || (Shumway.ImageType = {})));
    var ImageType = Shumway.ImageType;
    function getMIMETypeForImageType(type) {
        switch (type) {
        case ImageType.JPEG:
            return 'image/jpeg';
        case ImageType.PNG:
            return 'image/png';
        case ImageType.GIF:
            return 'image/gif';
        default:
            return 'text/plain';
        }
    }
    Shumway.getMIMETypeForImageType = getMIMETypeForImageType;
    var UI;
    (function (UI) {
        /*
         * Converts a |MouseCursor| number to a CSS |cursor| property value.
         */
        function toCSSCursor(mouseCursor) {
            switch (mouseCursor) {
            case 0:
                return 'auto';
            case 2:
                return 'pointer';
            case 3:
                return 'grab';
            case 4:
                return 'text';
            case 1:
            // MouseCursor.ARROW
            default:
                return 'default';
            }
        }
        UI.toCSSCursor = toCSSCursor;
    }(UI = Shumway.UI || (Shumway.UI = {})));
    var PromiseWrapper = function () {
        function PromiseWrapper() {
            this.promise = new Promise(function (resolve, reject) {
                this.resolve = resolve;
                this.reject = reject;
            }.bind(this));
        }
        PromiseWrapper.prototype.then = function (onFulfilled, onRejected) {
            return this.promise.then(onFulfilled, onRejected);
        };
        return PromiseWrapper;
    }();
    Shumway.PromiseWrapper = PromiseWrapper;
}(Shumway || (Shumway = {})));
if (typeof exports !== 'undefined') {
    exports['Shumway'] = Shumway;
}
/**
 * Extend builtin prototypes.
 *
 * TODO: Go through the code and remove all references to these.
 */
(function () {
    function extendBuiltin(prototype, property, value) {
        if (!prototype[property]) {
            Object.defineProperty(prototype, property, {
                value: value,
                writable: true,
                configurable: true,
                enumerable: false
            });
        }
    }
    function removeColors(s) {
        return s.replace(/\033\[[0-9]*m/g, '');
    }
    extendBuiltin(String.prototype, 'padRight', function (c, n) {
        var str = this;
        var length = removeColors(str).length;
        if (!c || length >= n) {
            return str;
        }
        var max = (n - length) / c.length;
        for (var i = 0; i < max; i++) {
            str += c;
        }
        return str;
    });
    extendBuiltin(String.prototype, 'padLeft', function (c, n) {
        var str = this;
        var length = str.length;
        if (!c || length >= n) {
            return str;
        }
        var max = (n - length) / c.length;
        for (var i = 0; i < max; i++) {
            str = c + str;
        }
        return str;
    });
    extendBuiltin(String.prototype, 'trim', function () {
        return this.replace(/^\s+|\s+$/g, '');
    });
    extendBuiltin(String.prototype, 'endsWith', function (str) {
        return this.indexOf(str, this.length - str.length) !== -1;
    });
    extendBuiltin(Array.prototype, 'replace', function (x, y) {
        if (x === y) {
            return 0;
        }
        var count = 0;
        for (var i = 0; i < this.length; i++) {
            if (this[i] === x) {
                this[i] = y;
                count++;
            }
        }
        return count;
    });
}());
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Option and Argument Management
 *
 * Options are configuration settings sprinkled throughout the code. They can be grouped into sets of
 * options called |OptionSets| which can form a hierarchy of options. For instance:
 *
 * var set = new OptionSet();
 * var opt = set.register(new Option("v", "verbose", "boolean", false, "Enables verbose logging."));
 *
 * creates an option set with one option in it. The option can be changed directly using |opt.value = true| or
 * automatically using the |ArgumentParser|:
 *
 * var parser = new ArgumentParser();
 * parser.addBoundOptionSet(set);
 * parser.parse(["-v"]);
 *
 * The |ArgumentParser| can also be used directly:
 *
 * var parser = new ArgumentParser();
 * argumentParser.addArgument("h", "help", "boolean", {parse: function (x) {
 *   printUsage();
 * }});
 */
///<reference path='references.ts' />
var Shumway;
(function (Shumway) {
    var Options;
    (function (Options) {
        var isObject = Shumway.isObject;
        var assert = Shumway.Debug.assert;
        var Argument = function () {
            function Argument(shortName, longName, type, options) {
                this.shortName = shortName;
                this.longName = longName;
                this.type = type;
                options = options || {};
                this.positional = options.positional;
                this.parseFn = options.parse;
                this.value = options.defaultValue;
            }
            Argument.prototype.parse = function (value) {
                if (this.type === 'boolean') {
                    release || assert(typeof value === 'boolean');
                    this.value = value;
                } else if (this.type === 'number') {
                    release || assert(!isNaN(value), value + ' is not a number');
                    this.value = parseInt(value, 10);
                } else {
                    this.value = value;
                }
                if (this.parseFn) {
                    this.parseFn(this.value);
                }
            };
            return Argument;
        }();
        Options.Argument = Argument;
        var ArgumentParser = function () {
            function ArgumentParser() {
                this.args = [];
            }
            ArgumentParser.prototype.addArgument = function (shortName, longName, type, options) {
                var argument = new Argument(shortName, longName, type, options);
                this.args.push(argument);
                return argument;
            };
            ArgumentParser.prototype.addBoundOption = function (option) {
                var options = {
                    parse: function (x) {
                        option.value = x;
                    }
                };
                this.args.push(new Argument(option.shortName, option.longName, option.type, options));
            };
            ArgumentParser.prototype.addBoundOptionSet = function (optionSet) {
                var self = this;
                optionSet.options.forEach(function (x) {
                    if (OptionSet.isOptionSet(x)) {
                        self.addBoundOptionSet(x);
                    } else {
                        release || assert(x);
                        self.addBoundOption(x);
                    }
                });
            };
            ArgumentParser.prototype.getUsage = function () {
                var str = '';
                this.args.forEach(function (x) {
                    if (!x.positional) {
                        str += '[-' + x.shortName + '|--' + x.longName + (x.type === 'boolean' ? '' : ' ' + x.type[0].toUpperCase()) + ']';
                    } else {
                        str += x.longName;
                    }
                    str += ' ';
                });
                return str;
            };
            ArgumentParser.prototype.parse = function (args) {
                var nonPositionalArgumentMap = {};
                var positionalArgumentList = [];
                this.args.forEach(function (x) {
                    if (x.positional) {
                        positionalArgumentList.push(x);
                    } else {
                        nonPositionalArgumentMap['-' + x.shortName] = x;
                        nonPositionalArgumentMap['--' + x.longName] = x;
                    }
                });
                var leftoverArguments = [];
                while (args.length) {
                    var argString = args.shift();
                    var argument = null, value = argString;
                    if (argString == '--') {
                        leftoverArguments = leftoverArguments.concat(args);
                        break;
                    } else if (argString.slice(0, 1) == '-' || argString.slice(0, 2) == '--') {
                        argument = nonPositionalArgumentMap[argString];
                        // release || assert(argument, "Argument " + argString + " is unknown.");
                        if (!argument) {
                            continue;
                        }
                        if (argument.type !== 'boolean') {
                            value = args.shift();
                            release || assert(value !== '-' && value !== '--', 'Argument ' + argString + ' must have a value.');
                        } else {
                            if (args.length && [
                                    'yes',
                                    'no',
                                    'true',
                                    'false',
                                    't',
                                    'f'
                                ].indexOf(args[0]) >= 0) {
                                value = [
                                    'yes',
                                    'true',
                                    't'
                                ].indexOf(args.shift()) >= 0;
                            } else {
                                value = true;
                            }
                        }
                    } else if (positionalArgumentList.length) {
                        argument = positionalArgumentList.shift();
                    } else {
                        leftoverArguments.push(value);
                    }
                    if (argument) {
                        argument.parse(value);
                    }
                }
                release || assert(positionalArgumentList.length === 0, 'Missing positional arguments.');
                return leftoverArguments;
            };
            return ArgumentParser;
        }();
        Options.ArgumentParser = ArgumentParser;
        var OptionSet = function () {
            function OptionSet(name, settings) {
                if (settings === void 0) {
                    settings = null;
                }
                this.open = false;
                this.name = name;
                this.settings = settings || {};
                this.options = [];
            }
            OptionSet.isOptionSet = function (obj) {
                // We will be getting options from different iframe, so this function will
                // check if the obj somewhat like OptionSet.
                if (obj instanceof OptionSet) {
                    return true;
                }
                if (typeof obj !== 'object' || obj === null || obj instanceof Option) {
                    return false;
                }
                return 'options' in obj && 'name' in obj && 'settings' in obj;
            };
            OptionSet.prototype.register = function (option) {
                if (OptionSet.isOptionSet(option)) {
                    // check for duplicate option sets (bail if found)
                    for (var i = 0; i < this.options.length; i++) {
                        var optionSet = this.options[i];
                        if (OptionSet.isOptionSet(optionSet) && optionSet.name === option.name) {
                            return optionSet;
                        }
                    }
                }
                this.options.push(option);
                if (this.settings) {
                    if (OptionSet.isOptionSet(option)) {
                        var optionSettings = this.settings[option.name];
                        if (isObject(optionSettings)) {
                            option.settings = optionSettings.settings;
                            option.open = optionSettings.open;
                        }
                    } else {
                        // build_bundle chokes on this:
                        // if (!isNullOrUndefined(this.settings[option.longName])) {
                        if (typeof this.settings[option.longName] !== 'undefined') {
                            switch (option.type) {
                            case 'boolean':
                                option.value = !!this.settings[option.longName];
                                break;
                            case 'number':
                                option.value = +this.settings[option.longName];
                                break;
                            default:
                                option.value = this.settings[option.longName];
                                break;
                            }
                        }
                    }
                }
                return option;
            };
            OptionSet.prototype.trace = function (writer) {
                writer.enter(this.name + ' {');
                this.options.forEach(function (option) {
                    option.trace(writer);
                });
                writer.leave('}');
            };
            OptionSet.prototype.getSettings = function () {
                var settings = {};
                this.options.forEach(function (option) {
                    if (OptionSet.isOptionSet(option)) {
                        settings[option.name] = {
                            settings: option.getSettings(),
                            open: option.open
                        };
                    } else {
                        settings[option.longName] = option.value;
                    }
                });
                return settings;
            };
            OptionSet.prototype.setSettings = function (settings) {
                if (!settings) {
                    return;
                }
                this.options.forEach(function (option) {
                    if (OptionSet.isOptionSet(option)) {
                        if (option.name in settings) {
                            option.setSettings(settings[option.name].settings);
                        }
                    } else {
                        if (option.longName in settings) {
                            option.value = settings[option.longName];
                        }
                    }
                });
            };
            return OptionSet;
        }();
        Options.OptionSet = OptionSet;
        var Option = function () {
            // config:
            //  { range: { min: 1, max: 5, step: 1 } }
            //  { list: [ "item 1", "item 2", "item 3" ] }
            //  { choices: { "choice 1": 1, "choice 2": 2, "choice 3": 3 } }
            function Option(shortName, longName, type, defaultValue, description, config) {
                if (config === void 0) {
                    config = null;
                }
                this.longName = longName;
                this.shortName = shortName;
                this.type = type;
                this.defaultValue = defaultValue;
                this.value = defaultValue;
                this.description = description;
                this.config = config;
            }
            Option.prototype.parse = function (value) {
                this.value = value;
            };
            Option.prototype.trace = function (writer) {
                writer.writeLn(('-' + this.shortName + '|--' + this.longName).padRight(' ', 30) + ' = ' + this.type + ' ' + this.value + ' [' + this.defaultValue + ']' + ' (' + this.description + ')');
            };
            return Option;
        }();
        Options.Option = Option;
    }(Options = Shumway.Options || (Shumway.Options = {})));
    var Settings;
    (function (Settings) {
        Settings.ROOT = 'Shumway Options';
        Settings.shumwayOptions = new Shumway.Options.OptionSet(Settings.ROOT);
        function setSettings(settings) {
            Settings.shumwayOptions.setSettings(settings);
        }
        Settings.setSettings = setSettings;
        function getSettings() {
            return Settings.shumwayOptions.getSettings();
        }
        Settings.getSettings = getSettings;
    }(Settings = Shumway.Settings || (Shumway.Settings = {})));
    var Option = Shumway.Options.Option;
    var OptionSet = Shumway.Options.OptionSet;
    var shumwayOptions = Shumway.Settings.shumwayOptions;
    Shumway.loggingOptions = shumwayOptions.register(new OptionSet('Logging Options'));
    Shumway.omitRepeatedWarnings = Shumway.loggingOptions.register(new Option('wo', 'warnOnce', 'boolean', true, 'Omit Repeated Warnings'));
    var Metrics;
    (function (Metrics) {
        var Timer = function () {
            function Timer(parent, name) {
                this._parent = parent;
                this._timers = Shumway.ObjectUtilities.createMap();
                this._name = name;
                this._begin = 0;
                this._last = 0;
                this._total = 0;
                this._count = 0;
            }
            Timer.time = function (name, fn) {
                Timer.start(name);
                fn();
                Timer.stop();
            };
            Timer.start = function (name) {
                Timer._top = Timer._top._timers[name] || (Timer._top._timers[name] = new Timer(Timer._top, name));
                Timer._top.start();
                var tmp = Timer._flat._timers[name] || (Timer._flat._timers[name] = new Timer(Timer._flat, name));
                tmp.start();
                Timer._flatStack.push(tmp);
            };
            Timer.stop = function () {
                Timer._top.stop();
                Timer._top = Timer._top._parent;
                Timer._flatStack.pop().stop();
            };
            Timer.stopStart = function (name) {
                Timer.stop();
                Timer.start(name);
            };
            Timer.prototype.start = function () {
                this._begin = Shumway.getTicks();
            };
            Timer.prototype.stop = function () {
                this._last = Shumway.getTicks() - this._begin;
                this._total += this._last;
                this._count += 1;
            };
            Timer.prototype.toJSON = function () {
                return {
                    name: this._name,
                    total: this._total,
                    timers: this._timers
                };
            };
            Timer.prototype.trace = function (writer) {
                writer.enter(this._name + ': ' + this._total.toFixed(2) + ' ms' + ', count: ' + this._count + ', average: ' + (this._total / this._count).toFixed(2) + ' ms');
                for (var name in this._timers) {
                    this._timers[name].trace(writer);
                }
                writer.outdent();
            };
            Timer.trace = function (writer) {
                Timer._base.trace(writer);
                Timer._flat.trace(writer);
            };
            Timer._base = new Timer(null, 'Total');
            Timer._top = Timer._base;
            Timer._flat = new Timer(null, 'Flat');
            Timer._flatStack = [];
            return Timer;
        }();
        Metrics.Timer = Timer;
        /**
         * Quick way to count named events.
         */
        var Counter = function () {
            function Counter(enabled) {
                this._enabled = enabled;
                this.clear();
            }
            Object.defineProperty(Counter.prototype, 'counts', {
                get: function () {
                    return this._counts;
                },
                enumerable: true,
                configurable: true
            });
            Counter.prototype.setEnabled = function (enabled) {
                this._enabled = enabled;
            };
            Counter.prototype.clear = function () {
                this._counts = Shumway.ObjectUtilities.createMap();
                this._times = Shumway.ObjectUtilities.createMap();
            };
            Counter.prototype.toJSON = function () {
                return {
                    counts: this._counts,
                    times: this._times
                };
            };
            Counter.prototype.count = function (name, increment, time) {
                if (increment === void 0) {
                    increment = 1;
                }
                if (time === void 0) {
                    time = 0;
                }
                if (!this._enabled) {
                    return;
                }
                if (this._counts[name] === undefined) {
                    this._counts[name] = 0;
                    this._times[name] = 0;
                }
                this._counts[name] += increment;
                this._times[name] += time;
                return this._counts[name];
            };
            Counter.prototype.trace = function (writer) {
                for (var name in this._counts) {
                    writer.writeLn(name + ': ' + this._counts[name]);
                }
            };
            Counter.prototype._pairToString = function (times, pair) {
                var name = pair[0];
                var count = pair[1];
                var time = times[name];
                var line = name + ': ' + count;
                if (time) {
                    line += ', ' + time.toFixed(4);
                    if (count > 1) {
                        line += ' (' + (time / count).toFixed(4) + ')';
                    }
                }
                return line;
            };
            Counter.prototype.toStringSorted = function () {
                var self = this;
                var times = this._times;
                var pairs = [];
                for (var name in this._counts) {
                    pairs.push([
                        name,
                        this._counts[name]
                    ]);
                }
                pairs.sort(function (a, b) {
                    return b[1] - a[1];
                });
                return pairs.map(function (pair) {
                    return self._pairToString(times, pair);
                }).join(', ');
            };
            Counter.prototype.traceSorted = function (writer, inline) {
                if (inline === void 0) {
                    inline = false;
                }
                var self = this;
                var times = this._times;
                var pairs = [];
                for (var name in this._counts) {
                    pairs.push([
                        name,
                        this._counts[name]
                    ]);
                }
                pairs.sort(function (a, b) {
                    return b[1] - a[1];
                });
                if (inline) {
                    writer.writeLn(pairs.map(function (pair) {
                        return self._pairToString(times, pair);
                    }).join(', '));
                } else {
                    pairs.forEach(function (pair) {
                        writer.writeLn(self._pairToString(times, pair));
                    });
                }
            };
            Counter.instance = new Counter(true);
            return Counter;
        }();
        Metrics.Counter = Counter;
        var Average = function () {
            function Average(max) {
                this._samples = new Float64Array(max);
                this._count = 0;
                this._index = 0;
            }
            Average.prototype.push = function (sample) {
                if (this._count < this._samples.length) {
                    this._count++;
                }
                this._index++;
                this._samples[this._index % this._samples.length] = sample;
            };
            Average.prototype.average = function () {
                var sum = 0;
                for (var i = 0; i < this._count; i++) {
                    sum += this._samples[i];
                }
                return sum / this._count;
            };
            return Average;
        }();
        Metrics.Average = Average;
    }(Metrics = Shumway.Metrics || (Shumway.Metrics = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    var ArrayUtilities;
    (function (ArrayUtilities) {
        var InflateState;
        (function (InflateState) {
            InflateState[InflateState['INIT'] = 0] = 'INIT';
            InflateState[InflateState['BLOCK_0'] = 1] = 'BLOCK_0';
            InflateState[InflateState['BLOCK_1'] = 2] = 'BLOCK_1';
            InflateState[InflateState['BLOCK_2_PRE'] = 3] = 'BLOCK_2_PRE';
            InflateState[InflateState['BLOCK_2'] = 4] = 'BLOCK_2';
            InflateState[InflateState['DONE'] = 5] = 'DONE';
            InflateState[InflateState['ERROR'] = 6] = 'ERROR';
            InflateState[InflateState['VERIFY_HEADER'] = 7] = 'VERIFY_HEADER';
        }(InflateState || (InflateState = {})));
        var WINDOW_SIZE = 32768;
        var WINDOW_SHIFT_POSITION = 65536;
        var MAX_WINDOW_SIZE = WINDOW_SHIFT_POSITION + 258;
        /* plus max copy len */
        var Inflate = function () {
            function Inflate(verifyHeader) {
            }
            Inflate.prototype.push = function (data) {
                Shumway.Debug.abstractMethod('Inflate.push');
            };
            Inflate.prototype.close = function () {
            };
            Inflate.create = function (verifyHeader) {
                if (typeof ShumwayCom !== 'undefined' && ShumwayCom.createSpecialInflate) {
                    return new SpecialInflateAdapter(verifyHeader, ShumwayCom.createSpecialInflate);
                }
                return new BasicInflate(verifyHeader);
            };
            Inflate.prototype._processZLibHeader = function (buffer, start, end) {
                /* returns -1 - bad header, 0 - not enough data, 1+ - number of bytes processed */
                var ZLIB_HEADER_SIZE = 2;
                if (start + ZLIB_HEADER_SIZE > end) {
                    return 0;
                }
                var header = buffer[start] << 8 | buffer[start + 1];
                var error = null;
                if ((header & 3840) !== 2048) {
                    error = 'inflate: unknown compression method';
                } else if (header % 31 !== 0) {
                    error = 'inflate: bad FCHECK';
                } else if ((header & 32) !== 0) {
                    error = 'inflate: FDICT bit set';
                }
                if (error) {
                    if (this.onError) {
                        this.onError(error);
                    }
                    return -1;
                } else {
                    return ZLIB_HEADER_SIZE;
                }
            };
            Inflate.inflate = function (data, expectedLength, zlibHeader) {
                var output = new Uint8Array(expectedLength);
                var position = 0;
                var inflate = Inflate.create(zlibHeader);
                inflate.onData = function (data) {
                    // Make sure we don't cause an exception here when trying to set out-of-bound data by clamping the number of
                    // bytes to write to the remaining space in our output buffer. The Flash Player ignores data that goes over the
                    // expected length, so should we.
                    var length = Math.min(data.length, output.length - position);
                    if (length) {
                        ArrayUtilities.memCopy(output, data, position, 0, length);
                    }
                    position += length;
                };
                inflate.onError = function (error) {
                    throw new Error(error);
                };
                inflate.push(data);
                inflate.close();
                return output;
            };
            return Inflate;
        }();
        ArrayUtilities.Inflate = Inflate;
        var BasicInflate = function (_super) {
            __extends(BasicInflate, _super);
            function BasicInflate(verifyHeader) {
                _super.call(this, verifyHeader);
                this._buffer = null;
                this._bufferSize = 0;
                this._bufferPosition = 0;
                this._bitBuffer = 0;
                this._bitLength = 0;
                this._window = new Uint8Array(MAX_WINDOW_SIZE);
                this._windowPosition = 0;
                this._state = verifyHeader ? InflateState.VERIFY_HEADER : InflateState.INIT;
                this._isFinalBlock = false;
                this._literalTable = null;
                this._distanceTable = null;
                this._block0Read = 0;
                this._block2State = null;
                this._copyState = {
                    state: 0,
                    len: 0,
                    lenBits: 0,
                    dist: 0,
                    distBits: 0
                };
                if (!areTablesInitialized) {
                    initializeTables();
                    areTablesInitialized = true;
                }
            }
            BasicInflate.prototype.push = function (data) {
                if (!this._buffer || this._buffer.length < this._bufferSize + data.length) {
                    var newBuffer = new Uint8Array(this._bufferSize + data.length);
                    if (this._buffer) {
                        newBuffer.set(this._buffer);
                    }
                    this._buffer = newBuffer;
                }
                this._buffer.set(data, this._bufferSize);
                this._bufferSize += data.length;
                this._bufferPosition = 0;
                var incomplete = false;
                do {
                    var lastPosition = this._windowPosition;
                    if (this._state === InflateState.INIT) {
                        incomplete = this._decodeInitState();
                        if (incomplete) {
                            break;
                        }
                    }
                    switch (this._state) {
                    case InflateState.BLOCK_0:
                        incomplete = this._decodeBlock0();
                        break;
                    case InflateState.BLOCK_2_PRE:
                        incomplete = this._decodeBlock2Pre();
                        if (incomplete) {
                            break;
                        }
                    /* fall through */
                    case InflateState.BLOCK_1:
                    case InflateState.BLOCK_2:
                        incomplete = this._decodeBlock();
                        break;
                    case InflateState.ERROR:
                    case InflateState.DONE:
                        // skipping all data
                        this._bufferPosition = this._bufferSize;
                        break;
                    case InflateState.VERIFY_HEADER:
                        var processed = this._processZLibHeader(this._buffer, this._bufferPosition, this._bufferSize);
                        if (processed > 0) {
                            this._bufferPosition += processed;
                            this._state = InflateState.INIT;
                        } else if (processed === 0) {
                            incomplete = true;
                        } else {
                            this._state = InflateState.ERROR;
                        }
                        break;
                    }
                    var decoded = this._windowPosition - lastPosition;
                    if (decoded > 0) {
                        this.onData(this._window.subarray(lastPosition, this._windowPosition));
                    }
                    if (this._windowPosition >= WINDOW_SHIFT_POSITION) {
                        // shift window
                        if ('copyWithin' in this._buffer) {
                            this._window['copyWithin'](0, this._windowPosition - WINDOW_SIZE, this._windowPosition);
                        } else {
                            this._window.set(this._window.subarray(this._windowPosition - WINDOW_SIZE, this._windowPosition));
                        }
                        this._windowPosition = WINDOW_SIZE;
                    }
                } while (!incomplete && this._bufferPosition < this._bufferSize);
                if (this._bufferPosition < this._bufferSize) {
                    // shift buffer
                    if ('copyWithin' in this._buffer) {
                        this._buffer['copyWithin'](0, this._bufferPosition, this._bufferSize);
                    } else {
                        this._buffer.set(this._buffer.subarray(this._bufferPosition, this._bufferSize));
                    }
                    this._bufferSize -= this._bufferPosition;
                } else {
                    this._bufferSize = 0;
                }
            };
            BasicInflate.prototype._decodeInitState = function () {
                if (this._isFinalBlock) {
                    this._state = InflateState.DONE;
                    return false;
                }
                var buffer = this._buffer, bufferSize = this._bufferSize;
                var bitBuffer = this._bitBuffer, bitLength = this._bitLength;
                var state;
                var position = this._bufferPosition;
                if ((bufferSize - position << 3) + bitLength < 3) {
                    return true;
                }
                if (bitLength < 3) {
                    bitBuffer |= buffer[position++] << bitLength;
                    bitLength += 8;
                }
                var type = bitBuffer & 7;
                bitBuffer >>= 3;
                bitLength -= 3;
                switch (type >> 1) {
                case 0:
                    bitBuffer = 0;
                    bitLength = 0;
                    if (bufferSize - position < 4) {
                        return true;
                    }
                    var length = buffer[position] | buffer[position + 1] << 8;
                    var length2 = buffer[position + 2] | buffer[position + 3] << 8;
                    position += 4;
                    if ((length ^ length2) !== 65535) {
                        this._error('inflate: invalid block 0 length');
                        state = InflateState.ERROR;
                        break;
                    }
                    if (length === 0) {
                        state = InflateState.INIT;
                    } else {
                        this._block0Read = length;
                        state = InflateState.BLOCK_0;
                    }
                    break;
                case 1:
                    state = InflateState.BLOCK_1;
                    this._literalTable = fixedLiteralTable;
                    this._distanceTable = fixedDistanceTable;
                    break;
                case 2:
                    if ((bufferSize - position << 3) + bitLength < 14 + 3 * 4) {
                        return true;
                    }
                    while (bitLength < 14) {
                        bitBuffer |= buffer[position++] << bitLength;
                        bitLength += 8;
                    }
                    var numLengthCodes = (bitBuffer >> 10 & 15) + 4;
                    if ((bufferSize - position << 3) + bitLength < 14 + 3 * numLengthCodes) {
                        return true;
                    }
                    var block2State = {
                        numLiteralCodes: (bitBuffer & 31) + 257,
                        numDistanceCodes: (bitBuffer >> 5 & 31) + 1,
                        codeLengthTable: undefined,
                        bitLengths: undefined,
                        codesRead: 0,
                        dupBits: 0
                    };
                    bitBuffer >>= 14;
                    bitLength -= 14;
                    var codeLengths = new Uint8Array(19);
                    for (var i = 0; i < numLengthCodes; ++i) {
                        if (bitLength < 3) {
                            bitBuffer |= buffer[position++] << bitLength;
                            bitLength += 8;
                        }
                        codeLengths[codeLengthOrder[i]] = bitBuffer & 7;
                        bitBuffer >>= 3;
                        bitLength -= 3;
                    }
                    for (; i < 19; i++) {
                        codeLengths[codeLengthOrder[i]] = 0;
                    }
                    block2State.bitLengths = new Uint8Array(block2State.numLiteralCodes + block2State.numDistanceCodes);
                    block2State.codeLengthTable = makeHuffmanTable(codeLengths);
                    this._block2State = block2State;
                    state = InflateState.BLOCK_2_PRE;
                    break;
                default:
                    this._error('inflate: unsupported block type');
                    state = InflateState.ERROR;
                    return false;
                }
                this._isFinalBlock = !!(type & 1);
                this._state = state;
                this._bufferPosition = position;
                this._bitBuffer = bitBuffer;
                this._bitLength = bitLength;
                return false;
            };
            BasicInflate.prototype._error = function (e) {
                if (this.onError) {
                    this.onError(e);
                }
            };
            BasicInflate.prototype._decodeBlock0 = function () {
                var position = this._bufferPosition;
                var windowPosition = this._windowPosition;
                var toRead = this._block0Read;
                var leftInWindow = MAX_WINDOW_SIZE - windowPosition;
                var leftInBuffer = this._bufferSize - position;
                var incomplete = leftInBuffer < toRead;
                var canFit = Math.min(leftInWindow, leftInBuffer, toRead);
                this._window.set(this._buffer.subarray(position, position + canFit), windowPosition);
                this._windowPosition = windowPosition + canFit;
                this._bufferPosition = position + canFit;
                this._block0Read = toRead - canFit;
                if (toRead === canFit) {
                    this._state = InflateState.INIT;
                    return false;
                }
                return incomplete && leftInWindow < leftInBuffer;
            };
            BasicInflate.prototype._readBits = function (size) {
                var bitBuffer = this._bitBuffer;
                var bitLength = this._bitLength;
                if (size > bitLength) {
                    var pos = this._bufferPosition;
                    var end = this._bufferSize;
                    do {
                        if (pos >= end) {
                            this._bufferPosition = pos;
                            this._bitBuffer = bitBuffer;
                            this._bitLength = bitLength;
                            return -1;
                        }
                        bitBuffer |= this._buffer[pos++] << bitLength;
                        bitLength += 8;
                    } while (size > bitLength);
                    this._bufferPosition = pos;
                }
                this._bitBuffer = bitBuffer >> size;
                this._bitLength = bitLength - size;
                return bitBuffer & (1 << size) - 1;
            };
            BasicInflate.prototype._readCode = function (codeTable) {
                var bitBuffer = this._bitBuffer;
                var bitLength = this._bitLength;
                var maxBits = codeTable.maxBits;
                if (maxBits > bitLength) {
                    var pos = this._bufferPosition;
                    var end = this._bufferSize;
                    do {
                        if (pos >= end) {
                            this._bufferPosition = pos;
                            this._bitBuffer = bitBuffer;
                            this._bitLength = bitLength;
                            return -1;
                        }
                        bitBuffer |= this._buffer[pos++] << bitLength;
                        bitLength += 8;
                    } while (maxBits > bitLength);
                    this._bufferPosition = pos;
                }
                var code = codeTable.codes[bitBuffer & (1 << maxBits) - 1];
                var len = code >> 16;
                if (code & 32768) {
                    this._error('inflate: invalid encoding');
                    this._state = InflateState.ERROR;
                    return -1;
                }
                this._bitBuffer = bitBuffer >> len;
                this._bitLength = bitLength - len;
                return code & 65535;
            };
            BasicInflate.prototype._decodeBlock2Pre = function () {
                var block2State = this._block2State;
                var numCodes = block2State.numLiteralCodes + block2State.numDistanceCodes;
                var bitLengths = block2State.bitLengths;
                var i = block2State.codesRead;
                var prev = i > 0 ? bitLengths[i - 1] : 0;
                var codeLengthTable = block2State.codeLengthTable;
                var j;
                if (block2State.dupBits > 0) {
                    j = this._readBits(block2State.dupBits);
                    if (j < 0) {
                        return true;
                    }
                    while (j--) {
                        bitLengths[i++] = prev;
                    }
                    block2State.dupBits = 0;
                }
                while (i < numCodes) {
                    var sym = this._readCode(codeLengthTable);
                    if (sym < 0) {
                        block2State.codesRead = i;
                        return true;
                    } else if (sym < 16) {
                        bitLengths[i++] = prev = sym;
                        continue;
                    }
                    var j, dupBits;
                    switch (sym) {
                    case 16:
                        dupBits = 2;
                        j = 3;
                        sym = prev;
                        break;
                    case 17:
                        dupBits = 3;
                        j = 3;
                        sym = 0;
                        break;
                    case 18:
                        dupBits = 7;
                        j = 11;
                        sym = 0;
                        break;
                    }
                    while (j--) {
                        bitLengths[i++] = sym;
                    }
                    j = this._readBits(dupBits);
                    if (j < 0) {
                        block2State.codesRead = i;
                        block2State.dupBits = dupBits;
                        return true;
                    }
                    while (j--) {
                        bitLengths[i++] = sym;
                    }
                    prev = sym;
                }
                this._literalTable = makeHuffmanTable(bitLengths.subarray(0, block2State.numLiteralCodes));
                this._distanceTable = makeHuffmanTable(bitLengths.subarray(block2State.numLiteralCodes));
                this._state = InflateState.BLOCK_2;
                this._block2State = null;
                return false;
            };
            BasicInflate.prototype._decodeBlock = function () {
                var literalTable = this._literalTable, distanceTable = this._distanceTable;
                var output = this._window, pos = this._windowPosition;
                var copyState = this._copyState;
                var i, j, sym;
                var len, lenBits, dist, distBits;
                if (copyState.state !== 0) {
                    // continuing len/distance operation
                    switch (copyState.state) {
                    case 1:
                        j = 0;
                        if ((j = this._readBits(copyState.lenBits)) < 0) {
                            return true;
                        }
                        copyState.len += j;
                        copyState.state = 2;
                    /* fall through */
                    case 2:
                        if ((sym = this._readCode(distanceTable)) < 0) {
                            return true;
                        }
                        copyState.distBits = distanceExtraBits[sym];
                        copyState.dist = distanceCodes[sym];
                        copyState.state = 3;
                    /* fall through */
                    case 3:
                        j = 0;
                        if (copyState.distBits > 0 && (j = this._readBits(copyState.distBits)) < 0) {
                            return true;
                        }
                        dist = copyState.dist + j;
                        len = copyState.len;
                        i = pos - dist;
                        while (len--) {
                            output[pos++] = output[i++];
                        }
                        copyState.state = 0;
                        if (pos >= WINDOW_SHIFT_POSITION) {
                            this._windowPosition = pos;
                            return false;
                        }
                        break;
                    }
                }
                do {
                    sym = this._readCode(literalTable);
                    if (sym < 0) {
                        this._windowPosition = pos;
                        return true;
                    } else if (sym < 256) {
                        output[pos++] = sym;
                    } else if (sym > 256) {
                        this._windowPosition = pos;
                        sym -= 257;
                        lenBits = lengthExtraBits[sym];
                        len = lengthCodes[sym];
                        j = lenBits === 0 ? 0 : this._readBits(lenBits);
                        if (j < 0) {
                            copyState.state = 1;
                            copyState.len = len;
                            copyState.lenBits = lenBits;
                            return true;
                        }
                        len += j;
                        sym = this._readCode(distanceTable);
                        if (sym < 0) {
                            copyState.state = 2;
                            copyState.len = len;
                            return true;
                        }
                        distBits = distanceExtraBits[sym];
                        dist = distanceCodes[sym];
                        j = distBits === 0 ? 0 : this._readBits(distBits);
                        if (j < 0) {
                            copyState.state = 3;
                            copyState.len = len;
                            copyState.dist = dist;
                            copyState.distBits = distBits;
                            return true;
                        }
                        dist += j;
                        i = pos - dist;
                        while (len--) {
                            output[pos++] = output[i++];
                        }
                    } else {
                        this._state = InflateState.INIT;
                        break;    // end of block
                    }
                } while (pos < WINDOW_SHIFT_POSITION);
                this._windowPosition = pos;
                return false;
            };
            return BasicInflate;
        }(Inflate);
        var codeLengthOrder;
        var distanceCodes;
        var distanceExtraBits;
        var fixedDistanceTable;
        var lengthCodes;
        var lengthExtraBits;
        var fixedLiteralTable;
        var areTablesInitialized = false;
        function initializeTables() {
            codeLengthOrder = new Uint8Array([
                16,
                17,
                18,
                0,
                8,
                7,
                9,
                6,
                10,
                5,
                11,
                4,
                12,
                3,
                13,
                2,
                14,
                1,
                15
            ]);
            distanceCodes = new Uint16Array(30);
            distanceExtraBits = new Uint8Array(30);
            for (var i = 0, j = 0, code = 1; i < 30; ++i) {
                distanceCodes[i] = code;
                code += 1 << (distanceExtraBits[i] = ~~((j += i > 2 ? 1 : 0) / 2));
            }
            var bitLengths = new Uint8Array(288);
            for (var i = 0; i < 32; ++i) {
                bitLengths[i] = 5;
            }
            fixedDistanceTable = makeHuffmanTable(bitLengths.subarray(0, 32));
            lengthCodes = new Uint16Array(29);
            lengthExtraBits = new Uint8Array(29);
            for (var i = 0, j = 0, code = 3; i < 29; ++i) {
                lengthCodes[i] = code - (i == 28 ? 1 : 0);
                code += 1 << (lengthExtraBits[i] = ~~((j += i > 4 ? 1 : 0) / 4 % 6));
            }
            for (var i = 0; i < 288; ++i) {
                bitLengths[i] = i < 144 || i > 279 ? 8 : i < 256 ? 9 : 7;
            }
            fixedLiteralTable = makeHuffmanTable(bitLengths);
        }
        function makeHuffmanTable(bitLengths) {
            var maxBits = Math.max.apply(null, bitLengths);
            var numLengths = bitLengths.length;
            var size = 1 << maxBits;
            var codes = new Uint32Array(size);
            // avoiding len == 0: using max number of bits
            var dummyCode = maxBits << 16 | 65535;
            for (var j = 0; j < size; j++) {
                codes[j] = dummyCode;
            }
            for (var code = 0, len = 1, skip = 2; len <= maxBits; code <<= 1, ++len, skip <<= 1) {
                for (var val = 0; val < numLengths; ++val) {
                    if (bitLengths[val] === len) {
                        var lsb = 0;
                        for (var i = 0; i < len; ++i)
                            lsb = lsb * 2 + (code >> i & 1);
                        for (var i = lsb; i < size; i += skip)
                            codes[i] = len << 16 | val;
                        ++code;
                    }
                }
            }
            return {
                codes: codes,
                maxBits: maxBits
            };
        }
        var SpecialInflateAdapter = function (_super) {
            __extends(SpecialInflateAdapter, _super);
            function SpecialInflateAdapter(verifyHeader, createSpecialInflate) {
                _super.call(this, verifyHeader);
                this._verifyHeader = verifyHeader;
                this._specialInflate = createSpecialInflate();
                this._specialInflate.setDataCallback(function (data) {
                    this.onData(data);
                }.bind(this));
            }
            SpecialInflateAdapter.prototype.push = function (data) {
                if (this._verifyHeader) {
                    var buffer;
                    if (this._buffer) {
                        buffer = new Uint8Array(this._buffer.length + data.length);
                        buffer.set(this._buffer);
                        buffer.set(data, this._buffer.length);
                        this._buffer = null;
                    } else {
                        buffer = new Uint8Array(data);
                    }
                    var processed = this._processZLibHeader(buffer, 0, buffer.length);
                    if (processed === 0) {
                        this._buffer = buffer;
                        return;
                    }
                    this._verifyHeader = true;
                    if (processed > 0) {
                        data = buffer.subarray(processed);
                    }
                }
                this._specialInflate.push(data);
            };
            SpecialInflateAdapter.prototype.close = function () {
                if (this._specialInflate) {
                    this._specialInflate.close();
                    this._specialInflate = null;
                }
            };
            return SpecialInflateAdapter;
        }(Inflate);
        var DeflateState;
        (function (DeflateState) {
            DeflateState[DeflateState['WRITE'] = 0] = 'WRITE';
            DeflateState[DeflateState['DONE'] = 1] = 'DONE';
            DeflateState[DeflateState['ZLIB_HEADER'] = 2] = 'ZLIB_HEADER';
        }(DeflateState || (DeflateState = {})));
        var Adler32 = function () {
            function Adler32() {
                this.a = 1;
                this.b = 0;
            }
            Adler32.prototype.update = function (data, start, end) {
                var a = this.a;
                var b = this.b;
                for (var i = start; i < end; ++i) {
                    a = (a + (data[i] & 255)) % 65521;
                    b = (b + a) % 65521;
                }
                this.a = a;
                this.b = b;
            };
            Adler32.prototype.getChecksum = function () {
                return this.b << 16 | this.a;
            };
            return Adler32;
        }();
        ArrayUtilities.Adler32 = Adler32;
        var Deflate = function () {
            function Deflate(writeZlibHeader) {
                this._writeZlibHeader = writeZlibHeader;
                this._state = writeZlibHeader ? DeflateState.ZLIB_HEADER : DeflateState.WRITE;
                this._adler32 = writeZlibHeader ? new Adler32() : null;
            }
            Deflate.prototype.push = function (data) {
                if (this._state === DeflateState.ZLIB_HEADER) {
                    this.onData(new Uint8Array([
                        120,
                        156
                    ]));
                    this._state = DeflateState.WRITE;
                }
                // simple non-compressing algorithm for now
                var len = data.length;
                var outputSize = len + Math.ceil(len / 65535) * 5;
                var output = new Uint8Array(outputSize);
                var outputPos = 0;
                var pos = 0;
                while (len > 65535) {
                    output.set(new Uint8Array([
                        0,
                        255,
                        255,
                        0,
                        0
                    ]), outputPos);
                    outputPos += 5;
                    output.set(data.subarray(pos, pos + 65535), outputPos);
                    pos += 65535;
                    outputPos += 65535;
                    len -= 65535;
                }
                output.set(new Uint8Array([
                    0,
                    len & 255,
                    len >> 8 & 255,
                    ~len & 255,
                    ~len >> 8 & 255
                ]), outputPos);
                outputPos += 5;
                output.set(data.subarray(pos, len), outputPos);
                this.onData(output);
                if (this._adler32) {
                    this._adler32.update(data, 0, len);
                }
            };
            Deflate.prototype.close = function () {
                this._state = DeflateState.DONE;
                this.onData(new Uint8Array([
                    1,
                    0,
                    0,
                    255,
                    255
                ]));
                if (this._adler32) {
                    var checksum = this._adler32.getChecksum();
                    this.onData(new Uint8Array([
                        checksum & 255,
                        checksum >> 8 & 255,
                        checksum >> 16 & 255,
                        checksum >>> 24 & 255
                    ]));
                }
            };
            return Deflate;
        }();
        ArrayUtilities.Deflate = Deflate;
        var InputStream = function () {
            function InputStream() {
                this.available = 0;
                this.pos = 0;
                this.buffer = new Uint8Array(2000);
            }
            InputStream.prototype.append = function (data) {
                var length = this.pos + this.available;
                var needLength = length + data.length;
                if (needLength > this.buffer.length) {
                    var newLength = this.buffer.length * 2;
                    while (newLength < needLength) {
                        newLength *= 2;
                    }
                    var newBuffer = new Uint8Array(newLength);
                    newBuffer.set(this.buffer);
                    this.buffer = newBuffer;
                }
                this.buffer.set(data, length);
                this.available += data.length;
            };
            InputStream.prototype.compact = function () {
                if (this.available === 0) {
                    return;
                }
                this.buffer.set(this.buffer.subarray(this.pos, this.pos + this.available), 0);
                this.pos = 0;
            };
            InputStream.prototype.readByte = function () {
                if (this.available <= 0) {
                    throw new Error('Unexpected end of file');
                }
                this.available--;
                return this.buffer[this.pos++];
            };
            return InputStream;
        }();
        var OutputStream = function () {
            function OutputStream(onData) {
                this.onData = onData;
                this.processed = 0;
            }
            OutputStream.prototype.writeBytes = function (data) {
                this.onData.call(null, data);
                this.processed += data.length;
            };
            return OutputStream;
        }();
        var OutWindow = function () {
            function OutWindow(outStream) {
                this.outStream = outStream;
                this.buf = null;
                this.pos = 0;
                this.size = 0;
                this.isFull = false;
                this.writePos = 0;
                this.totalPos = 0;
            }
            OutWindow.prototype.create = function (dictSize) {
                this.buf = new Uint8Array(dictSize);
                this.pos = 0;
                this.size = dictSize;
                this.isFull = false;
                this.writePos = 0;
                this.totalPos = 0;
            };
            OutWindow.prototype.putByte = function (b) {
                this.totalPos++;
                this.buf[this.pos++] = b;
                if (this.pos === this.size) {
                    this.flush();
                    this.pos = 0;
                    this.isFull = true;
                }
            };
            OutWindow.prototype.getByte = function (dist) {
                return this.buf[dist <= this.pos ? this.pos - dist : this.size - dist + this.pos];
            };
            OutWindow.prototype.flush = function () {
                if (this.writePos < this.pos) {
                    this.outStream.writeBytes(this.buf.subarray(this.writePos, this.pos));
                    this.writePos = this.pos === this.size ? 0 : this.pos;
                }
            };
            OutWindow.prototype.copyMatch = function (dist, len) {
                var pos = this.pos;
                var size = this.size;
                var buffer = this.buf;
                var getPos = dist <= pos ? pos - dist : size - dist + pos;
                var left = len;
                while (left > 0) {
                    var chunk = Math.min(Math.min(left, size - pos), size - getPos);
                    for (var i = 0; i < chunk; i++) {
                        var b = buffer[getPos++];
                        buffer[pos++] = b;
                    }
                    if (pos === size) {
                        this.pos = pos;
                        this.flush();
                        pos = 0;
                        this.isFull = true;
                    }
                    if (getPos === size) {
                        getPos = 0;
                    }
                    left -= chunk;
                }
                this.pos = pos;
                this.totalPos += len;
            };
            OutWindow.prototype.checkDistance = function (dist) {
                return dist <= this.pos || this.isFull;
            };
            OutWindow.prototype.isEmpty = function () {
                return this.pos === 0 && !this.isFull;
            };
            return OutWindow;
        }();
        var kNumBitModelTotalBits = 11;
        var kNumMoveBits = 5;
        var PROB_INIT_VAL = 1 << kNumBitModelTotalBits >> 1;
        function createProbsArray(length) {
            var p = new Uint16Array(length);
            for (var i = 0; i < length; i++) {
                p[i] = PROB_INIT_VAL;
            }
            return p;
        }
        var kTopValue = 1 << 24;
        var RangeDecoder = function () {
            function RangeDecoder(inStream) {
                this.inStream = inStream;
                this.range = 0;
                this.code = 0;
                this.corrupted = false;
            }
            RangeDecoder.prototype.init = function () {
                if (this.inStream.readByte() !== 0) {
                    this.corrupted = true;
                }
                this.range = 4294967295 | 0;
                var code = 0;
                for (var i = 0; i < 4; i++) {
                    code = code << 8 | this.inStream.readByte();
                }
                if (code === this.range) {
                    this.corrupted = true;
                }
                this.code = code;
            };
            RangeDecoder.prototype.isFinishedOK = function () {
                return this.code === 0;
            };
            RangeDecoder.prototype.decodeDirectBits = function (numBits) {
                var res = 0;
                var range = this.range;
                var code = this.code;
                do {
                    range = range >>> 1 | 0;
                    code = code - range | 0;
                    var t = code >> 31;
                    // if high bit set -1, otherwise 0
                    code = code + (range & t) | 0;
                    if (code === range) {
                        this.corrupted = true;
                    }
                    if (range >= 0 && range < kTopValue) {
                        range = range << 8;
                        code = code << 8 | this.inStream.readByte();
                    }
                    res = (res << 1) + t + 1 | 0;
                } while (--numBits);
                this.range = range;
                this.code = code;
                return res;
            };
            RangeDecoder.prototype.decodeBit = function (prob, index) {
                var range = this.range;
                var code = this.code;
                var v = prob[index];
                var bound = (range >>> kNumBitModelTotalBits) * v;
                // keep unsigned
                var symbol;
                if (code >>> 0 < bound) {
                    v = v + ((1 << kNumBitModelTotalBits) - v >> kNumMoveBits) | 0;
                    range = bound | 0;
                    symbol = 0;
                } else {
                    v = v - (v >> kNumMoveBits) | 0;
                    code = code - bound | 0;
                    range = range - bound | 0;
                    symbol = 1;
                }
                prob[index] = v & 65535;
                if (range >= 0 && range < kTopValue) {
                    range = range << 8;
                    code = code << 8 | this.inStream.readByte();
                }
                this.range = range;
                this.code = code;
                return symbol;
            };
            return RangeDecoder;
        }();
        function bitTreeReverseDecode(probs, offset, numBits, rc) {
            var m = 1;
            var symbol = 0;
            for (var i = 0; i < numBits; i++) {
                var bit = rc.decodeBit(probs, m + offset);
                m = (m << 1) + bit;
                symbol |= bit << i;
            }
            return symbol;
        }
        var BitTreeDecoder = function () {
            function BitTreeDecoder(numBits) {
                this.numBits = numBits;
                this.probs = createProbsArray(1 << numBits);
            }
            BitTreeDecoder.prototype.decode = function (rc) {
                var m = 1;
                for (var i = 0; i < this.numBits; i++) {
                    m = (m << 1) + rc.decodeBit(this.probs, m);
                }
                return m - (1 << this.numBits);
            };
            BitTreeDecoder.prototype.reverseDecode = function (rc) {
                return bitTreeReverseDecode(this.probs, 0, this.numBits, rc);
            };
            return BitTreeDecoder;
        }();
        function createBitTreeDecoderArray(numBits, length) {
            var p = [];
            p.length = length;
            for (var i = 0; i < length; i++) {
                p[i] = new BitTreeDecoder(numBits);
            }
            return p;
        }
        var kNumPosBitsMax = 4;
        var kNumStates = 12;
        var kNumLenToPosStates = 4;
        var kNumAlignBits = 4;
        var kStartPosModelIndex = 4;
        var kEndPosModelIndex = 14;
        var kNumFullDistances = 1 << (kEndPosModelIndex >> 1);
        var kMatchMinLen = 2;
        var LenDecoder = function () {
            function LenDecoder() {
                this.choice = createProbsArray(2);
                this.lowCoder = createBitTreeDecoderArray(3, 1 << kNumPosBitsMax);
                this.midCoder = createBitTreeDecoderArray(3, 1 << kNumPosBitsMax);
                this.highCoder = new BitTreeDecoder(8);
            }
            LenDecoder.prototype.decode = function (rc, posState) {
                if (rc.decodeBit(this.choice, 0) === 0) {
                    return this.lowCoder[posState].decode(rc);
                }
                if (rc.decodeBit(this.choice, 1) === 0) {
                    return 8 + this.midCoder[posState].decode(rc);
                }
                return 16 + this.highCoder.decode(rc);
            };
            return LenDecoder;
        }();
        function updateState_Literal(state) {
            if (state < 4) {
                return 0;
            } else if (state < 10) {
                return state - 3;
            } else {
                return state - 6;
            }
        }
        function updateState_Match(state) {
            return state < 7 ? 7 : 10;
        }
        function updateState_Rep(state) {
            return state < 7 ? 8 : 11;
        }
        function updateState_ShortRep(state) {
            return state < 7 ? 9 : 11;
        }
        var LZMA_DIC_MIN = 1 << 12;
        var MAX_DECODE_BITS_CALLS = 48;
        var LzmaDecoderInternal = function () {
            function LzmaDecoderInternal(inStream, outStream) {
                this.rangeDec = new RangeDecoder(inStream);
                this.outWindow = new OutWindow(outStream);
                this.markerIsMandatory = false;
                this.lc = 0;
                this.pb = 0;
                this.lp = 0;
                this.dictSize = 0;
                this.dictSizeInProperties = 0;
                this.unpackSize = undefined;
                this.leftToUnpack = undefined;
                this.reps = new Int32Array(4);
                this.state = 0;
            }
            LzmaDecoderInternal.prototype.decodeProperties = function (properties) {
                var d = properties[0];
                if (d >= 9 * 5 * 5) {
                    throw new Error('Incorrect LZMA properties');
                }
                this.lc = d % 9;
                d = d / 9 | 0;
                this.pb = d / 5 | 0;
                this.lp = d % 5;
                this.dictSizeInProperties = 0;
                for (var i = 0; i < 4; i++) {
                    this.dictSizeInProperties |= properties[i + 1] << 8 * i;
                }
                this.dictSize = this.dictSizeInProperties;
                if (this.dictSize < LZMA_DIC_MIN) {
                    this.dictSize = LZMA_DIC_MIN;
                }
            };
            LzmaDecoderInternal.prototype.create = function () {
                this.outWindow.create(this.dictSize);
                this.init();
                this.rangeDec.init();
                this.reps[0] = 0;
                this.reps[1] = 0;
                this.reps[2] = 0;
                this.reps[3] = 0;
                this.state = 0;
                this.leftToUnpack = this.unpackSize;
            };
            LzmaDecoderInternal.prototype.decodeLiteral = function (state, rep0) {
                var outWindow = this.outWindow;
                var rangeDec = this.rangeDec;
                var prevByte = 0;
                if (!outWindow.isEmpty()) {
                    prevByte = outWindow.getByte(1);
                }
                var symbol = 1;
                var litState = ((outWindow.totalPos & (1 << this.lp) - 1) << this.lc) + (prevByte >> 8 - this.lc);
                var probsIndex = 768 * litState;
                if (state >= 7) {
                    var matchByte = outWindow.getByte(rep0 + 1);
                    do {
                        var matchBit = matchByte >> 7 & 1;
                        matchByte <<= 1;
                        var bit = rangeDec.decodeBit(this.litProbs, probsIndex + ((1 + matchBit << 8) + symbol));
                        symbol = symbol << 1 | bit;
                        if (matchBit !== bit) {
                            break;
                        }
                    } while (symbol < 256);
                }
                while (symbol < 256) {
                    symbol = symbol << 1 | rangeDec.decodeBit(this.litProbs, probsIndex + symbol);
                }
                return symbol - 256 & 255;
            };
            LzmaDecoderInternal.prototype.decodeDistance = function (len) {
                var lenState = len;
                if (lenState > kNumLenToPosStates - 1) {
                    lenState = kNumLenToPosStates - 1;
                }
                var rangeDec = this.rangeDec;
                var posSlot = this.posSlotDecoder[lenState].decode(rangeDec);
                if (posSlot < 4) {
                    return posSlot;
                }
                var numDirectBits = (posSlot >> 1) - 1;
                var dist = (2 | posSlot & 1) << numDirectBits;
                if (posSlot < kEndPosModelIndex) {
                    dist = dist + bitTreeReverseDecode(this.posDecoders, dist - posSlot, numDirectBits, rangeDec) | 0;
                } else {
                    dist = dist + (rangeDec.decodeDirectBits(numDirectBits - kNumAlignBits) << kNumAlignBits) | 0;
                    dist = dist + this.alignDecoder.reverseDecode(rangeDec) | 0;
                }
                return dist;
            };
            LzmaDecoderInternal.prototype.init = function () {
                this.litProbs = createProbsArray(768 << this.lc + this.lp);
                this.posSlotDecoder = createBitTreeDecoderArray(6, kNumLenToPosStates);
                this.alignDecoder = new BitTreeDecoder(kNumAlignBits);
                this.posDecoders = createProbsArray(1 + kNumFullDistances - kEndPosModelIndex);
                this.isMatch = createProbsArray(kNumStates << kNumPosBitsMax);
                this.isRep = createProbsArray(kNumStates);
                this.isRepG0 = createProbsArray(kNumStates);
                this.isRepG1 = createProbsArray(kNumStates);
                this.isRepG2 = createProbsArray(kNumStates);
                this.isRep0Long = createProbsArray(kNumStates << kNumPosBitsMax);
                this.lenDecoder = new LenDecoder();
                this.repLenDecoder = new LenDecoder();
            };
            LzmaDecoderInternal.prototype.decode = function (notFinal) {
                var rangeDec = this.rangeDec;
                var outWindow = this.outWindow;
                var pb = this.pb;
                var dictSize = this.dictSize;
                var markerIsMandatory = this.markerIsMandatory;
                var leftToUnpack = this.leftToUnpack;
                var isMatch = this.isMatch;
                var isRep = this.isRep;
                var isRepG0 = this.isRepG0;
                var isRepG1 = this.isRepG1;
                var isRepG2 = this.isRepG2;
                var isRep0Long = this.isRep0Long;
                var lenDecoder = this.lenDecoder;
                var repLenDecoder = this.repLenDecoder;
                var rep0 = this.reps[0];
                var rep1 = this.reps[1];
                var rep2 = this.reps[2];
                var rep3 = this.reps[3];
                var state = this.state;
                while (true) {
                    // Based on worse case scenario one byte consumed per decodeBit calls,
                    // reserving keeping some amount of bytes in the input stream for
                    // non-final data blocks.
                    if (notFinal && rangeDec.inStream.available < MAX_DECODE_BITS_CALLS) {
                        this.outWindow.flush();
                        break;
                    }
                    if (leftToUnpack === 0 && !markerIsMandatory) {
                        this.outWindow.flush();
                        if (rangeDec.isFinishedOK()) {
                            return LZMA_RES_FINISHED_WITHOUT_MARKER;
                        }
                    }
                    var posState = outWindow.totalPos & (1 << pb) - 1;
                    if (rangeDec.decodeBit(isMatch, (state << kNumPosBitsMax) + posState) === 0) {
                        if (leftToUnpack === 0) {
                            return LZMA_RES_ERROR;
                        }
                        outWindow.putByte(this.decodeLiteral(state, rep0));
                        state = updateState_Literal(state);
                        leftToUnpack--;
                        continue;
                    }
                    var len;
                    if (rangeDec.decodeBit(isRep, state) !== 0) {
                        if (leftToUnpack === 0) {
                            return LZMA_RES_ERROR;
                        }
                        if (outWindow.isEmpty()) {
                            return LZMA_RES_ERROR;
                        }
                        if (rangeDec.decodeBit(isRepG0, state) === 0) {
                            if (rangeDec.decodeBit(isRep0Long, (state << kNumPosBitsMax) + posState) === 0) {
                                state = updateState_ShortRep(state);
                                outWindow.putByte(outWindow.getByte(rep0 + 1));
                                leftToUnpack--;
                                continue;
                            }
                        } else {
                            var dist;
                            if (rangeDec.decodeBit(isRepG1, state) === 0) {
                                dist = rep1;
                            } else {
                                if (rangeDec.decodeBit(isRepG2, state) === 0) {
                                    dist = rep2;
                                } else {
                                    dist = rep3;
                                    rep3 = rep2;
                                }
                                rep2 = rep1;
                            }
                            rep1 = rep0;
                            rep0 = dist;
                        }
                        len = repLenDecoder.decode(rangeDec, posState);
                        state = updateState_Rep(state);
                    } else {
                        rep3 = rep2;
                        rep2 = rep1;
                        rep1 = rep0;
                        len = lenDecoder.decode(rangeDec, posState);
                        state = updateState_Match(state);
                        rep0 = this.decodeDistance(len);
                        if (rep0 === -1) {
                            this.outWindow.flush();
                            return rangeDec.isFinishedOK() ? LZMA_RES_FINISHED_WITH_MARKER : LZMA_RES_ERROR;
                        }
                        if (leftToUnpack === 0) {
                            return LZMA_RES_ERROR;
                        }
                        if (rep0 >= dictSize || !outWindow.checkDistance(rep0)) {
                            return LZMA_RES_ERROR;
                        }
                    }
                    len += kMatchMinLen;
                    var isError = false;
                    if (leftToUnpack !== undefined && leftToUnpack < len) {
                        len = leftToUnpack;
                        isError = true;
                    }
                    outWindow.copyMatch(rep0 + 1, len);
                    leftToUnpack -= len;
                    if (isError) {
                        return LZMA_RES_ERROR;
                    }
                }
                this.state = state;
                this.reps[0] = rep0;
                this.reps[1] = rep1;
                this.reps[2] = rep2;
                this.reps[3] = rep3;
                this.leftToUnpack = leftToUnpack;
                return LZMA_RES_NOT_COMPLETE;
            };
            LzmaDecoderInternal.prototype.flushOutput = function () {
                this.outWindow.flush();
            };
            return LzmaDecoderInternal;
        }();
        var LZMA_RES_ERROR = 0;
        var LZMA_RES_FINISHED_WITH_MARKER = 1;
        var LZMA_RES_FINISHED_WITHOUT_MARKER = 2;
        var LZMA_RES_NOT_COMPLETE = 3;
        var SWF_LZMA_HEADER_LENGTH = 17;
        var STANDARD_LZMA_HEADER_LENGTH = 13;
        var EXTRA_LZMA_BYTES_NEEDED = 5;
        var LzmaDecoderState;
        (function (LzmaDecoderState) {
            LzmaDecoderState[LzmaDecoderState['WAIT_FOR_LZMA_HEADER'] = 0] = 'WAIT_FOR_LZMA_HEADER';
            LzmaDecoderState[LzmaDecoderState['WAIT_FOR_SWF_HEADER'] = 1] = 'WAIT_FOR_SWF_HEADER';
            LzmaDecoderState[LzmaDecoderState['PROCESS_DATA'] = 2] = 'PROCESS_DATA';
            LzmaDecoderState[LzmaDecoderState['CLOSED'] = 3] = 'CLOSED';
            LzmaDecoderState[LzmaDecoderState['ERROR'] = 4] = 'ERROR';
        }(LzmaDecoderState || (LzmaDecoderState = {})));
        var LzmaDecoder = function () {
            function LzmaDecoder(swfHeader) {
                if (swfHeader === void 0) {
                    swfHeader = false;
                }
                this._state = swfHeader ? LzmaDecoderState.WAIT_FOR_SWF_HEADER : LzmaDecoderState.WAIT_FOR_LZMA_HEADER;
                this.buffer = null;
            }
            LzmaDecoder.prototype.push = function (data) {
                if (this._state < LzmaDecoderState.PROCESS_DATA) {
                    var buffered = this.buffer ? this.buffer.length : 0;
                    var headerBytesExpected = (this._state === LzmaDecoderState.WAIT_FOR_SWF_HEADER ? SWF_LZMA_HEADER_LENGTH : STANDARD_LZMA_HEADER_LENGTH) + EXTRA_LZMA_BYTES_NEEDED;
                    if (buffered + data.length < headerBytesExpected) {
                        var newBuffer = new Uint8Array(buffered + data.length);
                        if (buffered > 0) {
                            newBuffer.set(this.buffer);
                        }
                        newBuffer.set(data, buffered);
                        this.buffer = newBuffer;
                        return;
                    }
                    var header = new Uint8Array(headerBytesExpected);
                    if (buffered > 0) {
                        header.set(this.buffer);
                    }
                    header.set(data.subarray(0, headerBytesExpected - buffered), buffered);
                    this._inStream = new InputStream();
                    this._inStream.append(header.subarray(headerBytesExpected - EXTRA_LZMA_BYTES_NEEDED));
                    this._outStream = new OutputStream(function (data) {
                        this.onData.call(null, data);
                    }.bind(this));
                    this._decoder = new LzmaDecoderInternal(this._inStream, this._outStream);
                    // See http://helpx.adobe.com/flash-player/kb/exception-thrown-you-decompress-lzma-compressed.html
                    if (this._state === LzmaDecoderState.WAIT_FOR_SWF_HEADER) {
                        this._decoder.decodeProperties(header.subarray(12, 17));
                        this._decoder.markerIsMandatory = false;
                        this._decoder.unpackSize = ((header[4] | header[5] << 8 | header[6] << 16 | header[7] << 24) >>> 0) - 8;
                    } else {
                        this._decoder.decodeProperties(header.subarray(0, 5));
                        var unpackSize = 0;
                        var unpackSizeDefined = false;
                        for (var i = 0; i < 8; i++) {
                            var b = header[5 + i];
                            if (b !== 255) {
                                unpackSizeDefined = true;
                            }
                            unpackSize |= b << 8 * i;
                        }
                        this._decoder.markerIsMandatory = !unpackSizeDefined;
                        this._decoder.unpackSize = unpackSizeDefined ? unpackSize : undefined;
                    }
                    this._decoder.create();
                    data = data.subarray(headerBytesExpected);
                    this._state = LzmaDecoderState.PROCESS_DATA;
                } else if (this._state !== LzmaDecoderState.PROCESS_DATA) {
                    return;
                }
                try {
                    this._inStream.append(data);
                    var res = this._decoder.decode(true);
                    this._inStream.compact();
                    if (res !== LZMA_RES_NOT_COMPLETE) {
                        this._checkError(res);
                    }
                } catch (e) {
                    this._decoder.flushOutput();
                    this._decoder = null;
                    this._error(e);
                }
            };
            LzmaDecoder.prototype.close = function () {
                if (this._state !== LzmaDecoderState.PROCESS_DATA) {
                    return;
                }
                this._state = LzmaDecoderState.CLOSED;
                try {
                    var res = this._decoder.decode(false);
                    this._checkError(res);
                } catch (e) {
                    this._decoder.flushOutput();
                    this._error(e);
                }
                this._decoder = null;
            };
            LzmaDecoder.prototype._error = function (error) {
                // Stopping processing any data if an error occurs.
                this._state = LzmaDecoderState.ERROR;
                if (this.onError) {
                    this.onError(error);
                }
            };
            LzmaDecoder.prototype._checkError = function (res) {
                var error;
                if (res === LZMA_RES_ERROR) {
                    error = 'LZMA decoding error';
                } else if (res === LZMA_RES_NOT_COMPLETE) {
                    error = 'Decoding is not complete';
                } else if (res === LZMA_RES_FINISHED_WITH_MARKER) {
                    if (this._decoder.unpackSize !== undefined && this._decoder.unpackSize !== this._outStream.processed) {
                        error = 'Finished with end marker before than specified size';
                    }
                } else {
                    error = 'Internal LZMA Error';
                }
                if (error) {
                    this._error(error);
                }
            };
            return LzmaDecoder;
        }();
        ArrayUtilities.LzmaDecoder = LzmaDecoder;
        var notImplemented = Shumway.Debug.notImplemented;
        var assert = Shumway.Debug.assert;
        var utf8decode = Shumway.StringUtilities.utf8decode;
        var utf8encode = Shumway.StringUtilities.utf8encode;
        var clamp = Shumway.NumberUtilities.clamp;
        function axCoerceString(x) {
            if (typeof x === 'string') {
                return x;
            } else if (x == undefined) {
                return null;
            }
            return x + '';
        }
        var PlainObjectDataBuffer = function () {
            function PlainObjectDataBuffer(buffer, length, littleEndian) {
                this.buffer = buffer;
                this.length = length;
                this.littleEndian = littleEndian;
            }
            return PlainObjectDataBuffer;
        }();
        ArrayUtilities.PlainObjectDataBuffer = PlainObjectDataBuffer;
        var bitMasks = new Uint32Array(33);
        for (var i = 1, mask = 0; i <= 32; i++) {
            bitMasks[i] = mask = mask << 1 | 1;
        }
        var TypedArrayViewFlags;
        (function (TypedArrayViewFlags) {
            TypedArrayViewFlags[TypedArrayViewFlags['U8'] = 1] = 'U8';
            TypedArrayViewFlags[TypedArrayViewFlags['I32'] = 2] = 'I32';
            TypedArrayViewFlags[TypedArrayViewFlags['F32'] = 4] = 'F32';
        }(TypedArrayViewFlags || (TypedArrayViewFlags = {})));
        var DataBuffer = function () {
            function DataBuffer(initialSize) {
                if (initialSize === void 0) {
                    initialSize = DataBuffer.INITIAL_SIZE;
                }
                // If we're constructing a child class of DataBuffer (or ByteArray), buffer initialization
                // has already happened at this point.
                if (this._buffer) {
                    return;
                }
                this._buffer = new ArrayBuffer(initialSize);
                this._length = 0;
                this._position = 0;
                this._resetViews();
                this._littleEndian = DataBuffer._nativeLittleEndian;
                this._bitBuffer = 0;
                this._bitLength = 0;
            }
            DataBuffer.FromArrayBuffer = function (buffer, length) {
                if (length === void 0) {
                    length = -1;
                }
                var dataBuffer = Object.create(DataBuffer.prototype);
                dataBuffer._buffer = buffer;
                dataBuffer._length = length === -1 ? buffer.byteLength : length;
                dataBuffer._position = 0;
                dataBuffer._resetViews();
                dataBuffer._littleEndian = DataBuffer._nativeLittleEndian;
                dataBuffer._bitBuffer = 0;
                dataBuffer._bitLength = 0;
                return dataBuffer;
            };
            DataBuffer.FromPlainObject = function (source) {
                var dataBuffer = DataBuffer.FromArrayBuffer(source.buffer, source.length);
                dataBuffer._littleEndian = source.littleEndian;
                return dataBuffer;
            };
            DataBuffer.prototype.toPlainObject = function () {
                return new PlainObjectDataBuffer(this._buffer, this._length, this._littleEndian);
            };
            /**
             * Clone the DataBuffer in a way that guarantees the underlying ArrayBuffer to be copied
             * into an instance of the current global's ArrayBuffer.
             *
             * Important if the underlying buffer comes from a different global, in which case accessing
             * its elements is excruiciatingly slow.
             */
            DataBuffer.prototype.clone = function () {
                var clone = DataBuffer.FromArrayBuffer(new Uint8Array(this._u8).buffer, this._length);
                clone._position = this._position;
                clone._littleEndian = this._littleEndian;
                clone._bitBuffer = this._bitBuffer;
                clone._bitLength = this._bitLength;
                return clone;
            };
            /**
             * By default, we only have a byte view. All other views are |null|.
             */
            DataBuffer.prototype._resetViews = function () {
                this._u8 = new Uint8Array(this._buffer);
                this._i32 = null;
                this._f32 = null;
            };
            /**
             * We don't want to eagerly allocate views if we won't ever need them. You must call this method
             * before using a view of a certain type to make sure it's available. Once a view is allocated,
             * it is not re-allocated unless the view becomes |null| as a result of a call to |resetViews|.
             */
            DataBuffer.prototype._requestViews = function (flags) {
                if ((this._buffer.byteLength & 3) === 0) {
                    if (this._i32 === null && flags & TypedArrayViewFlags.I32) {
                        this._i32 = new Int32Array(this._buffer);
                    }
                    if (this._f32 === null && flags & TypedArrayViewFlags.F32) {
                        this._f32 = new Float32Array(this._buffer);
                    }
                }
            };
            DataBuffer.prototype.getBytes = function () {
                return new Uint8Array(this._buffer, 0, this._length);
            };
            DataBuffer.prototype._ensureCapacity = function (length) {
                var currentBuffer = this._buffer;
                if (currentBuffer.byteLength >= length) {
                    return;
                }
                var newLength = Math.max(currentBuffer.byteLength, 1);
                while (newLength < length) {
                    newLength *= 2;
                }
                if (newLength > 4294967295) {
                    release || assert(this.sec);
                    this.sec.throwError('RangeError', Errors.ParamRangeError);
                }
                var newBuffer = DataBuffer._arrayBufferPool.acquire(newLength);
                var curentView = this._u8;
                this._buffer = newBuffer;
                this._resetViews();
                this._u8.set(curentView);
                var u8 = this._u8;
                // Zero out the rest of the buffer, since the arrayBufferPool doesn't
                // always give us a empty buffer.
                for (var i = curentView.length; i < u8.length; i++) {
                    u8[i] = 0;
                }
                DataBuffer._arrayBufferPool.release(currentBuffer);
            };
            DataBuffer.prototype.clear = function () {
                this._length = 0;
                this._position = 0;
            };
            DataBuffer.prototype.readBoolean = function () {
                return this.readUnsignedByte() !== 0;
            };
            DataBuffer.prototype.readByte = function () {
                return this.readUnsignedByte() << 24 >> 24;
            };
            DataBuffer.prototype.readUnsignedByte = function () {
                if (this._position + 1 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Errors.EOFError);
                }
                return this._u8[this._position++];
            };
            DataBuffer.prototype.readBytes = function (bytes, offset, length) {
                var position = this._position;
                offset = offset >>> 0;
                length = length >>> 0;
                if (length === 0) {
                    length = this._length - position;
                }
                if (position + length > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Errors.EOFError);
                }
                if (bytes.length < offset + length) {
                    bytes._ensureCapacity(offset + length);
                    bytes.length = offset + length;
                }
                bytes._u8.set(new Uint8Array(this._buffer, position, length), offset);
                this._position += length;
            };
            DataBuffer.prototype.readShort = function () {
                return this.readUnsignedShort() << 16 >> 16;
            };
            DataBuffer.prototype.readUnsignedShort = function () {
                var u8 = this._u8;
                var position = this._position;
                if (position + 2 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Errors.EOFError);
                }
                var a = u8[position + 0];
                var b = u8[position + 1];
                this._position = position + 2;
                return this._littleEndian ? b << 8 | a : a << 8 | b;
            };
            DataBuffer.prototype.readInt = function () {
                var u8 = this._u8;
                var position = this._position;
                if (position + 4 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Errors.EOFError);
                }
                var a = u8[position + 0];
                var b = u8[position + 1];
                var c = u8[position + 2];
                var d = u8[position + 3];
                this._position = position + 4;
                return this._littleEndian ? d << 24 | c << 16 | b << 8 | a : a << 24 | b << 16 | c << 8 | d;
            };
            DataBuffer.prototype.readUnsignedInt = function () {
                return this.readInt() >>> 0;
            };
            DataBuffer.prototype.readFloat = function () {
                var position = this._position;
                if (position + 4 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Errors.EOFError);
                }
                this._position = position + 4;
                this._requestViews(TypedArrayViewFlags.F32);
                if (this._littleEndian && (position & 3) === 0 && this._f32) {
                    return this._f32[position >> 2];
                } else {
                    var u8 = this._u8;
                    var t8 = Shumway.IntegerUtilities.u8;
                    if (this._littleEndian) {
                        t8[0] = u8[position + 0];
                        t8[1] = u8[position + 1];
                        t8[2] = u8[position + 2];
                        t8[3] = u8[position + 3];
                    } else {
                        t8[3] = u8[position + 0];
                        t8[2] = u8[position + 1];
                        t8[1] = u8[position + 2];
                        t8[0] = u8[position + 3];
                    }
                    return Shumway.IntegerUtilities.f32[0];
                }
            };
            DataBuffer.prototype.readDouble = function () {
                var u8 = this._u8;
                var position = this._position;
                if (position + 8 > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Errors.EOFError);
                }
                var t8 = Shumway.IntegerUtilities.u8;
                if (this._littleEndian) {
                    t8[0] = u8[position + 0];
                    t8[1] = u8[position + 1];
                    t8[2] = u8[position + 2];
                    t8[3] = u8[position + 3];
                    t8[4] = u8[position + 4];
                    t8[5] = u8[position + 5];
                    t8[6] = u8[position + 6];
                    t8[7] = u8[position + 7];
                } else {
                    t8[0] = u8[position + 7];
                    t8[1] = u8[position + 6];
                    t8[2] = u8[position + 5];
                    t8[3] = u8[position + 4];
                    t8[4] = u8[position + 3];
                    t8[5] = u8[position + 2];
                    t8[6] = u8[position + 1];
                    t8[7] = u8[position + 0];
                }
                this._position = position + 8;
                return Shumway.IntegerUtilities.f64[0];
            };
            DataBuffer.prototype.writeBoolean = function (value) {
                this.writeByte(!!value ? 1 : 0);
            };
            DataBuffer.prototype.writeByte = function (value) {
                var length = this._position + 1;
                this._ensureCapacity(length);
                this._u8[this._position++] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };
            DataBuffer.prototype.writeUnsignedByte = function (value) {
                var length = this._position + 1;
                this._ensureCapacity(length);
                this._u8[this._position++] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };
            DataBuffer.prototype.writeRawBytes = function (bytes) {
                var length = this._position + bytes.length;
                this._ensureCapacity(length);
                this._u8.set(bytes, this._position);
                this._position = length;
                if (length > this._length) {
                    this._length = length;
                }
            };
            DataBuffer.prototype.writeBytes = function (bytes, offset, length) {
                if (Shumway.isNullOrUndefined(bytes)) {
                    release || assert(this.sec);
                    this.sec.throwError('TypeError', Errors.NullPointerError, 'bytes');
                }
                offset = offset >>> 0;
                length = length >>> 0;
                if (arguments.length < 2) {
                    offset = 0;
                }
                if (arguments.length < 3) {
                    length = 0;
                }
                if (offset !== clamp(offset, 0, bytes.length) || offset + length !== clamp(offset + length, 0, bytes.length)) {
                    release || assert(this.sec);
                    this.sec.throwError('RangeError', Errors.ParamRangeError);
                }
                if (length === 0) {
                    length = bytes.length - offset;
                }
                this.writeRawBytes(new Int8Array(bytes._buffer, offset, length));
            };
            DataBuffer.prototype.writeShort = function (value) {
                this.writeUnsignedShort(value);
            };
            DataBuffer.prototype.writeUnsignedShort = function (value) {
                var position = this._position;
                this._ensureCapacity(position + 2);
                var u8 = this._u8;
                if (this._littleEndian) {
                    u8[position + 0] = value;
                    u8[position + 1] = value >> 8;
                } else {
                    u8[position + 0] = value >> 8;
                    u8[position + 1] = value;
                }
                position += 2;
                this._position = position;
                if (position > this._length) {
                    this._length = position;
                }
            };
            DataBuffer.prototype.writeInt = function (value) {
                this.writeUnsignedInt(value);
            };
            DataBuffer.prototype.write2Ints = function (a, b) {
                this.write2UnsignedInts(a, b);
            };
            DataBuffer.prototype.write4Ints = function (a, b, c, d) {
                this.write4UnsignedInts(a, b, c, d);
            };
            DataBuffer.prototype.writeUnsignedInt = function (value) {
                var position = this._position;
                this._ensureCapacity(position + 4);
                this._requestViews(TypedArrayViewFlags.I32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 3) === 0 && this._i32) {
                    this._i32[position >> 2] = value;
                } else {
                    var u8 = this._u8;
                    if (this._littleEndian) {
                        u8[position + 0] = value;
                        u8[position + 1] = value >> 8;
                        u8[position + 2] = value >> 16;
                        u8[position + 3] = value >> 24;
                    } else {
                        u8[position + 0] = value >> 24;
                        u8[position + 1] = value >> 16;
                        u8[position + 2] = value >> 8;
                        u8[position + 3] = value;
                    }
                }
                position += 4;
                this._position = position;
                if (position > this._length) {
                    this._length = position;
                }
            };
            DataBuffer.prototype.write2UnsignedInts = function (a, b) {
                var position = this._position;
                this._ensureCapacity(position + 8);
                this._requestViews(TypedArrayViewFlags.I32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 3) === 0 && this._i32) {
                    this._i32[(position >> 2) + 0] = a;
                    this._i32[(position >> 2) + 1] = b;
                    position += 8;
                    this._position = position;
                    if (position > this._length) {
                        this._length = position;
                    }
                } else {
                    this.writeUnsignedInt(a);
                    this.writeUnsignedInt(b);
                }
            };
            DataBuffer.prototype.write4UnsignedInts = function (a, b, c, d) {
                var position = this._position;
                this._ensureCapacity(position + 16);
                this._requestViews(TypedArrayViewFlags.I32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 3) === 0 && this._i32) {
                    this._i32[(position >> 2) + 0] = a;
                    this._i32[(position >> 2) + 1] = b;
                    this._i32[(position >> 2) + 2] = c;
                    this._i32[(position >> 2) + 3] = d;
                    position += 16;
                    this._position = position;
                    if (position > this._length) {
                        this._length = position;
                    }
                } else {
                    this.writeUnsignedInt(a);
                    this.writeUnsignedInt(b);
                    this.writeUnsignedInt(c);
                    this.writeUnsignedInt(d);
                }
            };
            DataBuffer.prototype.writeFloat = function (value) {
                var position = this._position;
                this._ensureCapacity(position + 4);
                this._requestViews(TypedArrayViewFlags.F32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 3) === 0 && this._f32) {
                    this._f32[position >> 2] = value;
                } else {
                    var u8 = this._u8;
                    Shumway.IntegerUtilities.f32[0] = value;
                    var t8 = Shumway.IntegerUtilities.u8;
                    if (this._littleEndian) {
                        u8[position + 0] = t8[0];
                        u8[position + 1] = t8[1];
                        u8[position + 2] = t8[2];
                        u8[position + 3] = t8[3];
                    } else {
                        u8[position + 0] = t8[3];
                        u8[position + 1] = t8[2];
                        u8[position + 2] = t8[1];
                        u8[position + 3] = t8[0];
                    }
                }
                position += 4;
                this._position = position;
                if (position > this._length) {
                    this._length = position;
                }
            };
            DataBuffer.prototype.write2Floats = function (a, b) {
                var position = this._position;
                this._ensureCapacity(position + 8);
                this._requestViews(TypedArrayViewFlags.F32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 3) === 0 && this._f32) {
                    this._f32[(position >> 2) + 0] = a;
                    this._f32[(position >> 2) + 1] = b;
                    position += 8;
                    this._position = position;
                    if (position > this._length) {
                        this._length = position;
                    }
                } else {
                    this.writeFloat(a);
                    this.writeFloat(b);
                }
            };
            DataBuffer.prototype.write6Floats = function (a, b, c, d, e, f) {
                var position = this._position;
                this._ensureCapacity(position + 24);
                this._requestViews(TypedArrayViewFlags.F32);
                if (this._littleEndian === DataBuffer._nativeLittleEndian && (position & 3) === 0 && this._f32) {
                    this._f32[(position >> 2) + 0] = a;
                    this._f32[(position >> 2) + 1] = b;
                    this._f32[(position >> 2) + 2] = c;
                    this._f32[(position >> 2) + 3] = d;
                    this._f32[(position >> 2) + 4] = e;
                    this._f32[(position >> 2) + 5] = f;
                    position += 24;
                    this._position = position;
                    if (position > this._length) {
                        this._length = position;
                    }
                } else {
                    this.writeFloat(a);
                    this.writeFloat(b);
                    this.writeFloat(c);
                    this.writeFloat(d);
                    this.writeFloat(e);
                    this.writeFloat(f);
                }
            };
            DataBuffer.prototype.writeDouble = function (value) {
                var position = this._position;
                this._ensureCapacity(position + 8);
                var u8 = this._u8;
                Shumway.IntegerUtilities.f64[0] = value;
                var t8 = Shumway.IntegerUtilities.u8;
                if (this._littleEndian) {
                    u8[position + 0] = t8[0];
                    u8[position + 1] = t8[1];
                    u8[position + 2] = t8[2];
                    u8[position + 3] = t8[3];
                    u8[position + 4] = t8[4];
                    u8[position + 5] = t8[5];
                    u8[position + 6] = t8[6];
                    u8[position + 7] = t8[7];
                } else {
                    u8[position + 0] = t8[7];
                    u8[position + 1] = t8[6];
                    u8[position + 2] = t8[5];
                    u8[position + 3] = t8[4];
                    u8[position + 4] = t8[3];
                    u8[position + 5] = t8[2];
                    u8[position + 6] = t8[1];
                    u8[position + 7] = t8[0];
                }
                position += 8;
                this._position = position;
                if (position > this._length) {
                    this._length = position;
                }
            };
            DataBuffer.prototype.readRawBytes = function () {
                return new Int8Array(this._buffer, 0, this._length);
            };
            DataBuffer.prototype.writeUTF = function (value) {
                value = axCoerceString(value);
                var bytes = utf8decode(value);
                this.writeShort(bytes.length);
                this.writeRawBytes(bytes);
            };
            DataBuffer.prototype.writeUTFBytes = function (value) {
                value = axCoerceString(value);
                var bytes = utf8decode(value);
                this.writeRawBytes(bytes);
            };
            DataBuffer.prototype.readUTF = function () {
                return this.readUTFBytes(this.readShort());
            };
            DataBuffer.prototype.readUTFBytes = function (length) {
                length = length >>> 0;
                var pos = this._position;
                if (pos + length > this._length) {
                    release || assert(this.sec);
                    this.sec.throwError('flash.errors.EOFError', Errors.EOFError);
                }
                this._position += length;
                return utf8encode(new Int8Array(this._buffer, pos, length));
            };
            Object.defineProperty(DataBuffer.prototype, 'length', {
                get: function () {
                    return this._length;
                },
                set: function (value) {
                    value = value >>> 0;
                    var capacity = this._buffer.byteLength;
                    /* XXX: Do we need to zero the difference if length <= cap? */
                    if (value > capacity) {
                        this._ensureCapacity(value);
                    }
                    this._length = value;
                    this._position = clamp(this._position, 0, this._length);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, 'bytesAvailable', {
                get: function () {
                    return this._length - this._position;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, 'position', {
                get: function () {
                    return this._position;
                },
                set: function (position) {
                    this._position = position >>> 0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, 'buffer', {
                get: function () {
                    return this._buffer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, 'bytes', {
                get: function () {
                    return this._u8;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, 'ints', {
                get: function () {
                    this._requestViews(TypedArrayViewFlags.I32);
                    return this._i32;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, 'objectEncoding', {
                get: function () {
                    return this._objectEncoding;
                },
                set: function (version) {
                    version = version >>> 0;
                    this._objectEncoding = version;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataBuffer.prototype, 'endian', {
                get: function () {
                    return this._littleEndian ? 'littleEndian' : 'bigEndian';
                },
                set: function (type) {
                    type = axCoerceString(type);
                    if (type === 'auto') {
                        this._littleEndian = DataBuffer._nativeLittleEndian;
                    } else {
                        this._littleEndian = type === 'littleEndian';
                    }
                },
                enumerable: true,
                configurable: true
            });
            DataBuffer.prototype.toString = function () {
                return utf8encode(new Int8Array(this._buffer, 0, this._length));
            };
            DataBuffer.prototype.toBlob = function (type) {
                return new Blob([new Int8Array(this._buffer, this._position, this._length)], { type: type });
            };
            DataBuffer.prototype.writeMultiByte = function (value, charSet) {
                value = axCoerceString(value);
                charSet = axCoerceString(charSet);
                release || release || notImplemented('packageInternal flash.utils.ObjectOutput::writeMultiByte');
                return;
            };
            DataBuffer.prototype.readMultiByte = function (length, charSet) {
                length = length >>> 0;
                charSet = axCoerceString(charSet);
                release || release || notImplemented('packageInternal flash.utils.ObjectInput::readMultiByte');
                return;
            };
            DataBuffer.prototype.getValue = function (name) {
                name = name | 0;
                if (name >= this._length) {
                    return undefined;
                }
                return this._u8[name];
            };
            DataBuffer.prototype.setValue = function (name, value) {
                name = name | 0;
                var length = name + 1;
                this._ensureCapacity(length);
                this._u8[name] = value;
                if (length > this._length) {
                    this._length = length;
                }
            };
            DataBuffer.prototype.readFixed = function () {
                return this.readInt() / 65536;
            };
            DataBuffer.prototype.readFixed8 = function () {
                return this.readShort() / 256;
            };
            DataBuffer.prototype.readFloat16 = function () {
                var uint16 = this.readUnsignedShort();
                var sign = uint16 >> 15 ? -1 : 1;
                var exponent = (uint16 & 31744) >> 10;
                var fraction = uint16 & 1023;
                if (!exponent) {
                    return sign * Math.pow(2, -14) * (fraction / 1024);
                }
                if (exponent === 31) {
                    return fraction ? NaN : sign * Infinity;
                }
                return sign * Math.pow(2, exponent - 15) * (1 + fraction / 1024);
            };
            DataBuffer.prototype.readEncodedU32 = function () {
                var value = this.readUnsignedByte();
                if (!(value & 128)) {
                    return value;
                }
                value = value & 127 | this.readUnsignedByte() << 7;
                if (!(value & 16384)) {
                    return value;
                }
                value = value & 16383 | this.readUnsignedByte() << 14;
                if (!(value & 2097152)) {
                    return value;
                }
                value = value & 2097151 | this.readUnsignedByte() << 21;
                if (!(value & 268435456)) {
                    return value;
                }
                return value & 268435455 | this.readUnsignedByte() << 28;
            };
            DataBuffer.prototype.readBits = function (size) {
                return this.readUnsignedBits(size) << 32 - size >> 32 - size;
            };
            DataBuffer.prototype.readUnsignedBits = function (size) {
                var buffer = this._bitBuffer;
                var length = this._bitLength;
                while (size > length) {
                    buffer = buffer << 8 | this.readUnsignedByte();
                    length += 8;
                }
                length -= size;
                var value = buffer >>> length & bitMasks[size];
                this._bitBuffer = buffer;
                this._bitLength = length;
                return value;
            };
            DataBuffer.prototype.readFixedBits = function (size) {
                return this.readBits(size) / 65536;
            };
            DataBuffer.prototype.readString = function (length) {
                var position = this._position;
                if (length) {
                    if (position + length > this._length) {
                        release || assert(this.sec);
                        this.sec.throwError('flash.errors.EOFError', Errors.EOFError);
                    }
                    this._position += length;
                } else {
                    length = 0;
                    for (var i = position; i < this._length && this._u8[i]; i++) {
                        length++;
                    }
                    this._position += length + 1;
                }
                return utf8encode(new Int8Array(this._buffer, position, length));
            };
            DataBuffer.prototype.align = function () {
                this._bitBuffer = 0;
                this._bitLength = 0;
            };
            DataBuffer.prototype.deflate = function () {
                this.compress('deflate');
            };
            DataBuffer.prototype.inflate = function () {
                this.uncompress('deflate');
            };
            DataBuffer.prototype.compress = function (algorithm) {
                if (arguments.length === 0) {
                    algorithm = 'zlib';
                } else {
                    algorithm = axCoerceString(algorithm);
                }
                var deflate;
                switch (algorithm) {
                case 'zlib':
                    deflate = new ArrayUtilities.Deflate(true);
                    break;
                case 'deflate':
                    deflate = new ArrayUtilities.Deflate(false);
                    break;
                default:
                    return;
                }
                var output = new DataBuffer();
                deflate.onData = output.writeRawBytes.bind(output);
                deflate.push(this._u8.subarray(0, this._length));
                deflate.close();
                this._ensureCapacity(output._u8.length);
                this._u8.set(output._u8);
                this.length = output.length;
                this._position = 0;
            };
            DataBuffer.prototype.uncompress = function (algorithm) {
                if (arguments.length === 0) {
                    algorithm = 'zlib';
                } else {
                    algorithm = axCoerceString(algorithm);
                }
                var inflate;
                switch (algorithm) {
                case 'zlib':
                    inflate = ArrayUtilities.Inflate.create(true);
                    break;
                case 'deflate':
                    inflate = ArrayUtilities.Inflate.create(false);
                    break;
                case 'lzma':
                    inflate = new ArrayUtilities.LzmaDecoder(false);
                    break;
                default:
                    return;
                }
                var output = new DataBuffer();
                var error;
                inflate.onData = output.writeRawBytes.bind(output);
                inflate.onError = function (e) {
                    return error = e;
                };
                inflate.push(this._u8.subarray(0, this._length));
                if (error) {
                    release || assert(this.sec);
                    this.sec.throwError('IOError', Errors.CompressedDataError);
                }
                inflate.close();
                this._ensureCapacity(output._u8.length);
                this._u8.set(output._u8);
                this.length = output.length;
                this._position = 0;
            };
            DataBuffer._nativeLittleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;
            /* The initial size of the backing, in bytes. Doubled every OOM. */
            DataBuffer.INITIAL_SIZE = 128;
            DataBuffer._arrayBufferPool = new Shumway.ArrayBufferPool();
            return DataBuffer;
        }();
        ArrayUtilities.DataBuffer = DataBuffer;
    }(ArrayUtilities = Shumway.ArrayUtilities || (Shumway.ArrayUtilities = {})));
    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
    var ensureTypedArrayCapacity = Shumway.ArrayUtilities.ensureTypedArrayCapacity;
    var assert = Shumway.Debug.assert;
    var PlainObjectShapeData = function () {
        function PlainObjectShapeData(commands, commandsPosition, coordinates, morphCoordinates, coordinatesPosition, styles, stylesLength, morphStyles, morphStylesLength, hasFills, hasLines) {
            this.commands = commands;
            this.commandsPosition = commandsPosition;
            this.coordinates = coordinates;
            this.morphCoordinates = morphCoordinates;
            this.coordinatesPosition = coordinatesPosition;
            this.styles = styles;
            this.stylesLength = stylesLength;
            this.morphStyles = morphStyles;
            this.morphStylesLength = morphStylesLength;
            this.hasFills = hasFills;
            this.hasLines = hasLines;
        }
        return PlainObjectShapeData;
    }();
    Shumway.PlainObjectShapeData = PlainObjectShapeData;
    var DefaultSize;
    (function (DefaultSize) {
        DefaultSize[DefaultSize['Commands'] = 32] = 'Commands';
        DefaultSize[DefaultSize['Coordinates'] = 128] = 'Coordinates';
        DefaultSize[DefaultSize['Styles'] = 16] = 'Styles';
    }(DefaultSize || (DefaultSize = {})));
    var ShapeData = function () {
        function ShapeData(initialize) {
            if (initialize === void 0) {
                initialize = true;
            }
            if (initialize) {
                this.clear();
            }
        }
        ShapeData.FromPlainObject = function (source) {
            var data = new ShapeData(false);
            data.commands = source.commands;
            data.coordinates = source.coordinates;
            data.morphCoordinates = source.morphCoordinates;
            data.commandsPosition = source.commandsPosition;
            data.coordinatesPosition = source.coordinatesPosition;
            data.styles = DataBuffer.FromArrayBuffer(source.styles, source.stylesLength);
            data.styles.endian = 'auto';
            if (source.morphStyles) {
                data.morphStyles = DataBuffer.FromArrayBuffer(source.morphStyles, source.morphStylesLength);
                data.morphStyles.endian = 'auto';
            }
            data.hasFills = source.hasFills;
            data.hasLines = source.hasLines;
            return data;
        };
        ShapeData.prototype.moveTo = function (x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = 9    /* MoveTo */;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };
        ShapeData.prototype.lineTo = function (x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = 10    /* LineTo */;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };
        ShapeData.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
            this.ensurePathCapacities(1, 4);
            this.commands[this.commandsPosition++] = 11    /* CurveTo */;
            this.coordinates[this.coordinatesPosition++] = controlX;
            this.coordinates[this.coordinatesPosition++] = controlY;
            this.coordinates[this.coordinatesPosition++] = anchorX;
            this.coordinates[this.coordinatesPosition++] = anchorY;
        };
        ShapeData.prototype.cubicCurveTo = function (controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
            this.ensurePathCapacities(1, 6);
            this.commands[this.commandsPosition++] = 12    /* CubicCurveTo */;
            this.coordinates[this.coordinatesPosition++] = controlX1;
            this.coordinates[this.coordinatesPosition++] = controlY1;
            this.coordinates[this.coordinatesPosition++] = controlX2;
            this.coordinates[this.coordinatesPosition++] = controlY2;
            this.coordinates[this.coordinatesPosition++] = anchorX;
            this.coordinates[this.coordinatesPosition++] = anchorY;
        };
        ShapeData.prototype.beginFill = function (color) {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 1    /* BeginSolidFill */;
            this.styles.writeUnsignedInt(color);
            this.hasFills = true;
        };
        ShapeData.prototype.writeMorphFill = function (color) {
            this.morphStyles.writeUnsignedInt(color);
        };
        ShapeData.prototype.endFill = function () {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 4    /* EndFill */;
        };
        ShapeData.prototype.endLine = function () {
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = 8    /* LineEnd */;
        };
        ShapeData.prototype.lineStyle = function (thickness, color, pixelHinting, scaleMode, caps, joints, miterLimit) {
            release || assert(thickness === (thickness | 0), thickness >= 0 && thickness <= 255 * 20);
            this.ensurePathCapacities(2, 0);
            this.commands[this.commandsPosition++] = 5    /* LineStyleSolid */;
            this.coordinates[this.coordinatesPosition++] = thickness;
            var styles = this.styles;
            styles.writeUnsignedInt(color);
            styles.writeBoolean(pixelHinting);
            styles.writeUnsignedByte(scaleMode);
            styles.writeUnsignedByte(caps);
            styles.writeUnsignedByte(joints);
            styles.writeUnsignedByte(miterLimit);
            this.hasLines = true;
        };
        ShapeData.prototype.writeMorphLineStyle = function (thickness, color) {
            this.morphCoordinates[this.coordinatesPosition - 1] = thickness;
            this.morphStyles.writeUnsignedInt(color);
        };
        /**
         * Bitmaps are specified the same for fills and strokes, so we only need to serialize them
         * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
         * be one of BeginBitmapFill and LineStyleBitmap.
         */
        ShapeData.prototype.beginBitmap = function (pathCommand, bitmapId, matrix, repeat, smooth) {
            release || assert(pathCommand === 3    /* BeginBitmapFill */ || pathCommand === 7    /* LineStyleBitmap */);
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = pathCommand;
            var styles = this.styles;
            styles.writeUnsignedInt(bitmapId);
            this._writeStyleMatrix(matrix, false);
            styles.writeBoolean(repeat);
            styles.writeBoolean(smooth);
            this.hasFills = true;
        };
        ShapeData.prototype.writeMorphBitmap = function (matrix) {
            this._writeStyleMatrix(matrix, true);
        };
        /**
         * Gradients are specified the same for fills and strokes, so we only need to serialize them
         * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
         * be one of BeginGradientFill and LineStyleGradient.
         */
        ShapeData.prototype.beginGradient = function (pathCommand, colors, ratios, gradientType, matrix, spread, interpolation, focalPointRatio) {
            release || assert(pathCommand === 2    /* BeginGradientFill */ || pathCommand === 6    /* LineStyleGradient */);
            this.ensurePathCapacities(1, 0);
            this.commands[this.commandsPosition++] = pathCommand;
            var styles = this.styles;
            styles.writeUnsignedByte(gradientType);
            release || assert(focalPointRatio === (focalPointRatio | 0));
            styles.writeShort(focalPointRatio);
            this._writeStyleMatrix(matrix, false);
            var colorStops = colors.length;
            styles.writeByte(colorStops);
            for (var i = 0; i < colorStops; i++) {
                // Ratio must be valid, otherwise we'd have bailed above.
                styles.writeUnsignedByte(ratios[i]);
                // Colors are coerced to uint32, with the highest byte stripped.
                styles.writeUnsignedInt(colors[i]);
            }
            styles.writeUnsignedByte(spread);
            styles.writeUnsignedByte(interpolation);
            this.hasFills = true;
        };
        ShapeData.prototype.writeMorphGradient = function (colors, ratios, matrix) {
            this._writeStyleMatrix(matrix, true);
            var styles = this.morphStyles;
            for (var i = 0; i < colors.length; i++) {
                // Ratio must be valid, otherwise we'd have bailed above.
                styles.writeUnsignedByte(ratios[i]);
                // Colors are coerced to uint32, with the highest byte stripped.
                styles.writeUnsignedInt(colors[i]);
            }
        };
        ShapeData.prototype.writeCommandAndCoordinates = function (command, x, y) {
            this.ensurePathCapacities(1, 2);
            this.commands[this.commandsPosition++] = command;
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };
        ShapeData.prototype.writeCoordinates = function (x, y) {
            this.ensurePathCapacities(0, 2);
            this.coordinates[this.coordinatesPosition++] = x;
            this.coordinates[this.coordinatesPosition++] = y;
        };
        ShapeData.prototype.writeMorphCoordinates = function (x, y) {
            this.morphCoordinates = ensureTypedArrayCapacity(this.morphCoordinates, this.coordinatesPosition);
            this.morphCoordinates[this.coordinatesPosition - 2] = x;
            this.morphCoordinates[this.coordinatesPosition - 1] = y;
        };
        ShapeData.prototype.clear = function () {
            this.commandsPosition = this.coordinatesPosition = 0;
            this.commands = new Uint8Array(DefaultSize.Commands);
            this.coordinates = new Int32Array(DefaultSize.Coordinates);
            this.styles = new DataBuffer(DefaultSize.Styles);
            this.styles.endian = 'auto';
            this.hasFills = this.hasLines = false;
        };
        ShapeData.prototype.isEmpty = function () {
            return this.commandsPosition === 0;
        };
        ShapeData.prototype.clone = function () {
            var copy = new ShapeData(false);
            copy.commands = new Uint8Array(this.commands);
            copy.commandsPosition = this.commandsPosition;
            copy.coordinates = new Int32Array(this.coordinates);
            copy.coordinatesPosition = this.coordinatesPosition;
            copy.styles = new DataBuffer(this.styles.length);
            copy.styles.writeRawBytes(this.styles.bytes.subarray(0, this.styles.length));
            if (this.morphStyles) {
                copy.morphStyles = new DataBuffer(this.morphStyles.length);
                copy.morphStyles.writeRawBytes(this.morphStyles.bytes.subarray(0, this.morphStyles.length));
            }
            copy.hasFills = this.hasFills;
            copy.hasLines = this.hasLines;
            return copy;
        };
        ShapeData.prototype.toPlainObject = function () {
            return new PlainObjectShapeData(this.commands, this.commandsPosition, this.coordinates, this.morphCoordinates, this.coordinatesPosition, this.styles.buffer, this.styles.length, this.morphStyles && this.morphStyles.buffer, this.morphStyles ? this.morphStyles.length : 0, this.hasFills, this.hasLines);
        };
        Object.defineProperty(ShapeData.prototype, 'buffers', {
            get: function () {
                var buffers = [
                    this.commands.buffer,
                    this.coordinates.buffer,
                    this.styles.buffer
                ];
                if (this.morphCoordinates) {
                    buffers.push(this.morphCoordinates.buffer);
                }
                if (this.morphStyles) {
                    buffers.push(this.morphStyles.buffer);
                }
                return buffers;
            },
            enumerable: true,
            configurable: true
        });
        ShapeData.prototype._writeStyleMatrix = function (matrix, isMorph) {
            var styles = isMorph ? this.morphStyles : this.styles;
            styles.write6Floats(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
        };
        ShapeData.prototype.ensurePathCapacities = function (numCommands, numCoordinates) {
            // ensureTypedArrayCapacity will hopefully be inlined, in which case the field writes
            // will be optimized out.
            this.commands = ensureTypedArrayCapacity(this.commands, this.commandsPosition + numCommands);
            this.coordinates = ensureTypedArrayCapacity(this.coordinates, this.coordinatesPosition + numCoordinates);
        };
        return ShapeData;
    }();
    Shumway.ShapeData = ShapeData;
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var SwfTagCodeNames = [
                'CODE_END',
                'CODE_SHOW_FRAME',
                'CODE_DEFINE_SHAPE',
                'CODE_FREE_CHARACTER',
                'CODE_PLACE_OBJECT',
                'CODE_REMOVE_OBJECT',
                'CODE_DEFINE_BITS',
                'CODE_DEFINE_BUTTON',
                'CODE_JPEG_TABLES',
                'CODE_SET_BACKGROUND_COLOR',
                'CODE_DEFINE_FONT',
                'CODE_DEFINE_TEXT',
                'CODE_DO_ACTION',
                'CODE_DEFINE_FONT_INFO',
                'CODE_DEFINE_SOUND',
                'CODE_START_SOUND',
                'CODE_STOP_SOUND',
                'CODE_DEFINE_BUTTON_SOUND',
                'CODE_SOUND_STREAM_HEAD',
                'CODE_SOUND_STREAM_BLOCK',
                'CODE_DEFINE_BITS_LOSSLESS',
                'CODE_DEFINE_BITS_JPEG2',
                'CODE_DEFINE_SHAPE2',
                'CODE_DEFINE_BUTTON_CXFORM',
                'CODE_PROTECT',
                'CODE_PATHS_ARE_POSTSCRIPT',
                'CODE_PLACE_OBJECT2',
                'INVALID',
                'CODE_REMOVE_OBJECT2',
                'CODE_SYNC_FRAME',
                'INVALID',
                'CODE_FREE_ALL',
                'CODE_DEFINE_SHAPE3',
                'CODE_DEFINE_TEXT2',
                'CODE_DEFINE_BUTTON2',
                'CODE_DEFINE_BITS_JPEG3',
                'CODE_DEFINE_BITS_LOSSLESS2',
                'CODE_DEFINE_EDIT_TEXT',
                'CODE_DEFINE_VIDEO',
                'CODE_DEFINE_SPRITE',
                'CODE_NAME_CHARACTER',
                'CODE_PRODUCT_INFO',
                'CODE_DEFINE_TEXT_FORMAT',
                'CODE_FRAME_LABEL',
                'CODE_DEFINE_BEHAVIOUR',
                'CODE_SOUND_STREAM_HEAD2',
                'CODE_DEFINE_MORPH_SHAPE',
                'CODE_GENERATE_FRAME',
                'CODE_DEFINE_FONT2',
                'CODE_GEN_COMMAND',
                'CODE_DEFINE_COMMAND_OBJECT',
                'CODE_CHARACTER_SET',
                'CODE_EXTERNAL_FONT',
                'CODE_DEFINE_FUNCTION',
                'CODE_PLACE_FUNCTION',
                'CODE_GEN_TAG_OBJECTS',
                'CODE_EXPORT_ASSETS',
                'CODE_IMPORT_ASSETS',
                'CODE_ENABLE_DEBUGGER',
                'CODE_DO_INIT_ACTION',
                'CODE_DEFINE_VIDEO_STREAM',
                'CODE_VIDEO_FRAME',
                'CODE_DEFINE_FONT_INFO2',
                'CODE_DEBUG_ID',
                'CODE_ENABLE_DEBUGGER2',
                'CODE_SCRIPT_LIMITS',
                'CODE_SET_TAB_INDEX',
                'CODE_DEFINE_SHAPE4',
                'INVALID',
                'CODE_FILE_ATTRIBUTES',
                'CODE_PLACE_OBJECT3',
                'CODE_IMPORT_ASSETS2',
                'CODE_DO_ABC_DEFINE',
                'CODE_DEFINE_FONT_ALIGN_ZONES',
                'CODE_CSM_TEXT_SETTINGS',
                'CODE_DEFINE_FONT3',
                'CODE_SYMBOL_CLASS',
                'CODE_METADATA',
                'CODE_DEFINE_SCALING_GRID',
                'INVALID',
                'INVALID',
                'INVALID',
                'CODE_DO_ABC',
                'CODE_DEFINE_SHAPE4',
                'CODE_DEFINE_MORPH_SHAPE2',
                'INVALID',
                'CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA',
                'CODE_DEFINE_BINARY_DATA',
                'CODE_DEFINE_FONT_NAME',
                'CODE_START_SOUND2',
                'CODE_DEFINE_BITS_JPEG4',
                'CODE_DEFINE_FONT4',
                'CODE_TELEMETRY'
            ];
            function getSwfTagCodeName(tagCode) {
                return release ? 'SwfTagCode: ' + tagCode : SwfTagCodeNames[tagCode];
            }
            Parser.getSwfTagCodeName = getSwfTagCodeName;
            (function (DefinitionTags) {
                DefinitionTags[DefinitionTags['CODE_DEFINE_SHAPE'] = 2] = 'CODE_DEFINE_SHAPE';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BITS'] = 6] = 'CODE_DEFINE_BITS';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BUTTON'] = 7] = 'CODE_DEFINE_BUTTON';
                DefinitionTags[DefinitionTags['CODE_DEFINE_FONT'] = 10] = 'CODE_DEFINE_FONT';
                DefinitionTags[DefinitionTags['CODE_DEFINE_TEXT'] = 11] = 'CODE_DEFINE_TEXT';
                DefinitionTags[DefinitionTags['CODE_DEFINE_SOUND'] = 14] = 'CODE_DEFINE_SOUND';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BITS_LOSSLESS'] = 20] = 'CODE_DEFINE_BITS_LOSSLESS';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BITS_JPEG2'] = 21] = 'CODE_DEFINE_BITS_JPEG2';
                DefinitionTags[DefinitionTags['CODE_DEFINE_SHAPE2'] = 22] = 'CODE_DEFINE_SHAPE2';
                DefinitionTags[DefinitionTags['CODE_DEFINE_SHAPE3'] = 32] = 'CODE_DEFINE_SHAPE3';
                DefinitionTags[DefinitionTags['CODE_DEFINE_TEXT2'] = 33] = 'CODE_DEFINE_TEXT2';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BUTTON2'] = 34] = 'CODE_DEFINE_BUTTON2';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BITS_JPEG3'] = 35] = 'CODE_DEFINE_BITS_JPEG3';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BITS_LOSSLESS2'] = 36] = 'CODE_DEFINE_BITS_LOSSLESS2';
                DefinitionTags[DefinitionTags['CODE_DEFINE_EDIT_TEXT'] = 37] = 'CODE_DEFINE_EDIT_TEXT';
                DefinitionTags[DefinitionTags['CODE_DEFINE_SPRITE'] = 39] = 'CODE_DEFINE_SPRITE';
                DefinitionTags[DefinitionTags['CODE_DEFINE_MORPH_SHAPE'] = 46] = 'CODE_DEFINE_MORPH_SHAPE';
                DefinitionTags[DefinitionTags['CODE_DEFINE_FONT2'] = 48] = 'CODE_DEFINE_FONT2';
                DefinitionTags[DefinitionTags['CODE_DEFINE_VIDEO_STREAM'] = 60] = 'CODE_DEFINE_VIDEO_STREAM';
                DefinitionTags[DefinitionTags['CODE_DEFINE_FONT3'] = 75] = 'CODE_DEFINE_FONT3';
                DefinitionTags[DefinitionTags['CODE_DEFINE_SHAPE4'] = 83] = 'CODE_DEFINE_SHAPE4';
                DefinitionTags[DefinitionTags['CODE_DEFINE_MORPH_SHAPE2'] = 84] = 'CODE_DEFINE_MORPH_SHAPE2';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BINARY_DATA'] = 87] = 'CODE_DEFINE_BINARY_DATA';
                DefinitionTags[DefinitionTags['CODE_DEFINE_BITS_JPEG4'] = 90] = 'CODE_DEFINE_BITS_JPEG4';
                DefinitionTags[DefinitionTags['CODE_DEFINE_FONT4'] = 91] = 'CODE_DEFINE_FONT4';
            }(Parser.DefinitionTags || (Parser.DefinitionTags = {})));
            var DefinitionTags = Parser.DefinitionTags;
            (function (ImageDefinitionTags) {
                ImageDefinitionTags[ImageDefinitionTags['CODE_DEFINE_BITS'] = 6] = 'CODE_DEFINE_BITS';
                ImageDefinitionTags[ImageDefinitionTags['CODE_DEFINE_BITS_JPEG2'] = 21] = 'CODE_DEFINE_BITS_JPEG2';
                ImageDefinitionTags[ImageDefinitionTags['CODE_DEFINE_BITS_JPEG3'] = 35] = 'CODE_DEFINE_BITS_JPEG3';
                ImageDefinitionTags[ImageDefinitionTags['CODE_DEFINE_BITS_JPEG4'] = 90] = 'CODE_DEFINE_BITS_JPEG4';
            }(Parser.ImageDefinitionTags || (Parser.ImageDefinitionTags = {})));
            var ImageDefinitionTags = Parser.ImageDefinitionTags;
            (function (FontDefinitionTags) {
                FontDefinitionTags[FontDefinitionTags['CODE_DEFINE_FONT'] = 10] = 'CODE_DEFINE_FONT';
                FontDefinitionTags[FontDefinitionTags['CODE_DEFINE_FONT2'] = 48] = 'CODE_DEFINE_FONT2';
                FontDefinitionTags[FontDefinitionTags['CODE_DEFINE_FONT3'] = 75] = 'CODE_DEFINE_FONT3';
                FontDefinitionTags[FontDefinitionTags['CODE_DEFINE_FONT4'] = 91] = 'CODE_DEFINE_FONT4';
            }(Parser.FontDefinitionTags || (Parser.FontDefinitionTags = {})));
            var FontDefinitionTags = Parser.FontDefinitionTags;
            (function (ControlTags) {
                ControlTags[ControlTags['CODE_PLACE_OBJECT'] = 4] = 'CODE_PLACE_OBJECT';
                ControlTags[ControlTags['CODE_PLACE_OBJECT2'] = 26] = 'CODE_PLACE_OBJECT2';
                ControlTags[ControlTags['CODE_PLACE_OBJECT3'] = 70] = 'CODE_PLACE_OBJECT3';
                ControlTags[ControlTags['CODE_REMOVE_OBJECT'] = 5] = 'CODE_REMOVE_OBJECT';
                ControlTags[ControlTags['CODE_REMOVE_OBJECT2'] = 28] = 'CODE_REMOVE_OBJECT2';
                ControlTags[ControlTags['CODE_START_SOUND'] = 15] = 'CODE_START_SOUND';
                ControlTags[ControlTags['CODE_START_SOUND2'] = 89] = 'CODE_START_SOUND2';
                ControlTags[ControlTags['CODE_VIDEO_FRAME'] = 61] = 'CODE_VIDEO_FRAME';
            }(Parser.ControlTags || (Parser.ControlTags = {})));
            var ControlTags = Parser.ControlTags;
        }(Parser = SWF.Parser || (SWF.Parser = {})));
    }(SWF = Shumway.SWF || (Shumway.SWF = {})));
    var unexpected = Shumway.Debug.unexpected;
    var BinaryFileReader = function () {
        function BinaryFileReader(url, method, mimeType, data) {
            this.url = url;
            this.method = method;
            this.mimeType = mimeType;
            this.data = data;
        }
        BinaryFileReader.prototype.readAll = function (progress, complete) {
            var url = this.url;
            var xhr = this.xhr = new XMLHttpRequest({ mozSystem: true });
            var async = true;
            xhr.open(this.method || 'GET', this.url, async);
            xhr.responseType = 'arraybuffer';
            if (progress) {
                xhr.onprogress = function (event) {
                    progress(xhr.response, event.loaded, event.total);
                };
            }
            xhr.onreadystatechange = function (event) {
                if (xhr.readyState === 4) {
                    if (xhr.status !== 200 && xhr.status !== 0 || xhr.response === null) {
                        unexpected('Path: ' + url + ' not found.');
                        complete(null, xhr.statusText);
                        return;
                    }
                    complete(xhr.response);
                }
            };
            if (this.mimeType) {
                xhr.setRequestHeader('Content-Type', this.mimeType);
            }
            xhr.send(this.data || null);
        };
        BinaryFileReader.prototype.readChunked = function (chunkSize, ondata, onerror, onopen, oncomplete, onhttpstatus) {
            if (chunkSize <= 0) {
                this.readAsync(ondata, onerror, onopen, oncomplete, onhttpstatus);
                return;
            }
            var position = 0;
            var buffer = new Uint8Array(chunkSize);
            var read = 0, total;
            this.readAsync(function (data, progress) {
                total = progress.total;
                var left = data.length, offset = 0;
                while (position + left >= chunkSize) {
                    var tailSize = chunkSize - position;
                    buffer.set(data.subarray(offset, offset + tailSize), position);
                    offset += tailSize;
                    left -= tailSize;
                    read += chunkSize;
                    ondata(buffer, {
                        loaded: read,
                        total: total
                    });
                    position = 0;
                }
                buffer.set(data.subarray(offset), position);
                position += left;
            }, onerror, onopen, function () {
                if (position > 0) {
                    read += position;
                    ondata(buffer.subarray(0, position), {
                        loaded: read,
                        total: total
                    });
                    position = 0;
                }
                oncomplete && oncomplete();
            }, onhttpstatus);
        };
        BinaryFileReader.prototype.readAsync = function (ondata, onerror, onopen, oncomplete, onhttpstatus) {
            var xhr = this.xhr = new XMLHttpRequest({ mozSystem: true });
            var url = this.url;
            var loaded = 0;
            var total = 0;
            xhr.open(this.method || 'GET', url, true);
            xhr.responseType = 'moz-chunked-arraybuffer';
            var isNotProgressive = xhr.responseType !== 'moz-chunked-arraybuffer';
            if (isNotProgressive) {
                xhr.responseType = 'arraybuffer';
            }
            xhr.onprogress = function (e) {
                if (isNotProgressive) {
                    return;
                }
                loaded = e.loaded;
                total = e.total;
                var bytes = new Uint8Array(xhr.response);
                // The event's `loaded` and `total` properties are sometimes lower than the actual
                // number of loaded bytes. In that case, increase them to that value.
                loaded = Math.max(loaded, bytes.byteLength);
                total = Math.max(total, bytes.byteLength);
                ondata(bytes, {
                    loaded: loaded,
                    total: total
                });
            };
            xhr.onreadystatechange = function (event) {
                if (xhr.readyState === 2 && onhttpstatus) {
                    onhttpstatus(url, xhr.status, xhr.getAllResponseHeaders());
                }
                if (xhr.readyState === 4) {
                    // Failed loads can be detected through either the status code or the fact that nothing
                    // has been loaded.
                    // Note: Just checking that `xhr.response` is set doesn't work, as Firefox enables
                    // chunked loading, and in that mode `response` is only set in the `onprogress` handler.
                    if (xhr.status !== 200 && xhr.status !== 0 || xhr.response === null && (total === 0 || loaded !== total)) {
                        onerror(xhr.statusText);
                        return;
                    }
                    if (isNotProgressive) {
                        var buffer = xhr.response;
                        ondata(new Uint8Array(buffer), {
                            loaded: buffer.byteLength,
                            total: buffer.byteLength
                        });
                    }
                }
            };
            xhr.onload = function () {
                if (oncomplete) {
                    oncomplete();
                }
            };
            if (this.mimeType) {
                xhr.setRequestHeader('Content-Type', this.mimeType);
            }
            xhr.send(this.data || null);
            if (onopen) {
                onopen();
            }
        };
        BinaryFileReader.prototype.abort = function () {
            if (this.xhr) {
                this.xhr.abort();
                this.xhr = null;
            }
        };
        return BinaryFileReader;
    }();
    Shumway.BinaryFileReader = BinaryFileReader;
    // Produces similar output as flashlog.txt It can be produced by the
    // debug builds of Flash Player.
    // See https://github.com/mozilla/shumway/wiki/Trace-Output-with-Flash-Player-Debugger
    var FlashLog = function () {
        function FlashLog() {
            this.isAS3TraceOn = true;
            this._startTime = Date.now();
        }
        Object.defineProperty(FlashLog.prototype, 'currentTimestamp', {
            get: function () {
                return Date.now() - this._startTime;
            },
            enumerable: true,
            configurable: true
        });
        FlashLog.prototype._writeLine = function (line) {
            Shumway.Debug.abstractMethod('FlashLog._writeLine');
        };
        FlashLog.prototype.writeAS3Trace = function (msg) {
            if (this.isAS3TraceOn) {
                this._writeLine(this.currentTimestamp + ' AVMINF: ' + msg);
            }
        };
        return FlashLog;
    }();
    Shumway.FlashLog = FlashLog;
    Shumway.flashlog = null;
    var Remoting;
    (function (Remoting) {
        (function (FilterType) {
            FilterType[FilterType['Blur'] = 0] = 'Blur';
            FilterType[FilterType['DropShadow'] = 1] = 'DropShadow';
            FilterType[FilterType['ColorMatrix'] = 2] = 'ColorMatrix';
        }(Remoting.FilterType || (Remoting.FilterType = {})));
        var FilterType = Remoting.FilterType;
        Remoting.MouseEventNames = [
            'click',
            'dblclick',
            'mousedown',
            'mousemove',
            'mouseup',
            'mouseover',
            'mouseout'
        ];
        Remoting.KeyboardEventNames = [
            'keydown',
            'keypress',
            'keyup'
        ];
        /**
         * Implementation of ITransportPeer that uses standard DOM postMessage and
         * events to exchange data between messaging peers.
         */
        var WindowTransportPeer = function () {
            function WindowTransportPeer(window, target) {
                this.window = window;
                this.target = target;    //
            }
            Object.defineProperty(WindowTransportPeer.prototype, 'onAsyncMessage', {
                set: function (callback) {
                    this.window.addEventListener('message', function (e) {
                        Promise.resolve(e.data).then(function (msg) {
                            callback(msg);
                        });
                    });
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(WindowTransportPeer.prototype, 'onSyncMessage', {
                set: function (callback) {
                    this.window.addEventListener('syncmessage', function (e) {
                        var wrappedMessage = e.detail;
                        wrappedMessage.result = callback(wrappedMessage.msg);
                    });
                },
                enumerable: true,
                configurable: true
            });
            WindowTransportPeer.prototype.postAsyncMessage = function (msg, transfers) {
                this.target.postMessage(msg, '*', transfers);
            };
            WindowTransportPeer.prototype.sendSyncMessage = function (msg, transfers) {
                var event = this.target.document.createEvent('CustomEvent');
                var wrappedMessage = {
                    msg: msg,
                    result: undefined
                };
                event.initCustomEvent('syncmessage', false, false, wrappedMessage);
                this.target.dispatchEvent(event);
                return wrappedMessage.result;
            };
            return WindowTransportPeer;
        }();
        Remoting.WindowTransportPeer = WindowTransportPeer;
        /**
         * Implementation of ITransportPeer that uses ShumwayCom API to exchange data
         * between messaging peers.
         */
        var ShumwayComTransportPeer = function () {
            function ShumwayComTransportPeer() {
            }
            Object.defineProperty(ShumwayComTransportPeer.prototype, 'onAsyncMessage', {
                set: function (callback) {
                    ShumwayCom.setAsyncMessageCallback(callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComTransportPeer.prototype, 'onSyncMessage', {
                set: function (callback) {
                    ShumwayCom.setSyncMessageCallback(callback);
                },
                enumerable: true,
                configurable: true
            });
            ShumwayComTransportPeer.prototype.postAsyncMessage = function (msg, transfers) {
                ShumwayCom.postAsyncMessage(msg);
            };
            ShumwayComTransportPeer.prototype.sendSyncMessage = function (msg, transfers) {
                return ShumwayCom.sendSyncMessage(msg);
            };
            return ShumwayComTransportPeer;
        }();
        Remoting.ShumwayComTransportPeer = ShumwayComTransportPeer;
    }(Remoting = Shumway.Remoting || (Shumway.Remoting = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ShumwayEnvironment = {
    DEBUG: 'test',
    DEVELOPMENT: 'dev',
    RELEASE: 'release',
    TEST: 'test'
};
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
///<reference path='es6-promises.d.ts' />
///<reference path='utilities.ts' />
///<reference path='options.ts' />
///<reference path='settings.ts'/>
///<reference path='metrics.ts' />
///<reference path='deflate.ts' />
///<reference path='lzma.ts' />
///<reference path='dataBuffer.ts' />
///<reference path='ShapeData.ts' />
///<reference path='SWFTags.ts' />
///<reference path='binaryFileReader.ts' />
///<reference path='flashlog.ts' />
///<reference path='remoting.ts' />
///<reference path='external.ts' />
var throwError;
var Errors;
//# sourceMappingURL=base.js.map
console.timeEnd('Load Shared Dependencies');
console.time('Load AVM2 Dependencies');
/*
 * Copyright 2013 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
var Shumway;
(function (Shumway) {
    var AVMX;
    (function (AVMX) {
        AVMX.timelineBuffer = Shumway.Tools ? new Shumway.Tools.Profiler.TimelineBuffer('AVX') : null;
        AVMX.counter = new Shumway.Metrics.Counter(!release);
        function countTimeline(name, value) {
            if (value === void 0) {
                value = 1;
            }
            AVMX.timelineBuffer && AVMX.timelineBuffer.count(name, value);
        }
        AVMX.countTimeline = countTimeline;
        function enterTimeline(name, data) {
            profile && AVMX.timelineBuffer && AVMX.timelineBuffer.enter(name, data);
        }
        AVMX.enterTimeline = enterTimeline;
        function leaveTimeline(data) {
            profile && AVMX.timelineBuffer && AVMX.timelineBuffer.leave(null, data);
        }
        AVMX.leaveTimeline = leaveTimeline;
        AVMX.Errors = {
            /**
             * AVM2 Error Codes
             */
            //  OutOfMemoryError                     : {code: 1000, message: "The system is out of memory."},
            NotImplementedError: {
                code: 1001,
                message: 'The method %1 is not implemented.'
            },
            InvalidPrecisionError: {
                code: 1002,
                message: 'Number.toPrecision has a range of 1 to 21. Number.toFixed and Number.toExponential have a range of 0 to 20. Specified value is not within expected range.'
            },
            InvalidRadixError: {
                code: 1003,
                message: 'The radix argument must be between 2 and 36; got %1.'
            },
            InvokeOnIncompatibleObjectError: {
                code: 1004,
                message: 'Method %1 was invoked on an incompatible object.'
            },
            ArrayIndexNotIntegerError: {
                code: 1005,
                message: 'Array index is not a positive integer (%1).'
            },
            CallOfNonFunctionError: {
                code: 1006,
                message: '%1 is not a function.'
            },
            ConstructOfNonFunctionError: {
                code: 1007,
                message: 'Instantiation attempted on a non-constructor.'
            },
            //  AmbiguousBindingError                : {code: 1008, message: "%1 is ambiguous; Found more than one matching binding."},
            ConvertNullToObjectError: {
                code: 1009,
                message: 'Cannot access a property or method of a null object reference.'
            },
            ConvertUndefinedToObjectError: {
                code: 1010,
                message: 'A term is undefined and has no properties.'
            },
            //  IllegalOpcodeError                   : {code: 1011, message: "Method %1 contained illegal opcode %2 at offset %3."},
            //  LastInstExceedsCodeSizeError         : {code: 1012, message: "The last instruction exceeded code size."},
            //  FindVarWithNoScopeError              : {code: 1013, message: "Cannot call OP_findproperty when scopeDepth is 0."},
            ClassNotFoundError: {
                code: 1014,
                message: 'Class %1 could not be found.'
            },
            //  IllegalSetDxns                       : {code: 1015, message: "Method %1 cannot set default xml namespace"},
            DescendentsError: {
                code: 1016,
                message: 'Descendants operator (..) not supported on type %1.'
            },
            //  ScopeStackOverflowError              : {code: 1017, message: "Scope stack overflow occurred."},
            //  ScopeStackUnderflowError             : {code: 1018, message: "Scope stack underflow occurred."},
            //  GetScopeObjectBoundsError            : {code: 1019, message: "Getscopeobject %1 is out of bounds."},
            //  CannotFallOffMethodError             : {code: 1020, message: "Code cannot fall off the end of a method."},
            //  InvalidBranchTargetError             : {code: 1021, message: "At least one branch target was not on a valid instruction in the method."},
            //  IllegalVoidError                     : {code: 1022, message: "Type void may only be used as a function return type."},
            StackOverflowError: {
                code: 1023,
                message: 'Stack overflow occurred.'
            },
            //  StackUnderflowError                  : {code: 1024, message: "Stack underflow occurred."},
            //  InvalidRegisterError                 : {code: 1025, message: "An invalid register %1 was accessed."},
            //  SlotExceedsCountError                : {code: 1026, message: "Slot %1 exceeds slotCount=%2 of %3."},
            //  MethodInfoExceedsCountError          : {code: 1027, message: "Method_info %1 exceeds method_count=%2."},
            //  DispIdExceedsCountError              : {code: 1028, message: "Disp_id %1 exceeds max_disp_id=%2 of %3."},
            //  DispIdUndefinedError                 : {code: 1029, message: "Disp_id %1 is undefined on %2."},
            //  StackDepthUnbalancedError            : {code: 1030, message: "Stack depth is unbalanced. %1 != %2."},
            //  ScopeDepthUnbalancedError            : {code: 1031, message: "Scope depth is unbalanced. %1 != %2."},
            CpoolIndexRangeError: {
                code: 1032,
                message: 'Cpool index %1 is out of range %2.'
            },
            CpoolEntryWrongTypeError: {
                code: 1033,
                message: 'Cpool entry %1 is wrong type.'
            },
            CheckTypeFailedError: {
                code: 1034,
                message: 'Type Coercion failed: cannot convert %1 to %2.'
            },
            //  IllegalSuperCallError                : {code: 1035, message: "Illegal super expression found in method %1."},
            CannotAssignToMethodError: {
                code: 1037,
                message: 'Cannot assign to a method %1 on %2.'
            },
            //  RedefinedError                       : {code: 1038, message: "%1 is already defined."},
            //  CannotVerifyUntilReferencedError     : {code: 1039, message: "Cannot verify method until it is referenced."},
            CantUseInstanceofOnNonObjectError: {
                code: 1040,
                message: 'The right-hand side of instanceof must be a class or function.'
            },
            IsTypeMustBeClassError: {
                code: 1041,
                message: 'The right-hand side of operator must be a class.'
            },
            InvalidMagicError: {
                code: 1042,
                message: 'Not an ABC file.  major_version=%1 minor_version=%2.'
            },
            //  InvalidCodeLengthError               : {code: 1043, message: "Invalid code_length=%1."},
            //  InvalidMethodInfoFlagsError          : {code: 1044, message: "MethodInfo-%1 unsupported flags=%2."},
            UnsupportedTraitsKindError: {
                code: 1045,
                message: 'Unsupported traits kind=%1.'
            },
            //  MethodInfoOrderError                 : {code: 1046, message: "MethodInfo-%1 referenced before definition."},
            //  MissingEntryPointError               : {code: 1047, message: "No entry point was found."},
            PrototypeTypeError: {
                code: 1049,
                message: 'Prototype objects must be vanilla Objects.'
            },
            ConvertToPrimitiveError: {
                code: 1050,
                message: 'Cannot convert %1 to primitive.'
            },
            //  IllegalEarlyBindingError             : {code: 1051, message: "Illegal early binding access to %1."},
            InvalidURIError: {
                code: 1052,
                message: 'Invalid URI passed to %1 function.'
            },
            //  IllegalOverrideError                 : {code: 1053, message: "Illegal override of %1 in %2."},
            //  IllegalExceptionHandlerError         : {code: 1054, message: "Illegal range or target offsets in exception handler."},
            WriteSealedError: {
                code: 1056,
                message: 'Cannot create property %1 on %2.'
            },
            //  IllegalSlotError                     : {code: 1057, message: "%1 can only contain methods."},
            //  IllegalOperandTypeError              : {code: 1058, message: "Illegal operand type: %1 must be %2."},
            //  ClassInfoOrderError                  : {code: 1059, message: "ClassInfo-%1 is referenced before definition."},
            //  ClassInfoExceedsCountError           : {code: 1060, message: "ClassInfo %1 exceeds class_count=%2."},
            //  NumberOutOfRangeError                : {code: 1061, message: "The value %1 cannot be converted to %2 without losing precision."},
            WrongArgumentCountError: {
                code: 1063,
                message: 'Argument count mismatch on %1. Expected %2, got %3.'
            },
            //  CannotCallMethodAsConstructor        : {code: 1064, message: "Cannot call method %1 as constructor."},
            UndefinedVarError: {
                code: 1065,
                message: 'Variable %1 is not defined.'
            },
            //  FunctionConstructorError             : {code: 1066, message: "The form function('function body') is not supported."},
            //  IllegalNativeMethodBodyError         : {code: 1067, message: "Native method %1 has illegal method body."},
            //  CannotMergeTypesError                : {code: 1068, message: "%1 and %2 cannot be reconciled."},
            ReadSealedError: {
                code: 1069,
                message: 'Property %1 not found on %2 and there is no default value.'
            },
            //  CallNotFoundError                    : {code: 1070, message: "Method %1 not found on %2"},
            //  AlreadyBoundError                    : {code: 1071, message: "Function %1 has already been bound to %2."},
            //  ZeroDispIdError                      : {code: 1072, message: "Disp_id 0 is illegal."},
            //  DuplicateDispIdError                 : {code: 1073, message: "Non-override method %1 replaced because of duplicate disp_id %2."},
            ConstWriteError: {
                code: 1074,
                message: 'Illegal write to read-only property %1 on %2.'
            },
            //  MathNotFunctionError                 : {code: 1075, message: "Math is not a function."},
            //  MathNotConstructorError              : {code: 1076, message: "Math is not a constructor."},
            //  WriteOnlyError                       : {code: 1077, message: "Illegal read of write-only property %1 on %2."},
            //  IllegalOpMultinameError              : {code: 1078, message: "Illegal opcode/multiname combination: %1<%2>."},
            //  IllegalNativeMethodError             : {code: 1079, message: "Native methods are not allowed in loaded code."},
            //  IllegalNamespaceError                : {code: 1080, message: "Illegal value for namespace."},
            //  ReadSealedErrorNs                    : {code: 1081, message: "Property %1 not found on %2 and there is no default value."},
            //  NoDefaultNamespaceError              : {code: 1082, message: "No default namespace has been set."},
            XMLPrefixNotBound: {
                code: 1083,
                message: 'The prefix "%1" for element "%2" is not bound.'
            },
            //  XMLBadQName                          : {code: 1084, message: "Element or attribute (\"%1\") does not match QName production: QName::=(NCName':')?NCName."},
            XMLUnterminatedElementTag: {
                code: 1085,
                message: 'The element type "%1" must be terminated by the matching end-tag "</%2>".'
            },
            XMLOnlyWorksWithOneItemLists: {
                code: 1086,
                message: 'The %1 method only works on lists containing one item.'
            },
            XMLAssignmentToIndexedXMLNotAllowed: {
                code: 1087,
                message: 'Assignment to indexed XML is not allowed.'
            },
            XMLMarkupMustBeWellFormed: {
                code: 1088,
                message: 'The markup in the document following the root element must be well-formed.'
            },
            XMLAssigmentOneItemLists: {
                code: 1089,
                message: 'Assignment to lists with more than one item is not supported.'
            },
            XMLMalformedElement: {
                code: 1090,
                message: 'XML parser failure: element is malformed.'
            },
            XMLUnterminatedCData: {
                code: 1091,
                message: 'XML parser failure: Unterminated CDATA section.'
            },
            XMLUnterminatedXMLDecl: {
                code: 1092,
                message: 'XML parser failure: Unterminated XML declaration.'
            },
            XMLUnterminatedDocTypeDecl: {
                code: 1093,
                message: 'XML parser failure: Unterminated DOCTYPE declaration.'
            },
            XMLUnterminatedComment: {
                code: 1094,
                message: 'XML parser failure: Unterminated comment.'
            },
            //  XMLUnterminatedAttribute             : {code: 1095, message: "XML parser failure: Unterminated attribute."},
            XMLUnterminatedElement: {
                code: 1096,
                message: 'XML parser failure: Unterminated element.'
            },
            //  XMLUnterminatedProcessingInstruction : {code: 1097, message: "XML parser failure: Unterminated processing instruction."},
            XMLNamespaceWithPrefixAndNoURI: {
                code: 1098,
                message: 'Illegal prefix %1 for no namespace.'
            },
            RegExpFlagsArgumentError: {
                code: 1100,
                message: 'Cannot supply flags when constructing one RegExp from another.'
            },
            //  NoScopeError                         : {code: 1101, message: "Cannot verify method %1 with unknown scope."},
            //  IllegalDefaultValue                  : {code: 1102, message: "Illegal default value for type %1."},
            //  CannotExtendFinalClass               : {code: 1103, message: "Class %1 cannot extend final base class."},
            //  XMLDuplicateAttribute                : {code: 1104, message: "Attribute \"%1\" was already specified for element \"%2\"."},
            //  CorruptABCError                      : {code: 1107, message: "The ABC data is corrupt, attempt to read out of bounds."},
            InvalidBaseClassError: {
                code: 1108,
                message: 'The OP_newclass opcode was used with the incorrect base class.'
            },
            //  DanglingFunctionError                : {code: 1109, message: "Attempt to directly call unbound function %1 from method %2."},
            //  CannotExtendError                    : {code: 1110, message: "%1 cannot extend %2."},
            //  CannotImplementError                 : {code: 1111, message: "%1 cannot implement %2."},
            //  CoerceArgumentCountError             : {code: 1112, message: "Argument count mismatch on class coercion.  Expected 1, got %1."},
            //  InvalidNewActivationError            : {code: 1113, message: "OP_newactivation used in method without NEED_ACTIVATION flag."},
            //  NoGlobalScopeError                   : {code: 1114, message: "OP_getglobalslot or OP_setglobalslot used with no global scope."},
            //  NotConstructorError                  : {code: 1115, message: "%1 is not a constructor."},
            //  ApplyError                           : {code: 1116, message: "second argument to Function.prototype.apply must be an array."},
            XMLInvalidName: {
                code: 1117,
                message: 'Invalid XML name: %1.'
            },
            XMLIllegalCyclicalLoop: {
                code: 1118,
                message: 'Illegal cyclical loop between nodes.'
            },
            //  DeleteTypeError                      : {code: 1119, message: "Delete operator is not supported with operand of type %1."},
            //  DeleteSealedError                    : {code: 1120, message: "Cannot delete property %1 on %2."},
            //  DuplicateMethodBodyError             : {code: 1121, message: "Method %1 has a duplicate method body."},
            //  IllegalInterfaceMethodBodyError      : {code: 1122, message: "Interface method %1 has illegal method body."},
            FilterError: {
                code: 1123,
                message: 'Filter operator not supported on type %1.'
            },
            //  InvalidHasNextError                  : {code: 1124, message: "OP_hasnext2 requires object and index to be distinct registers."},
            OutOfRangeError: {
                code: 1125,
                message: 'The index %1 is out of range %2.'
            },
            VectorFixedError: {
                code: 1126,
                message: 'Cannot change the length of a fixed Vector.'
            },
            TypeAppOfNonParamType: {
                code: 1127,
                message: 'Type application attempted on a non-parameterized type.'
            },
            WrongTypeArgCountError: {
                code: 1128,
                message: 'Incorrect number of type parameters for %1. Expected %2, got %3.'
            },
            JSONCyclicStructure: {
                code: 1129,
                message: 'Cyclic structure cannot be converted to JSON string.'
            },
            JSONInvalidReplacer: {
                code: 1131,
                message: 'Replacer argument to JSON stringifier must be an array or a two parameter function.'
            },
            JSONInvalidParseInput: {
                code: 1132,
                message: 'Invalid JSON parse input.'
            },
            //  FileOpenError                        : {code: 1500, message: "Error occurred opening file %1."},
            //  FileWriteError                       : {code: 1501, message: "Error occurred writing to file %1."},
            //  ScriptTimeoutError                   : {code: 1502, message: "A script has executed for longer than the default timeout period of 15 seconds."},
            //  ScriptTerminatedError                : {code: 1503, message: "A script failed to exit after 30 seconds and was terminated."},
            //  EndOfFileError                       : {code: 1504, message: "End of file."},
            //  StringIndexOutOfBoundsError          : {code: 1505, message: "The string index %1 is out of bounds; must be in range %2 to %3."},
            InvalidRangeError: {
                code: 1506,
                message: 'The specified range is invalid.'
            },
            NullArgumentError: {
                code: 1507,
                message: 'Argument %1 cannot be null.'
            },
            InvalidArgumentError: {
                code: 1508,
                message: 'The value specified for argument %1 is invalid.'
            },
            ArrayFilterNonNullObjectError: {
                code: 1510,
                message: 'When the callback argument is a method of a class, the optional this argument must be null.'
            },
            InvalidParamError: {
                code: 2004,
                message: 'One of the parameters is invalid.'
            },
            ParamRangeError: {
                code: 2006,
                message: 'The supplied index is out of bounds.'
            },
            NullPointerError: {
                code: 2007,
                message: 'Parameter %1 must be non-null.'
            },
            InvalidEnumError: {
                code: 2008,
                message: 'Parameter %1 must be one of the accepted values.'
            },
            CantInstantiateError: {
                code: 2012,
                message: '%1 class cannot be instantiated.'
            },
            InvalidBitmapData: {
                code: 2015,
                message: 'Invalid BitmapData.'
            },
            EOFError: {
                code: 2030,
                message: 'End of file was encountered.',
                fqn: 'flash.errors.EOFError'
            },
            CompressedDataError: {
                code: 2058,
                message: 'There was an error decompressing the data.',
                fqn: 'flash.errors.IOError'
            },
            EmptyStringError: {
                code: 2085,
                message: 'Parameter %1 must be non-empty string.'
            },
            ProxyGetPropertyError: {
                code: 2088,
                message: 'The Proxy class does not implement getProperty. It must be overridden by a subclass.'
            },
            ProxySetPropertyError: {
                code: 2089,
                message: 'The Proxy class does not implement setProperty. It must be overridden by a subclass.'
            },
            ProxyCallPropertyError: {
                code: 2090,
                message: 'The Proxy class does not implement callProperty. It must be overridden by a subclass.'
            },
            ProxyHasPropertyError: {
                code: 2091,
                message: 'The Proxy class does not implement hasProperty. It must be overridden by a subclass.'
            },
            ProxyDeletePropertyError: {
                code: 2092,
                message: 'The Proxy class does not implement deleteProperty. It must be overridden by a subclass.'
            },
            ProxyGetDescendantsError: {
                code: 2093,
                message: 'The Proxy class does not implement getDescendants. It must be overridden by a subclass.'
            },
            ProxyNextNameIndexError: {
                code: 2105,
                message: 'The Proxy class does not implement nextNameIndex. It must be overridden by a subclass.'
            },
            ProxyNextNameError: {
                code: 2106,
                message: 'The Proxy class does not implement nextName. It must be overridden by a subclass.'
            },
            ProxyNextValueError: {
                code: 2107,
                message: 'The Proxy class does not implement nextValue. It must be overridden by a subclass.'
            },
            //  InvalidArrayLengthError              : {code: 2108, message: "The value %1 is not a valid Array length."},
            //  ReadExternalNotImplementedError      : {code: 2173, message: "Unable to read object in stream.  The class %1 does not implement flash.utils.IExternalizable but is aliased to an externalizable class."},
            /**
             * Player Error Codes
             */
            //  NoSecurityContextError                                    : { code: 2000, message: "No active security context."},
            TooFewArgumentsError: {
                code: 2001,
                message: 'Too few arguments were specified; got %1, %2 expected.'
            },
            //  InvalidSocketError                                        : { code: 2002, message: "Operation attempted on invalid socket."},
            //  InvalidSocketPortError                                    : { code: 2003, message: "Invalid socket port number specified."},
            ParamTypeError: {
                code: 2005,
                message: 'Parameter %1 is of the incorrect type. Should be type %2.'
            },
            //  HasStyleSheetError                                        : { code: 2009, message: "This method cannot be used on a text field with a style sheet."},
            //  SocketLocalFileSecurityError                              : { code: 2010, message: "Local-with-filesystem SWF files are not permitted to use sockets."},
            SocketConnectError: {
                code: 2011,
                message: 'Socket connection failed to %1:%2.'
            },
            //  AuthoringOnlyFeatureError                                 : { code: 2013, message: "Feature can only be used in Flash Authoring."},
            //  FeatureNotAvailableError                                  : { code: 2014, message: "Feature is not available at this time."},
            //  InvalidBitmapDataError                                    : { code: 2015, message: "Invalid BitmapData."},
            //  SystemExitSecurityError                                   : { code: 2017, message: "Only trusted local files may cause the Flash Player to exit."},
            //  SystemExitUnsupportedError                                : { code: 2018, message: "System.exit is only available in the standalone Flash Player."},
            //  InvalidDepthError                                         : { code: 2019, message: "Depth specified is invalid."},
            //  MovieClipSwapError                                        : { code: 2020, message: "MovieClips objects with different parents cannot be swapped."},
            //  ObjectCreationError                                       : { code: 2021, message: "Object creation failed."},
            //  NotDisplayObjectError                                     : { code: 2022, message: "Class %1 must inherit from DisplayObject to link to a symbol."},
            //  NotSpriteError                                            : { code: 2023, message: "Class %1 must inherit from Sprite to link to the root."},
            CantAddSelfError: {
                code: 2024,
                message: 'An object cannot be added as a child of itself.'
            },
            NotAChildError: {
                code: 2025,
                message: 'The supplied DisplayObject must be a child of the caller.'
            },
            //  NavigateURLError                                          : { code: 2026, message: "An error occurred navigating to the URL %1."},
            //  MustBeNonNegativeError                                    : { code: 2027, message: "Parameter %1 must be a non-negative number; got %2."},
            //  LocalSecurityError                                        : { code: 2028, message: "Local-with-filesystem SWF file %1 cannot access Internet URL %2."},
            //  InvalidStreamError                                        : { code: 2029, message: "This URLStream object does not have a stream opened."},
            //  SocketError                                               : { code: 2031, message: "Socket Error."},
            //  StreamError                                               : { code: 2032, message: "Stream Error."},
            //  KeyGenerationError                                        : { code: 2033, message: "Key Generation Failed."},
            //  InvalidKeyError                                           : { code: 2034, message: "An invalid digest was supplied."},
            //  URLNotFoundError                                          : { code: 2035, message: "URL Not Found."},
            //  LoadNeverCompletedError                                   : { code: 2036, message: "Load Never Completed."},
            //  InvalidCallError                                          : { code: 2037, message: "Functions called in incorrect sequence, or earlier call was unsuccessful."},
            //  FileIOError                                               : { code: 2038, message: "File I/O Error."},
            //  RemoteURLError                                            : { code: 2039, message: "Invalid remote URL protocol. The remote URL protocol must be HTTP or HTTPS."},
            //  BrowseInProgressError                                     : { code: 2041, message: "Only one file browsing session may be performed at a time."},
            //  DigestNotSupportedError                                   : { code: 2042, message: "The digest property is not supported by this load operation."},
            UnhandledError: {
                code: 2044,
                message: 'Unhandled %1:.'
            },
            //  FileVerificationError                                     : { code: 2046, message: "The loaded file did not have a valid signature."},
            //  DisplayListSecurityError                                  : { code: 2047, message: "Security sandbox violation: %1: %2 cannot access %3."},
            //  DownloadSecurityError                                     : { code: 2048, message: "Security sandbox violation: %1 cannot load data from %2."},
            //  UploadSecurityError                                       : { code: 2049, message: "Security sandbox violation: %1 cannot upload data to %2."},
            //  OutboundScriptingSecurityError                            : { code: 2051, message: "Security sandbox violation: %1 cannot evaluate scripting URLs within %2 (allowScriptAccess is %3). Attempted URL was %4."},
            AllowDomainArgumentError: {
                code: 2052,
                message: 'Only String arguments are permitted for allowDomain and allowInsecureDomain.'
            },
            //  IntervalSecurityError                                     : { code: 2053, message: "Security sandbox violation: %1 cannot clear an interval timer set by %2."},
            //  ExactSettingsError                                        : { code: 2054, message: "The value of Security.exactSettings cannot be changed after it has been used."},
            //  PrintJobStartError                                        : { code: 2055, message: "The print job could not be started."},
            //  PrintJobSendError                                         : { code: 2056, message: "The print job could not be sent to the printer."},
            //  PrintJobAddPageError                                      : { code: 2057, message: "The page could not be added to the print job."},
            //  ExternalCallbackSecurityError                             : { code: 2059, message: "Security sandbox violation: %1 cannot overwrite an ExternalInterface callback added by %2."},
            //  ExternalInterfaceSecurityError                            : { code: 2060, message: "Security sandbox violation: ExternalInterface caller %1 cannot access %2."},
            //  ExternalInterfaceNoCallbackError                          : { code: 2061, message: "No ExternalInterface callback %1 registered."},
            //  NoCloneMethodError                                        : { code: 2062, message: "Children of Event must override clone() {return new MyEventClass (...);}."},
            //  IMEError                                                  : { code: 2063, message: "Error attempting to execute IME command."},
            //  FocusNotSetError                                          : { code: 2065, message: "The focus cannot be set for this target."},
            DelayRangeError: {
                code: 2066,
                message: 'The Timer delay specified is out of range.'
            },
            ExternalInterfaceNotAvailableError: {
                code: 2067,
                message: 'The ExternalInterface is not available in this container. ExternalInterface requires Internet Explorer ActiveX, Firefox, Mozilla 1.7.5 and greater, or other browsers that support NPRuntime.'
            },
            //  InvalidSoundError                                         : { code: 2068, message: "Invalid sound."},
            InvalidLoaderMethodError: {
                code: 2069,
                message: 'The Loader class does not implement this method.'
            },
            //  StageOwnerSecurityError                                   : { code: 2070, message: "Security sandbox violation: caller %1 cannot access Stage owned by %2."},
            InvalidStageMethodError: {
                code: 2071,
                message: 'The Stage class does not implement this property or method.'
            },
            //  ProductManagerDiskError                                   : { code: 2073, message: "There was a problem saving the application to disk."},
            //  ProductManagerStageError                                  : { code: 2074, message: "The stage is too small to fit the download ui."},
            //  ProductManagerVerifyError                                 : { code: 2075, message: "The downloaded file is invalid."},
            //  FilterFailedError                                         : { code: 2077, message: "This filter operation cannot be performed with the specified input parameters."},
            TimelineObjectNameSealedError: {
                code: 2078,
                message: 'The name property of a Timeline-placed object cannot be modified.'
            },
            //  BitmapNotAssociatedWithBitsCharError                      : { code: 2079, message: "Classes derived from Bitmap can only be associated with defineBits characters (bitmaps)."},
            AlreadyConnectedError: {
                code: 2082,
                message: 'Connect failed because the object is already connected.'
            },
            CloseNotConnectedError: {
                code: 2083,
                message: 'Close failed because the object is not connected.'
            },
            ArgumentSizeError: {
                code: 2084,
                message: 'The AMF encoding of the arguments cannot exceed 40K.'
            },
            //  FileReferenceProhibitedError                              : { code: 2086, message: "A setting in the mms.cfg file prohibits this FileReference request."},
            //  DownloadFileNameProhibitedError                           : { code: 2087, message: "The FileReference.download() file name contains prohibited characters."},
            //  EventDispatchRecursionError                               : { code: 2094, message: "Event dispatch recursion overflow."},
            AsyncError: {
                code: 2095,
                message: '%1 was unable to invoke callback %2.'
            },
            //  DisallowedHTTPHeaderError                                 : { code: 2096, message: "The HTTP request header %1 cannot be set via ActionScript."},
            //  FileFilterError                                           : { code: 2097, message: "The FileFilter Array is not in the correct format."},
            LoadingObjectNotSWFError: {
                code: 2098,
                message: 'The loading object is not a .swf file, you cannot request SWF properties from it.'
            },
            LoadingObjectNotInitializedError: {
                code: 2099,
                message: 'The loading object is not sufficiently loaded to provide this information.'
            },
            //  EmptyByteArrayError                                       : { code: 2100, message: "The ByteArray parameter in Loader.loadBytes() must have length greater than 0."},
            DecodeParamError: {
                code: 2101,
                message: 'The String passed to URLVariables.decode() must be a URL-encoded query string containing name/value pairs.'
            },
            //  NotAnXMLChildError                                        : { code: 2102, message: "The before XMLNode parameter must be a child of the caller."},
            //  XMLRecursionError                                         : { code: 2103, message: "XML recursion failure: new child would create infinite loop."},
            SceneNotFoundError: {
                code: 2108,
                message: 'Scene %1 was not found.'
            },
            FrameLabelNotFoundError: {
                code: 2109,
                message: 'Frame label %1 not found in scene %2.'
            },
            //  DisableAVM1LoadingError                                   : { code: 2110, message: "The value of Security.disableAVM1Loading cannot be set unless the caller can access the stage and is in an ActionScript 3.0 SWF file."},
            //  AVM1LoadingError                                          : { code: 2111, message: "Security.disableAVM1Loading is true so the current load of the ActionScript 1.0/2.0 SWF file has been blocked."},
            //  ApplicationDomainSecurityError                            : { code: 2112, message: "Provided parameter LoaderContext.ApplicationDomain is from a disallowed domain."},
            //  SecurityDomainSecurityError                               : { code: 2113, message: "Provided parameter LoaderContext.SecurityDomain is from a disallowed domain."},
            //  NonNullPointerError                                       : { code: 2114, message: "Parameter %1 must be null."},
            //  TrueParamError                                            : { code: 2115, message: "Parameter %1 must be false."},
            //  FalseParamError                                           : { code: 2116, message: "Parameter %1 must be true."},
            InvalidLoaderInfoMethodError: {
                code: 2118,
                message: 'The LoaderInfo class does not implement this method.'
            },
            //  LoaderInfoAppDomainSecurityError                          : { code: 2119, message: "Security sandbox violation: caller %1 cannot access LoaderInfo.applicationDomain owned by %2."},
            SecuritySwfNotAllowedError: {
                code: 2121,
                message: 'Security sandbox violation: %1: %2 cannot access %3. This may be worked around by calling Security.allowDomain.'
            },
            //  SecurityNonSwfIncompletePolicyFilesError                  : { code: 2122, message: "Security sandbox violation: %1: %2 cannot access %3. A policy file is required, but the checkPolicyFile flag was not set when this media was loaded."},
            //  SecurityNonSwfNotAllowedError                             : { code: 2123, message: "Security sandbox violation: %1: %2 cannot access %3. No policy files granted access."},
            UnknownFileTypeError: {
                code: 2124,
                message: 'Loaded file is an unknown type.'
            },
            //  SecurityCrossVMNotAllowedError                            : { code: 2125, message: "Security sandbox violation: %1 cannot use Runtime Shared Library %2 because crossing the boundary between ActionScript 3.0 and ActionScript 1.0/2.0 objects is not allowed."},
            //  NotConnectedError                                         : { code: 2126, message: "NetConnection object must be connected."},
            //  FileRefBadPostDataTypeError                               : { code: 2127, message: "FileReference POST data cannot be type ByteArray."},
            //  NetConnectionConnectError                                 : { code: 2129, message: "Connection to %1 failed."},
            //  SharedObjectFlushFailedError                              : { code: 2130, message: "Unable to flush SharedObject."},
            //  DefinitionNotFoundError                                   : { code: 2131, message: "Definition %1 cannot be found."},
            //  NetConnectionInvalidConnectFromNetStatusEventError        : { code: 2132, message: "NetConnection.connect cannot be called from a netStatus event handler."},
            //  CallbackNotRegisteredError                                : { code: 2133, message: "Callback %1 is not registered."},
            //  SharedObjectCreateError                                   : { code: 2134, message: "Cannot create SharedObject."},
            //  InvalidSWFError                                           : { code: 2136, message: "The SWF file %1 contains invalid data."},
            //  NavigationSecurityError                                   : { code: 2137, message: "Security sandbox violation: %1 cannot navigate window %2 within %3 (allowScriptAccess is %4). Attempted URL was %5."},
            //  NonParsableRichTextXMLError                               : { code: 2138, message: "Rich text XML could not be parsed."},
            //  SharedObjectConnectError                                  : { code: 2139, message: "SharedObject could not connect."},
            //  LocalSecurityLoadingError                                 : { code: 2140, message: "Security sandbox violation: %1 cannot load %2. Local-with-filesystem and local-with-networking SWF files cannot load each other."},
            //  MultiplePrintJobsError                                    : { code: 2141, message: "Only one PrintJob may be in use at a time."},
            //  LocalImportSecurityError                                  : { code: 2142, message: "Security sandbox violation: local SWF files cannot use the LoaderContext.sec property. %1 was attempting to load %2."},
            //  AccOverrideRole                                           : { code: 2143, message: "AccessibilityImplementation.get_accRole() must be overridden from its default."},
            //  AccOverrideState                                          : { code: 2144, message: "AccessibilityImplementation.get_accState() must be overridden from its default."},
            //  URLRequestHeaderInvalidLengthError                        : { code: 2145, message: "Cumulative length of requestHeaders must be less than 8192 characters."},
            //  AllowNetworkingSecurityError                              : { code: 2146, message: "Security sandbox violation: %1 cannot call %2 because the HTML/container parameter allowNetworking has the value %3."},
            //  ForbiddenProtocolError                                    : { code: 2147, message: "Forbidden protocol in URL %1."},
            //  RemoteToLocalSecurityError                                : { code: 2148, message: "SWF file %1 cannot access local resource %2. Only local-with-filesystem and trusted local SWF files may access local resources."},
            //  FsCommandSecurityError                                    : { code: 2149, message: "Security sandbox violation: %1 cannot make fscommand calls to %2 (allowScriptAccess is %3)."},
            CantAddParentError: {
                code: 2150,
                message: 'An object cannot be added as a child to one of it\'s children (or children\'s children, etc.).'
            },
            //  FullScreenSecurityError                                   : { code: 2151, message: "You cannot enter full screen mode when the settings dialog is visible."},
            //  FullScreenNotAllowedError                                 : { code: 2152, message: "Full screen mode is not allowed."},
            //  URLRequestInvalidHeader                                   : { code: 2153, message: "The URLRequest.requestHeaders array must contain only non-NULL URLRequestHeader objects."},
            //  InvalidNetStreamObject                                    : { code: 2154, message: "The NetStream Object is invalid.  This may be due to a failed NetConnection."},
            //  InvalidFunctionName                                       : { code: 2155, message: "The ExternalInterface.call functionName parameter is invalid.  Only alphanumeric characters are supported."},
            //  ForbiddenPortForProtocolError                             : { code: 2156, message: "Port %1 may not be accessed using protocol %2. Calling SWF was %3."},
            //  NoAsfunctionErrror                                        : { code: 2157, message: "Rejecting URL %1 because the 'asfunction:' protocol may only be used for link targets, not for networking APIs."},
            //  InvalidNetConnectionObject                                : { code: 2158, message: "The NetConnection Object is invalid.  This may be due to a dropped NetConnection."},
            //  InvalidSharedObject                                       : { code: 2159, message: "The SharedObject Object is invalid."},
            //  InvalidTextLineError                                      : { code: 2160, message: "The TextLine is INVALID and cannot be used to access the current state of the TextBlock."},
            //  TextLayoutError                                           : { code: 2161, message: "An internal error occured while laying out the text."},
            //  FragmentOutputType                                        : { code: 2162, message: "The Shader output type is not compatible for this operation."},
            //  FragmentInputType                                         : { code: 2163, message: "The Shader input type %1 is not compatible for this operation."},
            //  FragmentInputMissing                                      : { code: 2164, message: "The Shader input %1 is missing or an unsupported type."},
            //  FragmentInputTooSmall                                     : { code: 2165, message: "The Shader input %1 does not have enough data."},
            //  FragmentInputNoDimension                                  : { code: 2166, message: "The Shader input %1 lacks valid dimensions."},
            //  FragmentNotEnoughInput                                    : { code: 2167, message: "The Shader does not have the required number of inputs for this operation."},
            //  StaticTextLineError                                       : { code: 2168, message: "Static text lines have no atoms and no reference to a text block."},
            //  SecurityQuestionableBrowserScriptingError                 : { code: 2169, message: "The method %1 may not be used for browser scripting.  The URL %2 requested by %3 is being ignored.  If you intend to call browser script, use navigateToURL instead."},
            //  HeaderSecurityError                                       : { code: 2170, message: "Security sandbox violation: %1 cannot send HTTP headers to %2."},
            //  FragmentMissing                                           : { code: 2171, message: "The Shader object contains no byte code to execute."},
            //  FragmentAlreadyRunning                                    : { code: 2172, message: "The ShaderJob is already running or finished."},
            //  FileReferenceBusyError                                    : { code: 2174, message: "Only one download, upload, load or save operation can be active at a time on each FileReference."},
            //  UnformattedElementError                                   : { code: 2175, message: "One or more elements of the content of the TextBlock has a null ElementFormat."},
            //  UserActionRequiredError                                   : { code: 2176, message: "Certain actions, such as those that display a pop-up window, may only be invoked upon user interaction, for example by a mouse click or button press."},
            //  FragmentInputTooLarge                                     : { code: 2177, message: "The Shader input %1 is too large."},
            //  ClipboardConstNotAllowed                                  : { code: 2178, message: "The Clipboard.generalClipboard object must be used instead of creating a new Clipboard."},
            //  ClipboardDisallowedRead                                   : { code: 2179, message: "The Clipboard.generalClipboard object may only be read while processing a flash.events.Event.PASTE event."},
            //  CantMoveAVM1ContentLoadedIntoAVM2                         : { code: 2180, message: "It is illegal to move AVM1 content (AS1 or AS2) to a different part of the displayList when it has been loaded into AVM2 (AS3) content."},
            //  InvalidTextLineMethodError                                : { code: 2181, message: "The TextLine class does not implement this property or method."},
            //  PerspectiveFieldOfViewValueInvalid                        : { code: 2182, message: "Invalid fieldOfView value.  The value must be greater than 0 and less than 180."},
            //  Invalid3DScale                                            : { code: 2183, message: "Scale values must not be zero."},
            //  LockedElementFormatError                                  : { code: 2184, message: "The ElementFormat object is locked and cannot be modified."},
            //  LockedFontDescriptionError                                : { code: 2185, message: "The FontDescription object is locked and cannot be modified."},
            //  PerspectiveFocalLengthInvalid                             : { code: 2186, message: "Invalid focalLength %1."},
            //  Matrix3DDecomposeTypeInvalid                              : { code: 2187, message: "Invalid orientation style %1.  Value must be one of 'Orientation3D.EULER_ANGLES', 'Orientation3D.AXIS_ANGLE', or 'Orientation3D.QUATERNION'."},
            //  MatrixNonInvertibleError                                  : { code: 2188, message: "Invalid raw matrix. Matrix must be invertible."},
            Matrix3DRefCannontBeShared: {
                code: 2189,
                message: 'A Matrix3D can not be assigned to more than one DisplayObject.'
            },
            //  ForceDownloadSecurityError                                : { code: 2190, message: "The attempted load of %1 failed as it had a Content-Disposition of attachment set."},
            //  ClipboardDisallowedWrite                                  : { code: 2191, message: "The Clipboard.generalClipboard object may only be written to as the result of user interaction, for example by a mouse click or button press."},
            //  MalformedUnicodeError                                     : { code: 2192, message: "An unpaired Unicode surrogate was encountered in the input."},
            //  SecurityContentAccessDeniedError                          : { code: 2193, message: "Security sandbox violation: %1: %2 cannot access %3."},
            //  LoaderParamError                                          : { code: 2194, message: "Parameter %1 cannot be a Loader."},
            //  LoaderAsyncError                                          : { code: 2195, message: "Error thrown as Loader called %1."},
            ObjectWithStringsParamError: {
                code: 2196,
                message: 'Parameter %1 must be an Object with only String values.'
            },
            //  SystemUpdaterPlayerNotSupportedError                      : { code: 2200, message: "The SystemUpdater class is not supported by this player."},
            //  SystemUpdaterOSNotSupportedError                          : { code: 2201, message: "The requested update type is not supported on this operating system."},
            //  SystemUpdaterBusy                                         : { code: 2202, message: "Only one SystemUpdater action is allowed at a time."},
            //  SystemUpdaterFailed                                       : { code: 2203, message: "The requested SystemUpdater action cannot be completed."},
            //  SystemUpdaterCannotCancel                                 : { code: 2204, message: "This operation cannot be canceled because it is waiting for user interaction."},
            //  SystemUpdaterUnknownTarget                                : { code: 2205, message: "Invalid update type %1."},
            //  SignedSWfLoadingError                                     : { code: 2500, message: "An error occurred decrypting the signed swf file. The swf will not be loaded."},
            //  NotScreenSharingError                                     : { code: 2501, message: "This property can only be accessed during screen sharing."},
            //  NotSharingMonitorError                                    : { code: 2502, message: "This property can only be accessed if sharing the entire screen."},
            //  FileBadPathName                                           : { code: 3000, message: "Illegal path name."},
            //  FileAccessDenied                                          : { code: 3001, message: "File or directory access denied."},
            //  FileExists                                                : { code: 3002, message: "File or directory exists."},
            //  FileDoesNotExist                                          : { code: 3003, message: "File or directory does not exist."},
            //  FileInsufficientSpace                                     : { code: 3004, message: "Insufficient file space."},
            //  FileSystemResources                                       : { code: 3005, message: "Insufficient system resources."},
            //  FileNotAFile                                              : { code: 3006, message: "Not a file."},
            //  FileNotADir                                               : { code: 3007, message: "Not a directory."},
            //  FileReadOnlyFileSys                                       : { code: 3008, message: "Read-only or write-protected media."},
            //  FileNotSameDevice                                         : { code: 3009, message: "Cannot move file or directory to a different device."},
            //  DirNotEmpty                                               : { code: 3010, message: "Directory is not empty."},
            //  FileDestinationExists                                     : { code: 3011, message: "Move or copy destination already exists."},
            //  FileCantDelete                                            : { code: 3012, message: "Cannot delete file or directory."},
            //  FileInUse                                                 : { code: 3013, message: "File or directory is in use."},
            //  FileCopyMoveAncestor                                      : { code: 3014, message: "Cannot copy or move a file or directory to overwrite a containing directory."},
            //  LoadBytesCodeExecutionSecurityError                       : { code: 3015, message: "Loader.loadBytes() is not permitted to load content with executable code."},
            //  FileApplicationNotFound                                   : { code: 3016, message: "No application was found that can open this file."},
            //  SQLConnectionCannotClose                                  : { code: 3100, message: "A SQLConnection cannot be closed while statements are still executing."},
            //  SQLConnectionAlreadyOpen                                  : { code: 3101, message: "Database connection is already open."},
            //  SQLConnectionInvalidName                                  : { code: 3102, message: "Name argument specified was invalid. It must not be null or empty."},
            //  SQLConnectionInTransaction                                : { code: 3103, message: "Operation cannot be performed while there is an open transaction on this connection."},
            //  SQLConnectionNotOpen                                      : { code: 3104, message: "A SQLConnection must be open to perform this operation."},
            //  SQLConnectionNoOpenTransaction                            : { code: 3105, message: "Operation is only allowed if a connection has an open transaction."},
            //  SQLStatementIsExecutingProperty                           : { code: 3106, message: "Property cannot be changed while SQLStatement.executing is true."},
            //  SQLStatementIvalidCall                                    : { code: 3107, message: "%1 may not be called unless SQLResult.complete is false."},
            //  SQLStatementInvalidText                                   : { code: 3108, message: "Operation is not permitted when the SQLStatement.text property is not set."},
            //  SQLStatementInvalidConnection                             : { code: 3109, message: "Operation is not permitted when the SQLStatement.sqlConnection property is not set."},
            //  SQLStatementIsExecutingCall                               : { code: 3110, message: "Operation cannot be performed while SQLStatement.executing is true."},
            //  SQLStatementInvalidSchemaType                             : { code: 3111, message: "An invalid schema type was specified."},
            //  SQLConnectionInvalidLockType                              : { code: 3112, message: "An invalid transaction lock type was specified."},
            //  SQLConnectionNotFileReference                             : { code: 3113, message: "Reference specified is not of type File."},
            //  SQLConnectionInvalidModeSpecified                         : { code: 3114, message: "An invalid open mode was specified."},
            //  SQLGeneralEngineError                                     : { code: 3115, message: "SQL Error."},
            //  SQLInternalEngineError                                    : { code: 3116, message: "An internal logic error occurred."},
            //  SQLPermissionError                                        : { code: 3117, message: "Access permission denied."},
            //  SQLOperationAbortedError                                  : { code: 3118, message: "Operation aborted."},
            //  SQLDatabaseLockedError                                    : { code: 3119, message: "Database file is currently locked."},
            //  SQLTableLockedError                                       : { code: 3120, message: "Table is locked."},
            //  SQLOutOfMemoryError                                       : { code: 3121, message: "Out of memory."},
            //  SQLDatabaseIsReadonlyError                                : { code: 3122, message: "Attempt to write a readonly database."},
            //  SQLDatabaseCorruptError                                   : { code: 3123, message: "Database disk image is malformed."},
            //  SQLDatabaseFullError                                      : { code: 3124, message: "Insertion failed because database is full."},
            //  SQLCannotOpenDatabaseError                                : { code: 3125, message: "Unable to open the database file."},
            //  SQLLockingProtocolError                                   : { code: 3126, message: "Database lock protocol error."},
            //  SQLDatabaseEmptyError                                     : { code: 3127, message: "Database is empty."},
            //  SQLDiskIOError                                            : { code: 3128, message: "Disk I/O error occurred."},
            //  SQLSchemaChangedError                                     : { code: 3129, message: "The database schema changed."},
            //  SQLTooMuchDataError                                       : { code: 3130, message: "Too much data for one row of a table."},
            //  SQLConstraintError                                        : { code: 3131, message: "Abort due to constraint violation."},
            //  SQLDataTypeMismatchError                                  : { code: 3132, message: "Data type mismatch."},
            //  SQLConcurrencyError                                       : { code: 3133, message: "An internal error occurred."},
            //  SQLNotSupportedOnOSError                                  : { code: 3134, message: "Feature not supported on this operating system."},
            //  SQLAuthorizationDeniedError                               : { code: 3135, message: "Authorization denied."},
            //  SQLAuxDatabaseFormatError                                 : { code: 3136, message: "Auxiliary database format error."},
            //  SQLBindingRangeError                                      : { code: 3137, message: "An index specified for a parameter was out of range."},
            //  SQLInvalidDatabaseFileError                               : { code: 3138, message: "File opened is not a database file."},
            //  SQLInvalidPageSizeError                                   : { code: 3139, message: "The page size specified was not valid for this operation."},
            //  SQLInvalidKeySizeError                                    : { code: 3140, message: "The encryption key size specified was not valid for this operation. Keys must be exactly 16 bytes in length"},
            //  SQLInvalidConfigurationError                              : { code: 3141, message: "The requested database configuration is not supported."},
            //  SQLCannotRekeyNonKeyedDatabase                            : { code: 3143, message: "Unencrypted databases may not be reencrypted."},
            //  NativeWindowClosedError                                   : { code: 3200, message: "Cannot perform operation on closed window."},
            //  PDFNoReaderInstalled                                      : { code: 3201, message: "Adobe Reader cannot be found."},
            //  PDFOldReaderInstalled                                     : { code: 3202, message: "Adobe Reader 8.1 or later cannot be found."},
            //  PDFOldDefaultText                                         : { code: 3203, message: "Default Adobe Reader must be version 8.1 or later."},
            //  PDFCannotLoadReader                                       : { code: 3204, message: "An error ocurred trying to load Adobe Reader."},
            //  ApplicationFeatureSecurityError                           : { code: 3205, message: "Only application-sandbox content can access this feature."},
            //  LoaderInfoDoorSecurityError                               : { code: 3206, message: "Caller %1 cannot set LoaderInfo property %2."},
            //  ApplicationNonFeatureSecurityError                        : { code: 3207, message: "Application-sandbox content cannot access this feature."},
            //  InvalidClipboardAccess                                    : { code: 3208, message: "Attempt to access invalid clipboard."},
            //  DeadClipboardAccess                                       : { code: 3209, message: "Attempt to access dead clipboard."},
            //  DeadJavaScriptObjectAccess                                : { code: 3210, message: "The application attempted to reference a JavaScript object in a HTML page that is no longer loaded."},
            //  FilePromiseIOError                                        : { code: 3211, message: "Drag and Drop File Promise error: %1"},
            //  NativeProcessNotRunning                                   : { code: 3212, message: "Cannot perform operation on a NativeProcess that is not running."},
            //  NativeProcessAlreadyRunning                               : { code: 3213, message: "Cannot perform operation on a NativeProcess that is already running."},
            //  NativeProcessBadExecutable                                : { code: 3214, message: "NativeProcessStartupInfo.executable does not specify a valid executable file."},
            //  NativeProcessBadWorkingDirectory                          : { code: 3215, message: "NativeProcessStartupInfo.workingDirectory does not specify a valid directory."},
            //  NativeProcessStdOutReadError                              : { code: 3216, message: "Error while reading data from NativeProcess.standardOutput."},
            //  NativeProcessStdErrReadError                              : { code: 3217, message: "Error while reading data from NativeProcess.standardError."},
            //  NativeProcessStdInWriteError                              : { code: 3218, message: "Error while writing data to NativeProcess.standardInput."},
            //  NativeProcessNotStarted                                   : { code: 3219, message: "The NativeProcess could not be started. '%1'"},
            //  ActionNotAllowedSecurityError                             : { code: 3220, message: "Action '%1' not allowed in current security context '%2'."},
            //  SWFNoPlayerInstalled                                      : { code: 3221, message: "Adobe Flash Player cannot be found."},
            //  SWFOldPlayerInstalled                                     : { code: 3222, message: "The installed version of Adobe Flash Player is too old."},
            //  DNSResolverLookupError                                    : { code: 3223, message: "DNS lookup error: platform error %1"},
            //  SocketMessageTooLongError                                 : { code: 3224, message: "Socket message too long"},
            //  SocketCannotSendDataToAddressAfterConnect                 : { code: 3225, message: "Cannot send data to a location when connected."},
            AllowCodeImportError: {
                code: 3226,
                message: 'Cannot import a SWF file when LoaderContext.allowCodeImport is false.'
            },
            //  BackgroundLaunchError                                     : { code: 3227, message: "Cannot launch another application from background."},
            //  StageWebViewLoadError                                     : { code: 3228, message: "StageWebView encountered an error during the load operation."},
            //  StageWebViewProtocolNotSupported                          : { code: 3229, message: "The protocol is not supported.:"},
            //  BrowseOperationUnsupported                                : { code: 3230, message: "The browse operation is unsupported."},
            //  InvalidVoucher                                            : { code: 3300, message: "Voucher is invalid."},
            //  AuthenticationFailed                                      : { code: 3301, message: "User authentication failed."},
            //  RequireSSLError                                           : { code: 3302, message: "Flash Access server does not support SSL."},
            //  ContentExpiredError                                       : { code: 3303, message: "Content expired."},
            //  AuthorizationFailed                                       : { code: 3304, message: "User authorization failed (for example, the user has not purchased the content)."},
            //  ServerConnectionFailed                                    : { code: 3305, message: "Can't connect to the server."},
            //  ClientUpdateRequired                                      : { code: 3306, message: "Client update required (Flash Access server requires new client)."},
            //  InternalError                                             : { code: 3307, message: "Generic internal Flash Access failure."},
            //  WrongVoucherKey                                           : { code: 3308, message: "Wrong voucher key."},
            //  CorruptedFLV                                              : { code: 3309, message: "Video content is corrupted."},
            //  AppIDMismatch                                             : { code: 3310, message: "The AIR application or Flash Player SWF does not match the one specified in the DRM policy."},
            //  AppVersionMismatch                                        : { code: 3311, message: "The version of the application does not match the one specified in the DRM policy."},
            //  VoucherIntegrityError                                     : { code: 3312, message: "Verification of voucher failed."},
            //  WriteFileSystemFailed                                     : { code: 3313, message: "Write to the file system failed."},
            //  FLVHeaderIntegrityFailed                                  : { code: 3314, message: "Verification of FLV/F4V header file failed."},
            PermissionDenied: {
                code: 3315,
                message: 'The current security context does not allow this operation.'
            },
            //  LocalConnectionUserScopedLocked                           : { code: 3316, message: "The value of LocalConnection.isPerUser cannot be changed because it has already been locked by a call to LocalConnection.connect, .send, or .close."},
            //  LoadAdobeCPFailed                                         : { code: 3317, message: "Failed to load Flash Access module."},
            //  IncompatibleAdobeCPVersion                                : { code: 3318, message: "Incompatible version of Flash Access module found."},
            //  MissingAdobeCPEntryPoint                                  : { code: 3319, message: "Missing Flash Access module API entry point."},
            //  InternalErrorHA                                           : { code: 3320, message: "Generic internal Flash Access failure."},
            //  IndividualizationFailed                                   : { code: 3321, message: "Individualization failed."},
            //  DeviceBindingFailed                                       : { code: 3322, message: "Device binding failed."},
            //  CorruptStore                                              : { code: 3323, message: "The internal stores are corrupted."},
            //  MachineTokenInvalid                                       : { code: 3324, message: "Reset license files and the client will fetch a new machine token."},
            //  CorruptServerStateStore                                   : { code: 3325, message: "Internal stores are corrupt."},
            //  TamperingDetected                                         : { code: 3326, message: "Call customer support."},
            //  ClockTamperingDetected                                    : { code: 3327, message: "Clock tampering detected."},
            //  ServerErrorTryAgain                                       : { code: 3328, message: "Server error; retry the request."},
            //  ApplicationSpecificError                                  : { code: 3329, message: "Error in application-specific namespace."},
            //  NeedAuthentication                                        : { code: 3330, message: "Need to authenticate the user and reacquire the voucher."},
            //  ContentNotYetValid                                        : { code: 3331, message: "Content is not yet valid."},
            //  CachedVoucherExpired                                      : { code: 3332, message: "Cached voucher has expired. Reacquire the voucher from the server."},
            //  PlaybackWindowExpired                                     : { code: 3333, message: "The playback window for this policy has expired."},
            //  InvalidDRMPlatform                                        : { code: 3334, message: "This platform is not allowed to play this content."},
            //  InvalidDRMVersion                                         : { code: 3335, message: "Invalid version of Flash Access module. Upgrade AIR or Flash Access module for the Flash Player."},
            //  InvalidRuntimePlatform                                    : { code: 3336, message: "This platform is not allowed to play this content."},
            //  InvalidRuntimeVersion                                     : { code: 3337, message: "Upgrade Flash Player or AIR  and retry playback."},
            //  UnknownConnectionType                                     : { code: 3338, message: "Unknown connection type."},
            //  NoAnalogPlaybackAllowed                                   : { code: 3339, message: "Can't play back on analog device. Connect to a digital device."},
            //  NoAnalogProtectionAvail                                   : { code: 3340, message: "Can't play back because connected analog device doesn't have the correct capabilities."},
            //  NoDigitalPlaybackAllowed                                  : { code: 3341, message: "Can't play back on digital device."},
            //  NoDigitalProtectionAvail                                  : { code: 3342, message: "The connected digital device doesn't have the correct capabilities."},
            InternalErrorIV: {
                code: 3343,
                message: 'Internal Error.'
            }
        };
        for (var k in AVMX.Errors) {
            var error = AVMX.Errors[k];
            error.typeName = k;
            AVMX.Errors[error.code] = error;
        }
        function getErrorMessage(index) {
            var message = 'Error #' + index;
            if (!Shumway.AVM2.Runtime.debuggerMode.value) {
                return message;
            }
            var error = AVMX.Errors[index];
            return message + ': ' + (error && error.message || '(unknown)');
        }
        AVMX.getErrorMessage = getErrorMessage;
        function getErrorInfo(index) {
            return AVMX.Errors[index];
        }
        AVMX.getErrorInfo = getErrorInfo;
        function formatErrorMessage(error) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var message = error.message;
            args.forEach(function (x, i) {
                message = message.replace('%' + (i + 1), x);
            });
            return 'Error #' + error.code + ': ' + message;
        }
        AVMX.formatErrorMessage = formatErrorMessage;
        function translateErrorMessage(error) {
            if (error.type) {
                switch (error.type) {
                case 'undefined_method':
                    return formatErrorMessage(AVMX.Errors.CallOfNonFunctionError, 'value');
                default:
                    throw Shumway.Debug.notImplemented(error.type);
                }
            } else {
                if (error.message.indexOf('is not a function') >= 0) {
                    return formatErrorMessage(AVMX.Errors.CallOfNonFunctionError, 'value');
                }
                return error.message;
            }
        }
        AVMX.translateErrorMessage = translateErrorMessage;
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
}(Shumway || (Shumway = {})));
// Errors is used in dataBuffer.ts, which is compiled way before this. Gotta break the cycle.
Errors = Shumway.AVMX.Errors;
var Shumway;
(function (Shumway) {
    var AVM2;
    (function (AVM2) {
        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;
        var shumwayOptions = Shumway.Settings.shumwayOptions;
        var avm2Options = shumwayOptions.register(new OptionSet('AVM2'));
        var Runtime;
        (function (Runtime) {
            var options = avm2Options.register(new OptionSet('Runtime'));
            Runtime.traceRuntime = options.register(new Option('tr', 'traceRuntime', 'boolean', false, 'trace runtime'));
            Runtime.traceExecution = options.register(new Option('tx', 'traceExecution', 'boolean', false, 'trace execution'));
            Runtime.traceInterpreter = options.register(new Option('ti', 'traceInterpreter', 'boolean', false, 'trace interpreter'));
            Runtime.debuggerMode = options.register(new Option('db', 'debuggerMode', 'boolean', true, 'enable debugger mode'));
        }(Runtime = AVM2.Runtime || (AVM2.Runtime = {})));
        var ABC;
        (function (ABC) {
            var textDecoder = null;
            if (typeof TextDecoder !== 'undefined') {
                textDecoder = new TextDecoder();
            }
            var AbcStream = function () {
                function AbcStream(bytes) {
                    this._bytes = bytes;
                    this._view = new DataView(bytes.buffer, bytes.byteOffset);
                    this._position = 0;
                }
                AbcStream._getResultBuffer = function (length) {
                    if (!AbcStream._resultBuffer || AbcStream._resultBuffer.length < length) {
                        AbcStream._resultBuffer = new Int32Array(length * 2);
                    }
                    return AbcStream._resultBuffer;
                };
                Object.defineProperty(AbcStream.prototype, 'position', {
                    get: function () {
                        return this._position;
                    },
                    enumerable: true,
                    configurable: true
                });
                AbcStream.prototype.remaining = function () {
                    return this._bytes.length - this._position;
                };
                AbcStream.prototype.seek = function (position) {
                    this._position = position;
                };
                AbcStream.prototype.advance = function (length) {
                    this._position += length;
                };
                AbcStream.prototype.readU8 = function () {
                    return this._bytes[this._position++];
                };
                AbcStream.prototype.readU8s = function (count) {
                    var b = new Uint8Array(count);
                    b.set(this._bytes.subarray(this._position, this._position + count), 0);
                    this._position += count;
                    return b;
                };
                AbcStream.prototype.viewU8s = function (count) {
                    var view = this._bytes.subarray(this._position, this._position + count);
                    this._position += count;
                    return view;
                };
                AbcStream.prototype.readS8 = function () {
                    return this._bytes[this._position++] << 24 >> 24;
                };
                AbcStream.prototype.readU32 = function () {
                    return this.readS32() >>> 0;
                };
                AbcStream.prototype.readU30 = function () {
                    var result = this.readU32();
                    if (result & 3221225472) {
                        // TODO: Spec says this is a corrupt ABC file, but it seems that some content
                        // has this, e.g. 1000-0.abc
                        // error("Corrupt ABC File");
                        return result;
                    }
                    return result;
                };
                AbcStream.prototype.readU30Unsafe = function () {
                    return this.readU32();
                };
                AbcStream.prototype.readS16 = function () {
                    return this.readU30Unsafe() << 16 >> 16;
                };
                /**
                 * Read a variable-length encoded 32-bit signed integer. The value may use one to five bytes (little endian),
                 * each contributing 7 bits. The most significant bit of each byte indicates that the next byte is part of
                 * the value. The spec indicates that the most significant bit of the last byte to be read is sign extended
                 * but this turns out not to be the case in the real implementation, for instance 0x7f should technically be
                 * -1, but instead it's 127. Moreover, what happens to the remaining 4 high bits of the fifth byte that is
                 * read? Who knows, here we'll just stay true to the Tamarin implementation.
                 */
                AbcStream.prototype.readS32 = function () {
                    var result = this.readU8();
                    if (result & 128) {
                        result = result & 127 | this.readU8() << 7;
                        if (result & 16384) {
                            result = result & 16383 | this.readU8() << 14;
                            if (result & 2097152) {
                                result = result & 2097151 | this.readU8() << 21;
                                if (result & 268435456) {
                                    result = result & 268435455 | this.readU8() << 28;
                                    result = result & 4294967295;
                                }
                            }
                        }
                    }
                    return result;
                };
                AbcStream.prototype.readWord = function () {
                    var result = this._view.getUint32(this._position, true);
                    this._position += 4;
                    return result;
                };
                AbcStream.prototype.readS24 = function () {
                    var u = this.readU8() | this.readU8() << 8 | this.readU8() << 16;
                    return u << 8 >> 8;
                };
                AbcStream.prototype.readDouble = function () {
                    var result = this._view.getFloat64(this._position, true);
                    this._position += 8;
                    return result;
                };
                AbcStream.prototype.readUTFString = function (length) {
                    /**
                     * Use the TextDecoder API whenever available.
                     * http://encoding.spec.whatwg.org/#concept-encoding-get
                     */
                    if (textDecoder) {
                        var position = this._position;
                        this._position += length;
                        return textDecoder.decode(this._bytes.subarray(position, position + length));
                    }
                    var pos = this._position;
                    var end = pos + length;
                    var bytes = this._bytes;
                    var i = 0;
                    var result = AbcStream._getResultBuffer(length * 2);
                    while (pos < end) {
                        var c = bytes[pos++];
                        if (c <= 127) {
                            result[i++] = c;
                        } else if (c >= 192) {
                            var code = 0;
                            if (c < 224) {
                                code = (c & 31) << 6 | bytes[pos++] & 63;
                            } else if (c < 240) {
                                code = (c & 15) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63;
                            } else {
                                // turned into two characters in JS as surrogate pair
                                code = ((c & 7) << 18 | (bytes[pos++] & 63) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63) - 65536;
                                // High surrogate
                                result[i++] = ((code & 1047552) >>> 10) + 55296;
                                // Low surrogate
                                code = (code & 1023) + 56320;
                            }
                            result[i++] = code;
                        }    // Otherwise it's an invalid UTF8, skipped.
                    }
                    this._position = pos;
                    return Shumway.StringUtilities.fromCharCodeArray(result.subarray(0, i));
                };
                AbcStream._resultBuffer = new Int32Array(256);
                return AbcStream;
            }();
            ABC.AbcStream = AbcStream;
        }(ABC = AVM2.ABC || (AVM2.ABC = {})));
    }(AVM2 = Shumway.AVM2 || (Shumway.AVM2 = {})));
    var AVMX;
    (function (AVMX) {
        var assert = Shumway.Debug.assert;
        var writer = new Shumway.IndentingWriter();
        var bytecodeNames = [
            '',
            'BKPT',
            'NOP',
            'THROW',
            'GETSUPER',
            'SETSUPER',
            'DXNS',
            'DXNSLATE',
            'KILL',
            'LABEL',
            'LF32X4',
            'SF32X4',
            'IFNLT',
            'IFNLE',
            'IFNGT',
            'IFNGE',
            'JUMP',
            'IFTRUE',
            'IFFALSE',
            'IFEQ',
            'IFNE',
            'IFLT',
            'IFLE',
            'IFGT',
            'IFGE',
            'IFSTRICTEQ',
            'IFSTRICTNE',
            'LOOKUPSWITCH',
            'PUSHWITH',
            'POPSCOPE',
            'NEXTNAME',
            'HASNEXT',
            'PUSHNULL',
            'PUSHUNDEFINED',
            'PUSHFLOAT',
            'NEXTVALUE',
            'PUSHBYTE',
            'PUSHSHORT',
            'PUSHTRUE',
            'PUSHFALSE',
            'PUSHNAN',
            'POP',
            'DUP',
            'SWAP',
            'PUSHSTRING',
            'PUSHINT',
            'PUSHUINT',
            'PUSHDOUBLE',
            'PUSHSCOPE',
            'PUSHNAMESPACE',
            'HASNEXT2',
            ,
            ,
            'LI8',
            'LI16',
            'LI32',
            'LF32',
            'LF64',
            'SI8',
            'SI16',
            'SI32',
            'SF32',
            'SF64',
            ,
            'NEWFUNCTION',
            'CALL',
            'CONSTRUCT',
            'CALLMETHOD',
            'CALLSTATIC',
            'CALLSUPER',
            'CALLPROPERTY',
            'RETURNVOID',
            'RETURNVALUE',
            'CONSTRUCTSUPER',
            'CONSTRUCTPROP',
            'CALLSUPERID',
            'CALLPROPLEX',
            'CALLINTERFACE',
            'CALLSUPERVOID',
            'CALLPROPVOID',
            'SXI1',
            'SXI8',
            'SXI16',
            'APPLYTYPE',
            'PUSHFLOAT4',
            'NEWOBJECT',
            'NEWARRAY',
            'NEWACTIVATION',
            'NEWCLASS',
            'GETDESCENDANTS',
            'NEWCATCH',
            ,
            ,
            'FINDPROPSTRICT',
            'FINDPROPERTY',
            'FINDDEF',
            'GETLEX',
            'SETPROPERTY',
            'GETLOCAL',
            'SETLOCAL',
            'GETGLOBALSCOPE',
            'GETSCOPEOBJECT',
            'GETPROPERTY',
            'GETOUTERSCOPE',
            'INITPROPERTY',
            'UNUSED_69',
            'DELETEPROPERTY',
            'UNUSED_6B',
            'GETSLOT',
            'SETSLOT',
            'GETGLOBALSLOT',
            'SETGLOBALSLOT',
            'CONVERT_S',
            'ESC_XELEM',
            'ESC_XATTR',
            'CONVERT_I',
            'CONVERT_U',
            'CONVERT_D',
            'CONVERT_B',
            'CONVERT_O',
            'CHECKFILTER',
            'CONVERT_F',
            'UNPLUS',
            'CONVERT_F4',
            'BC_7C',
            'BC_7D',
            'BC_7E',
            'BC_7F',
            'COERCE',
            'COERCE_B',
            'COERCE_A',
            'COERCE_I',
            'COERCE_D',
            'COERCE_S',
            'ASTYPE',
            'ASTYPELATE',
            'COERCE_U',
            'COERCE_O',
            ,
            ,
            ,
            ,
            ,
            ,
            'NEGATE',
            'INCREMENT',
            'INCLOCAL',
            'DECREMENT',
            'DECLOCAL',
            'TYPEOF',
            'NOT',
            'BITNOT',
            'UNUSED_98',
            'UNUSED_99',
            'UNUSED_9A',
            'UNUSED_9B',
            'UNUSED_9C',
            'UNUSED_9D',
            'UNUSED_9E',
            'UNUSED_9F',
            'ADD',
            'SUBTRACT',
            'MULTIPLY',
            'DIVIDE',
            'MODULO',
            'LSHIFT',
            'RSHIFT',
            'URSHIFT',
            'BITAND',
            'BITOR',
            'BITXOR',
            'EQUALS',
            'STRICTEQUALS',
            'LESSTHAN',
            'LESSEQUALS',
            'GREATERTHAN',
            'GREATEREQUALS',
            'INSTANCEOF',
            'ISTYPE',
            'ISTYPELATE',
            'IN',
            'UNUSED_B5',
            'UNUSED_B6',
            'UNUSED_B7',
            'UNUSED_B8',
            'UNUSED_B9',
            'UNUSED_BA',
            'UNUSED_BB',
            'UNUSED_BC',
            'UNUSED_BD',
            'UNUSED_BE',
            'UNUSED_BF',
            'INCREMENT_I',
            'DECREMENT_I',
            'INCLOCAL_I',
            'DECLOCAL_I',
            'NEGATE_I',
            'ADD_I',
            'SUBTRACT_I',
            'MULTIPLY_I',
            'UNUSED_C8',
            'UNUSED_C9',
            'UNUSED_CA',
            'UNUSED_CB',
            'UNUSED_CC',
            'UNUSED_CD',
            'UNUSED_CE',
            'UNUSED_CF',
            'GETLOCAL0',
            'GETLOCAL1',
            'GETLOCAL2',
            'GETLOCAL3',
            'SETLOCAL0',
            'SETLOCAL1',
            'SETLOCAL2',
            'SETLOCAL3',
            'UNUSED_D8',
            'UNUSED_D9',
            'UNUSED_DA',
            'UNUSED_DB',
            'UNUSED_DC',
            'UNUSED_DD',
            'UNUSED_DE',
            'UNUSED_DF',
            'UNUSED_E0',
            'UNUSED_E1',
            'UNUSED_E2',
            'UNUSED_E3',
            'UNUSED_E4',
            'UNUSED_E5',
            'UNUSED_E6',
            'UNUSED_E7',
            'UNUSED_E8',
            'UNUSED_E9',
            'UNUSED_EA',
            'UNUSED_EB',
            'UNUSED_EC',
            'INVALID',
            'UNUSED_EE',
            'DEBUG',
            'DEBUGLINE',
            'DEBUGFILE',
            'BKPTLINE',
            'TIMESTAMP',
            'RESTARGC',
            'RESTARG',
            'UNUSED_F6',
            'UNUSED_F7',
            'UNUSED_F8',
            'UNUSED_F9',
            'UNUSED_FA',
            'UNUSED_FB',
            'UNUSED_FC',
            'UNUSED_FD',
            'UNUSED_FE',
            'END'
        ];
        function getBytecodeName(bytecode) {
            return release ? 'Bytecode: ' + bytecode : bytecodeNames[bytecode];
        }
        AVMX.getBytecodeName = getBytecodeName;
        /**
         * A array that maps from a bytecode value to the set of {@link OPFlags} for the corresponding instruction.
         */
        AVMX.BytecodeFlags = new Uint32Array(256);
        AVMX.BytecodeFormat = new Array(256);
        function define(bytecode, format, flags) {
            if (flags === void 0) {
                flags = 0;
            }
            var instructionLength = format.length;
            AVMX.BytecodeFlags[bytecode] = flags;
            AVMX.BytecodeFormat[bytecode] = format;    // release || assert (!isConditionalBranch(opcode) || isBranch(opcode), "a conditional branch must also be a branch");
        }
        /**
         * Only call this before the compiler is used.
         */
        function defineBytecodes() {
            define(1    /* BKPT */, '');
            define(2    /* NOP */, '');
            define(3    /* THROW */, '');
            define(4    /* GETSUPER */, 'e');
            define(5    /* SETSUPER */, 'e');
            define(6    /* DXNS */, 'e');
            define(7    /* DXNSLATE */, '');
            define(8    /* KILL */, 'e');
            define(9    /* LABEL */, '');
            define(10    /* LF32X4 */, '');
            define(11    /* SF32X4 */, '');
            define(12    /* IFNLT */, 'd');
            define(13    /* IFNLE */, 'd');
            define(14    /* IFNGT */, 'd');
            define(15    /* IFNGE */, 'd');
            define(16    /* JUMP */, 'd');
            define(17    /* IFTRUE */, 'd');
            define(18    /* IFFALSE */, 'd');
            define(19    /* IFEQ */, 'd');
            define(20    /* IFNE */, 'd');
            define(21    /* IFLT */, 'd');
            define(22    /* IFLE */, 'd');
            define(23    /* IFGT */, 'd');
            define(24    /* IFGE */, 'd');
            define(25    /* IFSTRICTEQ */, 'd');
            define(26    /* IFSTRICTNE */, 'd');
            define(27    /* LOOKUPSWITCH */, '');
            define(28    /* PUSHWITH */, '');
            define(29    /* POPSCOPE */, '');
            define(30    /* NEXTNAME */, '');
            define(31    /* HASNEXT */, '');
            define(32    /* PUSHNULL */, '');
            define(33    /* PUSHUNDEFINED */, '');
            define(35    /* NEXTVALUE */, '');
            define(36    /* PUSHBYTE */, 'b');
            define(37    /* PUSHSHORT */, 'c');
            define(38    /* PUSHTRUE */, '');
            define(39    /* PUSHFALSE */, '');
            define(40    /* PUSHNAN */, '');
            define(41    /* POP */, '');
            define(42    /* DUP */, '');
            define(43    /* SWAP */, '');
            define(44    /* PUSHSTRING */, 'e');
            define(45    /* PUSHINT */, 'e');
            define(46    /* PUSHUINT */, 'e');
            define(47    /* PUSHDOUBLE */, 'e');
            define(48    /* PUSHSCOPE */, '');
            define(49    /* PUSHNAMESPACE */, 'e');
            define(50    /* HASNEXT2 */, 'ee');
            // define(Bytecode.UNDEFINED, "");
            // define(Bytecode.UNDEFINED, "");
            define(53    /* LI8 */, '');
            define(54    /* LI16 */, '');
            define(55    /* LI32 */, '');
            define(56    /* LF32 */, '');
            define(57    /* LF64 */, '');
            define(58    /* SI8 */, '');
            define(59    /* SI16 */, '');
            define(60    /* SI32 */, '');
            define(61    /* SF32 */, '');
            define(62    /* SF64 */, '');
            define(64    /* NEWFUNCTION */, 'e');
            define(65    /* CALL */, 'e');
            define(66    /* CONSTRUCT */, 'e');
            define(67    /* CALLMETHOD */, 'ee');
            define(68    /* CALLSTATIC */, 'ee');
            define(69    /* CALLSUPER */, 'ee');
            define(70    /* CALLPROPERTY */, 'ee');
            define(71    /* RETURNVOID */, '');
            define(72    /* RETURNVALUE */, '');
            define(73    /* CONSTRUCTSUPER */, 'e');
            define(74    /* CONSTRUCTPROP */, 'ee');
            define(75    /* CALLSUPERID */, '');
            define(76    /* CALLPROPLEX */, 'ee');
            define(77    /* CALLINTERFACE */, '');
            define(78    /* CALLSUPERVOID */, 'ee');
            define(79    /* CALLPROPVOID */, 'ee');
            define(80    /* SXI1 */, '');
            define(81    /* SXI8 */, '');
            define(82    /* SXI16 */, '');
            define(83    /* APPLYTYPE */, 'e');
            define(84    /* PUSHFLOAT4 */, '');
            define(85    /* NEWOBJECT */, 'e');
            define(86    /* NEWARRAY */, 'e');
            define(87    /* NEWACTIVATION */, '');
            define(88    /* NEWCLASS */, 'e');
            define(89    /* GETDESCENDANTS */, 'e');
            define(90    /* NEWCATCH */, 'e');
            // define(Bytecode.UNDEFINED, "");
            // define(Bytecode.UNDEFINED, "");
            define(93    /* FINDPROPSTRICT */, 'e');
            define(94    /* FINDPROPERTY */, 'e');
            define(95    /* FINDDEF */, '');
            define(96    /* GETLEX */, 'e');
            define(97    /* SETPROPERTY */, 'e');
            define(98    /* GETLOCAL */, 'e');
            define(99    /* SETLOCAL */, 'e');
            define(100    /* GETGLOBALSCOPE */, '');
            define(101    /* GETSCOPEOBJECT */, 'e');
            define(102    /* GETPROPERTY */, 'e');
            define(103    /* GETOUTERSCOPE */, '');
            define(104    /* INITPROPERTY */, 'e');
            define(106    /* DELETEPROPERTY */, 'e');
            define(108    /* GETSLOT */, 'e');
            define(109    /* SETSLOT */, 'e');
            define(110    /* GETGLOBALSLOT */, 'e');
            define(111    /* SETGLOBALSLOT */, 'e');
            define(112    /* CONVERT_S */, '');
            define(113    /* ESC_XELEM */, '');
            define(114    /* ESC_XATTR */, '');
            define(115    /* CONVERT_I */, '');
            define(116    /* CONVERT_U */, '');
            define(117    /* CONVERT_D */, '');
            define(118    /* CONVERT_B */, '');
            define(119    /* CONVERT_O */, '');
            define(120    /* CHECKFILTER */, '');
            define(121    /* CONVERT_F */, '');
            define(122    /* UNPLUS */, '');
            define(123    /* CONVERT_F4 */, '');
            define(128    /* COERCE */, 'e');
            define(129    /* COERCE_B */, '');
            define(130    /* COERCE_A */, '');
            define(131    /* COERCE_I */, '');
            define(132    /* COERCE_D */, '');
            define(133    /* COERCE_S */, '');
            define(134    /* ASTYPE */, 'e');
            define(135    /* ASTYPELATE */, '');
            define(136    /* COERCE_U */, '');
            define(137    /* COERCE_O */, '');
            define(144    /* NEGATE */, '');
            define(145    /* INCREMENT */, '');
            define(146    /* INCLOCAL */, 'e');
            define(147    /* DECREMENT */, '');
            define(148    /* DECLOCAL */, 'e');
            define(149    /* TYPEOF */, '');
            define(150    /* NOT */, '');
            define(151    /* BITNOT */, '');
            define(160    /* ADD */, '');
            define(161    /* SUBTRACT */, '');
            define(162    /* MULTIPLY */, '');
            define(163    /* DIVIDE */, '');
            define(164    /* MODULO */, '');
            define(165    /* LSHIFT */, '');
            define(166    /* RSHIFT */, '');
            define(167    /* URSHIFT */, '');
            define(168    /* BITAND */, '');
            define(169    /* BITOR */, '');
            define(170    /* BITXOR */, '');
            define(171    /* EQUALS */, '');
            define(172    /* STRICTEQUALS */, '');
            define(173    /* LESSTHAN */, '');
            define(174    /* LESSEQUALS */, '');
            define(175    /* GREATERTHAN */, '');
            define(176    /* GREATEREQUALS */, '');
            define(177    /* INSTANCEOF */, '');
            define(178    /* ISTYPE */, 'e');
            define(179    /* ISTYPELATE */, '');
            define(180    /* IN */, '');
            define(192    /* INCREMENT_I */, '');
            define(193    /* DECREMENT_I */, '');
            define(194    /* INCLOCAL_I */, 'e');
            define(195    /* DECLOCAL_I */, 'e');
            define(196    /* NEGATE_I */, '');
            define(197    /* ADD_I */, '');
            define(198    /* SUBTRACT_I */, '');
            define(199    /* MULTIPLY_I */, '');
            define(208    /* GETLOCAL0 */, '');
            define(209    /* GETLOCAL1 */, '');
            define(210    /* GETLOCAL2 */, '');
            define(211    /* GETLOCAL3 */, '');
            define(212    /* SETLOCAL0 */, '');
            define(213    /* SETLOCAL1 */, '');
            define(214    /* SETLOCAL2 */, '');
            define(215    /* SETLOCAL3 */, '');
            define(237    /* INVALID */, '');
            define(239    /* DEBUG */, 'aeae');
            define(240    /* DEBUGLINE */, 'e');
            define(241    /* DEBUGFILE */, 'e');
            define(242    /* BKPTLINE */, 'e');
            define(243    /* TIMESTAMP */, '');    // define(Bytecode.UNUSED_6B, "", Flags.NONE);
                                                   // define(Bytecode.UNUSED_DE, "", Flags.NONE);
                                                   // define(Bytecode.UNUSED_BB, "", Flags.NONE);
        }
        AVMX.defineBytecodes = defineBytecodes;
        defineBytecodes();
        var Bytes = function () {
            function Bytes() {
            }
            Bytes.u8 = function (code, i) {
                return code[i];
            };
            Bytes.s32 = function (code, i) {
                var result = code[i];
                if (result & 128) {
                    result = result & 127 | code[i + 1] << 7;
                    if (result & 16384) {
                        result = result & 16383 | code[i + 2] << 14;
                        if (result & 2097152) {
                            result = result & 2097151 | code[i + 3] << 21;
                            if (result & 268435456) {
                                result = result & 268435455 | code[i + 4] << 28;
                                result = result & 4294967295;
                            }
                        }
                    }
                }
                return result;
            };
            Bytes.u32 = function (code, i) {
                return Bytes.s32(code, i) >>> 0;
            };
            Bytes.u30 = function (code, i) {
                return Bytes.u32(code, i);
            };
            Bytes.s32Length = function (code, i) {
                var result = code[i];
                if (result & 128) {
                    result = result & 127 | code[i + 1] << 7;
                    if (result & 16384) {
                        result = result & 16383 | code[i + 2] << 14;
                        if (result & 2097152) {
                            result = result & 2097151 | code[i + 3] << 21;
                            if (result & 268435456) {
                                return 5;
                            }
                            return 4;
                        }
                        return 3;
                    }
                    return 2;
                }
                return 1;
            };
            return Bytes;
        }();
        AVMX.Bytes = Bytes;
        function lengthAt(code, i) {
            var l = 1;
            var bytecode = code[i];
            if (bytecode === 27    /* LOOKUPSWITCH */) {
                l += 3;
                // Default offset.
                var n = Bytes.u30(code, i + l) + 1;
                // Offsets
                l += Bytes.s32Length(code, i + l);
                l += n * 3;
                return l;
            }
            var format = AVMX.BytecodeFormat[bytecode];
            if (format === '') {
                return l;
            }
            assert(format, 'OP: ' + getBytecodeName(bytecode));
            for (var j = 0; j < format.length; j++) {
                var f = format[j].charCodeAt(0) - 97;
                switch (f) {
                case 0    /* u08 */:
                case 1    /* s08 */:
                    l += 1;
                    continue;
                case 3    /* s24 */:
                    l += 3;
                    continue;
                case 2    /* s16 */:
                case 4    /* u30 */:
                case 5    /* u32 */:
                    l += Bytes.s32Length(code, i + l);
                    continue;
                }
            }
            return l;
        }
        var BytecodeStream = function () {
            function BytecodeStream(code) {
                this._code = code;
                this.setBCI(0);
            }
            BytecodeStream.prototype.next = function () {
                this.setBCI(this._nextBCI);
            };
            BytecodeStream.prototype.endBCI = function () {
                return this._code.length;
            };
            Object.defineProperty(BytecodeStream.prototype, 'nextBCI', {
                get: function () {
                    return this._nextBCI;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BytecodeStream.prototype, 'currentBCI', {
                get: function () {
                    return this._currentBCI;
                },
                enumerable: true,
                configurable: true
            });
            BytecodeStream.prototype.currentBytecode = function () {
                return this._bytecode;
            };
            BytecodeStream.prototype.nextBC = function () {
                return Bytes.u8(this._code, this._nextBCI);
            };
            BytecodeStream.prototype.setBCI = function (bci) {
                this._currentBCI = bci;
                if (this._currentBCI < this._code.length) {
                    this._bytecode = Bytes.u8(this._code, bci);
                    var l = lengthAt(this._code, bci);
                    this._nextBCI = bci + l;
                } else {
                    this._bytecode = 255    /* END */;
                    this._nextBCI = this._currentBCI;
                }
            };
            return BytecodeStream;
        }();
        AVMX.BytecodeStream = BytecodeStream;
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
}(Shumway || (Shumway = {})));
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    var AVMX;
    (function (AVMX) {
        var assert = Shumway.Debug.assert;
        var AbcStream = Shumway.AVM2.ABC.AbcStream;
        var writer = new Shumway.IndentingWriter();
        var CONSTANTNames = [
            'Undefined',
            'Utf8|ClassSealed',
            'Float|ClassFinal',
            'Int',
            'UInt|ClassInterface',
            'PrivateNs',
            'Double',
            'QName',
            'Namespace|ClassProtectedNs',
            'Multiname',
            'False',
            'True',
            'Null',
            'QNameA',
            'MultinameA',
            'RTQName',
            'RTQNameA',
            'RTQNameL',
            'RTQNameLA',
            'NameL',
            'NameLA',
            'NamespaceSet',
            'PackageNamespace',
            'PackageInternalNs',
            'ProtectedNamespace',
            'ExplicitNamespace',
            'StaticProtectedNs',
            'MultinameL',
            'MultinameLA',
            'TypeName'
        ];
        function getCONSTANTName(constant) {
            return release ? String(constant) : CONSTANTNames[constant];
        }
        AVMX.getCONSTANTName = getCONSTANTName;
        var TRAITNames = [
            'Slot',
            'Method',
            'Getter',
            'Setter',
            'Class',
            'Function',
            'Const',
            'GetterSetter'
        ];
        function getTRAITName(trait) {
            return release ? String(trait) : TRAITNames[trait];
        }
        AVMX.getTRAITName = getTRAITName;
        var namespaceTypeNames = [
            'Public',
            'Protected',
            'PackageInternal',
            'Private',
            'Explicit',
            'StaticProtected'
        ];
        function getNamespaceTypeName(namespaceType) {
            return release ? String(namespaceType) : namespaceTypeNames[namespaceType];
        }
        AVMX.getNamespaceTypeName = getNamespaceTypeName;
        var MetadataInfo = function () {
            function MetadataInfo(abc, name, keys, values) {
                this.abc = abc;
                this.name = name;
                this.keys = keys;
                this.values = values;    // ...
            }
            MetadataInfo.prototype.getName = function () {
                if (typeof this.name === 'number') {
                    this.name = this.abc.getString(this.name);
                }
                return this.name;
            };
            MetadataInfo.prototype.getKeyAt = function (i) {
                return this.abc.getString(this.keys[i]);
            };
            MetadataInfo.prototype.getValueAt = function (i) {
                return this.abc.getString(this.values[i]);
            };
            MetadataInfo.prototype.getValue = function (key) {
                for (var i = 0; i < this.keys.length; i++) {
                    if (this.abc.getString(this.keys[i]) === key) {
                        return this.abc.getString(this.values[i]);
                    }
                }
                return null;
            };
            return MetadataInfo;
        }();
        AVMX.MetadataInfo = MetadataInfo;
        /**
         * The Traits class represents the collection of compile-time traits associated with a type.
         * It's not used for runtime name resolution on instances; instead, the combined traits for
         * a type and all its super types is resolved and translated to an instance of RuntimeTraits.
         */
        var Traits = function () {
            function Traits(traits) {
                this.traits = traits;
                this._resolved = false;    // ...
            }
            Traits.prototype.resolve = function () {
                if (this._resolved) {
                    return;
                }
                for (var i = 0; i < this.traits.length; i++) {
                    this.traits[i].resolve();
                }
                this._resolved = true;
            };
            Traits.prototype.attachHolder = function (holder) {
                for (var i = 0; i < this.traits.length; i++) {
                    release || assert(!this.traits[i].holder);
                    this.traits[i].holder = holder;
                }
            };
            Traits.prototype.trace = function (writer) {
                if (writer === void 0) {
                    writer = new Shumway.IndentingWriter();
                }
                this.resolve();
                this.traits.forEach(function (x) {
                    return writer.writeLn(x.toString());
                });
            };
            /**
             * Searches for a trait with the specified name.
             */
            Traits.prototype.indexOf = function (mn) {
                release || assert(this._resolved);
                var mnName = mn.name;
                var nss = mn.namespaces;
                var traits = this.traits;
                for (var i = 0; i < traits.length; i++) {
                    var trait = traits[i];
                    var traitMn = trait.name;
                    if (traitMn.name === mnName) {
                        var ns = traitMn.namespaces[0];
                        for (var j = 0; j < nss.length; j++) {
                            if (ns === nss[j]) {
                                return i;
                            }
                        }
                    }
                }
                return -1;
            };
            Traits.prototype.getTrait = function (mn) {
                var i = this.indexOf(mn);
                return i >= 0 ? this.traits[i] : null;
            };
            /**
             * Turns a list of compile-time traits into runtime traits with resolved bindings.
             *
             * Runtime traits are stored in 2-dimensional maps. The outer dimension is keyed on the
             * trait's local name. The inner dimension is a map of mangled namespace names to traits.
             *
             * Lookups are thus O(n) in the number of namespaces present in the query, instead of O(n+m)
             * in the number of traits (n) on the type times the number of namespaces present in the
             * query (m).
             *
             * Negative result note: an implementation with ECMAScript Maps with Namespace objects as
             * keys was tried and found to be much slower than the Object-based one implemented here.
             * Mostly, the difference was in how well accesses are optimized in JS engines, with Maps
             * being new-ish and less well-optimized.
             *
             * Additionally, all protected traits get added to a map with their unqualified name as key.
             * That map is created with the super type's map on its prototype chain. If a type overrides
             * a protected trait, it gets set as that type's value for the unqualified name. Additionally,
             * its name is canonicalized to use the namespace used in the initially introducing type.
             * During name lookup, we first check for a hit in that map and (after verifying that the mn
             * has a correct protected name in its namespaces set) return the most recent trait. That way,
             * all lookups always get the most recent trait, even if they originate from a super class.
             */
            Traits.prototype.resolveRuntimeTraits = function (superTraits, protectedNs, scope) {
                // Resolve traits so that indexOf works out.
                this.resolve();
                var protectedNsMappings = Object.create(superTraits ? superTraits.protectedNsMappings : null);
                var result = new RuntimeTraits(superTraits, protectedNs, protectedNsMappings);
                // Add all of the child traits, replacing or extending parent traits where necessary.
                for (var i = 0; i < this.traits.length; i++) {
                    var trait = this.traits[i];
                    var name = trait.name;
                    var runtimeTrait = new RuntimeTraitInfo(name, trait.kind, trait.abc);
                    if (name.namespaces[0].type === 1    /* Protected */) {
                        // Names for protected traits get canonicalized to the name of the type that initially
                        // introduces the trait.
                        if (result.protectedNsMappings[name.name]) {
                            runtimeTrait.name = result.protectedNsMappings[name.name].name;
                        }
                        result.protectedNsMappings[name.name] = runtimeTrait;
                    }
                    var currentTrait = result.addTrait(runtimeTrait);
                    switch (trait.kind) {
                    case 1    /* Method */:
                        var method = createMethodForTrait(trait, scope);
                        runtimeTrait.value = method;
                        break;
                    case 2    /* Getter */:
                        runtimeTrait.get = createMethodForTrait(trait, scope);
                        if (currentTrait && currentTrait.set) {
                            runtimeTrait.set = currentTrait.set;
                            runtimeTrait.kind = 7    /* GetterSetter */;
                        }
                        break;
                    case 3    /* Setter */:
                        runtimeTrait.set = createMethodForTrait(trait, scope);
                        if (currentTrait && currentTrait.get) {
                            runtimeTrait.get = currentTrait.get;
                            runtimeTrait.kind = 7    /* GetterSetter */;
                        }
                        break;
                    case 0    /* Slot */:
                    case 6    /* Const */:
                    case 4    /* Class */:
                        // Only non-const slots need to be writable. Everything else is fixed.
                        runtimeTrait.writable = true;
                        var slotTrait = trait;
                        runtimeTrait.slot = slotTrait.slot;
                        runtimeTrait.value = slotTrait.getDefaultValue();
                        runtimeTrait.typeName = slotTrait.typeName;
                        // TODO: Throw error for const without default.
                        result.addSlotTrait(runtimeTrait);
                    }
                }
                return result;
            };
            return Traits;
        }();
        AVMX.Traits = Traits;
        function createMethodForTrait(methodTraitInfo, scope) {
            if (methodTraitInfo.method) {
                return methodTraitInfo.method;
            }
            var methodInfo = methodTraitInfo.getMethodInfo();
            var method;
            if (methodInfo.flags & 32    /* Native */) {
                var metadata = methodInfo.getNativeMetadata();
                if (metadata || methodTraitInfo.holder instanceof ScriptInfo) {
                    if (metadata) {
                        method = AVMX.AS.getNative(metadata.getValueAt(0));
                    } else {
                        var mn = methodTraitInfo.getName();
                        method = AVMX.AS.getNative(mn.uri + '.' + mn.name);
                    }
                    method = createGlobalNative(method, scope.object.sec);
                } else {
                    method = AVMX.AS.getMethodOrAccessorNative(methodTraitInfo);
                }
                if (!release) {
                    method.toString = function () {
                        return 'Native ' + methodTraitInfo.toString();
                    };
                    method.isInterpreted = false;
                }
            } else {
                method = function () {
                    var self = this === jsGlobal ? scope.global.object : this;
                    return AVMX.interpret(self, methodInfo, scope, arguments, null);
                };
                if (!release) {
                    method.toString = function () {
                        return 'Interpreted ' + methodTraitInfo.toString();
                    };
                    method.isInterpreted = true;
                }
            }
            if (!release && Shumway.flashlog && methodInfo.trait) {
                method = function (wrapped, methodInfo) {
                    var traceMsg = methodInfo.toFlashlogString();
                    var result = function () {
                        Shumway.flashlog.writeAS3Trace(traceMsg);
                        return wrapped.apply(this, arguments);
                    };
                    result.toString = wrapped.toString;
                    result.isInterpreted = wrapped.isInterpreted;
                    return result;
                }(method, methodInfo);
            }
            methodTraitInfo.method = method;
            method.methodInfo = methodInfo;
            if (!release) {
                try {
                    Object.defineProperty(method, 'name', { value: methodInfo.getName() });
                } catch (e) {
                }
            }
            method.methodInfo = methodInfo;
            return method;
        }
        function createGlobalNative(native, sec) {
            return function () {
                switch (arguments.length) {
                case 0:
                    return native(sec);
                case 1:
                    return native(sec, arguments[0]);
                case 2:
                    return native(sec, arguments[0], arguments[1]);
                case 3:
                    return native(sec, arguments[0], arguments[1], arguments[2]);
                default:
                    var args = [sec];
                    for (var i = 0; i < arguments.length; i++) {
                        args.push(arguments[i]);
                    }
                    return native.apply(this, args);
                }
            };
        }
        var TraitInfo = function () {
            function TraitInfo(abc, kind, name) {
                this.abc = abc;
                this.kind = kind;
                this.name = name;
                this.metadata = null;
                this.holder = null;
            }
            TraitInfo.prototype.getMetadata = function () {
                if (!this.metadata) {
                    return null;
                }
                if (this.metadata instanceof Uint32Array) {
                    var metadata = new Array(this.metadata.length);
                    for (var i = 0; i < this.metadata.length; i++) {
                        metadata[i] = this.abc.getMetadataInfo(this.metadata[i]);
                    }
                    this.metadata = metadata;
                }
                return this.metadata;
            };
            TraitInfo.prototype.getName = function () {
                return this.name;
            };
            TraitInfo.prototype.resolve = function () {
                if (typeof this.name === 'number') {
                    this.name = this.abc.getMultiname(this.name);
                }
            };
            TraitInfo.prototype.toString = function () {
                return getTRAITName(this.kind) + ' ' + this.name;
            };
            TraitInfo.prototype.toFlashlogString = function () {
                this.resolve();
                return this.getName().toFlashlogString();
            };
            TraitInfo.prototype.isConst = function () {
                return this.kind === 6    /* Const */;
            };
            TraitInfo.prototype.isSlot = function () {
                return this.kind === 0    /* Slot */;
            };
            TraitInfo.prototype.isMethod = function () {
                return this.kind === 1    /* Method */;
            };
            TraitInfo.prototype.isGetter = function () {
                return this.kind === 2    /* Getter */;
            };
            TraitInfo.prototype.isSetter = function () {
                return this.kind === 3    /* Setter */;
            };
            TraitInfo.prototype.isAccessor = function () {
                return this.kind === 2    /* Getter */ || this.kind === 3    /* Setter */;
            };
            TraitInfo.prototype.isMethodOrAccessor = function () {
                return this.isAccessor() || this.kind === 1    /* Method */;
            };
            return TraitInfo;
        }();
        AVMX.TraitInfo = TraitInfo;
        var RuntimeTraits = function () {
            function RuntimeTraits(superTraits, protectedNs, protectedNsMappings) {
                this.superTraits = superTraits;
                this.protectedNs = protectedNs;
                this.protectedNsMappings = protectedNsMappings;
                this.slots = [];
                this._nextSlotID = 1;
                var traits = this._traits = Object.create(null);
                if (!superTraits) {
                    return;
                }
                var superMappings = superTraits._traits;
                for (var key in superMappings) {
                    traits[key] = Object.create(superMappings[key]);
                }
            }
            /**
             * Adds the given trait and returns any trait that might already exist under that name.
             *
             * See the comment for `Trait#resolveRuntimeTraits` for an explanation of the lookup scheme.
             */
            RuntimeTraits.prototype.addTrait = function (trait) {
                var mn = trait.name;
                var mappings = this._traits[mn.name];
                if (!mappings) {
                    mappings = this._traits[mn.name] = Object.create(null);
                }
                var nsName = mn.namespaces[0].mangledName;
                var current = mappings[nsName];
                mappings[nsName] = trait;
                return current;
            };
            RuntimeTraits.prototype.addSlotTrait = function (trait) {
                var slot = trait.slot;
                if (!slot) {
                    slot = trait.slot = this._nextSlotID++;
                } else {
                    this._nextSlotID = slot + 1;
                }
                release || assert(!this.slots[slot]);
                this.slots[slot] = trait;
            };
            /**
             * Returns the trait matching the given multiname parts, if any.
             *
             * See the comment for `Trait#resolveRuntimeTraits` for an explanation of the lookup scheme.
             */
            RuntimeTraits.prototype.getTrait = function (namespaces, name) {
                release || assert(typeof name === 'string');
                var mappings = this._traits[name];
                if (!mappings) {
                    return null;
                }
                var trait;
                for (var i = 0; i < namespaces.length; i++) {
                    var ns = namespaces[i];
                    trait = mappings[ns.mangledName];
                    if (trait) {
                        return trait;
                    }
                    if (ns.type === 1    /* Protected */) {
                        var protectedScope = this;
                        while (protectedScope) {
                            if (protectedScope.protectedNs === ns) {
                                trait = protectedScope.protectedNsMappings[name];
                                if (trait) {
                                    return trait;
                                }
                            }
                            protectedScope = protectedScope.superTraits;
                        }
                    }
                }
                return null;
            };
            RuntimeTraits.prototype.getTraitsList = function () {
                var list = [];
                var names = this._traits;
                for (var name in names) {
                    var mappings = names[name];
                    for (var nsName in mappings) {
                        list.push(mappings[nsName]);
                    }
                }
                return list;
            };
            RuntimeTraits.prototype.getSlotPublicTraitNames = function () {
                var slots = this.slots;
                var names = [];
                for (var i = 1; i < slots.length; i++) {
                    var slot = slots[i];
                    if (!slot.name.namespace.isPublic()) {
                        continue;
                    }
                    names.push(slot.name.name);
                }
                return names;
            };
            RuntimeTraits.prototype.getSlot = function (i) {
                return this.slots[i];
            };
            return RuntimeTraits;
        }();
        AVMX.RuntimeTraits = RuntimeTraits;
        var RuntimeTraitInfo = function () {
            function RuntimeTraitInfo(name, kind, abc) {
                this.name = name;
                this.kind = kind;
                this.abc = abc;
                this.configurable = true;
                // Always true.
                this._type = undefined;
                this.typeName = null;
            }
            RuntimeTraitInfo.prototype.getType = function () {
                if (this._type !== undefined) {
                    return this._type;
                }
                if (this.typeName === null) {
                    return this._type = null;
                }
                var type = this.abc.applicationDomain.getClass(this.typeName);
                return this._type = type && type.axCoerce ? type : null;
            };
            return RuntimeTraitInfo;
        }();
        AVMX.RuntimeTraitInfo = RuntimeTraitInfo;
        var typeDefaultValues = {
            __proto__: null,
            $BgNumber: NaN,
            $Bgint: 0,
            $Bguint: 0,
            $BgBoolean: false
        };
        var SlotTraitInfo = function (_super) {
            __extends(SlotTraitInfo, _super);
            function SlotTraitInfo(abc, kind, name, slot, typeName, defaultValueKind, defaultValueIndex) {
                _super.call(this, abc, kind, name);
                this.slot = slot;
                this.typeName = typeName;
                this.defaultValueKind = defaultValueKind;
                this.defaultValueIndex = defaultValueIndex;
            }
            SlotTraitInfo.prototype.resolve = function () {
                _super.prototype.resolve.call(this);
                if (typeof this.typeName === 'number') {
                    this.typeName = this.abc.getMultiname(this.typeName);
                }
            };
            SlotTraitInfo.prototype.getTypeName = function () {
                this.resolve();
                return this.typeName;
            };
            SlotTraitInfo.prototype.getDefaultValue = function () {
                if (this.defaultValueKind === -1) {
                    if (this.typeName === null) {
                        return undefined;
                    }
                    var value = typeDefaultValues[this.typeName.getMangledName()];
                    return value === undefined ? null : value;
                }
                return this.abc.getConstant(this.defaultValueKind, this.defaultValueIndex);
            };
            return SlotTraitInfo;
        }(TraitInfo);
        AVMX.SlotTraitInfo = SlotTraitInfo;
        var MethodTraitInfo = function (_super) {
            __extends(MethodTraitInfo, _super);
            function MethodTraitInfo(abc, kind, name, methodInfo) {
                _super.call(this, abc, kind, name);
                this.methodInfo = methodInfo;
                this.method = null;
            }
            MethodTraitInfo.prototype.getMethodInfo = function () {
                return this.methodInfo;
            };
            MethodTraitInfo.prototype.resolve = function () {
                _super.prototype.resolve.call(this);
                if (typeof this.methodInfo === 'number') {
                    this.methodInfo = this.abc.getMethodInfo(this.methodInfo);
                }
            };
            return MethodTraitInfo;
        }(TraitInfo);
        AVMX.MethodTraitInfo = MethodTraitInfo;
        var ClassTraitInfo = function (_super) {
            __extends(ClassTraitInfo, _super);
            function ClassTraitInfo(abc, kind, name, slot, classInfo) {
                _super.call(this, abc, kind, name, slot, 0, 0, -1);
                this.classInfo = classInfo;
            }
            return ClassTraitInfo;
        }(SlotTraitInfo);
        AVMX.ClassTraitInfo = ClassTraitInfo;
        var ParameterInfo = function () {
            function ParameterInfo(abc, type, name, optionalValueKind, optionalValueIndex) {
                this.abc = abc;
                this.type = type;
                this.name = name;
                this.optionalValueKind = optionalValueKind;
                this.optionalValueIndex = optionalValueIndex;    // ...
            }
            ParameterInfo.prototype.getName = function () {
                if (typeof this.name === 'number') {
                    this.name = this.abc.getString(this.name);
                }
                return this.name;
            };
            ParameterInfo.prototype.getType = function () {
                if (typeof this.type === 'number') {
                    this.type = this.abc.getMultiname(this.type);
                }
                return this.type;
            };
            ParameterInfo.prototype.hasOptionalValue = function () {
                return this.optionalValueKind >= 0;
            };
            ParameterInfo.prototype.getOptionalValue = function () {
                return this.abc.getConstant(this.optionalValueKind, this.optionalValueIndex);
            };
            ParameterInfo.prototype.toString = function () {
                var str = '';
                if (this.name) {
                    str += this.getName();
                } else {
                    str += '?';
                }
                if (this.type) {
                    str += ': ' + this.getType().name;
                }
                if (this.optionalValueKind >= 0) {
                    str += ' = ' + this.abc.getConstant(this.optionalValueKind, this.optionalValueIndex);
                }
                return str;
            };
            return ParameterInfo;
        }();
        AVMX.ParameterInfo = ParameterInfo;
        var Info = function () {
            function Info() {
            }
            return Info;
        }();
        AVMX.Info = Info;
        var InstanceInfo = function (_super) {
            __extends(InstanceInfo, _super);
            function InstanceInfo(abc, name, superName, flags, protectedNs, interfaceNameIndices, initializer, traits) {
                _super.call(this);
                this.abc = abc;
                this.name = name;
                this.superName = superName;
                this.flags = flags;
                this.protectedNs = protectedNs;
                this.interfaceNameIndices = interfaceNameIndices;
                this.initializer = initializer;
                this.traits = traits;
                this.classInfo = null;
                this.runtimeTraits = null;
                this._interfaces = null;
            }
            InstanceInfo.prototype.getInitializer = function () {
                if (typeof this.initializer === 'number') {
                    this.initializer = this.abc.getMethodInfo(this.initializer);
                }
                return this.initializer;
            };
            InstanceInfo.prototype.getName = function () {
                if (typeof this.name === 'number') {
                    this.name = this.abc.getMultiname(this.name);
                }
                return this.name;
            };
            InstanceInfo.prototype.getClassName = function () {
                var name = this.getName();
                if (name.namespaces[0].uri) {
                    return name.namespaces[0].uri + '.' + name.name;
                }
                return name.name;
            };
            InstanceInfo.prototype.getSuperName = function () {
                if (typeof this.superName === 'number') {
                    this.superName = this.abc.getMultiname(this.superName);
                }
                return this.superName;
            };
            InstanceInfo.prototype.getInterfaces = function (ownerClass) {
                if (this._interfaces) {
                    return this._interfaces;
                }
                var superClassInterfaces;
                var superClass = ownerClass.superClass;
                if (superClass) {
                    superClassInterfaces = superClass.classInfo.instanceInfo.getInterfaces(superClass);
                }
                var SetCtor = Set;
                var interfaces = this._interfaces = new SetCtor(superClassInterfaces);
                for (var i = 0; i < this.interfaceNameIndices.length; i++) {
                    var mn = this.abc.getMultiname(this.interfaceNameIndices[i]);
                    var type = this.abc.applicationDomain.getClass(mn);
                    interfaces.add(type);
                    var implementedInterfaces = type.classInfo.instanceInfo.getInterfaces(type);
                    implementedInterfaces.forEach(function (iface) {
                        return interfaces.add(iface);
                    });
                }
                return interfaces;
            };
            InstanceInfo.prototype.toString = function () {
                return 'InstanceInfo ' + this.getName().name;
            };
            InstanceInfo.prototype.toFlashlogString = function () {
                return this.getName().toFlashlogString();
            };
            InstanceInfo.prototype.trace = function (writer) {
                writer.enter('InstanceInfo: ' + this.getName());
                this.superName && writer.writeLn('Super: ' + this.getSuperName());
                this.traits.trace(writer);
                writer.outdent();
            };
            InstanceInfo.prototype.isInterface = function () {
                return !!(this.flags & 4    /* ClassInterface */);
            };
            InstanceInfo.prototype.isSealed = function () {
                return !!(this.flags & 1    /* ClassSealed */);
            };
            InstanceInfo.prototype.isFinal = function () {
                return !!(this.flags & 2    /* ClassFinal */);
            };
            return InstanceInfo;
        }(Info);
        AVMX.InstanceInfo = InstanceInfo;
        var ScriptInfo = function (_super) {
            __extends(ScriptInfo, _super);
            function ScriptInfo(abc, initializer, traits) {
                _super.call(this);
                this.abc = abc;
                this.initializer = initializer;
                this.traits = traits;
                this.global = null;
                this.state = 0    /* None */;
            }
            ScriptInfo.prototype.getInitializer = function () {
                return this.abc.getMethodInfo(this.initializer);
            };
            ScriptInfo.prototype.trace = function (writer) {
                writer.enter('ScriptInfo');
                this.traits.trace(writer);
                writer.outdent();
            };
            return ScriptInfo;
        }(Info);
        AVMX.ScriptInfo = ScriptInfo;
        var ClassInfo = function (_super) {
            __extends(ClassInfo, _super);
            function ClassInfo(abc, instanceInfo, initializer, traits) {
                _super.call(this);
                this.abc = abc;
                this.instanceInfo = instanceInfo;
                this.initializer = initializer;
                this.traits = traits;
                this.trait = null;
                this.runtimeTraits = null;
            }
            ClassInfo.prototype.getNativeMetadata = function () {
                if (!this.trait) {
                    return null;
                }
                var metadata = this.trait.getMetadata();
                if (!metadata) {
                    return null;
                }
                for (var i = 0; i < metadata.length; i++) {
                    if (metadata[i].getName() === 'native') {
                        return metadata[i];
                    }
                }
                return null;
            };
            ClassInfo.prototype.getInitializer = function () {
                if (typeof this.initializer === 'number') {
                    return this.initializer = this.abc.getMethodInfo(this.initializer);
                }
                return this.initializer;
            };
            ClassInfo.prototype.toString = function () {
                return 'ClassInfo ' + this.instanceInfo.getName();
            };
            ClassInfo.prototype.trace = function (writer) {
                writer.enter('ClassInfo');
                this.traits.trace(writer);
                writer.outdent();
            };
            return ClassInfo;
        }(Info);
        AVMX.ClassInfo = ClassInfo;
        var ExceptionInfo = function () {
            function ExceptionInfo(abc, start, end, target, type, varName) {
                this.abc = abc;
                this.start = start;
                this.end = end;
                this.target = target;
                this.type = type;
                this.varName = varName;
                this.catchPrototype = null;
                this._traits = null;    // ...
            }
            ExceptionInfo.prototype.getType = function () {
                if (typeof this.type === 'number') {
                    this.type = this.abc.getMultiname(this.type);
                }
                return this.type;
            };
            ExceptionInfo.prototype.getTraits = function () {
                if (!this._traits) {
                    var traits = [];
                    if (this.varName) {
                        traits.push(new SlotTraitInfo(this.abc, 0    /* Slot */, this.varName, 1, this.type, 0, 0));
                    }
                    this._traits = new Traits(traits);
                    this._traits.resolve();
                }
                return this._traits;
            };
            return ExceptionInfo;
        }();
        AVMX.ExceptionInfo = ExceptionInfo;
        var MethodBodyInfo = function (_super) {
            __extends(MethodBodyInfo, _super);
            function MethodBodyInfo(maxStack, localCount, initScopeDepth, maxScopeDepth, code, catchBlocks, traits) {
                _super.call(this);
                this.maxStack = maxStack;
                this.localCount = localCount;
                this.initScopeDepth = initScopeDepth;
                this.maxScopeDepth = maxScopeDepth;
                this.code = code;
                this.catchBlocks = catchBlocks;
                this.traits = traits;
                this.activationPrototype = null;
            }
            MethodBodyInfo.prototype.trace = function (writer) {
                writer.writeLn('Code: ' + this.code.length);
                var stream = new AVMX.BytecodeStream(this.code);
                while (stream.currentBytecode() !== 255    /* END */) {
                    writer.writeLn(stream.currentBCI + ': ' + AVMX.getBytecodeName(stream.currentBytecode()));
                    stream.next();
                }
            };
            return MethodBodyInfo;
        }(Info);
        AVMX.MethodBodyInfo = MethodBodyInfo;
        var MethodInfo = function () {
            function MethodInfo(abc, _index, name, returnTypeNameIndex, parameters, optionalCount, flags) {
                this.abc = abc;
                this._index = _index;
                this.name = name;
                this.returnTypeNameIndex = returnTypeNameIndex;
                this.parameters = parameters;
                this.optionalCount = optionalCount;
                this.flags = flags;
                this.trait = null;
                this._body = null;
                this.minArgs = parameters.length - optionalCount;
            }
            MethodInfo.prototype.getNativeMetadata = function () {
                if (!this.trait) {
                    return null;
                }
                var metadata = this.trait.getMetadata();
                if (!metadata) {
                    return null;
                }
                for (var i = 0; i < metadata.length; i++) {
                    if (metadata[i].getName() === 'native') {
                        return metadata[i];
                    }
                }
                return null;
            };
            MethodInfo.prototype.getBody = function () {
                return this._body || (this._body = this.abc.getMethodBodyInfo(this._index));
            };
            MethodInfo.prototype.getType = function () {
                if (this._returnType !== undefined) {
                    return this._returnType;
                }
                if (this.returnTypeNameIndex === 0) {
                    this._returnType = null;
                } else {
                    var mn = this.abc.getMultiname(this.returnTypeNameIndex);
                    this._returnType = this.abc.applicationDomain.getClass(mn);
                }
                return this._returnType;
            };
            MethodInfo.prototype.getName = function () {
                if (this.name) {
                    return this.abc.getString(this.name);
                }
                if (this.trait) {
                    return this.trait.getName().name;
                }
                return 'anonymous';
            };
            MethodInfo.prototype.toString = function () {
                var str = 'anonymous';
                if (this.name) {
                    str = this.abc.getString(this.name);
                }
                str += ' (' + this.parameters.join(', ') + ')';
                if (this.returnTypeNameIndex) {
                    str += ': ' + this.abc.getMultiname(this.returnTypeNameIndex).name;
                }
                return str;
            };
            MethodInfo.prototype.toFlashlogString = function () {
                var trait = this.trait;
                var prefix = trait.kind === 2    /* Getter */ ? 'get ' : trait.kind === 3    /* Setter */ ? 'set ' : '';
                var name = trait.toFlashlogString();
                var holder = trait.holder;
                var holderName;
                if (holder && holder instanceof InstanceInfo) {
                    holderName = holder.toFlashlogString();
                    prefix = holderName + '/' + prefix;
                }
                if (holder && holder instanceof ClassInfo && holder.trait) {
                    holderName = holder.trait.toFlashlogString();
                    prefix = holderName + '$/' + prefix;
                }
                var prefixPos;
                if (holderName && (prefixPos = name.indexOf('::')) > 0 && holderName.indexOf(name.substring(0, prefixPos + 2)) === 0) {
                    name = name.substring(prefixPos + 2);
                }
                return 'MTHD ' + prefix + name + ' ()';
            };
            MethodInfo.prototype.isNative = function () {
                return !!(this.flags & 32    /* Native */);
            };
            MethodInfo.prototype.needsRest = function () {
                return !!(this.flags & 4    /* NeedRest */);
            };
            MethodInfo.prototype.needsArguments = function () {
                return !!(this.flags & 1    /* NeedArguments */);
            };
            return MethodInfo;
        }();
        AVMX.MethodInfo = MethodInfo;
        var Multiname = function () {
            function Multiname(abc, index, kind, namespaces, name, parameterType) {
                if (parameterType === void 0) {
                    parameterType = null;
                }
                this.abc = abc;
                this.index = index;
                this.kind = kind;
                this.namespaces = namespaces;
                this.name = name;
                this.parameterType = parameterType;
                this.id = Multiname._nextID++;
                this._mangledName = null;    // ...
            }
            Multiname.FromFQNString = function (fqn, nsType) {
                var lastDot = fqn.lastIndexOf('.');
                var uri = lastDot === -1 ? '' : fqn.substr(0, lastDot);
                var name = lastDot === -1 ? fqn : fqn.substr(lastDot + 1);
                var ns = internNamespace(nsType, uri);
                return new Multiname(null, 0, 15    /* RTQName */, [ns], name);
            };
            Multiname.prototype._nameToString = function () {
                if (this.isAnyName()) {
                    return '*';
                }
                return this.isRuntimeName() ? '[' + this.name + ']' : this.name;
            };
            Multiname.prototype.isRuntime = function () {
                switch (this.kind) {
                case 7    /* QName */:
                case 13    /* QNameA */:
                case 9    /* Multiname */:
                case 14    /* MultinameA */:
                    return false;
                }
                return true;
            };
            Multiname.prototype.isRuntimeName = function () {
                switch (this.kind) {
                case 17    /* RTQNameL */:
                case 18    /* RTQNameLA */:
                case 27    /* MultinameL */:
                case 28    /* MultinameLA */:
                    return true;
                }
                return false;
            };
            Multiname.prototype.isRuntimeNamespace = function () {
                switch (this.kind) {
                case 15    /* RTQName */:
                case 16    /* RTQNameA */:
                case 17    /* RTQNameL */:
                case 18    /* RTQNameLA */:
                    return true;
                }
                return false;
            };
            Multiname.prototype.isAnyName = function () {
                return this.name === null;
            };
            Multiname.prototype.isAnyNamespace = function () {
                if (this.isRuntimeNamespace() || this.namespaces.length > 1) {
                    return false;
                }
                return this.namespaces.length === 0 || this.namespaces[0].uri === '';    // x.* has the same meaning as x.*::*, so look for the former case and give
                                                                                         // it the same meaning of the latter.
                                                                                         // return !this.isRuntimeNamespace() &&
                                                                                         //  (this.namespaces.length === 0 || (this.isAnyName() && this.namespaces.length !== 1));
            };
            Multiname.prototype.isQName = function () {
                var kind = this.kind;
                var result = kind === 29    /* TypeName */ || kind === 7    /* QName */ || kind === 13    /* QNameA */ || kind >= 15    /* RTQName */ && kind <= 18    /* RTQNameLA */;
                release || assert(!(result && this.namespaces.length !== 1));
                return result;
            };
            Object.defineProperty(Multiname.prototype, 'namespace', {
                get: function () {
                    release || assert(this.isQName());
                    return this.namespaces[0];
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Multiname.prototype, 'uri', {
                get: function () {
                    release || assert(this.isQName());
                    return this.namespaces[0].uri;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Multiname.prototype, 'prefix', {
                get: function () {
                    release || assert(this.isQName());
                    return this.namespaces[0].prefix;
                },
                set: function (prefix) {
                    release || assert(this.isQName());
                    var ns = this.namespaces[0];
                    if (ns.prefix === prefix) {
                        return;
                    }
                    this.namespaces[0] = internPrefixedNamespace(ns.type, ns.uri, prefix);
                },
                enumerable: true,
                configurable: true
            });
            Multiname.prototype.equalsQName = function (mn) {
                release || assert(this.isQName());
                return this.name === mn.name && this.namespaces[0].uri === mn.namespaces[0].uri;
            };
            Multiname.prototype.matches = function (mn) {
                release || assert(this.isQName());
                var anyName = mn.isAnyName();
                if (anyName && !mn.isQName()) {
                    return true;
                }
                if (!anyName && this.name !== mn.name) {
                    return false;
                }
                var uri = this.namespaces[0].uri;
                for (var i = mn.namespaces.length; i--;) {
                    if (mn.namespaces[i].uri === uri) {
                        return true;
                    }
                }
                return false;
            };
            Multiname.prototype.isAttribute = function () {
                switch (this.kind) {
                case 13    /* QNameA */:
                case 16    /* RTQNameA */:
                case 18    /* RTQNameLA */:
                case 14    /* MultinameA */:
                case 28    /* MultinameLA */:
                    return true;
                }
                return false;
            };
            Multiname.prototype.getMangledName = function () {
                release || assert(this.isQName());
                return this._mangledName || this._mangleName();
            };
            Multiname.prototype._mangleName = function () {
                release || assert(!this._mangledName);
                var mangledName = '$' + this.namespaces[0].mangledName + AVMX.axCoerceString(this.name);
                if (!this.isRuntime()) {
                    this._mangledName = mangledName;
                }
                return mangledName;
            };
            Multiname.prototype.getPublicMangledName = function () {
                if (Shumway.isNumeric(this.name)) {
                    return this.name;
                }
                return '$Bg' + AVMX.axCoerceString(this.name);
            };
            Multiname.isPublicQualifiedName = function (value) {
                return value.indexOf('$Bg') === 0;
            };
            Multiname.getPublicMangledName = function (name) {
                if (Shumway.isNumeric(name)) {
                    return name;
                }
                return '$Bg' + name;
            };
            Multiname.prototype.toFQNString = function (useColons) {
                release || assert(this.isQName());
                var prefix = this.namespaces[0].uri;
                if (prefix.length) {
                    prefix += useColons ? '::' : '.';
                }
                return prefix + this.name;
            };
            Multiname.prototype.toString = function () {
                var str = getCONSTANTName(this.kind) + ' ';
                str += this.isAttribute() ? '@' : '';
                if (this.isRuntimeNamespace()) {
                    var namespaces = this.namespaces ? this.namespaces.map(function (x) {
                        return String(x);
                    }).join(', ') : null;
                    str += '[' + namespaces + ']::' + this._nameToString();
                } else if (this.isQName()) {
                    str += this.namespaces[0] + '::';
                    str += this._nameToString();
                } else {
                    str += '{' + this.namespaces.map(function (x) {
                        return String(x);
                    }).join(', ') + '}';
                    str += '::' + this._nameToString();
                }
                if (this.parameterType) {
                    str += '<' + this.parameterType + '>';
                }
                return str;
            };
            Multiname.prototype.toFlashlogString = function () {
                var namespaceUri = this.uri;
                return namespaceUri ? namespaceUri + '::' + this.name : this.name;
            };
            /**
             * Removes the public prefix, or returns undefined if the prefix doesn't exist.
             */
            Multiname.stripPublicMangledName = function (name) {
                if (name.indexOf('$Bg') === 0) {
                    return name.substring(3);
                }
                return undefined;
            };
            Multiname.FromSimpleName = function (simpleName) {
                var nameIndex = simpleName.lastIndexOf('.');
                if (nameIndex <= 0) {
                    nameIndex = simpleName.lastIndexOf(' ');
                }
                var uri = '';
                var name;
                if (nameIndex > 0 && nameIndex < simpleName.length - 1) {
                    name = simpleName.substring(nameIndex + 1).trim();
                    uri = simpleName.substring(0, nameIndex).trim();
                } else {
                    name = simpleName;
                }
                var ns = internNamespace(0    /* Public */, uri);
                return new Multiname(null, 0, 15    /* RTQName */, [ns], name);
            };
            Multiname._nextID = 1;
            return Multiname;
        }();
        AVMX.Multiname = Multiname;
        // Used in _hashNamespace so we don't need to allocate a new buffer each time.
        var namespaceHashingBuffer = new Int32Array(100);
        var Namespace = function () {
            function Namespace(type, uri, prefix) {
                this.type = type;
                this.uri = uri;
                this.prefix = prefix;
                this.mangledName = null;
                assert(type !== undefined);
                this.mangleName();
                if (!release) {
                    Object.freeze(this);
                }
            }
            Namespace.prototype.toString = function () {
                return getNamespaceTypeName(this.type) + (this.uri !== '' ? ':' + this.uri : '');
            };
            Namespace._hashNamespace = function (type, uri, prefix) {
                uri = uri + '';
                prefix = prefix + '';
                var index = Namespace._knownNames.indexOf(uri);
                if (index >= 0) {
                    return type << 2 | index;
                }
                var length = 1 + uri.length + prefix.length;
                var data = length < 101 ? namespaceHashingBuffer : new Int32Array(length);
                var j = 0;
                data[j++] = type;
                for (var i = 0; i < uri.length; i++) {
                    data[j++] = uri.charCodeAt(i);
                }
                for (var i = 0; i < prefix.length; i++) {
                    data[j++] = prefix.charCodeAt(i);
                }
                return Shumway.HashUtilities.hashBytesTo32BitsMD5(data, 0, j);
            };
            Namespace.prototype.mangleName = function () {
                if (this.type === 0    /* Public */ && this.uri === '') {
                    this.mangledName = 'Bg';
                    return;
                }
                var nsHash = Namespace._hashNamespace(this.type, this.uri, this.prefix);
                this.mangledName = Shumway.StringUtilities.variableLengthEncodeInt32(nsHash);
            };
            Namespace.prototype.isPublic = function () {
                return this.type === 0    /* Public */;
            };
            Object.defineProperty(Namespace.prototype, 'reflectedURI', {
                get: function () {
                    // For public names without a URI, Tamarin uses `null`, we use `""`.
                    // Hence: special-casing for reflection.
                    return this.uri || (this.type === 0    /* Public */ ? null : this.uri);
                },
                enumerable: true,
                configurable: true
            });
            Namespace._knownNames = [''];
            return Namespace;
        }();
        AVMX.Namespace = Namespace;
        var _namespaces = {};
        function internNamespace(type, uri) {
            var key = type + uri;
            return _namespaces[key] || (_namespaces[key] = new Namespace(type, uri, ''));
        }
        AVMX.internNamespace = internNamespace;
        function internPrefixedNamespace(type, uri, prefix) {
            var key = type + uri + prefix;
            var ns = _namespaces[key];
            if (!ns) {
                ns = _namespaces[key] = new Namespace(type, uri, prefix);
            }
            return ns;
        }
        AVMX.internPrefixedNamespace = internPrefixedNamespace;
        Namespace.PUBLIC = internNamespace(0    /* Public */, '');
        var ABCFile = function () {
            function ABCFile(env, _buffer) {
                this._buffer = _buffer;
                this.env = env;
                this._stream = new AbcStream(_buffer);
                this._checkMagic();
                this._parseConstantPool();
                this._parseNamespaces();
                this._parseNamespaceSets();
                this._parseMultinames();
                this._parseMethodInfos();
                this._parseMetaData();
                this._parseInstanceAndClassInfos();
                this._parseScriptInfos();
                this._parseMethodBodyInfos();
            }
            Object.defineProperty(ABCFile.prototype, 'applicationDomain', {
                get: function () {
                    release || assert(this.env.app);
                    return this.env.app;
                },
                enumerable: true,
                configurable: true
            });
            ABCFile.prototype._parseConstantPool = function () {
                this._parseNumericConstants();
                this._parseStringConstants();
            };
            ABCFile.prototype._parseNumericConstants = function () {
                var n = 0, s = this._stream;
                // Parse Signed Integers
                n = s.readU30();
                var ints = new Int32Array(n);
                ints[0] = 0;
                for (var i = 1; i < n; i++) {
                    ints[i] = s.readS32();
                }
                this.ints = ints;
                // Parse Unsigned Integers
                n = s.readU30();
                var uints = new Uint32Array(n);
                uints[0] = 0;
                for (var i = 1; i < n; i++) {
                    uints[i] = s.readS32();
                }
                this.uints = uints;
                // Parse Doubles
                n = s.readU30();
                var doubles = new Float64Array(n);
                doubles[0] = NaN;
                for (var i = 1; i < n; i++) {
                    doubles[i] = s.readDouble();
                }
                this.doubles = doubles;
            };
            ABCFile.prototype._parseStringConstants = function () {
                var n = 0, s = this._stream;
                n = s.readU30();
                this._strings = new Array(n);
                this._strings[0] = null;
                // Record the offset of each string in |stringOffsets|. This array has one extra
                // element so that we can compute the length of the last string.
                var stringOffsets = this._stringOffsets = new Uint32Array(n);
                stringOffsets[0] = -1;
                for (var i = 1; i < n; i++) {
                    stringOffsets[i] = s.position;
                    s.advance(s.readU30());
                }
            };
            ABCFile.prototype._parseNamespaces = function () {
                var s = this._stream;
                var n = s.readU30();
                this._namespaces = new Array(n);
                var namespaceOffsets = this._namespaceOffsets = new Uint32Array(n);
                namespaceOffsets[0] = -1;
                for (var i = 1; i < n; i++) {
                    namespaceOffsets[i] = s.position;
                    s.readU8();
                    // Kind
                    s.readU30();    // String
                }
            };
            ABCFile.prototype._parseNamespaceSets = function () {
                var s = this._stream;
                var n = s.readU30();
                this._namespaceSets = new Array(n);
                var namespaceSetOffsets = this._namespaceSetOffsets = new Uint32Array(n);
                namespaceSetOffsets[0] = -1;
                for (var i = 1; i < n; i++) {
                    namespaceSetOffsets[i] = s.position;
                    var c = s.readU30();
                    // Count
                    for (var j = 0; j < c; j++) {
                        s.readU30();    // Namespace
                    }
                }
            };
            ABCFile.prototype._consumeMultiname = function () {
                var s = this._stream;
                var kind = s.readU8();
                switch (kind) {
                case 7    /* QName */:
                case 13    /* QNameA */:
                    s.readU30();
                    s.readU30();
                    break;
                case 15    /* RTQName */:
                case 16    /* RTQNameA */:
                    s.readU30();
                    break;
                case 17    /* RTQNameL */:
                case 18    /* RTQNameLA */:
                    break;
                case 9    /* Multiname */:
                case 14    /* MultinameA */:
                    s.readU30();
                    s.readU30();
                    break;
                case 27    /* MultinameL */:
                case 28    /* MultinameLA */:
                    s.readU30();
                    break;
                case 29    /* TypeName */:
                    s.readU32();
                    var typeParameterCount = s.readU32();
                    release || assert(typeParameterCount === 1);
                    // This is probably the number of type
                    // parameters.
                    s.readU32();
                    break;
                default:
                    Shumway.Debug.unexpected(kind);
                    break;
                }
            };
            ABCFile.prototype._parseMultinames = function () {
                var s = this._stream;
                var n = s.readU30();
                this._multinames = new Array(n);
                var multinameOffsets = this._multinameOffsets = new Uint32Array(n);
                multinameOffsets[0] = -1;
                for (var i = 1; i < n; i++) {
                    multinameOffsets[i] = s.position;
                    this._consumeMultiname();
                }
            };
            ABCFile.prototype._parseMultiname = function (i) {
                var stream = this._stream;
                var namespaceIsRuntime = false;
                var namespaceIndex;
                var useNamespaceSet = true;
                var nameIndex = 0;
                var kind = stream.readU8();
                switch (kind) {
                case 7    /* QName */:
                case 13    /* QNameA */:
                    namespaceIndex = stream.readU30();
                    useNamespaceSet = false;
                    nameIndex = stream.readU30();
                    break;
                case 15    /* RTQName */:
                case 16    /* RTQNameA */:
                    namespaceIsRuntime = true;
                    nameIndex = stream.readU30();
                    break;
                case 17    /* RTQNameL */:
                case 18    /* RTQNameLA */:
                    namespaceIsRuntime = true;
                    break;
                case 9    /* Multiname */:
                case 14    /* MultinameA */:
                    nameIndex = stream.readU30();
                    namespaceIndex = stream.readU30();
                    break;
                case 27    /* MultinameL */:
                case 28    /* MultinameLA */:
                    namespaceIndex = stream.readU30();
                    if (!release && namespaceIndex === 0) {
                        // TODO: figure out what to do in this case. What would Tamarin do?
                        Shumway.Debug.warning('Invalid multiname: namespace-set index is 0');
                    }
                    break;
                /**
                     * This is undocumented, looking at Tamarin source for this one.
                     */
                case 29    /* TypeName */:
                    var mn = stream.readU32();
                    var typeParameterCount = stream.readU32();
                    if (!release && typeParameterCount !== 1) {
                        // TODO: figure out what to do in this case. What would Tamarin do?
                        Shumway.Debug.warning('Invalid multiname: bad type parameter count ' + typeParameterCount);
                    }
                    var typeParameter = this.getMultiname(stream.readU32());
                    var factory = this.getMultiname(mn);
                    return new Multiname(this, i, kind, factory.namespaces, factory.name, typeParameter);
                default:
                    Shumway.Debug.unexpected();
                    break;
                }
                // A name index of 0 means that it's a runtime name.
                var name = nameIndex === 0 ? null : this.getString(nameIndex);
                var namespaces;
                if (namespaceIsRuntime) {
                    namespaces = null;
                } else {
                    namespaces = useNamespaceSet ? this.getNamespaceSet(namespaceIndex) : [this.getNamespace(namespaceIndex)];
                }
                return new Multiname(this, i, kind, namespaces, name);
            };
            ABCFile.prototype._checkMagic = function () {
                var magic = this._stream.readWord();
                var flashPlayerBrannan = 46 << 16 | 15;
                if (magic < flashPlayerBrannan) {
                    this.env.app.sec.throwError('VerifierError', AVMX.Errors.InvalidMagicError, magic >> 16, magic & 65535);
                }
            };
            /**
             * String duplicates exist in practice but are extremely rare.
             */
            ABCFile.prototype._checkForDuplicateStrings = function () {
                var a = [];
                for (var i = 0; i < this._strings.length; i++) {
                    a.push(this.getString(i));
                }
                a.sort();
                for (var i = 0; i < a.length - 1; i++) {
                    if (a[i] === a[i + 1]) {
                        return true;
                    }
                }
                return false;
            };
            /**
             * Returns the string at the specified index in the string table.
             */
            ABCFile.prototype.getString = function (i) {
                release || assert(i >= 0 && i < this._stringOffsets.length);
                var str = this._strings[i];
                if (str === undefined) {
                    var s = this._stream;
                    s.seek(this._stringOffsets[i]);
                    var l = s.readU30();
                    str = this._strings[i] = s.readUTFString(l);
                }
                return str;
            };
            /**
             * Returns the multiname at the specified index in the multiname table.
             */
            ABCFile.prototype.getMultiname = function (i) {
                if (i < 0 || i >= this._multinameOffsets.length) {
                    this.applicationDomain.sec.throwError('VerifierError', AVMX.Errors.CpoolIndexRangeError, i, this._multinameOffsets.length);
                }
                if (i === 0) {
                    return null;
                }
                var mn = this._multinames[i];
                if (mn === undefined) {
                    var s = this._stream;
                    s.seek(this._multinameOffsets[i]);
                    mn = this._multinames[i] = this._parseMultiname(i);
                }
                return mn;
            };
            /**
             * Returns the namespace at the specified index in the namespace table.
             */
            ABCFile.prototype.getNamespace = function (i) {
                if (i < 0 || i >= this._namespaceOffsets.length) {
                    this.applicationDomain.sec.throwError('VerifierError', AVMX.Errors.CpoolIndexRangeError, i, this._namespaceOffsets.length);
                }
                if (i === 0) {
                    return Namespace.PUBLIC;
                }
                var ns = this._namespaces[i];
                if (ns !== undefined) {
                    return ns;
                }
                var s = this._stream;
                s.seek(this._namespaceOffsets[i]);
                var kind = s.readU8();
                var uriIndex = s.readU30();
                var uri = uriIndex ? this.getString(uriIndex) : undefined;
                var type;
                switch (kind) {
                case 8    /* Namespace */:
                case 22    /* PackageNamespace */:
                    type = 0    /* Public */;
                    break;
                case 23    /* PackageInternalNs */:
                    type = 2    /* PackageInternal */;
                    break;
                case 24    /* ProtectedNamespace */:
                    type = 1    /* Protected */;
                    break;
                case 25    /* ExplicitNamespace */:
                    type = 4    /* Explicit */;
                    break;
                case 26    /* StaticProtectedNs */:
                    type = 5    /* StaticProtected */;
                    break;
                case 5    /* PrivateNs */:
                    type = 3    /* Private */;
                    break;
                default:
                    this.applicationDomain.sec.throwError('VerifierError', AVMX.Errors.CpoolEntryWrongTypeError, i);
                }
                if (uri && type !== 3    /* Private */) {
                } else if (uri === undefined) {
                    // Only private namespaces gets the empty string instead of undefined. A comment
                    // in Tamarin source code indicates this might not be intentional, but oh well.
                    uri = '';
                }
                ns = this._namespaces[i] = internNamespace(type, uri);
                return ns;
            };
            /**
             * Returns the namespace set at the specified index in the namespace set table.
             */
            ABCFile.prototype.getNamespaceSet = function (i) {
                if (i < 0 || i >= this._namespaceSets.length) {
                    this.applicationDomain.sec.throwError('VerifierError', AVMX.Errors.CpoolIndexRangeError, i, this._namespaceSets.length);
                }
                if (i === 0) {
                    return null;
                }
                var nss = this._namespaceSets[i];
                if (nss === undefined) {
                    var s = this._stream;
                    var o = this._namespaceSetOffsets[i];
                    s.seek(o);
                    var c = s.readU30();
                    // Count
                    nss = this._namespaceSets[i] = new Array(c);
                    o = s.position;
                    for (var j = 0; j < c; j++) {
                        s.seek(o);
                        var x = s.readU30();
                        o = s.position;
                        // The call to |getNamespace| can change our current position.
                        nss[j] = this.getNamespace(x);
                    }
                }
                return nss;
            };
            ABCFile.prototype._parseMethodInfos = function () {
                var s = this._stream;
                var n = s.readU30();
                this._methods = new Array(n);
                this._methodInfoOffsets = new Uint32Array(n);
                for (var i = 0; i < n; ++i) {
                    this._methodInfoOffsets[i] = s.position;
                    this._consumeMethodInfo();
                }
            };
            ABCFile.prototype._consumeMethodInfo = function () {
                var s = this._stream;
                var parameterCount = s.readU30();
                s.readU30();
                // Return Type
                var parameterOffset = s.position;
                for (var i = 0; i < parameterCount; i++) {
                    s.readU30();
                }
                var nm = s.readU30();
                var flags = s.readU8();
                if (flags & 8    /* HasOptional */) {
                    var optionalCount = s.readU30();
                    release || assert(parameterCount >= optionalCount);
                    for (var i = parameterCount - optionalCount; i < parameterCount; i++) {
                        s.readU30();
                        // Value Index
                        s.readU8();    // Value Kind
                    }
                }
                if (flags & 128    /* HasParamNames */) {
                    for (var i = 0; i < parameterCount; i++) {
                        s.readU30();
                    }
                }
            };
            ABCFile.prototype._parseMethodInfo = function (j) {
                var s = this._stream;
                var parameterCount = s.readU30();
                var returnType = s.readU30();
                var parameterOffset = s.position;
                var parameters = new Array(parameterCount);
                for (var i = 0; i < parameterCount; i++) {
                    parameters[i] = new ParameterInfo(this, s.readU30(), 0, -1, -1);
                }
                var name = s.readU30();
                var flags = s.readU8();
                var optionalCount = 0;
                if (flags & 8    /* HasOptional */) {
                    optionalCount = s.readU30();
                    release || assert(parameterCount >= optionalCount);
                    for (var i = parameterCount - optionalCount; i < parameterCount; i++) {
                        parameters[i].optionalValueIndex = s.readU30();
                        parameters[i].optionalValueKind = s.readU8();
                    }
                }
                if (flags & 128    /* HasParamNames */) {
                    for (var i = 0; i < parameterCount; i++) {
                        // NOTE: We can't get the parameter name as described in the spec because some SWFs have
                        // invalid parameter names. Tamarin ignores parameter names and so do we.
                        parameters[i].name = s.readU30();
                    }
                }
                return new MethodInfo(this, j, name, returnType, parameters, optionalCount, flags);
            };
            /**
             * Returns the method info at the specified index in the method info table.
             */
            ABCFile.prototype.getMethodInfo = function (i) {
                release || assert(i >= 0 && i < this._methodInfoOffsets.length);
                var mi = this._methods[i];
                if (mi === undefined) {
                    var s = this._stream;
                    s.seek(this._methodInfoOffsets[i]);
                    mi = this._methods[i] = this._parseMethodInfo(i);
                }
                return mi;
            };
            ABCFile.prototype.getMethodBodyInfo = function (i) {
                return this._methodBodies[i];
            };
            ABCFile.prototype._parseMetaData = function () {
                var s = this._stream;
                var n = s.readU30();
                this._metadata = new Array(n);
                var metadataInfoOffsets = this._metadataInfoOffsets = new Uint32Array(n);
                for (var i = 0; i < n; i++) {
                    metadataInfoOffsets[i] = s.position;
                    s.readU30();
                    // Name
                    var itemCount = s.readU30();
                    // Item Count
                    for (var j = 0; j < itemCount; j++) {
                        s.readU30();
                        s.readU30();
                    }
                }
            };
            ABCFile.prototype.getMetadataInfo = function (i) {
                release || assert(i >= 0 && i < this._metadata.length);
                var mi = this._metadata[i];
                if (mi === undefined) {
                    var s = this._stream;
                    s.seek(this._metadataInfoOffsets[i]);
                    var name = s.readU30();
                    // Name
                    var itemCount = s.readU30();
                    // Item Count
                    var keys = new Uint32Array(itemCount);
                    for (var j = 0; j < itemCount; j++) {
                        keys[j] = s.readU30();
                    }
                    var values = new Uint32Array(itemCount);
                    for (var j = 0; j < itemCount; j++) {
                        values[j] = s.readU30();
                    }
                    mi = this._metadata[i] = new MetadataInfo(this, name, keys, values);
                }
                return mi;
            };
            ABCFile.prototype._parseInstanceAndClassInfos = function () {
                var s = this._stream;
                var n = s.readU30();
                var instances = this.instances = new Array(n);
                for (var i = 0; i < n; i++) {
                    instances[i] = this._parseInstanceInfo();
                }
                this._parseClassInfos(n);
                var o = s.position;
                for (var i = 0; i < n; i++) {
                    instances[i].classInfo = this.classes[i];
                }
                s.seek(o);
            };
            ABCFile.prototype._parseInstanceInfo = function () {
                var s = this._stream;
                var name = s.readU30();
                var superName = s.readU30();
                var flags = s.readU8();
                var protectedNsIndex = 0;
                if (flags & 8    /* ClassProtectedNs */) {
                    protectedNsIndex = s.readU30();
                }
                var interfaceCount = s.readU30();
                var interfaces = [];
                for (var i = 0; i < interfaceCount; i++) {
                    interfaces[i] = s.readU30();
                }
                var initializer = s.readU30();
                var traits = this._parseTraits();
                var instanceInfo = new InstanceInfo(this, name, superName, flags, protectedNsIndex, interfaces, initializer, traits);
                traits.attachHolder(instanceInfo);
                return instanceInfo;
            };
            ABCFile.prototype._parseTraits = function () {
                var s = this._stream;
                var n = s.readU30();
                var traits = [];
                for (var i = 0; i < n; i++) {
                    traits.push(this._parseTrait());
                }
                return new Traits(traits);
            };
            ABCFile.prototype._parseTrait = function () {
                var s = this._stream;
                var name = s.readU30();
                var tag = s.readU8();
                var kind = tag & 15;
                var attributes = tag >> 4 & 15;
                var trait;
                switch (kind) {
                case 0    /* Slot */:
                case 6    /* Const */:
                    var slot = s.readU30();
                    var type = s.readU30();
                    var valueIndex = s.readU30();
                    var valueKind = -1;
                    if (valueIndex !== 0) {
                        valueKind = s.readU8();
                    }
                    trait = new SlotTraitInfo(this, kind, name, slot, type, valueKind, valueIndex);
                    break;
                case 1    /* Method */:
                case 2    /* Getter */:
                case 3    /* Setter */:
                    var dispID = s.readU30();
                    // Tamarin optimization.
                    var methodInfoIndex = s.readU30();
                    var o = s.position;
                    var methodInfo = this.getMethodInfo(methodInfoIndex);
                    trait = methodInfo.trait = new MethodTraitInfo(this, kind, name, methodInfo);
                    s.seek(o);
                    break;
                case 4    /* Class */:
                    var slot = s.readU30();
                    var classInfo = this.classes[s.readU30()];
                    trait = classInfo.trait = new ClassTraitInfo(this, kind, name, slot, classInfo);
                    break;
                default:
                    this.applicationDomain.sec.throwError('VerifierError', AVMX.Errors.UnsupportedTraitsKindError, kind);
                }
                if (attributes & 4    /* Metadata */) {
                    var n = s.readU30();
                    var metadata = new Uint32Array(n);
                    for (var i = 0; i < n; i++) {
                        metadata[i] = s.readU30();
                    }
                    trait.metadata = metadata;
                }
                return trait;
            };
            ABCFile.prototype._parseClassInfos = function (n) {
                var s = this._stream;
                var classes = this.classes = new Array(n);
                for (var i = 0; i < n; i++) {
                    classes[i] = this._parseClassInfo(i);
                }
            };
            ABCFile.prototype._parseClassInfo = function (i) {
                var s = this._stream;
                var initializer = s.readU30();
                var traits = this._parseTraits();
                var classInfo = new ClassInfo(this, this.instances[i], initializer, traits);
                traits.attachHolder(classInfo);
                return classInfo;
            };
            ABCFile.prototype._parseScriptInfos = function () {
                var s = this._stream;
                var n = s.readU30();
                var scripts = this.scripts = new Array(n);
                for (var i = 0; i < n; i++) {
                    scripts[i] = this._parseScriptInfo();
                }
            };
            ABCFile.prototype._parseScriptInfo = function () {
                var s = this._stream;
                var initializer = s.readU30();
                var traits = this._parseTraits();
                var scriptInfo = new ScriptInfo(this, initializer, traits);
                traits.attachHolder(scriptInfo);
                return scriptInfo;
            };
            ABCFile.prototype._parseMethodBodyInfos = function () {
                var s = this._stream;
                var methodBodies = this._methodBodies = new Array(this._methods.length);
                var n = s.readU30();
                var o = s.position;
                for (var i = 0; i < n; i++) {
                    var methodInfo = s.readU30();
                    var maxStack = s.readU30();
                    var localCount = s.readU30();
                    var initScopeDepth = s.readU30();
                    var maxScopeDepth = s.readU30();
                    var code = s.viewU8s(s.readU30());
                    var e = s.readU30();
                    var exceptions = new Array(e);
                    for (var j = 0; j < e; ++j) {
                        exceptions[j] = this._parseException();
                    }
                    var traits = this._parseTraits();
                    methodBodies[methodInfo] = new MethodBodyInfo(maxStack, localCount, initScopeDepth, maxScopeDepth, code, exceptions, traits);
                    traits.attachHolder(methodBodies[methodInfo]);
                }
            };
            ABCFile.prototype._parseException = function () {
                var s = this._stream;
                var start = s.readU30();
                var end = s.readU30();
                var target = s.readU30();
                var type = s.readU30();
                var varName = s.readU30();
                return new ExceptionInfo(this, start, end, target, type, varName);
            };
            ABCFile.prototype.getConstant = function (kind, i) {
                switch (kind) {
                case 3    /* Int */:
                    return this.ints[i];
                case 4    /* UInt */:
                    return this.uints[i];
                case 6    /* Double */:
                    return this.doubles[i];
                case 1    /* Utf8 */:
                    return this.getString(i);
                case 11    /* True */:
                    return true;
                case 10    /* False */:
                    return false;
                case 12    /* Null */:
                    return null;
                case 0    /* Undefined */:
                    return undefined;
                case 8    /* Namespace */:
                case 23    /* PackageInternalNs */:
                    return this.getNamespace(i);
                case 7    /* QName */:
                case 14    /* MultinameA */:
                case 15    /* RTQName */:
                case 16    /* RTQNameA */:
                case 17    /* RTQNameL */:
                case 18    /* RTQNameLA */:
                case 19    /* NameL */:
                case 20    /* NameLA */:
                    return this.getMultiname(i);
                case 2    /* Float */:
                    Shumway.Debug.warning('TODO: CONSTANT.Float may be deprecated?');
                    break;
                default:
                    release || assert(false, 'Not Implemented Kind ' + kind);
                }
            };
            ABCFile.prototype.stress = function () {
                for (var i = 0; i < this._multinames.length; i++) {
                    this.getMultiname(i);
                }
                for (var i = 0; i < this._namespaceSets.length; i++) {
                    this.getNamespaceSet(i);
                }
                for (var i = 0; i < this._namespaces.length; i++) {
                    this.getNamespace(i);
                }
                for (var i = 0; i < this._strings.length; i++) {
                    this.getString(i);
                }
            };
            ABCFile.prototype.trace = function (writer) {
                writer.writeLn('Multinames: ' + this._multinames.length);
                if (true) {
                    writer.indent();
                    for (var i = 0; i < this._multinames.length; i++) {
                        writer.writeLn(i + ' ' + this.getMultiname(i));
                    }
                    writer.outdent();
                }
                writer.writeLn('Namespace Sets: ' + this._namespaceSets.length);
                if (true) {
                    writer.indent();
                    for (var i = 0; i < this._namespaceSets.length; i++) {
                        writer.writeLn(i + ' ' + this.getNamespaceSet(i));
                    }
                    writer.outdent();
                }
                writer.writeLn('Namespaces: ' + this._namespaces.length);
                if (true) {
                    writer.indent();
                    for (var i = 0; i < this._namespaces.length; i++) {
                        writer.writeLn(i + ' ' + this.getNamespace(i));
                    }
                    writer.outdent();
                }
                writer.writeLn('Strings: ' + this._strings.length);
                if (true) {
                    writer.indent();
                    for (var i = 0; i < this._strings.length; i++) {
                        writer.writeLn(i + ' ' + this.getString(i));
                    }
                    writer.outdent();
                }
                writer.writeLn('MethodInfos: ' + this._methods.length);
                if (true) {
                    writer.indent();
                    for (var i = 0; i < this._methods.length; i++) {
                        writer.writeLn(i + ' ' + this.getMethodInfo(i));
                        if (this._methodBodies[i]) {
                            this._methodBodies[i].trace(writer);
                        }
                    }
                    writer.outdent();
                }
                writer.writeLn('InstanceInfos: ' + this.instances.length);
                if (true) {
                    writer.indent();
                    for (var i = 0; i < this.instances.length; i++) {
                        writer.writeLn(i + ' ' + this.instances[i]);
                        this.instances[i].trace(writer);
                    }
                    writer.outdent();
                }
                writer.writeLn('ClassInfos: ' + this.classes.length);
                if (true) {
                    writer.indent();
                    for (var i = 0; i < this.classes.length; i++) {
                        this.classes[i].trace(writer);
                    }
                    writer.outdent();
                }
                writer.writeLn('ScriptInfos: ' + this.scripts.length);
                if (true) {
                    writer.indent();
                    for (var i = 0; i < this.scripts.length; i++) {
                        this.scripts[i].trace(writer);
                    }
                    writer.outdent();
                }
            };
            return ABCFile;
        }();
        AVMX.ABCFile = ABCFile;
        var ABCCatalog = function () {
            function ABCCatalog(app, abcs, index) {
                this.app = app;
                this.map = Shumway.ObjectUtilities.createMap();
                this.abcs = abcs;
                this.scripts = Shumway.ObjectUtilities.createMap();
                for (var i = 0; i < index.length; i++) {
                    var abc = index[i];
                    this.scripts[abc.name] = abc;
                    release || assert(Array.isArray(abc.defs));
                    for (var j = 0; j < abc.defs.length; j++) {
                        var def = abc.defs[j].split(':');
                        var nameMappings = this.map[def[1]];
                        if (!nameMappings) {
                            nameMappings = this.map[def[1]] = Object.create(null);
                        }
                        nameMappings[def[0]] = abc.name;
                    }
                }
            }
            ABCCatalog.prototype.getABCByScriptName = function (scriptName) {
                var entry = this.scripts[scriptName];
                if (!entry) {
                    return null;
                }
                var env = {
                    url: scriptName,
                    app: this.app
                };
                return new ABCFile(env, this.abcs.subarray(entry.offset, entry.offset + entry.length));
            };
            ABCCatalog.prototype.getABCByMultiname = function (mn) {
                var mappings = this.map[mn.name];
                if (!mappings) {
                    return null;
                }
                var namespaces = mn.namespaces;
                for (var i = 0; i < namespaces.length; i++) {
                    var ns = namespaces[i];
                    var scriptName = mappings[ns.uri];
                    if (scriptName) {
                        return this.getABCByScriptName(scriptName);
                    }
                }
                return null;
            };
            return ABCCatalog;
        }();
        AVMX.ABCCatalog = ABCCatalog;
        var assert = Shumway.Debug.assert;
        var popManyInto = Shumway.ArrayUtilities.popManyInto;
        var getPropertyDescriptor = Shumway.ObjectUtilities.getPropertyDescriptor;
        /**
         * Helps the interpreter allocate fewer Scope objects.
         */
        var ScopeStack = function () {
            function ScopeStack(parent) {
                this.parent = parent;
                this.stack = [];
                this.isWith = [];
            }
            ScopeStack.prototype.push = function (object, isWith) {
                this.stack.push(object);
                this.isWith.push(!!isWith);
            };
            ScopeStack.prototype.get = function (index) {
                return this.stack[index];
            };
            ScopeStack.prototype.clear = function () {
                this.stack.length = 0;
                this.isWith.length = 0;
            };
            ScopeStack.prototype.pop = function () {
                this.isWith.pop();
                this.stack.pop();
                if (this.scopes && this.scopes.length > this.stack.length) {
                    this.scopes.length--;
                    release || assert(this.scopes.length === this.stack.length);
                }
            };
            ScopeStack.prototype.topScope = function () {
                if (!this.scopes) {
                    if (this.stack.length === 0) {
                        return this.parent;
                    }
                    this.scopes = [];
                }
                var parent = this.parent;
                for (var i = 0; i < this.stack.length; i++) {
                    var object = this.stack[i], isWith = this.isWith[i], scope = this.scopes[i];
                    if (!scope || scope.parent !== parent || scope.object !== object || scope.isWith !== isWith) {
                        scope = this.scopes[i] = new AVMX.Scope(parent, object, isWith);
                    }
                    parent = scope;
                }
                return parent;
            };
            return ScopeStack;
        }();
        AVMX.ScopeStack = ScopeStack;
        function popNameInto(stack, mn, rn) {
            rn.id = mn.id;
            rn.kind = mn.kind;
            if (mn.isRuntimeName()) {
                var name = stack.pop();
                // Unwrap content script-created AXQName instances.
                if (name && name.axClass && name.axClass === name.sec.AXQName) {
                    name = name.name;
                    release || assert(name instanceof AVMX.Multiname);
                    rn.kind = mn.isAttribute() ? 18    /* RTQNameLA */ : 17    /* RTQNameL */;
                    rn.id = name.id;
                    rn.name = name.name;
                    rn.namespaces = name.namespaces;
                    return;
                }
                rn.name = name;
                rn.id = -1;
            } else {
                rn.name = mn.name;
            }
            if (mn.isRuntimeNamespace()) {
                var ns = stack.pop();
                // Unwrap content script-created AXNamespace instances.
                if (ns._ns) {
                    release || assert(ns.sec && ns.axClass === ns.sec.AXNamespace);
                    ns = ns._ns;
                }
                rn.namespaces = [ns];
                rn.id = -1;
            } else {
                rn.namespaces = mn.namespaces;
            }
            AVMX.interpreterWriter && AVMX.interpreterWriter.greenLn('Name: ' + rn.name);
        }
        function interpret(self, methodInfo, savedScope, args, callee) {
            AVMX.executionWriter && AVMX.executionWriter.enter('> ' + methodInfo);
            try {
                var result = _interpret(self, methodInfo, savedScope, args, callee);
                AVMX.executionWriter && AVMX.executionWriter.leave('< ' + methodInfo.trait);
                return result;
            } catch (e) {
                AVMX.executionWriter && AVMX.executionWriter.leave('< ' + methodInfo.trait + ', Exception: ' + e);
                throw e;
            }
        }
        AVMX.interpret = interpret;
        var InterpreterFrame = function () {
            function InterpreterFrame(receiver, methodInfo, parentScope, callArgs, callee) {
                this.pc = 0;
                this.stack = [];
                this.hasNext2Infos = null;
                var body = this.body = methodInfo.getBody();
                this.code = body.code;
                this.scopes = new ScopeStack(parentScope);
                var locals = this.locals = [receiver];
                var app = this.app = methodInfo.abc.applicationDomain;
                var sec = this.sec = app.sec;
                var argCount = callArgs.length;
                var arg;
                for (var i = 0, j = methodInfo.parameters.length; i < j; i++) {
                    var p = methodInfo.parameters[i];
                    if (i < argCount) {
                        arg = callArgs[i];
                    } else if (p.hasOptionalValue()) {
                        arg = p.getOptionalValue();
                    } else {
                        arg = undefined;
                    }
                    var rn = p.getType();
                    if (rn && !rn.isAnyName()) {
                        var type = parentScope.getScopeProperty(rn, true, false);
                        if (!type) {
                            // During class initialization the class' constructor isn't in scope and can't be
                            // resolved as a scope property: trying to do so yields `null`.
                            // However, using it as a constructor parameter type *does* work, and correctly
                            // applies coercion to the constructor. It's unclear why and how this works in
                            // Tamarin, but since it does work, we check for this scenario here and work around it.
                            if ('axClass' in receiver && receiver.axClass.name.matches(rn)) {
                                type = receiver.axClass;
                            } else {
                                continue;
                            }
                        }
                        if (!release && AVMX.interpreterWriter) {
                            AVMX.interpreterWriter.writeLn('Coercing argument to type ' + (type.axClass ? type.axClass.name.toFQNString(false) : type));
                        }
                        arg = type.axCoerce(arg);
                    }
                    locals.push(arg);
                }
                if (methodInfo.needsRest()) {
                    locals.push(sec.createArrayUnsafe(AVMX.sliceArguments(callArgs, methodInfo.parameters.length)));
                } else if (methodInfo.needsArguments()) {
                    var argsArray = AVMX.sliceArguments(callArgs, 0);
                    var argumentsArray = Object.create(sec.argumentsPrototype);
                    argumentsArray.value = argsArray;
                    argumentsArray.callee = callee;
                    argumentsArray.receiver = receiver;
                    argumentsArray.methodInfo = methodInfo;
                    locals.push(argumentsArray);
                }
            }
            InterpreterFrame.prototype.bc = function () {
                return this.code[this.pc++];
            };
            InterpreterFrame.prototype.peekStack = function () {
                return this.stack[this.stack.length - 1];
            };
            InterpreterFrame.prototype.u30 = function () {
                var code = this.code;
                var pc = this.pc;
                var result = code[pc++];
                if (result & 128) {
                    result = result & 127 | code[pc++] << 7;
                    if (result & 16384) {
                        result = result & 16383 | code[pc++] << 14;
                        if (result & 2097152) {
                            result = result & 2097151 | code[pc++] << 21;
                            if (result & 268435456) {
                                result = result & 268435455 | code[pc++] << 28;
                                result = result & 4294967295;
                            }
                        }
                    }
                }
                this.pc = pc;
                return result >>> 0;
            };
            InterpreterFrame.prototype.s24 = function () {
                var code = this.code;
                var pc = this.pc;
                var u = code[pc] | code[pc + 1] << 8 | code[pc + 2] << 16;
                this.pc = pc + 3;
                return u << 8 >> 8;
            };
            InterpreterFrame.prototype.getHasNext2Info = function () {
                var pc = this.pc;
                var hasNext2Infos = this.hasNext2Infos;
                if (!hasNext2Infos) {
                    hasNext2Infos = this.hasNext2Infos = [];
                }
                if (!hasNext2Infos[pc]) {
                    hasNext2Infos[pc] = new AVMX.HasNext2Info(null, 0);
                }
                return hasNext2Infos[pc];
            };
            return InterpreterFrame;
        }();
        function _interpret(self, methodInfo, savedScope, callArgs, callee) {
            var frame = new InterpreterFrame(self, methodInfo, savedScope, callArgs, callee);
            var stack = frame.stack;
            var locals = frame.locals;
            var scopes = frame.scopes;
            var sec = frame.sec;
            var abc = methodInfo.abc;
            var rn = new AVMX.Multiname(abc, 0, null, null, null);
            var value, object, receiver, type, a, b, offset, index, result;
            var args = [];
            var argCount = 0;
            var scopeStacksHeight = AVMX.scopeStacks.length;
            AVMX.scopeStacks.push(frame.scopes);
            interpretLabel:
                while (true) {
                    if (!release && AVMX.interpreterWriter) {
                        AVMX.interpreterWriter.greenLn('' + frame.pc + ': ' + AVMX.getBytecodeName(frame.code[frame.pc]) + ' [' + frame.stack.map(function (x) {
                            return stringifyStackEntry(x);
                        }).join(', ') + ']');
                    }
                    try {
                        var bc = frame.bc();
                        switch (bc) {
                        case 9    /* LABEL */:
                            continue;
                        case 3    /* THROW */:
                            throw stack.pop();
                        case 8    /* KILL */:
                            locals[frame.u30()] = undefined;
                            break;
                        case 12    /* IFNLT */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (!(a < b)) {
                                frame.pc += offset;
                            }
                            continue;
                        case 24    /* IFGE */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (a >= b) {
                                frame.pc += offset;
                            }
                            continue;
                        case 13    /* IFNLE */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (!(a <= b)) {
                                frame.pc += offset;
                            }
                            continue;
                        case 23    /* IFGT */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (a > b) {
                                frame.pc += offset;
                            }
                            continue;
                        case 14    /* IFNGT */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (!(a > b)) {
                                frame.pc += offset;
                            }
                            continue;
                        case 22    /* IFLE */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (a <= b) {
                                frame.pc += offset;
                            }
                            continue;
                        case 15    /* IFNGE */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (!(a >= b)) {
                                frame.pc += offset;
                            }
                            continue;
                        case 21    /* IFLT */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (a < b) {
                                frame.pc += offset;
                            }
                            continue;
                        case 16    /* JUMP */:
                            frame.pc = frame.s24() + frame.pc;
                            continue;
                        case 17    /* IFTRUE */:
                            offset = frame.s24();
                            if (!!stack.pop()) {
                                frame.pc += offset;
                            }
                            continue;
                        case 18    /* IFFALSE */:
                            offset = frame.s24();
                            if (!stack.pop()) {
                                frame.pc += offset;
                            }
                            continue;
                        case 19    /* IFEQ */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (AVMX.axEquals(a, b, sec)) {
                                frame.pc += offset;
                            }
                            continue;
                        case 20    /* IFNE */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (!AVMX.axEquals(a, b, sec)) {
                                frame.pc += offset;
                            }
                            continue;
                        case 25    /* IFSTRICTEQ */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (a === b) {
                                frame.pc += offset;
                            }
                            continue;
                        case 26    /* IFSTRICTNE */:
                            b = stack.pop();
                            a = stack.pop();
                            offset = frame.s24();
                            if (a !== b) {
                                frame.pc += offset;
                            }
                            continue;
                        case 27    /* LOOKUPSWITCH */:
                            var basePC = frame.pc - 1;
                            offset = frame.s24();
                            var caseCount = frame.u30();
                            index = stack.pop();
                            if (index <= caseCount) {
                                frame.pc += 3 * index;
                                // Jump to case offset.
                                offset = frame.s24();
                            }
                            frame.pc = basePC + offset;
                            continue;
                        case 29    /* POPSCOPE */:
                            scopes.pop();
                            break;
                        case 30    /* NEXTNAME */:
                            index = stack.pop();
                            receiver = sec.box(frame.peekStack());
                            stack[stack.length - 1] = receiver.axNextName(index);
                            break;
                        case 35    /* NEXTVALUE */:
                            index = stack.pop();
                            receiver = sec.box(frame.peekStack());
                            stack[stack.length - 1] = receiver.axNextValue(index);
                            break;
                        case 50    /* HASNEXT2 */:
                            var hasNext2Info = frame.getHasNext2Info();
                            var objectIndex = frame.u30();
                            var indexIndex = frame.u30();
                            hasNext2Info.next(sec.box(locals[objectIndex]), locals[indexIndex]);
                            locals[objectIndex] = hasNext2Info.object;
                            locals[indexIndex] = hasNext2Info.index;
                            stack.push(!!hasNext2Info.index);
                            break;
                        case 32    /* PUSHNULL */:
                            stack.push(null);
                            break;
                        case 33    /* PUSHUNDEFINED */:
                            stack.push(undefined);
                            break;
                        case 36    /* PUSHBYTE */:
                            stack.push(frame.code[frame.pc++] << 24 >> 24);
                            break;
                        case 37    /* PUSHSHORT */:
                            stack.push(frame.u30() << 16 >> 16);
                            break;
                        case 44    /* PUSHSTRING */:
                            stack.push(abc.getString(frame.u30()));
                            break;
                        case 45    /* PUSHINT */:
                            stack.push(abc.ints[frame.u30()]);
                            break;
                        case 46    /* PUSHUINT */:
                            stack.push(abc.uints[frame.u30()]);
                            break;
                        case 47    /* PUSHDOUBLE */:
                            stack.push(abc.doubles[frame.u30()]);
                            break;
                        case 38    /* PUSHTRUE */:
                            stack.push(true);
                            break;
                        case 39    /* PUSHFALSE */:
                            stack.push(false);
                            break;
                        case 40    /* PUSHNAN */:
                            stack.push(NaN);
                            break;
                        case 41    /* POP */:
                            stack.pop();
                            break;
                        case 42    /* DUP */:
                            stack.push(stack[stack.length - 1]);
                            break;
                        case 43    /* SWAP */:
                            value = stack[stack.length - 1];
                            stack[stack.length - 1] = stack[stack.length - 2];
                            stack[stack.length - 2] = value;
                            break;
                        case 48    /* PUSHSCOPE */:
                            scopes.push(sec.box(stack.pop()), false);
                            break;
                        case 28    /* PUSHWITH */:
                            scopes.push(sec.box(stack.pop()), true);
                            break;
                        case 49    /* PUSHNAMESPACE */:
                            stack.push(sec.AXNamespace.FromNamespace(abc.getNamespace(frame.u30())));
                            break;
                        case 64    /* NEWFUNCTION */:
                            stack.push(sec.createFunction(abc.getMethodInfo(frame.u30()), scopes.topScope(), true));
                            break;
                        case 65    /* CALL */:
                            popManyInto(stack, frame.u30(), args);
                            object = stack.pop();
                            value = stack[stack.length - 1];
                            AVMX.validateCall(sec, value, args.length);
                            stack[stack.length - 1] = value.axApply(object, args);
                            break;
                        case 66    /* CONSTRUCT */:
                            popManyInto(stack, frame.u30(), args);
                            receiver = sec.box(frame.peekStack());
                            AVMX.validateConstruct(sec, receiver, args.length);
                            stack[stack.length - 1] = receiver.axConstruct(args);
                            break;
                        case 71    /* RETURNVOID */:
                            release || assert(AVMX.scopeStacks.length === scopeStacksHeight + 1);
                            AVMX.scopeStacks.length--;
                            return;
                        case 72    /* RETURNVALUE */:
                            value = stack.pop();
                            // TODO: ensure proper unwinding of the scope stack.
                            if (methodInfo.returnTypeNameIndex) {
                                receiver = methodInfo.getType();
                                if (receiver) {
                                    value = receiver.axCoerce(value);
                                }
                            }
                            release || assert(AVMX.scopeStacks.length === scopeStacksHeight + 1);
                            AVMX.scopeStacks.length--;
                            return value;
                        case 73    /* CONSTRUCTSUPER */:
                            popManyInto(stack, frame.u30(), args);
                            savedScope.object.superClass.tPrototype.axInitializer.apply(stack.pop(), args);
                            break;
                        case 74    /* CONSTRUCTPROP */:
                            index = frame.u30();
                            popManyInto(stack, frame.u30(), args);
                            popNameInto(stack, abc.getMultiname(index), rn);
                            receiver = sec.box(frame.peekStack());
                            stack[stack.length - 1] = receiver.axConstructProperty(rn, args);
                            break;
                        case 76    /* CALLPROPLEX */:
                        case 70    /* CALLPROPERTY */:
                        case 79    /* CALLPROPVOID */:
                            index = frame.u30();
                            argCount = frame.u30();
                            popManyInto(stack, argCount, args);
                            popNameInto(stack, abc.getMultiname(index), rn);
                            receiver = sec.box(stack[stack.length - 1]);
                            result = receiver.axCallProperty(rn, args, bc === 76    /* CALLPROPLEX */);
                            if (bc === 79    /* CALLPROPVOID */) {
                                stack.length--;
                            } else {
                                stack[stack.length - 1] = result;
                            }
                            break;
                        case 69    /* CALLSUPER */:
                        case 78    /* CALLSUPERVOID */:
                            index = frame.u30();
                            argCount = frame.u30();
                            popManyInto(stack, argCount, args);
                            popNameInto(stack, abc.getMultiname(index), rn);
                            receiver = sec.box(stack[stack.length - 1]);
                            result = receiver.axCallSuper(rn, savedScope, args);
                            if (bc === 78    /* CALLSUPERVOID */) {
                                stack.length--;
                            } else {
                                stack[stack.length - 1] = result;
                            }
                            break;
                        //case Bytecode.CALLSTATIC:
                        //  index = frame.u30();
                        //  argCount = frame.u30();
                        //  popManyInto(stack, argCount, args);
                        //  value = abc.getMetadataInfo(index);
                        //  var receiver = box(stack[stack.length - 1]);
                        //  stack.push(value.axApply(receiver, args));
                        //  break;
                        case 83    /* APPLYTYPE */:
                            popManyInto(stack, frame.u30(), args);
                            stack[stack.length - 1] = sec.applyType(stack[stack.length - 1], args);
                            break;
                        case 85    /* NEWOBJECT */:
                            object = Object.create(sec.AXObject.tPrototype);
                            argCount = frame.u30();
                            // For LIFO-order iteration to be correct, we have to add items highest on the stack
                            // first.
                            for (var i = stack.length - argCount * 2; i < stack.length; i += 2) {
                                value = stack[i + 1];
                                object.axSetPublicProperty(stack[i], value);
                            }
                            stack.length -= argCount * 2;
                            stack.push(object);
                            break;
                        case 86    /* NEWARRAY */:
                            object = [];
                            argCount = frame.u30();
                            for (var i = stack.length - argCount; i < stack.length; i++) {
                                object.push(stack[i]);
                            }
                            stack.length -= argCount;
                            stack.push(sec.AXArray.axBox(object));
                            break;
                        case 87    /* NEWACTIVATION */:
                            stack.push(sec.createActivation(methodInfo, scopes.topScope()));
                            break;
                        case 88    /* NEWCLASS */:
                            // Storing super class in `value` to make exception handling easier.
                            value = stack[stack.length - 1];
                            stack[stack.length - 1] = sec.createClass(abc.classes[frame.u30()], value, scopes.topScope());
                            break;
                        case 89    /* GETDESCENDANTS */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            if (rn.name === undefined) {
                                rn.name = '*';
                            }
                            result = AVMX.axGetDescendants(stack[stack.length - 1], rn, sec);
                            release || AVMX.checkValue(result);
                            stack[stack.length - 1] = result;
                            break;
                        case 90    /* NEWCATCH */:
                            stack.push(sec.createCatch(frame.body.catchBlocks[frame.u30()], scopes.topScope()));
                            break;
                        case 94    /* FINDPROPERTY */:
                        case 93    /* FINDPROPSTRICT */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            stack.push(scopes.topScope().findScopeProperty(rn, bc === 93    /* FINDPROPSTRICT */, false));
                            break;
                        case 96    /* GETLEX */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            object = scopes.topScope().findScopeProperty(rn, true, false);
                            result = object.axGetProperty(rn);
                            release || AVMX.checkValue(result);
                            stack.push(result);
                            break;
                        case 104    /* INITPROPERTY */:
                        case 97    /* SETPROPERTY */:
                            value = stack.pop();
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            receiver = sec.box(stack.pop());
                            receiver.axSetProperty(rn, value, 104    /* INITPROPERTY */, methodInfo);
                            break;
                        case 102    /* GETPROPERTY */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            receiver = sec.box(frame.peekStack());
                            result = receiver.axGetProperty(rn);
                            release || AVMX.checkValue(result);
                            stack[stack.length - 1] = result;
                            break;
                        case 106    /* DELETEPROPERTY */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            receiver = sec.box(frame.peekStack());
                            stack[stack.length - 1] = receiver.axDeleteProperty(rn);
                            break;
                        case 4    /* GETSUPER */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            receiver = sec.box(frame.peekStack());
                            result = receiver.axGetSuper(rn, savedScope);
                            release || AVMX.checkValue(result);
                            stack[stack.length - 1] = result;
                            break;
                        case 5    /* SETSUPER */:
                            value = stack.pop();
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            receiver = sec.box(stack.pop());
                            receiver.axSetSuper(rn, savedScope, value);
                            break;
                        case 98    /* GETLOCAL */:
                            stack.push(locals[frame.u30()]);
                            break;
                        case 99    /* SETLOCAL */:
                            locals[frame.u30()] = stack.pop();
                            break;
                        case 100    /* GETGLOBALSCOPE */:
                            stack.push(savedScope.global.object);
                            break;
                        case 101    /* GETSCOPEOBJECT */:
                            stack.push(scopes.get(frame.code[frame.pc++]));
                            break;
                        case 108    /* GETSLOT */:
                            receiver = sec.box(frame.peekStack());
                            result = receiver.axGetSlot(frame.u30());
                            release || AVMX.checkValue(result);
                            stack[stack.length - 1] = result;
                            break;
                        case 109    /* SETSLOT */:
                            value = stack.pop();
                            receiver = sec.box(stack.pop());
                            receiver.axSetSlot(frame.u30(), value);
                            break;
                        case 110    /* GETGLOBALSLOT */:
                            result = savedScope.global.object.axGetSlot(frame.u30());
                            release || AVMX.checkValue(result);
                            stack[stack.length - 1] = result;
                            break;
                        case 111    /* SETGLOBALSLOT */:
                            value = stack.pop();
                            savedScope.global.object.axSetSlot(frame.u30(), value);
                            break;
                        case 114    /* ESC_XATTR */:
                            stack[stack.length - 1] = AVMX.AS.escapeAttributeValue(stack[stack.length - 1]);
                            break;
                        case 113    /* ESC_XELEM */:
                            stack[stack.length - 1] = AVMX.AS.escapeElementValue(sec, stack[stack.length - 1]);
                            break;
                        case 131    /* COERCE_I */:
                        case 115    /* CONVERT_I */:
                            stack[stack.length - 1] |= 0;
                            break;
                        case 136    /* COERCE_U */:
                        case 116    /* CONVERT_U */:
                            stack[stack.length - 1] >>>= 0;
                            break;
                        case 132    /* COERCE_D */:
                        case 117    /* CONVERT_D */:
                            stack[stack.length - 1] = +stack[stack.length - 1];
                            break;
                        case 129    /* COERCE_B */:
                        case 118    /* CONVERT_B */:
                            stack[stack.length - 1] = !!stack[stack.length - 1];
                            break;
                        case 133    /* COERCE_S */:
                            stack[stack.length - 1] = AVMX.axCoerceString(stack[stack.length - 1]);
                            break;
                        case 112    /* CONVERT_S */:
                            stack[stack.length - 1] = AVMX.axConvertString(stack[stack.length - 1]);
                            break;
                        case 120    /* CHECKFILTER */:
                            stack[stack.length - 1] = AVMX.axCheckFilter(sec, stack[stack.length - 1]);
                            break;
                        case 128    /* COERCE */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            receiver = scopes.topScope().getScopeProperty(rn, true, false);
                            stack[stack.length - 1] = receiver.axCoerce(stack[stack.length - 1]);
                            break;
                        case 130    /* COERCE_A */:
                            break;
                        case 134    /* ASTYPE */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            receiver = scopes.topScope().getScopeProperty(rn, true, false);
                            stack[stack.length - 2] = receiver.axAsType(stack[stack.length - 1]);
                            break;
                        case 135    /* ASTYPELATE */:
                            receiver = stack.pop();
                            stack[stack.length - 1] = receiver.axAsType(stack[stack.length - 1]);
                            break;
                        case 137    /* COERCE_O */:
                            object = stack[stack.length - 1];
                            stack[stack.length - 1] = object == undefined ? null : object;
                            break;
                        case 144    /* NEGATE */:
                            stack[stack.length - 1] = -stack[stack.length - 1];
                            break;
                        case 145    /* INCREMENT */:
                            ++stack[stack.length - 1];
                            break;
                        case 146    /* INCLOCAL */:
                            ++locals[frame.u30()];
                            break;
                        case 147    /* DECREMENT */:
                            --stack[stack.length - 1];
                            break;
                        case 148    /* DECLOCAL */:
                            --locals[frame.u30()];
                            break;
                        case 149    /* TYPEOF */:
                            stack[stack.length - 1] = AVMX.axTypeOf(stack[stack.length - 1], sec);
                            break;
                        case 150    /* NOT */:
                            stack[stack.length - 1] = !stack[stack.length - 1];
                            break;
                        case 151    /* BITNOT */:
                            stack[stack.length - 1] = ~stack[stack.length - 1];
                            break;
                        case 160    /* ADD */:
                            b = stack.pop();
                            a = stack[stack.length - 1];
                            if (typeof a === 'number' && typeof b === 'number') {
                                stack[stack.length - 1] = a + b;
                            } else {
                                stack[stack.length - 1] = AVMX.axAdd(a, b, sec);
                            }
                            break;
                        case 161    /* SUBTRACT */:
                            stack[stack.length - 2] -= stack.pop();
                            break;
                        case 162    /* MULTIPLY */:
                            stack[stack.length - 2] *= stack.pop();
                            break;
                        case 163    /* DIVIDE */:
                            stack[stack.length - 2] /= stack.pop();
                            break;
                        case 164    /* MODULO */:
                            stack[stack.length - 2] %= stack.pop();
                            break;
                        case 165    /* LSHIFT */:
                            stack[stack.length - 2] <<= stack.pop();
                            break;
                        case 166    /* RSHIFT */:
                            stack[stack.length - 2] >>= stack.pop();
                            break;
                        case 167    /* URSHIFT */:
                            stack[stack.length - 2] >>>= stack.pop();
                            break;
                        case 168    /* BITAND */:
                            stack[stack.length - 2] &= stack.pop();
                            break;
                        case 169    /* BITOR */:
                            stack[stack.length - 2] |= stack.pop();
                            break;
                        case 170    /* BITXOR */:
                            stack[stack.length - 2] ^= stack.pop();
                            break;
                        case 171    /* EQUALS */:
                            a = stack[stack.length - 2];
                            b = stack.pop();
                            stack[stack.length - 1] = AVMX.axEquals(a, b, sec);
                            break;
                        case 172    /* STRICTEQUALS */:
                            stack[stack.length - 2] = stack[stack.length - 2] === stack.pop();
                            break;
                        case 173    /* LESSTHAN */:
                            stack[stack.length - 2] = stack[stack.length - 2] < stack.pop();
                            break;
                        case 174    /* LESSEQUALS */:
                            stack[stack.length - 2] = stack[stack.length - 2] <= stack.pop();
                            break;
                        case 175    /* GREATERTHAN */:
                            stack[stack.length - 2] = stack[stack.length - 2] > stack.pop();
                            break;
                        case 176    /* GREATEREQUALS */:
                            stack[stack.length - 2] = stack[stack.length - 2] >= stack.pop();
                            break;
                        case 177    /* INSTANCEOF */:
                            receiver = stack.pop();
                            stack[stack.length - 1] = receiver.axIsInstanceOf(stack[stack.length - 1]);
                            break;
                        case 178    /* ISTYPE */:
                            popNameInto(stack, abc.getMultiname(frame.u30()), rn);
                            receiver = scopes.topScope().findScopeProperty(rn, true, false);
                            stack[stack.length - 1] = receiver.axIsType(stack[stack.length - 1]);
                            break;
                        case 179    /* ISTYPELATE */:
                            receiver = stack.pop();
                            stack[stack.length - 1] = receiver.axIsType(stack[stack.length - 1]);
                            break;
                        case 180    /* IN */:
                            receiver = sec.box(stack.pop());
                            var name = stack[stack.length - 1];
                            if (name && name.axClass === sec.AXQName) {
                                stack[stack.length - 1] = receiver.axHasProperty(name.name);
                            } else {
                                stack[stack.length - 1] = receiver.axHasPublicProperty(name);
                            }
                            break;
                        case 192    /* INCREMENT_I */:
                            stack[stack.length - 1] = (stack[stack.length - 1] | 0) + 1;
                            break;
                        case 193    /* DECREMENT_I */:
                            stack[stack.length - 1] = (stack[stack.length - 1] | 0) - 1;
                            break;
                        case 194    /* INCLOCAL_I */:
                            index = frame.u30();
                            locals[index] = (locals[index] | 0) + 1;
                            break;
                        case 195    /* DECLOCAL_I */:
                            index = frame.u30();
                            locals[index] = (locals[index] | 0) - 1;
                            break;
                        case 196    /* NEGATE_I */:
                            stack[stack.length - 1] = -(stack[stack.length - 1] | 0);
                            break;
                        case 197    /* ADD_I */:
                            stack[stack.length - 2] = (stack[stack.length - 2] | 0) + (stack.pop() | 0) | 0;
                            break;
                        case 198    /* SUBTRACT_I */:
                            stack[stack.length - 2] = (stack[stack.length - 2] | 0) - (stack.pop() | 0) | 0;
                            break;
                        case 199    /* MULTIPLY_I */:
                            stack[stack.length - 2] = (stack[stack.length - 2] | 0) * (stack.pop() | 0) | 0;
                            break;
                        case 208    /* GETLOCAL0 */:
                        case 209    /* GETLOCAL1 */:
                        case 210    /* GETLOCAL2 */:
                        case 211    /* GETLOCAL3 */:
                            stack.push(locals[bc - 208    /* GETLOCAL0 */]);
                            break;
                        case 212    /* SETLOCAL0 */:
                        case 213    /* SETLOCAL1 */:
                        case 214    /* SETLOCAL2 */:
                        case 215    /* SETLOCAL3 */:
                            locals[bc - 212    /* SETLOCAL0 */] = stack.pop();
                            break;
                        case 6    /* DXNS */:
                            scopes.topScope().defaultNamespace = AVMX.internNamespace(0    /* Public */, abc.getString(frame.u30()));
                            break;
                        case 7    /* DXNSLATE */:
                            scopes.topScope().defaultNamespace = AVMX.internNamespace(0    /* Public */, stack.pop());
                            break;
                        case 239    /* DEBUG */:
                            frame.pc++;
                            frame.u30();
                            frame.pc++;
                            frame.u30();
                            break;
                        case 240    /* DEBUGLINE */:
                        case 241    /* DEBUGFILE */:
                            frame.u30();
                            break;
                        case 2    /* NOP */:
                        case 1    /* BKPT */:
                            break;
                        default:
                            Shumway.Debug.notImplemented(AVMX.getBytecodeName(bc));
                        }
                    } catch (e) {
                        // TODO: e = translateError(e);
                        // All script exceptions must be primitive or have a security domain, if they don't then
                        // this must be a VM exception.
                        if (!AVMX.isValidASValue(e)) {
                            // We omit many checks in the interpreter loop above to keep the code small. These
                            // checks can be done after the fact here by turning the VM-internal exception into a
                            // proper error according to the current operation.
                            e = createValidException(sec, e, bc, value, receiver, a, b, rn, scopeStacksHeight + 1);
                        }
                        var catchBlocks = frame.body.catchBlocks;
                        for (var i = 0; i < catchBlocks.length; i++) {
                            var handler = catchBlocks[i];
                            if (frame.pc >= handler.start && frame.pc <= handler.end) {
                                var typeName = handler.getType();
                                if (!typeName || frame.app.getClass(typeName).axIsType(e)) {
                                    stack.length = 0;
                                    stack.push(e);
                                    scopes.clear();
                                    frame.pc = handler.target;
                                    continue interpretLabel;
                                }
                            }
                        }
                        release || assert(AVMX.scopeStacks.length === scopeStacksHeight + 1);
                        AVMX.scopeStacks.length--;
                        throw e;
                    }
                }
        }
        function createValidException(sec, internalError, bc, value, receiver, a, b, mn, expectedScopeStacksHeight) {
            var isProperErrorObject = internalError instanceof Error && typeof internalError.name === 'string' && typeof internalError.message === 'string';
            if (isProperErrorObject) {
                if (internalError instanceof RangeError || internalError.name === 'InternalError') {
                    var obj = Object.create(sec.AXError.tPrototype);
                    obj._errorID = 1023;
                    // Stack exhaustion errors are annoying to catch: Identifying them requires
                    // pattern-matching of error messages, and throwing them must be done very
                    // carefully to not cause the next one.
                    if (internalError.message === 'allocation size overflow') {
                        obj.$Bgmessage = 'allocation size overflow';
                        return obj;
                    }
                    if (internalError.message.indexOf('recursion') > -1 || internalError.message.indexOf('call stack size exceeded') > -1) {
                        obj.$Bgmessage = 'Stack overflow occurred';
                        AVMX.scopeStacks.length = expectedScopeStacksHeight;
                        return obj;
                    }
                } else if (internalError instanceof TypeError) {
                    if (internalError.message.indexOf('convert') > -1 && (internalError.message.indexOf('to primitive') > -1 || internalError.message.indexOf('to string') > -1)) {
                        return sec.createError('TypeError', AVMX.Errors.ConvertToPrimitiveError, 'value');
                    }
                    // Internal error thrown by generic Array methods.
                    if (internalError.message === 'Conversion to Array failed') {
                        return sec.createError('TypeError', AVMX.Errors.CheckTypeFailedError, 'value', 'Array');
                    }
                }
            }
            var message;
            var isSuper = false;
            switch (bc) {
            case 65    /* CALL */:
                if (!value || !value.axApply) {
                    return sec.createError('TypeError', AVMX.Errors.CallOfNonFunctionError, 'value');
                }
                break;
            case 66    /* CONSTRUCT */:
                if (!receiver || !receiver.axConstruct) {
                    return sec.createError('TypeError', AVMX.Errors.ConstructOfNonFunctionError);
                }
                break;
            case 88    /* NEWCLASS */:
                if (!value || !sec.AXClass.axIsType(value)) {
                    return sec.createError('VerifyError', AVMX.Errors.InvalidBaseClassError);
                }
                break;
            case 78    /* CALLSUPERVOID */:
            case 73    /* CONSTRUCTSUPER */:
                isSuper = true;
            // Fallthrough.
            case 70    /* CALLPROPERTY */:
            case 79    /* CALLPROPVOID */:
            case 76    /* CALLPROPLEX */:
            case 74    /* CONSTRUCTPROP */:
            case 69    /* CALLSUPER */:
                if (receiver === null) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertNullToObjectError);
                }
                if (receiver === undefined) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                }
                if (!(receiver.axResolveMultiname(mn) in receiver)) {
                    var axClass = isSuper ? receiver.axClass.superClass : receiver.axClass;
                    if (axClass.classInfo.instanceInfo.isSealed()) {
                        return sec.createError('ReferenceError', AVMX.Errors.ReadSealedError, mn.name, axClass.name.toFQNString(false));
                    }
                    return sec.createError('TypeError', isSuper ? AVMX.Errors.ConstructOfNonFunctionError : AVMX.Errors.CallOfNonFunctionError, mn.name);
                }
                if (isProperErrorObject && internalError.name === 'RangeError' && (internalError.message.indexOf('arguments array passed') > -1 || internalError.message.indexOf('call stack size') > -1)) {
                    return sec.createError('RangeError', AVMX.Errors.StackOverflowError);
                }
                break;
            case 4    /* GETSUPER */:
                isSuper = true;
            // Fallthrough.
            case 102    /* GETPROPERTY */:
                if (receiver === null) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertNullToObjectError);
                }
                if (receiver === undefined) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                }
                break;
            case 104    /* INITPROPERTY */:
            case 97    /* SETPROPERTY */:
                if (receiver === null) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertNullToObjectError);
                }
                if (receiver === undefined) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                }
                var nm = receiver.axResolveMultiname(mn);
                if (nm in receiver && getPropertyDescriptor(receiver, nm).writable === false) {
                    return sec.createError('ReferenceError', AVMX.Errors.ConstWriteError, nm, receiver.axClass.name.name);
                }
                break;
            case 177    /* INSTANCEOF */:
                if (!receiver || !receiver.axIsInstanceOf) {
                    return sec.createError('TypeError', AVMX.Errors.CantUseInstanceofOnNonObjectError);
                }
                break;
            case 134    /* ASTYPE */:
            case 135    /* ASTYPELATE */:
                // ASTYPE(LATE) have almost the same error messages as ISTYPE(LATE), but not *quite*.
                if (receiver && !receiver.axAsType) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertNullToObjectError);
                }
            // Fallthrough.
            case 178    /* ISTYPE */:
            case 179    /* ISTYPELATE */:
                if (receiver === null) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertNullToObjectError);
                }
                if (receiver === undefined) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                }
                if (!receiver.axIsType) {
                    return sec.createError('TypeError', AVMX.Errors.IsTypeMustBeClassError);
                }
                break;
            case 128    /* COERCE */:
                if (!receiver) {
                    return sec.createError('ReferenceError', AVMX.Errors.ClassNotFoundError, mn.toFQNString(false));
                }
                break;
            case 180    /* IN */:
                if (receiver === null) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertNullToObjectError);
                }
                if (receiver === undefined) {
                    return sec.createError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                }
                break;
            case 19    /* IFEQ */:
            case 20    /* IFNE */:
            case 171    /* EQUALS */:
                if (typeof a !== typeof b) {
                    if (typeof a === 'object' && a && typeof b !== 'object' || typeof b === 'object' && b && typeof a !== 'object') {
                        return sec.createError('TypeError', AVMX.Errors.ConvertToPrimitiveError, 'Object');
                    }
                }
                break;
            default:
                // Pattern-match some otherwise-annoying-to-convert exceptions. This is all best-effort,
                // so we fail if we're not sure about something.
                if (!internalError || typeof internalError.message !== 'string' || typeof internalError.stack !== 'string' || typeof internalError.name !== 'string') {
                    break;
                }
                message = internalError.message;
                var stack = internalError.stack.split('\n');
                var lastFunctionEntry = stack[0].indexOf('at ') === 0 ? stack[0].substr(3) : stack[0];
                switch (internalError.name) {
                case 'TypeError':
                    if (lastFunctionEntry.indexOf('AXBasePrototype_valueOf') === 0 || lastFunctionEntry.indexOf('AXBasePrototype_toString') === 0) {
                        return sec.createError('TypeError', AVMX.Errors.CallOfNonFunctionError, 'value');
                    }
                }
            }
            // To be sure we don't let VM exceptions flow into the player, box them manually here,
            // even in release builds.
            message = 'Uncaught VM-internal exception during op ' + AVMX.getBytecodeName(bc) + ': ';
            var stack;
            try {
                message += internalError.toString();
                stack = internalError.stack;
            } catch (e) {
                message += '[Failed to stringify exception]';
            }
            // In the extension, we can just kill all the things.
            var player = sec['player'];
            console.error(message, '\n', stack);
            if (player) {
            }
            // In other packagings, at least throw a valid value.
            return sec.createError('Error', AVMX.Errors.InternalErrorIV);
        }
        function stringifyStackEntry(x) {
            if (!x || !x.toString) {
                return String(x);
            }
            if (x.$BgtoString && x.$BgtoString.isInterpreted) {
                return '<unprintable ' + (x.axClass ? x.axClass.name.toFQNString(false) : 'object') + '>';
            }
            try {
                return x.toString();
            } catch (e) {
                return '<unprintable ' + (x.axClass ? x.axClass.name.toFQNString(false) : 'object') + '>';
            }
        }
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
}(Shumway || (Shumway = {})));
var $ = null;
var Shumway;
(function (Shumway) {
    var AVMX;
    (function (AVMX) {
        /*
         *     +--------------------------+
         *     |      Base Prototype      |
         *     +--------------------------+
         *     |- axHasPropertyInternal   |
         *     |- axHasProperty           |            +-------------------+
         *     |- axSetProperty           |     +-----#|  objectPrototype  |
         *     |- axGetProperty           |     |      +-------------------+
         *     |- axSetPublicProperty     |     |      | - sec             |
         *     |- axGetSlot               |<----+      +-------------------+
         *     |- axSetSlot               |     |
         *     |  …                       |     |
         *     |                          |     |      +-------------------+
         *     |                          |     +-----#|  objectPrototype  |
         *     |                          |            +-------------------+
         *     +--------------------------+            | - sec             |
         *                                             +-------------------+
         *                                                       ^
         *                                                       |
         *                                                       |
         *                                                       #
         *     +-----------------+                        +------------+
         *  +-#|  Class Object   |----------------------->| tPrototype |<-----------------<--------------------+
         *  |  +-----------------+                        +------------+                  |                    |
         *  |                                                    ^                        |                    |
         *  |                                                    |                        |                    |
         *  |                                                    |--------+               |                    |
         *  |                                                    |        |               #                    #
         *  |                         +------------+             |        |      +-----------------+  +-----------------+
         *  |                         | - traits   |             #        |      |     Number      |  |      Uint       |
         *  |  +-----------------+    +------------+      +------------+  |      +-----------------+  +-----------------+
         *  +-#|   Class Class   |--->| tPrototype |#---->| dPrototype |  |      | - value         |  | - value         |
         *  |  +-----------------+    +------------+      +------------+  |      +-----------------+  +-----------------+
         *  |                                ^                            |
         *  |                                |                            |      +-----------------+  +-----------------+
         *  +--------------------------------+----------------------------+-----#|     Boolean     |  |      Array      |
         *  |                                                             |      +-----------------+  +-----------------+
         *  |                                                             |      | - value         |  | - value         |
         *  |  +-----------------+    +------------+      +------------+  |      +-----------------+  +-----------------+
         *  +-#|     Class A     |--->| tPrototype |#---->| dPrototype |#-+
         *  |  +-----------------+    +------------+      +------------+         +-----------------+  +-----------------+
         *  |                         | - traits   |--+          ^               |       Int       |  |    Function     |
         *  |                         +------------+  |          |               +-----------------+  +-----------------+
         *  |                                ^        |          |               | - value         |  | - value         |
         *  |                                |        |          +--------+      +-----------------+  +-----------------+
         *  |                                #        |                   |
         *  |                         +------------+  |   +------------+  |      +-----------------+
         *  |                         |  Object A  |  +-->|   Traits   |  |      |     String      |
         *  |                         +------------+      +------------+  |      +-----------------+
         *  |                                                             |      | - value         |
         *  |                                                             |      +-----------------+
         *  |                                                             |
         *  |                                                             |
         *  |                                                             |
         *  |                                                             |
         *  |                                                             |
         *  | +-----------------+     +------------+      +------------+  |
         *  +#|Class B extends A|---->| tPrototype |#---->| dPrototype |#-+
         *    +-----------------+     +------------+      +------------+
         *                            | - traits   |
         *                            +------------+
         *
         */
        function validateCall(sec, fun, argc) {
            if (!fun || !fun.axApply) {
                sec.throwError('TypeError', AVMX.Errors.CallOfNonFunctionError, fun && fun.methodInfo ? fun.methodInfo.getName() : 'value');
            }
            if (fun.methodInfo && argc < fun.methodInfo.minArgs) {
                sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, fun.methodInfo.getName(), fun.methodInfo.minArgs, argc);
            }
        }
        AVMX.validateCall = validateCall;
        function validateConstruct(sec, axClass, argc) {
            if (!axClass || !axClass.axConstruct) {
                var name = axClass && axClass.classInfo ? axClass.classInfo.instanceInfo.getName().name : 'value';
                sec.throwError('TypeError', AVMX.Errors.ConstructOfNonFunctionError, name);
            }
            var methodInfo = axClass.classInfo.getInitializer();
            if (argc < methodInfo.minArgs) {
                sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, axClass.classInfo.instanceInfo.getName().name, methodInfo.minArgs, argc);
            }
        }
        AVMX.validateConstruct = validateConstruct;
        function checkNullParameter(argument, name, sec) {
            if (argument == undefined) {
                sec.throwError('TypeError', AVMX.Errors.NullPointerError, name);
            }
        }
        AVMX.checkNullParameter = checkNullParameter;
        // REDUX: check if we need this now that we do arg checking at callsites.
        function checkParameterType(argument, name, type) {
            if (argument == null) {
                type.sec.throwError('TypeError', AVMX.Errors.NullPointerError, name);
            }
            if (!type.axIsType(argument)) {
                type.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, argument, type.classInfo.instanceInfo.getClassName());
            }
        }
        AVMX.checkParameterType = checkParameterType;
        function forEachPublicProperty(object, callbackfn, thisArg) {
            // REDUX: Do we need to walk the proto chain here?
            var properties = object.axGetEnumerableKeys();
            for (var i = 0; i < properties.length; i++) {
                var property = properties[i];
                var value = object.axGetPublicProperty(property);
                callbackfn.call(thisArg, property, value);
            }
        }
        AVMX.forEachPublicProperty = forEachPublicProperty;
        (function (WriterFlags) {
            WriterFlags[WriterFlags['None'] = 0] = 'None';
            WriterFlags[WriterFlags['Runtime'] = 1] = 'Runtime';
            WriterFlags[WriterFlags['Execution'] = 2] = 'Execution';
            WriterFlags[WriterFlags['Interpreter'] = 4] = 'Interpreter';
        }(AVMX.WriterFlags || (AVMX.WriterFlags = {})));
        var WriterFlags = AVMX.WriterFlags;
        var writer = new Shumway.IndentingWriter(false, function (x) {
            dumpLine(x);
        });
        AVMX.runtimeWriter = null;
        AVMX.executionWriter = null;
        AVMX.interpreterWriter = null;
        function sliceArguments(args, offset) {
            return Array.prototype.slice.call(args, offset);
        }
        AVMX.sliceArguments = sliceArguments;
        function setWriters(flags) {
            AVMX.runtimeWriter = flags & WriterFlags.Runtime ? writer : null;
            AVMX.executionWriter = flags & (WriterFlags.Execution | WriterFlags.Interpreter) ? writer : null;
            AVMX.interpreterWriter = flags & WriterFlags.Interpreter ? writer : null;
        }
        AVMX.setWriters = setWriters;
        var assert = Shumway.Debug.assert;
        var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
        var defineReadOnlyProperty = Shumway.ObjectUtilities.defineReadOnlyProperty;
        function axBoxIdentity(args) {
            return args[0];
        }
        function axBoxPrimitive(value) {
            var boxed = Object.create(this.tPrototype);
            boxed.value = value;
            return boxed;
        }
        function ensureBoxedReceiver(sec, receiver, callable) {
            if (receiver && typeof receiver === 'object') {
                release || checkValue(receiver);
                return receiver;
            }
            var boxedReceiver = sec.box(receiver);
            // Boxing still leaves `null` and `undefined` unboxed, so return the current global instead.
            if (!boxedReceiver) {
                if (AVMX.scopeStacks.length) {
                    boxedReceiver = AVMX.scopeStacks[AVMX.scopeStacks.length - 1].topScope().global.object;
                } else if (callable.receiver) {
                    // If no scripts are on the stack (e.g., for ExternalInterface calls), use the function's
                    // own global.
                    boxedReceiver = callable.receiver.scope.global.object;
                }
            }
            return boxedReceiver;
        }
        AVMX.ensureBoxedReceiver = ensureBoxedReceiver;
        function axCoerceObject(x) {
            if (x == null) {
                return null;
            }
            return x;
        }
        function axApplyObject(_, args) {
            var x = args[0];
            if (x == null) {
                return Object.create(this.tPrototype);
            }
            return x;
        }
        function axConstructObject(args) {
            var x = args[0];
            if (x == null) {
                return Object.create(this.tPrototype);
            }
            return x;
        }
        function axCoerceInt(x) {
            return x | 0;
        }
        AVMX.axCoerceInt = axCoerceInt;
        function axCoerceUint(x) {
            return x >>> 0;
        }
        AVMX.axCoerceUint = axCoerceUint;
        function axCoerceNumber(x) {
            if (as3Compatibility) {
                if (typeof x === 'string') {
                    return AVMX.AS.ASNumber.convertStringToDouble(x);
                }
                if (x && typeof x === 'object') {
                    x = x.valueOf();
                    // Make sure to only call valueOf() once.
                    if (typeof x === 'string') {
                        return AVMX.AS.ASNumber.convertStringToDouble(x);
                    }
                }
            }
            return +x;
        }
        AVMX.axCoerceNumber = axCoerceNumber;
        function axCoerceBoolean(x) {
            return !!x;
        }
        AVMX.axCoerceBoolean = axCoerceBoolean;
        /**
         * Similar to |toString| but returns |null| for |null| or |undefined| instead
         * of "null" or "undefined".
         */
        function axCoerceString(x) {
            if (typeof x === 'string') {
                return x;
            } else if (x == undefined) {
                return null;
            }
            return x + '';
        }
        AVMX.axCoerceString = axCoerceString;
        /**
         * Same as |axCoerceString| except for returning "null" instead of |null| for
         * |null| or |undefined|, and calls |toString| instead of (implicitly) |valueOf|.
         */
        function axCoerceName(x) {
            if (typeof x === 'string') {
                return x;
            } else if (x == undefined) {
                return 'null';
            }
            return x.toString();
        }
        AVMX.axCoerceName = axCoerceName;
        function axConvertString(x) {
            if (typeof x === 'string') {
                return x;
            }
            return x + '';
        }
        AVMX.axConvertString = axConvertString;
        function axIsTypeNumber(x) {
            return typeof x === 'number';
        }
        AVMX.axIsTypeNumber = axIsTypeNumber;
        function axIsTypeInt(x) {
            return typeof x === 'number' && (x | 0) === x;
        }
        AVMX.axIsTypeInt = axIsTypeInt;
        function axIsTypeUint(x) {
            return typeof x === 'number' && x >>> 0 === x;
        }
        AVMX.axIsTypeUint = axIsTypeUint;
        function axIsTypeBoolean(x) {
            return typeof x === 'boolean';
        }
        AVMX.axIsTypeBoolean = axIsTypeBoolean;
        function axIsTypeString(x) {
            return typeof x === 'string';
        }
        AVMX.axIsTypeString = axIsTypeString;
        function axIsXMLCollection(x, sec) {
            return sec.AXXML.dPrototype.isPrototypeOf(x) || sec.AXXMLList.dPrototype.isPrototypeOf(x);
        }
        function axGetDescendants(object, mn, sec) {
            if (!axIsXMLCollection(object, sec)) {
                sec.throwError('TypeError', AVMX.Errors.DescendentsError, object);
            }
            return object.descendants(mn);
        }
        AVMX.axGetDescendants = axGetDescendants;
        function axCheckFilter(sec, value) {
            if (!value || !AVMX.AS.isXMLCollection(sec, value)) {
                var className = value && value.axClass ? value.axClass.name.toFQNString(false) : '[unknown]';
                sec.throwError('TypeError', AVMX.Errors.FilterError, className);
            }
            return value;
        }
        AVMX.axCheckFilter = axCheckFilter;
        function axFalse() {
            return false;
        }
        AVMX.axFalse = axFalse;
        /**
         * Returns the current interpreter frame's callee.
         */
        function axGetArgumentsCallee() {
            var callee = this.callee;
            if (callee) {
                return callee;
            }
            release || assert(this.receiver);
            release || assert(this.methodInfo);
            if (this.methodInfo.trait === null) {
                console.error('arguments.callee used on trait-less methodInfo function. Probably a constructor');
                return null;
            }
            release || assert(this.methodInfo.trait);
            var mn = this.methodInfo.trait.name;
            var methodClosure = this.receiver.axGetProperty(mn);
            release || assert(this.sec.AXMethodClosure.tPrototype === Object.getPrototypeOf(methodClosure));
            return methodClosure;
        }
        function axDefaultCompareFunction(a, b) {
            return String(a).localeCompare(String(b));
        }
        AVMX.axDefaultCompareFunction = axDefaultCompareFunction;
        function axCompare(a, b, options, sortOrder, compareFunction) {
            release || Shumway.Debug.assertNotImplemented(!(options & 4    /* UNIQUESORT */), 'UNIQUESORT');
            release || Shumway.Debug.assertNotImplemented(!(options & 8    /* RETURNINDEXEDARRAY */), 'RETURNINDEXEDARRAY');
            var result = 0;
            if (options & 1    /* CASEINSENSITIVE */) {
                a = String(a).toLowerCase();
                b = String(b).toLowerCase();
            }
            if (options & 16    /* NUMERIC */) {
                a = +a;
                b = +b;
                result = a < b ? -1 : a > b ? 1 : 0;
            } else {
                result = compareFunction(a, b);
            }
            return result * sortOrder;
        }
        AVMX.axCompare = axCompare;
        function axCompareFields(objA, objB, names, optionsList) {
            release || assert(names.length === optionsList.length);
            release || assert(names.length > 0);
            var result = 0;
            var i;
            for (i = 0; i < names.length && result === 0; i++) {
                var name = names[i];
                var a = objA[name];
                var b = objB[name];
                var options = optionsList[i];
                if (options & 1    /* CASEINSENSITIVE */) {
                    a = String(a).toLowerCase();
                    b = String(b).toLowerCase();
                }
                if (options & 16    /* NUMERIC */) {
                    a = +a;
                    b = +b;
                    result = a < b ? -1 : a > b ? 1 : 0;
                } else {
                    result = String(a).localeCompare(String(b));
                }
            }
            if (optionsList[i - 1] & 2    /* DESCENDING */) {
                result *= -1;
            }
            return result;
        }
        AVMX.axCompareFields = axCompareFields;
        /**
         * ActionScript 3 has different behaviour when deciding whether to call toString or valueOf
         * when one operand is a string. Unlike JavaScript, it calls toString if one operand is a
         * string and valueOf otherwise. This sucks, but we have to emulate this behaviour because
         * YouTube depends on it.
         *
         * AS3 also overloads the `+` operator to concatenate XMLs/XMLLists instead of stringifying them.
         */
        function axAdd(l, r, sec) {
            release || assert(!(typeof l === 'number' && typeof r === 'number'), 'Inline number addition.');
            if (typeof l === 'string' || typeof r === 'string') {
                return String(l) + String(r);
            }
            if (AVMX.AS.isXMLCollection(sec, l) && AVMX.AS.isXMLCollection(sec, r)) {
                return AVMX.AS.ASXMLList.addXML(l, r);
            }
            return l + r;
        }
        AVMX.axAdd = axAdd;
        function axEquals(left, right, sec) {
            // See E4X spec, 11.5 Equality Operators for why this is required.
            if (AVMX.AS.isXMLType(left, sec)) {
                return left.equals(right);
            }
            if (AVMX.AS.isXMLType(right, sec)) {
                return right.equals(left);
            }
            return left == right;
        }
        AVMX.axEquals = axEquals;
        /**
         * These values are allowed to exist without being boxed.
         */
        function isPrimitiveJSValue(value) {
            return value === null || value === undefined || typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean';
        }
        function isValidASValue(value) {
            return AVMX.AXBasePrototype.isPrototypeOf(value) || isPrimitiveJSValue(value);
        }
        AVMX.isValidASValue = isValidASValue;
        function checkValue(value) {
            if (!release) {
                if (!isValidASValue(value)) {
                    // Stringifying the value is potentially costly, so only do it if necessary,
                    // even in debug mode.
                    assert(false, 'Value: ' + value + ' is not allowed to flow into AS3.');
                }
            }
        }
        AVMX.checkValue = checkValue;
        function axTypeOf(x, sec) {
            // ABC doesn't box primitives, so typeof returns the primitive type even when
            // the value is new'd
            if (x) {
                if (x.value) {
                    return typeof x.value;
                }
                if (axIsXMLCollection(x, sec)) {
                    return 'xml';
                }
            }
            return typeof x;
        }
        AVMX.axTypeOf = axTypeOf;
        function axIsCallable(value) {
            return value && typeof value.axApply === 'function';
        }
        AVMX.axIsCallable = axIsCallable;
        function axCoerce(x) {
            if (Shumway.isNullOrUndefined(x)) {
                return null;
            }
            if (!this.axIsType(x)) {
                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, x, this.classInfo.instanceInfo.getClassName());
            }
            return x;
        }
        function axImplementsInterface(type) {
            var interfaces = this.classInfo.instanceInfo.getInterfaces(this.axClass);
            return interfaces.has(type);
        }
        function axIsTypeObject(x) {
            return this.dPrototype.isPrototypeOf(this.sec.box(x)) || x === this.dPrototype;
        }
        function axIsTypeInterface(x) {
            if (!x || typeof x !== 'object') {
                return false;
            }
            release || checkValue(x);
            return x.axImplementsInterface(this);
        }
        function axAsType(x) {
            return this.axIsType(x) ? x : null;
        }
        function axIsInstanceOfObject(x) {
            return this.dPrototype.isPrototypeOf(this.sec.box(x));
        }
        function axIsInstanceOfInterface(x) {
            return false;
        }
        var Scope = function () {
            function Scope(parent, object, isWith) {
                if (isWith === void 0) {
                    isWith = false;
                }
                this.parent = parent;
                this.object = object;
                this.global = parent ? parent.global : this;
                this.isWith = isWith;
                this.cache = [];
                this.defaultNamespace = null;
            }
            Scope.prototype.findDepth = function (object) {
                var current = this;
                var depth = 0;
                while (current) {
                    if (current.object === object) {
                        return depth;
                    }
                    depth++;
                    current = current.parent;
                }
                return -1;
            };
            Scope.prototype.getScopeObjects = function () {
                var objects = [];
                var current = this;
                while (current) {
                    objects.unshift(current.object);
                    current = current.parent;
                }
                return objects;
            };
            Scope.prototype.getScopeProperty = function (mn, strict, scopeOnly) {
                return this.findScopeProperty(mn, strict, scopeOnly).axGetProperty(mn);
            };
            Scope.prototype.findScopeProperty = function (mn, strict, scopeOnly) {
                // Multinames with a `null` name are the any name, '*'. Need to catch those here, because
                // otherwise we'll get a failing assert in `RuntimeTraits#getTrait` below.
                if (mn.name === null) {
                    this.global.object.sec.throwError('ReferenceError', AVMX.Errors.UndefinedVarError, '*');
                }
                var object;
                if (!scopeOnly && !mn.isRuntime()) {
                    if (object = this.cache[mn.id]) {
                        return object;
                    }
                }
                // Scope lookups should not be trapped by proxies. Except for with scopes, check only trait
                // properties.
                if (this.object && (this.isWith ? this.object.axHasPropertyInternal(mn) : this.object.traits.getTrait(mn.namespaces, mn.name))) {
                    return this.isWith || mn.isRuntime() ? this.object : this.cache[mn.id] = this.object;
                }
                if (this.parent) {
                    var object = this.parent.findScopeProperty(mn, strict, scopeOnly);
                    if (mn.kind === 7    /* QName */) {
                        this.cache[mn.id] = object;
                    }
                    return object;
                }
                if (scopeOnly) {
                    return null;
                }
                // Attributes can't be stored on globals or be directly defined in scripts.
                if (mn.isAttribute()) {
                    this.object.sec.throwError('ReferenceError', AVMX.Errors.UndefinedVarError, mn.name);
                }
                // If we can't find the property look in the domain.
                var globalObject = this.global.object;
                if (object = globalObject.applicationDomain.findProperty(mn, strict, true)) {
                    return object;
                }
                // If we still haven't found it, look for dynamic properties on the global.
                // No need to do this for non-strict lookups as we'll end up returning the
                // global anyways.
                if (strict) {
                    if (!(mn.getPublicMangledName() in globalObject)) {
                        this.global.object.sec.throwError('ReferenceError', AVMX.Errors.UndefinedVarError, mn.name);
                    }
                }
                // Can't find it still, return the global object.
                return globalObject;
            };
            return Scope;
        }();
        AVMX.Scope = Scope;
        function applyTraits(object, traits) {
            release || assert(!object.hasOwnProperty('traits'));
            defineReadOnlyProperty(object, 'traits', traits);
            var T = traits.getTraitsList();
            for (var i = 0; i < T.length; i++) {
                var t = T[i];
                var p = t;
                if (p.value instanceof AVMX.Namespace) {
                    // We can't call |object.sec.AXNamespace.FromNamespace(...)| because the
                    // AXNamespace class may not have been loaded yet. However, at this point we do have a
                    // valid reference to |object.sec.AXNamespace| because |prepareNativeClass| has
                    // been called.
                    p = { value: AVMX.AS.ASNamespace.FromNamespace.call(object.sec.AXNamespace, p.value) };
                }
                if (!release && (t.kind === 0    /* Slot */ || t.kind === 6    /* Const */)) {
                    checkValue(p.value);
                }
                Object.defineProperty(object, t.name.getMangledName(), p);
            }
        }
        AVMX.applyTraits = applyTraits;
        var D = defineNonEnumerableProperty;
        // The Object that's at the root of all AXObjects' prototype chain, regardless of their
        // SecurityDomain.
        AVMX.AXBasePrototype = null;
        function AXBasePrototype_$BgtoString() {
            // Dynamic prototypes just return [object Object], so we have to special-case them.
            // Since the dynamic object is the one holding the direct reference to `classInfo`,
            // we can check for that.
            var name = this.hasOwnProperty('classInfo') ? 'Object' : this.classInfo.instanceInfo.name.name;
            return Shumway.StringUtilities.concat3('[object ', name, ']');
        }
        ;
        function AXBasePrototype_toString() {
            return this.$BgtoString.axCall(this);
        }
        ;
        function AXBasePrototype_$BgvalueOf() {
            return this;
        }
        ;
        function AXBasePrototype_valueOf() {
            return this.$BgvalueOf.axCall(this);
        }
        ;
        /**
         * Execute this lazily because we want to make sure the AS package is available.
         */
        function initializeAXBasePrototype() {
            if (AVMX.AXBasePrototype) {
                return;
            }
            var Op = AVMX.AS.ASObject.prototype;
            AVMX.AXBasePrototype = Object.create(null);
            D(AVMX.AXBasePrototype, 'axHasPropertyInternal', Op.axHasPropertyInternal);
            D(AVMX.AXBasePrototype, 'axHasProperty', Op.axHasProperty);
            D(AVMX.AXBasePrototype, 'axSetProperty', Op.axSetProperty);
            D(AVMX.AXBasePrototype, 'axHasProperty', Op.axHasProperty);
            D(AVMX.AXBasePrototype, 'axHasPublicProperty', Op.axHasPublicProperty);
            D(AVMX.AXBasePrototype, 'axSetPublicProperty', Op.axSetPublicProperty);
            D(AVMX.AXBasePrototype, 'axGetPublicProperty', Op.axGetPublicProperty);
            D(AVMX.AXBasePrototype, 'axCallPublicProperty', Op.axCallPublicProperty);
            D(AVMX.AXBasePrototype, 'axDeletePublicProperty', Op.axDeletePublicProperty);
            D(AVMX.AXBasePrototype, 'axGetProperty', Op.axGetProperty);
            D(AVMX.AXBasePrototype, 'axDeleteProperty', Op.axDeleteProperty);
            D(AVMX.AXBasePrototype, 'axGetSuper', Op.axGetSuper);
            D(AVMX.AXBasePrototype, 'axSetSuper', Op.axSetSuper);
            D(AVMX.AXBasePrototype, 'axSetSlot', Op.axSetSlot);
            D(AVMX.AXBasePrototype, 'axGetSlot', Op.axGetSlot);
            D(AVMX.AXBasePrototype, 'axCallProperty', Op.axCallProperty);
            D(AVMX.AXBasePrototype, 'axCallSuper', Op.axCallSuper);
            D(AVMX.AXBasePrototype, 'axConstructProperty', Op.axConstructProperty);
            D(AVMX.AXBasePrototype, 'axResolveMultiname', Op.axResolveMultiname);
            D(AVMX.AXBasePrototype, 'axNextNameIndex', Op.axNextNameIndex);
            D(AVMX.AXBasePrototype, 'axNextName', Op.axNextName);
            D(AVMX.AXBasePrototype, 'axNextValue', Op.axNextValue);
            D(AVMX.AXBasePrototype, 'axGetEnumerableKeys', Op.axGetEnumerableKeys);
            D(AVMX.AXBasePrototype, 'axImplementsInterface', axImplementsInterface);
            // Dummy traits object so Object.prototype lookups succeed.
            D(AVMX.AXBasePrototype, 'traits', new AVMX.RuntimeTraits(null, null, Object.create(null)));
            // Helper methods borrowed from Object.prototype.
            D(AVMX.AXBasePrototype, 'isPrototypeOf', Object.prototype.isPrototypeOf);
            D(AVMX.AXBasePrototype, 'hasOwnProperty', Object.prototype.hasOwnProperty);
            AVMX.AXBasePrototype.$BgtoString = AXBasePrototype_$BgtoString;
            AVMX.AXBasePrototype.toString = AXBasePrototype_toString;
            AVMX.AXBasePrototype.$BgvalueOf = AXBasePrototype_$BgvalueOf;
            AVMX.AXBasePrototype.valueOf = AXBasePrototype_valueOf;
        }
        // Add the |axApply| and |axCall| methods on the function prototype so that we can treat
        // Functions as AXCallables.
        Function.prototype.axApply = Function.prototype.apply;
        Function.prototype.axCall = Function.prototype.call;
        /**
         * Make sure we bottom out at the securityDomain's objectPrototype.
         */
        function safeGetPrototypeOf(object) {
            var axClass = object.axClass;
            if (!axClass || axClass === axClass.sec.AXObject) {
                return null;
            }
            var prototype = axClass.dPrototype;
            if (prototype === object) {
                prototype = axClass.superClass.dPrototype;
            }
            release || assert(prototype.sec);
            return prototype;
        }
        AVMX.safeGetPrototypeOf = safeGetPrototypeOf;
        var HasNext2Info = function () {
            function HasNext2Info(object, index) {
                this.object = object;
                this.index = index;    // ...
            }
            /**
             * Determine if the given object has any more properties after the specified |index| and if so,
             * return the next index or |zero| otherwise. If the |obj| has no more properties then continue
             * the search in
             * |obj.__proto__|. This function returns an updated index and object to be used during
             * iteration.
             *
             * the |for (x in obj) { ... }| statement is compiled into the following pseudo bytecode:
             *
             * index = 0;
             * while (true) {
             *   (obj, index) = hasNext2(obj, index);
             *   if (index) { #1
             *     x = nextName(obj, index); #2
             *   } else {
             *     break;
             *   }
             * }
             *
             * #1 If we return zero, the iteration stops.
             * #2 The spec says we need to get the nextName at index + 1, but it's actually index - 1, this
             * caused me two hours of my life that I will probably never get back.
             *
             * TODO: We can't match the iteration order semantics of Action Script, hopefully programmers
             * don't rely on it.
             */
            HasNext2Info.prototype.next = function (object, index) {
                if (Shumway.isNullOrUndefined(object)) {
                    this.index = 0;
                    this.object = null;
                    return;
                } else {
                    this.object = object;
                    this.index = index;
                }
                var nextIndex = object.axNextNameIndex(this.index);
                if (nextIndex > 0) {
                    this.index = nextIndex;
                    return;
                }
                // If there are no more properties in the object then follow the prototype chain.
                while (true) {
                    var object = safeGetPrototypeOf(object);
                    if (!object) {
                        this.index = 0;
                        this.object = null;
                        return;
                    }
                    nextIndex = object.axNextNameIndex(0);
                    if (nextIndex > 0) {
                        this.index = nextIndex;
                        this.object = object;
                        return;
                    }
                }
            };
            return HasNext2Info;
        }();
        AVMX.HasNext2Info = HasNext2Info;
        /**
         * Generic axConstruct method that lives on the AXClass prototype. This just
         * creates an empty object with the right prototype and then calls the
         * instance initializer.
         *
         * TODO: Flatten out the argArray, or create an alternate ax helper to
         * make object construction faster.
         */
        function axConstruct(argArray) {
            var object = Object.create(this.tPrototype);
            object.axInitializer.apply(object, argArray);
            return object;
        }
        /**
         * Default initializer.
         */
        function axDefaultInitializer() {
        }
        /**
         * Throwing initializer for interfaces.
         */
        function axInterfaceInitializer() {
            this.sec.throwError('VerifierError', AVMX.Errors.NotImplementedError, this.name.name);
        }
        /**
         * Default axApply.
         */
        function axDefaultApply(self, args) {
            return this.axCoerce(args ? args[0] : undefined);
        }
        AVMX.scopeStacks = [];
        function getCurrentScope() {
            if (AVMX.scopeStacks.length === 0) {
                return null;
            }
            return AVMX.scopeStacks[AVMX.scopeStacks.length - 1].topScope();
        }
        AVMX.getCurrentScope = getCurrentScope;
        function getCurrentABC() {
            if (AVMX.scopeStacks.length === 0) {
                return null;
            }
            var globalObject = AVMX.scopeStacks[AVMX.scopeStacks.length - 1].topScope().global.object;
            return globalObject.scriptInfo.abc;
        }
        AVMX.getCurrentABC = getCurrentABC;
        /**
         * Provides security isolation between application domains.
         */
        var AXSecurityDomain = function () {
            function AXSecurityDomain() {
                initializeAXBasePrototype();
                this.system = new AXApplicationDomain(this, null);
                this.application = new AXApplicationDomain(this, this.system);
                this.classAliases = new AVMX.ClassAliases();
                this.nativeClasses = Object.create(null);
                this.vectorClasses = new Map();
                this._catalogs = [];
            }
            Object.defineProperty(AXSecurityDomain.prototype, 'xmlParser', {
                get: function () {
                    return this._xmlParser || (this._xmlParser = new AVMX.AS.XMLParser(this));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AXSecurityDomain.prototype, 'AXFunctionUndefinedPrototype', {
                get: function () {
                    return this._AXFunctionUndefinedPrototype || (this._AXFunctionUndefinedPrototype = this.createObject());
                },
                enumerable: true,
                configurable: true
            });
            AXSecurityDomain.prototype.addCatalog = function (abcCatalog) {
                this._catalogs.push(abcCatalog);
            };
            AXSecurityDomain.prototype.findDefiningABC = function (mn) {
                AVMX.runtimeWriter && AVMX.runtimeWriter.writeLn('findDefiningABC: ' + mn);
                var abcFile = null;
                for (var i = 0; i < this._catalogs.length; i++) {
                    var abcCatalog = this._catalogs[i];
                    abcFile = abcCatalog.getABCByMultiname(mn);
                    if (abcFile) {
                        return abcFile;
                    }
                }
                return null;
            };
            AXSecurityDomain.prototype.throwError = function (className, error, replacement1, replacement2, replacement3, replacement4) {
                throw this.createError.apply(this, arguments);
            };
            AXSecurityDomain.prototype.createError = function (className, error, replacement1, replacement2, replacement3, replacement4) {
                var message = AVMX.formatErrorMessage.apply(null, sliceArguments(arguments, 1));
                var mn = AVMX.Multiname.FromFQNString(className, 0    /* Public */);
                var axClass = this.system.getProperty(mn, true, true);
                return axClass.axConstruct([
                    message,
                    error.code
                ]);
            };
            AXSecurityDomain.prototype.applyType = function (axClass, types) {
                var vectorProto = this.ObjectVector.axClass.superClass.dPrototype;
                if (!vectorProto.isPrototypeOf(axClass.dPrototype)) {
                    this.throwError('TypeError', AVMX.Errors.TypeAppOfNonParamType);
                }
                if (types.length !== 1) {
                    this.throwError('TypeError', AVMX.Errors.WrongTypeArgCountError, '__AS3__.vec::Vector', 1, types.length);
                }
                var type = types[0] || this.AXObject;
                return this.getVectorClass(type);
            };
            AXSecurityDomain.prototype.getVectorClass = function (type) {
                var vectorClass = this.vectorClasses.get(type);
                if (vectorClass) {
                    return vectorClass;
                }
                var typeClassName = type ? type.classInfo.instanceInfo.getName().getMangledName() : '$BgObject';
                switch (typeClassName) {
                case '$BgNumber':
                case '$Bgdouble':
                    vectorClass = this.Float64Vector.axClass;
                    break;
                case '$Bgint':
                    vectorClass = this.Int32Vector.axClass;
                    break;
                case '$Bguint':
                    vectorClass = this.Uint32Vector.axClass;
                    break;
                default:
                    vectorClass = this.createVectorClass(type);
                }
                this.vectorClasses.set(type, vectorClass);
                return vectorClass;
            };
            AXSecurityDomain.prototype.createVectorClass = function (type) {
                var genericVectorClass = this.ObjectVector.axClass;
                var axClass = Object.create(genericVectorClass);
                // Put the superClass tPrototype on the prototype chain so we have access
                // to all factory protocol handlers by default.
                axClass.tPrototype = Object.create(genericVectorClass.tPrototype);
                axClass.tPrototype.axClass = axClass;
                // We don't need a new dPrototype object.
                axClass.dPrototype = genericVectorClass.dPrototype;
                axClass.superClass = genericVectorClass;
                axClass.type = type;
                return axClass;
            };
            /**
             * Constructs a plain vanilla object in this security domain.
             */
            AXSecurityDomain.prototype.createObject = function () {
                return Object.create(this.AXObject.tPrototype);
            };
            /**
             * Takes a JS Object and transforms it into an AXObject.
             */
            AXSecurityDomain.prototype.createObjectFromJS = function (value, deep) {
                if (deep === void 0) {
                    deep = false;
                }
                var keys = Object.keys(value);
                var result = this.createObject();
                for (var i = 0; i < keys.length; i++) {
                    var v = value[keys[i]];
                    if (deep) {
                        v = AVMX.AS.transformJSValueToAS(this, v, true);
                    }
                    result.axSetPublicProperty(keys[i], v);
                }
                return result;
            };
            /**
             * Constructs an AXArray in this security domain and sets its value to the given array.
             * Warning: This doesn't handle non-indexed keys.
             */
            AXSecurityDomain.prototype.createArrayUnsafe = function (value) {
                var array = Object.create(this.AXArray.tPrototype);
                array.value = value;
                if (!release) {
                    for (var k in value) {
                        assert(Shumway.isIndex(k));
                        checkValue(value[k]);
                    }
                }
                return array;
            };
            /**
             * Constructs an AXArray in this security domain and copies all enumerable properties of
             * the given array, setting them as public properties on the AXArray.
             * Warning: this does not use the given Array as the `value`.
             */
            AXSecurityDomain.prototype.createArray = function (value) {
                var array = this.createArrayUnsafe([]);
                for (var k in value) {
                    array.axSetPublicProperty(k, value[k]);
                    release || checkValue(value[k]);
                }
                array.length = value.length;
                return array;
            };
            /**
             * Constructs an AXFunction in this security domain and sets its value to the given function.
             */
            AXSecurityDomain.prototype.boxFunction = function (value) {
                var fn = Object.create(this.AXFunction.tPrototype);
                fn.value = value;
                return fn;
            };
            AXSecurityDomain.prototype.createClass = function (classInfo, superClass, scope) {
                var instanceInfo = classInfo.instanceInfo;
                var className = instanceInfo.getName().toFQNString(false);
                var axClass = this.nativeClasses[className] || Object.create(this.AXClass.tPrototype);
                var classScope = new Scope(scope, axClass);
                if (!this.nativeClasses[className]) {
                    if (instanceInfo.isInterface()) {
                        axClass.dPrototype = Object.create(this.objectPrototype);
                        axClass.tPrototype = Object.create(axClass.dPrototype);
                        axClass.tPrototype.axInitializer = axInterfaceInitializer;
                        axClass.axIsInstanceOf = axIsInstanceOfInterface;
                        axClass.axIsType = axIsTypeInterface;
                    } else {
                        // For direct descendants of Object, we want the dynamic prototype to inherit from
                        // Object's tPrototype because Foo.prototype is always a proper instance of Object.
                        // For all other cases, the dynamic prototype should extend the parent class's
                        // dynamic prototype not the tPrototype.
                        if (superClass === this.AXObject) {
                            axClass.dPrototype = Object.create(this.objectPrototype);
                        } else {
                            axClass.dPrototype = Object.create(superClass.dPrototype);
                        }
                        axClass.tPrototype = Object.create(axClass.dPrototype);
                        axClass.tPrototype.axInitializer = this.createInitializerFunction(classInfo, classScope);
                    }
                } else {
                    axClass.tPrototype.axInitializer = this.createInitializerFunction(classInfo, classScope);
                    // Native classes have their inheritance structure set up during initial SecurityDomain
                    // creation.
                    release || assert(axClass.dPrototype);
                    release || assert(axClass.tPrototype);
                }
                axClass.classInfo = axClass.dPrototype.classInfo = classInfo;
                axClass.dPrototype.axClass = axClass;
                axClass.superClass = superClass;
                axClass.scope = scope;
                // Object and Class have their traits initialized earlier to avoid circular dependencies.
                if (className !== 'Object' && className !== 'Class') {
                    this.initializeRuntimeTraits(axClass, superClass, classScope);
                }
                // Add the |constructor| property on the class dynamic prototype so that all instances can
                // get to their class constructor, and FooClass.prototype.constructor returns FooClass.
                defineNonEnumerableProperty(axClass.dPrototype, '$Bgconstructor', axClass);
                // Copy over all TS symbols.
                AVMX.AS.tryLinkNativeClass(axClass);
                // Run the static initializer.
                var initializer = classInfo.getInitializer();
                var initializerCode = initializer.getBody().code;
                // ... except if it's the standard class initializer that doesn't really do anything.
                if (initializerCode[0] !== 208 || initializerCode[1] !== 48 || initializerCode[2] !== 71) {
                    AVMX.interpret(axClass, initializer, classScope, [axClass], null);
                }
                return axClass;
            };
            AXSecurityDomain.prototype.initializeRuntimeTraits = function (axClass, superClass, scope) {
                var classInfo = axClass.classInfo;
                var instanceInfo = classInfo.instanceInfo;
                // Prepare class traits.
                var classTraits;
                if (axClass === this.AXClass) {
                    classTraits = instanceInfo.traits.resolveRuntimeTraits(null, null, scope);
                } else {
                    var rootClassTraits = this.AXClass.classInfo.instanceInfo.runtimeTraits;
                    release || assert(rootClassTraits);
                    // Class traits don't capture the class' scope. This is relevant because it allows
                    // referring to global names that would be shadowed if the class scope were active.
                    // Haxe's stdlib uses just such constructs, e.g. Std.parseFloat calls the global
                    // parseFloat.
                    classTraits = classInfo.traits.resolveRuntimeTraits(rootClassTraits, null, scope.parent);
                }
                classInfo.runtimeTraits = classTraits;
                applyTraits(axClass, classTraits);
                // Prepare instance traits.
                var superInstanceTraits = superClass ? superClass.classInfo.instanceInfo.runtimeTraits : null;
                var protectedNs = classInfo.abc.getNamespace(instanceInfo.protectedNs);
                var instanceTraits = instanceInfo.traits.resolveRuntimeTraits(superInstanceTraits, protectedNs, scope);
                instanceInfo.runtimeTraits = instanceTraits;
                applyTraits(axClass.tPrototype, instanceTraits);
            };
            AXSecurityDomain.prototype.createFunction = function (methodInfo, scope, hasDynamicScope) {
                var traceMsg = !release && Shumway.flashlog && methodInfo.trait ? methodInfo.toFlashlogString() : null;
                var fun = this.boxFunction(function () {
                    release || traceMsg && Shumway.flashlog.writeAS3Trace(methodInfo.toFlashlogString());
                    var self = this === jsGlobal ? scope.global.object : this;
                    return AVMX.interpret(self, methodInfo, scope, arguments, fun);
                });
                //fun.methodInfo = methodInfo;
                fun.receiver = { scope: scope };
                if (!release) {
                    try {
                        Object.defineProperty(fun.value, 'name', { value: methodInfo.getName() });
                    } catch (e) {
                    }
                }
                return fun;
            };
            AXSecurityDomain.prototype.createInitializerFunction = function (classInfo, scope) {
                var methodInfo = classInfo.instanceInfo.getInitializer();
                var traceMsg = !release && Shumway.flashlog && methodInfo.trait ? methodInfo.toFlashlogString() : null;
                var fun = AVMX.AS.getNativeInitializer(classInfo);
                if (!fun) {
                    release || assert(!methodInfo.isNative(), 'Must provide a native initializer for ' + classInfo.instanceInfo.getClassName());
                    fun = function () {
                        release || traceMsg && Shumway.flashlog.writeAS3Trace(methodInfo.toFlashlogString());
                        return AVMX.interpret(this, methodInfo, scope, arguments, null);
                    };
                    if (!release) {
                        try {
                            var className = classInfo.instanceInfo.getName().toFQNString(false);
                            Object.defineProperty(fun, 'name', { value: className });
                        } catch (e) {
                        }
                    }
                    // REDUX: enable arg count checking on native ctors. Currently impossible because natives
                    // are frozen.
                    fun.methodInfo = methodInfo;
                }
                return fun;
            };
            AXSecurityDomain.prototype.createActivation = function (methodInfo, scope) {
                var body = methodInfo.getBody();
                if (!body.activationPrototype) {
                    body.traits.resolve();
                    body.activationPrototype = Object.create(this.AXActivationPrototype);
                    defineReadOnlyProperty(body.activationPrototype, 'traits', body.traits.resolveRuntimeTraits(null, null, scope));
                }
                return Object.create(body.activationPrototype);
            };
            AXSecurityDomain.prototype.createCatch = function (exceptionInfo, scope) {
                if (!exceptionInfo.catchPrototype) {
                    var traits = exceptionInfo.getTraits();
                    exceptionInfo.catchPrototype = Object.create(this.AXCatchPrototype);
                    defineReadOnlyProperty(exceptionInfo.catchPrototype, 'traits', traits.resolveRuntimeTraits(null, null, scope));
                }
                return Object.create(exceptionInfo.catchPrototype);
            };
            AXSecurityDomain.prototype.box = function (v) {
                if (v == undefined) {
                    return v;
                }
                if (AVMX.AXBasePrototype.isPrototypeOf(v)) {
                    return v;
                }
                if (v instanceof Array) {
                    return this.AXArray.axBox(v);
                }
                if (typeof v === 'number') {
                    return this.AXNumber.axBox(v);
                }
                if (typeof v === 'boolean') {
                    return this.AXBoolean.axBox(v);
                }
                if (typeof v === 'string') {
                    return this.AXString.axBox(v);
                }
                assert(false, 'Cannot box: ' + v);
            };
            AXSecurityDomain.prototype.isPrimitive = function (v) {
                return isPrimitiveJSValue(v) || this.AXPrimitiveBox.dPrototype.isPrototypeOf(v);
            };
            AXSecurityDomain.prototype.createAXGlobal = function (applicationDomain, scriptInfo) {
                var global = Object.create(this.AXGlobalPrototype);
                global.applicationDomain = applicationDomain;
                global.scriptInfo = scriptInfo;
                var scope = global.scope = new Scope(null, global, false);
                var objectTraits = this.AXObject.classInfo.instanceInfo.runtimeTraits;
                var traits = scriptInfo.traits.resolveRuntimeTraits(objectTraits, null, scope);
                applyTraits(global, traits);
                return global;
            };
            /**
             * Prepares the dynamic Class prototype that all Class instances (including Class) have in
             * their prototype chain.
             *
             * This prototype defines the default hooks for all classes. Classes can override some or
             * all of them.
             */
            AXSecurityDomain.prototype.prepareRootClassPrototype = function () {
                var dynamicClassPrototype = Object.create(this.objectPrototype);
                var rootClassPrototype = Object.create(dynamicClassPrototype);
                rootClassPrototype.$BgtoString = function axClassToString() {
                    return '[class ' + this.classInfo.instanceInfo.getName().name + ']';
                };
                var D = defineNonEnumerableProperty;
                D(rootClassPrototype, 'axBox', axBoxIdentity);
                D(rootClassPrototype, 'axCoerce', axCoerce);
                D(rootClassPrototype, 'axIsType', axIsTypeObject);
                D(rootClassPrototype, 'axAsType', axAsType);
                D(rootClassPrototype, 'axIsInstanceOf', axIsInstanceOfObject);
                D(rootClassPrototype, 'axConstruct', axConstruct);
                D(rootClassPrototype, 'axApply', axDefaultApply);
                Object.defineProperty(rootClassPrototype, 'name', {
                    get: function () {
                        return this.classInfo.instanceInfo.name;
                    }
                });
                this.rootClassPrototype = rootClassPrototype;
            };
            AXSecurityDomain.prototype.initializeCoreNatives = function () {
                // Some facts:
                // - The Class constructor is itself an instance of Class.
                // - The Class constructor is an instance of Object.
                // - The Object constructor is an instance of Class.
                // - The Object constructor is an instance of Object.
                this.prepareRootClassPrototype();
                var AXClass = this.prepareNativeClass('AXClass', 'Class', false);
                AXClass.classInfo = this.system.findClassInfo('Class');
                AXClass.defaultValue = null;
                var AXObject = this.prepareNativeClass('AXObject', 'Object', false);
                AXObject.classInfo = this.system.findClassInfo('Object');
                var AXObject = this.AXObject;
                // AXFunction needs to exist for runtime trait resolution.
                var AXFunction = this.prepareNativeClass('AXFunction', 'Function', false);
                defineNonEnumerableProperty(AXFunction, 'axBox', axBoxPrimitive);
                // Initialization of the core classes' traits is a messy multi-step process:
                // First, create a scope for looking up all the things.
                var scope = new Scope(null, AXClass, false);
                // Then, create the runtime traits all Object instances share.
                var objectCI = this.AXObject.classInfo;
                var objectII = objectCI.instanceInfo;
                var objectRTT = objectII.runtimeTraits = objectII.traits.resolveRuntimeTraits(null, null, scope);
                applyTraits(this.AXObject.tPrototype, objectRTT);
                // Building on that, create the runtime traits all Class instances share.
                var classCI = this.AXClass.classInfo;
                var classII = classCI.instanceInfo;
                classII.runtimeTraits = classII.traits.resolveRuntimeTraits(objectRTT, null, scope);
                applyTraits(this.AXClass.tPrototype, classII.runtimeTraits);
                // As sort of a loose end, also create the one class trait Class itself has.
                classCI.runtimeTraits = classCI.traits.resolveRuntimeTraits(objectRTT, null, scope);
                applyTraits(this.AXClass, classCI.runtimeTraits);
                // Now we can create Object's runtime class traits.
                objectCI.runtimeTraits = objectCI.traits.resolveRuntimeTraits(classII.runtimeTraits, null, scope);
                applyTraits(this.AXObject, objectCI.runtimeTraits);
                return AXObject;
            };
            AXSecurityDomain.prototype.prepareNativeClass = function (exportName, name, isPrimitiveClass) {
                var axClass = Object.create(this.rootClassPrototype);
                // For Object and Class, we've already created the instance prototype to break
                // circular dependencies.
                if (name === 'Object') {
                    axClass.dPrototype = Object.getPrototypeOf(this.objectPrototype);
                    axClass.tPrototype = this.objectPrototype;
                } else if (name === 'Class') {
                    axClass.dPrototype = Object.getPrototypeOf(this.rootClassPrototype);
                    axClass.tPrototype = this.rootClassPrototype;
                } else {
                    var instancePrototype = isPrimitiveClass ? this.AXPrimitiveBox.dPrototype : exportName === 'AXMethodClosure' ? this.AXFunction.dPrototype : this.objectPrototype;
                    axClass.dPrototype = Object.create(instancePrototype);
                    axClass.tPrototype = Object.create(axClass.dPrototype);
                }
                this[exportName] = this.nativeClasses[name] = axClass;
                return axClass;
            };
            AXSecurityDomain.prototype.preparePrimitiveClass = function (exportName, name, convert, defaultValue, coerce, isType, isInstanceOf) {
                var axClass = this.prepareNativeClass(exportName, name, true);
                var D = defineNonEnumerableProperty;
                D(axClass, 'axBox', axBoxPrimitive);
                D(axClass, 'axApply', function axApply(_, args) {
                    return convert(args && args.length ? args[0] : defaultValue);
                });
                D(axClass, 'axConstruct', function axConstruct(args) {
                    return convert(args && args.length ? args[0] : defaultValue);
                });
                D(axClass, 'axCoerce', coerce);
                D(axClass, 'axIsType', isType);
                D(axClass, 'axIsInstanceOf', isInstanceOf);
                D(axClass.dPrototype, 'value', defaultValue);
                return axClass;
            };
            /**
             * Configures all the builtin Objects.
             */
            AXSecurityDomain.prototype.initialize = function () {
                var D = defineNonEnumerableProperty;
                // The basic dynamic prototype that all objects in this security domain have in common.
                var dynamicObjectPrototype = Object.create(AVMX.AXBasePrototype);
                dynamicObjectPrototype.sec = this;
                // The basic traits prototype that all objects in this security domain have in common.
                Object.defineProperty(this, 'objectPrototype', { value: Object.create(dynamicObjectPrototype) });
                this.initializeCoreNatives();
                // Debugging Helper
                release || (this.objectPrototype['trace'] = function trace() {
                    var self = this;
                    var writer = new Shumway.IndentingWriter();
                    this.traits.traits.forEach(function (t) {
                        writer.writeLn(t + ': ' + self[t.getName().getMangledName()]);
                    });
                });
                this.AXGlobalPrototype = Object.create(this.objectPrototype);
                this.AXGlobalPrototype.$BgtoString = function () {
                    return '[object global]';
                };
                this.AXActivationPrototype = Object.create(this.objectPrototype);
                this.AXActivationPrototype.$BgtoString = function () {
                    return '[Activation]';
                };
                this.AXCatchPrototype = Object.create(this.objectPrototype);
                this.AXCatchPrototype.$BgtoString = function () {
                    return '[Catch]';
                };
                // The core classes' MOP hooks and dynamic prototype methods are defined
                // here to keep all the hooks initialization in one place.
                var AXObject = this.AXObject;
                var AXFunction = this.AXFunction;
                // Object(null) creates an object, and this behaves differently than:
                // (function (x: Object) { trace (x); })(null) which prints null.
                D(AXObject, 'axApply', axApplyObject);
                D(AXObject, 'axConstruct', axConstructObject);
                D(AXObject.tPrototype, 'axInitializer', axDefaultInitializer);
                D(AXObject, 'axCoerce', axCoerceObject);
                this.prepareNativeClass('AXMethodClosure', 'builtin.as$0.MethodClosure', false);
                this.prepareNativeClass('AXError', 'Error', false);
                this.prepareNativeClass('AXMath', 'Math', false);
                this.prepareNativeClass('AXDate', 'Date', false);
                this.prepareNativeClass('AXXML', 'XML', false);
                this.prepareNativeClass('AXXMLList', 'XMLList', false);
                this.prepareNativeClass('AXQName', 'QName', false);
                this.prepareNativeClass('AXNamespace', 'Namespace', false);
                var AXArray = this.prepareNativeClass('AXArray', 'Array', false);
                D(AXArray, 'axBox', axBoxPrimitive);
                AXArray.tPrototype.$BgtoString = AXFunction.axBox(function () {
                    return this.value.toString();
                });
                // Array.prototype is an Array, and behaves like one.
                AXArray.dPrototype['value'] = [];
                this.argumentsPrototype = Object.create(this.AXArray.tPrototype);
                Object.defineProperty(this.argumentsPrototype, '$Bgcallee', { get: axGetArgumentsCallee });
                var AXRegExp = this.prepareNativeClass('AXRegExp', 'RegExp', false);
                // RegExp.prototype is an (empty string matching) RegExp, and behaves like one.
                AXRegExp.dPrototype['value'] = /(?:)/;
                // Boolean, int, Number, String, and uint are primitives in AS3. We create a placeholder
                // base class to help us with instanceof tests.
                var AXPrimitiveBox = this.prepareNativeClass('AXPrimitiveBox', 'PrimitiveBox', false);
                D(AXPrimitiveBox.dPrototype, '$BgtoString', AXFunction.axBox(function () {
                    return this.value.toString();
                }));
                var AXBoolean = this.preparePrimitiveClass('AXBoolean', 'Boolean', axCoerceBoolean, false, axCoerceBoolean, axIsTypeBoolean, axIsTypeBoolean);
                var AXString = this.preparePrimitiveClass('AXString', 'String', axConvertString, '', axCoerceString, axIsTypeString, axIsTypeString);
                var AXNumber = this.preparePrimitiveClass('AXNumber', 'Number', axCoerceNumber, 0, axCoerceNumber, axIsTypeNumber, axIsTypeNumber);
                var AXInt = this.preparePrimitiveClass('AXInt', 'int', axCoerceInt, 0, axCoerceInt, axIsTypeInt, axFalse);
                var AXUint = this.preparePrimitiveClass('AXUint', 'uint', axCoerceUint, 0, axCoerceUint, axIsTypeUint, axFalse);
                // Install class loaders on the security domain.
                AVMX.AS.installClassLoaders(this.application, this);
                AVMX.AS.installNativeFunctions(this);
            };
            return AXSecurityDomain;
        }();
        AVMX.AXSecurityDomain = AXSecurityDomain;
        /**
         * All code lives within an application domain.
         */
        var AXApplicationDomain = function () {
            function AXApplicationDomain(sec, parent) {
                this.sec = sec;
                this.parent = parent;
                this.system = parent ? parent.system : this;
                this._abcs = [];
            }
            AXApplicationDomain.prototype.loadABC = function (abc) {
                assert(this._abcs.indexOf(abc) < 0);
                this._abcs.push(abc);
            };
            AXApplicationDomain.prototype.loadAndExecuteABC = function (abc) {
                this.loadABC(abc);
                this.executeABC(abc);
            };
            AXApplicationDomain.prototype.executeABC = function (abc) {
                var lastScript = abc.scripts[abc.scripts.length - 1];
                this.executeScript(lastScript);
            };
            AXApplicationDomain.prototype.findClassInfo = function (name) {
                for (var i = 0; i < this._abcs.length; i++) {
                    var abc = this._abcs[i];
                    for (var j = 0; j < abc.instances.length; j++) {
                        var c = abc.classes[j];
                        if (c.instanceInfo.getName().name === name) {
                            return c;
                        }
                    }
                }
                return null;
            };
            AXApplicationDomain.prototype.executeScript = function (scriptInfo) {
                assert(scriptInfo.state === 0    /* None */);
                AVMX.runtimeWriter && AVMX.runtimeWriter.writeLn('Running Script: ' + scriptInfo);
                var global = this.sec.createAXGlobal(this, scriptInfo);
                scriptInfo.global = global;
                scriptInfo.state = 1    /* Executing */;
                AVMX.interpret(global, scriptInfo.getInitializer(), global.scope, [], null);
                scriptInfo.state = 2    /* Executed */;
            };
            AXApplicationDomain.prototype.findProperty = function (mn, strict, execute) {
                release || assert(mn instanceof AVMX.Multiname);
                var script = this.findDefiningScript(mn, execute);
                if (script) {
                    return script.global;
                }
                return null;
            };
            AXApplicationDomain.prototype.getClass = function (mn) {
                release || assert(mn instanceof AVMX.Multiname);
                return this.getProperty(mn, true, true);
            };
            AXApplicationDomain.prototype.getProperty = function (mn, strict, execute) {
                release || assert(mn instanceof AVMX.Multiname);
                var global = this.findProperty(mn, strict, execute);
                if (global) {
                    return global.axGetProperty(mn);
                }
                return null;
            };
            AXApplicationDomain.prototype.findDefiningScript = function (mn, execute) {
                release || assert(mn instanceof AVMX.Multiname);
                // Look in parent domain first.
                var script;
                if (this.parent) {
                    script = this.parent.findDefiningScript(mn, execute);
                    if (script) {
                        return script;
                    }
                }
                // Search through the loaded abcs.
                for (var i = 0; i < this._abcs.length; i++) {
                    var abc = this._abcs[i];
                    script = this._findDefiningScriptInABC(abc, mn, execute);
                    if (script) {
                        return script;
                    }
                }
                // Still no luck, so let's ask the security domain to load additional ABCs and try again.
                var abc = this.system.sec.findDefiningABC(mn);
                if (abc) {
                    this.loadABC(abc);
                    script = this._findDefiningScriptInABC(abc, mn, execute);
                    release || assert(script, 'Shall find class in loaded ABC');
                    return script;
                }
                return null;
            };
            AXApplicationDomain.prototype._findDefiningScriptInABC = function (abc, mn, execute) {
                var scripts = abc.scripts;
                for (var j = 0; j < scripts.length; j++) {
                    var script = scripts[j];
                    var traits = script.traits;
                    traits.resolve();
                    if (traits.getTrait(mn)) {
                        // Ensure script is executed.
                        if (execute && script.state === 0    /* None */) {
                            this.executeScript(script);
                        }
                        return script;
                    }
                }
                return null;
            };
            return AXApplicationDomain;
        }();
        AVMX.AXApplicationDomain = AXApplicationDomain;
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
    var AVM2;
    (function (AVM2) {
        var AS;
        (function (AS) {
            // Keep this module around for now so the flash.js package doesn't fail.
            var ASObject = function () {
                function ASObject() {
                }
                return ASObject;
            }();
            AS.ASObject = ASObject;
            var ASNative = function (_super) {
                __extends(ASNative, _super);
                function ASNative() {
                    _super.apply(this, arguments);
                }
                return ASNative;
            }(ASObject);
            AS.ASNative = ASNative;
            var ASError = function (_super) {
                __extends(ASError, _super);
                function ASError() {
                    _super.apply(this, arguments);
                }
                return ASError;
            }(ASObject);
            AS.ASError = ASError;
        }(AS = AVM2.AS || (AVM2.AS = {})));
    }(AVM2 = Shumway.AVM2 || (Shumway.AVM2 = {})));
}(Shumway || (Shumway = {})));
/**
 * Make Shumway bug-for-bug compatible with Tamarin.
 */
var as3Compatibility = true;
/**
 * AS3 has a bug when converting a certain character range to lower case.
 */
function as3ToLowerCase(value) {
    var chars = null;
    for (var i = 0; i < value.length; i++) {
        var charCode = value.charCodeAt(i);
        if (charCode >= 4256 && charCode <= 4293) {
            if (!chars) {
                chars = new Array(value.length);
            }
            chars[i] = String.fromCharCode(charCode + 48);
        }
    }
    if (chars) {
        // Fill in remaining chars if the bug needs to be emulated.
        for (var i = 0; i < chars.length; i++) {
            var char = chars[i];
            if (!char) {
                chars[i] = value.charAt(i).toLocaleString();
            }
        }
        return chars.join('');
    }
    return value.toLowerCase();
}
var Shumway;
(function (Shumway) {
    var AVMX;
    (function (AVMX) {
        var AS;
        (function (AS) {
            var assert = Shumway.Debug.assert;
            var hasOwnProperty = Shumway.ObjectUtilities.hasOwnProperty;
            var hasOwnGetter = Shumway.ObjectUtilities.hasOwnGetter;
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var isNullOrUndefined = Shumway.isNullOrUndefined;
            var notImplemented = Shumway.Debug.notImplemented;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var pushMany = Shumway.ArrayUtilities.pushMany;
            var copyOwnPropertyDescriptors = Shumway.ObjectUtilities.copyOwnPropertyDescriptors;
            var copyPropertiesByList = Shumway.ObjectUtilities.copyPropertiesByList;
            var Multiname = Shumway.AVMX.Multiname;
            var writer = new Shumway.IndentingWriter();
            function wrapJSGlobalFunction(fun) {
                return function (sec) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    return fun.apply(jsGlobal, args);
                };
            }
            /**
             * Other natives can live in this module
             */
            var Natives;
            (function (Natives) {
                function print(sec, expression, arg1, arg2, arg3, arg4) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    jsGlobal.print.apply(null, args);
                }
                Natives.print = print;
                function debugBreak(v) {
                    /* tslint:disable */
                    debugger;    /* tslint:enable */
                }
                Natives.debugBreak = debugBreak;
                function bugzilla(_, n) {
                    switch (n) {
                    case 574600:
                        return true;
                    }
                    return false;
                }
                Natives.bugzilla = bugzilla;
                function decodeURI(sec, encodedURI) {
                    try {
                        return jsGlobal.decodeURI(encodedURI);
                    } catch (e) {
                        sec.throwError('URIError', AVMX.Errors.InvalidURIError, 'decodeURI');
                    }
                }
                Natives.decodeURI = decodeURI;
                function decodeURIComponent(sec, encodedURI) {
                    try {
                        return jsGlobal.decodeURIComponent(encodedURI);
                    } catch (e) {
                        sec.throwError('URIError', AVMX.Errors.InvalidURIError, 'decodeURIComponent');
                    }
                }
                Natives.decodeURIComponent = decodeURIComponent;
                function encodeURI(sec, uri) {
                    try {
                        return jsGlobal.encodeURI(uri);
                    } catch (e) {
                        sec.throwError('URIError', AVMX.Errors.InvalidURIError, 'encodeURI');
                    }
                }
                Natives.encodeURI = encodeURI;
                function encodeURIComponent(sec, uri) {
                    try {
                        return jsGlobal.encodeURIComponent(uri);
                    } catch (e) {
                        sec.throwError('URIError', AVMX.Errors.InvalidURIError, 'encodeURIComponent');
                    }
                }
                Natives.encodeURIComponent = encodeURIComponent;
                Natives.isNaN = wrapJSGlobalFunction(jsGlobal.isNaN);
                Natives.isFinite = wrapJSGlobalFunction(jsGlobal.isFinite);
                Natives.parseInt = wrapJSGlobalFunction(jsGlobal.parseInt);
                Natives.parseFloat = wrapJSGlobalFunction(jsGlobal.parseFloat);
                Natives.escape = wrapJSGlobalFunction(jsGlobal.escape);
                Natives.unescape = wrapJSGlobalFunction(jsGlobal.unescape);
                Natives.isXMLName = function () {
                    return false;    // "FIX ME";
                };
                Natives.notImplemented = wrapJSGlobalFunction(jsGlobal.Shumway.Debug.notImplemented);
                /**
                 * Returns the fully qualified class name of an object.
                 */
                function getQualifiedClassName(_, value) {
                    release || AVMX.checkValue(value);
                    var valueType = typeof value;
                    switch (valueType) {
                    case 'undefined':
                        return 'void';
                    case 'object':
                        if (value === null) {
                            return 'null';
                        }
                        return value.classInfo.instanceInfo.name.toFQNString(true);
                    case 'number':
                        return (value | 0) === value ? 'int' : 'Number';
                    case 'string':
                        return 'String';
                    case 'boolean':
                        return 'Boolean';
                    }
                    release || assertUnreachable('invalid value type ' + valueType);
                }
                Natives.getQualifiedClassName = getQualifiedClassName;
                /**
                 * Returns the fully qualified class name of the base class of the object specified by the
                 * |value| parameter.
                 */
                function getQualifiedSuperclassName(sec, value) {
                    if (isNullOrUndefined(value)) {
                        return 'null';
                    }
                    value = sec.box(value);
                    // The value might be from another domain, so don't use passed-in the current
                    // AXSecurityDomain.
                    var axClass = value.sec.AXClass.axIsType(value) ? value.superClass : value.axClass.superClass;
                    return getQualifiedClassName(sec, axClass);
                }
                Natives.getQualifiedSuperclassName = getQualifiedSuperclassName;
                /**
                 * Returns the class with the specified name, or |null| if no such class exists.
                 */
                function getDefinitionByName(sec, name) {
                    name = AVMX.axCoerceString(name).replace('::', '.');
                    var mn = Multiname.FromFQNString(name, 0    /* Public */);
                    return AVMX.getCurrentABC().env.app.getClass(mn);
                }
                Natives.getDefinitionByName = getDefinitionByName;
                function describeType(sec, value, flags) {
                    return AS.describeType(sec, value, flags);
                }
                Natives.describeType = describeType;
                function describeTypeJSON(sec, value, flags) {
                    return AS.describeTypeJSON(sec, value, flags);
                }
                Natives.describeTypeJSON = describeTypeJSON;
            }(Natives = AS.Natives || (AS.Natives = {})));
            var nativeClasses = Shumway.ObjectUtilities.createMap();
            var nativeFunctions = Shumway.ObjectUtilities.createMap();
            /**
             * Searches for natives using a string path "a.b.c...".
             */
            function getNative(path) {
                var chain = path.split('.');
                var v = Natives;
                for (var i = 0, j = chain.length; i < j; i++) {
                    v = v && v[chain[i]];
                }
                if (!v) {
                    v = nativeFunctions[path];
                }
                release || assert(v, 'getNative(' + path + ') not found.');
                return v;
            }
            AS.getNative = getNative;
            var rn = new Multiname(null, 0, 17    /* RTQNameL */, [], null);
            function makeMultiname(v, namespace) {
                var rn = new Multiname(null, 0, 17    /* RTQNameL */, [], null);
                rn.namespaces = namespace ? [namespace] : [AVMX.Namespace.PUBLIC];
                rn.name = v;
                return rn;
            }
            AS.makeMultiname = makeMultiname;
            function qualifyPublicName(v) {
                return Shumway.isIndex(v) ? v : '$Bg' + v;
            }
            function addPrototypeFunctionAlias(object, name, fun) {
                release || assert(name.indexOf('$Bg') === 0);
                release || assert(typeof fun === 'function');
                // REDUX: remove the need to box the function.
                defineNonEnumerableProperty(object, name, object.sec.AXFunction.axBox(fun));
            }
            AS.addPrototypeFunctionAlias = addPrototypeFunctionAlias;
            function checkReceiverType(receiver, type, methodName) {
                if (!type.dPrototype.isPrototypeOf(receiver)) {
                    receiver.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, methodName);
                }
            }
            AS.checkReceiverType = checkReceiverType;
            /**
             * MetaobjectProtocol base traps. Inherit some or all of these to
             * implement custom behaviour.
             */
            var ASObject = function () {
                function ASObject() {
                    // To prevent accidental instantiation of template classes, make sure that we throw
                    // right during construction.
                    release || AVMX.checkValue(this);
                }
                ASObject.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASObject.prototype;
                    addPrototypeFunctionAlias(proto, '$BghasOwnProperty', asProto.native_hasOwnProperty);
                    addPrototypeFunctionAlias(proto, '$BgpropertyIsEnumerable', asProto.native_propertyIsEnumerable);
                    addPrototypeFunctionAlias(proto, '$BgsetPropertyIsEnumerable', asProto.native_setPropertyIsEnumerable);
                    addPrototypeFunctionAlias(proto, '$BgisPrototypeOf', asProto.native_isPrototypeOf);
                    addPrototypeFunctionAlias(proto, '$BgtoLocaleString', asProto.toString);
                };
                ASObject._init = function () {
                };
                ASObject.init = function () {
                };
                ASObject.prototype.native_isPrototypeOf = function (v) {
                    return this.isPrototypeOf(this.sec.box(v));
                };
                ASObject.prototype.native_hasOwnProperty = function (nm) {
                    return this.axHasOwnProperty(makeMultiname(nm));
                };
                ASObject.prototype.native_propertyIsEnumerable = function (nm) {
                    var descriptor = Object.getOwnPropertyDescriptor(this, qualifyPublicName(AVMX.axCoerceString(nm)));
                    return !!descriptor && descriptor.enumerable;
                };
                ASObject.prototype.native_setPropertyIsEnumerable = function (nm, enumerable) {
                    if (enumerable === void 0) {
                        enumerable = true;
                    }
                    var qualifiedName = qualifyPublicName(AVMX.axCoerceString(nm));
                    enumerable = !!enumerable;
                    var instanceInfo = this.axClass.classInfo.instanceInfo;
                    if (instanceInfo.isSealed() && this !== this.axClass.dPrototype) {
                        this.sec.throwError('ReferenceError', AVMX.Errors.WriteSealedError, nm, instanceInfo.name.name);
                    }
                    // Silently ignore trait properties.
                    var descriptor = Object.getOwnPropertyDescriptor(this.axClass.tPrototype, qualifiedName);
                    if (descriptor && this !== this.axClass.dPrototype) {
                        return;
                    }
                    var descriptor = Object.getOwnPropertyDescriptor(this, qualifiedName);
                    // ... and non-existent properties.
                    if (!descriptor) {
                        return;
                    }
                    if (descriptor.enumerable !== enumerable) {
                        descriptor.enumerable = enumerable;
                        Object.defineProperty(this, qualifiedName, descriptor);
                    }
                };
                ASObject.prototype.axResolveMultiname = function (mn) {
                    var name = mn.name;
                    if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                        release || assert(mn.isRuntimeName());
                        return +name;
                    }
                    var t = this.traits.getTrait(mn.namespaces, name);
                    return t ? t.name.getMangledName() : '$Bg' + name;
                };
                ASObject.prototype.axHasProperty = function (mn) {
                    return this.axHasPropertyInternal(mn);
                };
                ASObject.prototype.axHasPublicProperty = function (nm) {
                    rn.name = nm;
                    var result = this.axHasProperty(rn);
                    release || assert(rn.name === nm || isNaN(rn.name) && isNaN(nm));
                    return result;
                };
                ASObject.prototype.axSetProperty = function (mn, value, bc) {
                    release || AVMX.checkValue(value);
                    var name = mn.name;
                    if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                        release || assert(mn.isRuntimeName());
                        this[+name] = value;
                        return;
                    }
                    var freeze = false;
                    var t = this.traits.getTrait(mn.namespaces, name);
                    if (t) {
                        var mangledName = t.name.getMangledName();
                        switch (t.kind) {
                        case 1    /* Method */:
                            this.sec.throwError('ReferenceError', AVMX.Errors.CannotAssignToMethodError, name, this.axClass.name.name);
                        // Unreachable because of throwError.
                        case 2    /* Getter */:
                            this.sec.throwError('ReferenceError', AVMX.Errors.ConstWriteError, name, this.axClass.name.name);
                        // Unreachable because of throwError.
                        case 4    /* Class */:
                        case 6    /* Const */:
                            // Technically, we need to check if the currently running function is the
                            // initializer of whatever class/package the property is initialized on.
                            // In practice, we freeze the property after first assignment, causing
                            // an internal error to be thrown if it's being initialized a second time.
                            // Invalid bytecode could leave out the assignent during first initialization,
                            // but it's hard to see how that could convert into real-world problems.
                            if (bc !== 104    /* INITPROPERTY */) {
                                this.sec.throwError('ReferenceError', AVMX.Errors.ConstWriteError, name, this.axClass.name.name);
                            }
                            freeze = true;
                            break;
                        }
                        var type = t.getType();
                        if (type) {
                            value = type.axCoerce(value);
                        }
                    } else {
                        mangledName = '$Bg' + name;
                    }
                    this[mangledName] = value;
                    if (freeze) {
                        Object.defineProperty(this, mangledName, {
                            __proto__: null,
                            writable: false
                        });
                    }
                };
                ASObject.prototype.axGetProperty = function (mn) {
                    var name = this.axResolveMultiname(mn);
                    var value = this[name];
                    if (typeof value === 'function') {
                        return this.axGetMethod(name);
                    }
                    release || AVMX.checkValue(value);
                    return value;
                };
                ASObject.prototype.axGetMethod = function (name) {
                    release || assert(typeof this[name] === 'function');
                    var cache = this._methodClosureCache;
                    if (!cache) {
                        Object.defineProperty(this, '_methodClosureCache', { value: Object.create(null) });
                        cache = this._methodClosureCache;
                    }
                    var method = cache[name];
                    if (!method) {
                        method = cache[name] = this.sec.AXMethodClosure.Create(this, this[name]);
                    }
                    return method;
                };
                ASObject.prototype.axGetSuper = function (mn, scope) {
                    var name = AVMX.axCoerceName(mn.name);
                    var namespaces = mn.namespaces;
                    var trait = scope.parent.object.tPrototype.traits.getTrait(namespaces, name);
                    var value;
                    if (trait.kind === 2    /* Getter */ || trait.kind === 7    /* GetterSetter */) {
                        value = trait.get.call(this);
                    } else {
                        var mangledName = trait.name.getMangledName();
                        value = this[mangledName];
                        if (typeof value === 'function') {
                            return this.axGetMethod(mangledName);
                        }
                    }
                    release || AVMX.checkValue(value);
                    return value;
                };
                ASObject.prototype.axSetSuper = function (mn, scope, value) {
                    release || AVMX.checkValue(value);
                    var name = AVMX.axCoerceName(mn.name);
                    var namespaces = mn.namespaces;
                    var trait = scope.parent.object.tPrototype.traits.getTrait(namespaces, name);
                    var type = trait.getType();
                    if (type) {
                        value = type.axCoerce(value);
                    }
                    if (trait.kind === 3    /* Setter */ || trait.kind === 7    /* GetterSetter */) {
                        trait.set.call(this, value);
                    } else {
                        this[trait.name.getMangledName()] = value;
                    }
                };
                ASObject.prototype.axDeleteProperty = function (mn) {
                    // Cannot delete traits.
                    var name = AVMX.axCoerceName(mn.name);
                    var namespaces = mn.namespaces;
                    if (this.traits.getTrait(namespaces, name)) {
                        return false;
                    }
                    return delete this[mn.getPublicMangledName()];
                };
                ASObject.prototype.axCallProperty = function (mn, args, isLex) {
                    var name = this.axResolveMultiname(mn);
                    var fun = this[name];
                    AVMX.validateCall(this.sec, fun, args.length);
                    return fun.axApply(isLex ? null : this, args);
                };
                ASObject.prototype.axCallSuper = function (mn, scope, args) {
                    var name = this.axResolveMultiname(mn);
                    var fun = scope.parent.object.tPrototype[name];
                    AVMX.validateCall(this.sec, fun, args.length);
                    return fun.axApply(this, args);
                };
                ASObject.prototype.axConstructProperty = function (mn, args) {
                    var name = this.axResolveMultiname(mn);
                    var ctor = this[name];
                    AVMX.validateConstruct(this.sec, ctor, args.length);
                    return ctor.axConstruct(args);
                };
                ASObject.prototype.axHasPropertyInternal = function (mn) {
                    return this.axResolveMultiname(mn) in this;
                };
                ASObject.prototype.axHasOwnProperty = function (mn) {
                    var name = this.axResolveMultiname(mn);
                    // We have to check for trait properties too if a simple hasOwnProperty fails.
                    // This is different to JavaScript's hasOwnProperty behaviour where hasOwnProperty returns
                    // false for properties defined on the property chain and not on the instance itself.
                    return this.hasOwnProperty(name) || this.axClass.tPrototype.hasOwnProperty(name);
                };
                ASObject.prototype.axGetEnumerableKeys = function () {
                    if (this.sec.isPrimitive(this)) {
                        return [];
                    }
                    var tPrototype = Object.getPrototypeOf(this);
                    var keys = Object.keys(this);
                    var result = [];
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        if (Shumway.isNumeric(key)) {
                            result.push(key);
                        } else {
                            if (tPrototype.hasOwnProperty(key)) {
                                continue;
                            }
                            var name = Multiname.stripPublicMangledName(key);
                            if (name !== undefined) {
                                result.push(name);
                            }
                        }
                    }
                    return result;
                };
                ASObject.prototype.axGetPublicProperty = function (nm) {
                    return this[Multiname.getPublicMangledName(nm)];
                };
                ASObject.prototype.axSetPublicProperty = function (nm, value) {
                    release || AVMX.checkValue(value);
                    this[Multiname.getPublicMangledName(nm)] = value;
                };
                ASObject.prototype.axCallPublicProperty = function (nm, argArray) {
                    return this[Multiname.getPublicMangledName(nm)].axApply(this, argArray);
                };
                ASObject.prototype.axDeletePublicProperty = function (nm) {
                    return delete this[Multiname.getPublicMangledName(nm)];
                };
                ASObject.prototype.axGetSlot = function (i) {
                    var t = this.traits.getSlot(i);
                    var value = this[t.name.getMangledName()];
                    release || AVMX.checkValue(value);
                    return value;
                };
                ASObject.prototype.axSetSlot = function (i, value) {
                    release || AVMX.checkValue(value);
                    var t = this.traits.getSlot(i);
                    var name = t.name.getMangledName();
                    var type = t.getType();
                    this[name] = type ? type.axCoerce(value) : value;
                };
                /**
                 * Gets the next name index of an object. Index |zero| is actually not an
                 * index, but rather an indicator to start the iteration.
                 */
                ASObject.prototype.axNextNameIndex = function (index) {
                    var self = this;
                    if (index === 0) {
                        // Gather all enumerable keys since we're starting a new iteration.
                        defineNonEnumerableProperty(self, 'axEnumerableKeys', self.axGetEnumerableKeys());
                    }
                    var axEnumerableKeys = self.axEnumerableKeys;
                    while (index < axEnumerableKeys.length) {
                        rn.name = axEnumerableKeys[index];
                        if (self.axHasPropertyInternal(rn)) {
                            release || assert(rn.name === axEnumerableKeys[index]);
                            return index + 1;
                        }
                        index++;
                    }
                    return 0;
                };
                /**
                 * Gets the nextName after the specified |index|, which you would expect to
                 * be index + 1, but it's actually index - 1;
                 */
                ASObject.prototype.axNextName = function (index) {
                    var self = this;
                    var axEnumerableKeys = self.axEnumerableKeys;
                    release || assert(axEnumerableKeys && index > 0 && index < axEnumerableKeys.length + 1);
                    return axEnumerableKeys[index - 1];
                };
                ASObject.prototype.axNextValue = function (index) {
                    return this.axGetPublicProperty(this.axNextName(index));
                };
                ASObject.prototype.axSetNumericProperty = function (nm, value) {
                    this.axSetPublicProperty(nm, value);
                };
                ASObject.prototype.axGetNumericProperty = function (nm) {
                    return this.axGetPublicProperty(nm);
                };
                ASObject.classSymbols = null;
                ASObject.instanceSymbols = null;
                return ASObject;
            }();
            AS.ASObject = ASObject;
            var ASClass = function (_super) {
                __extends(ASClass, _super);
                function ASClass() {
                    _super.apply(this, arguments);
                }
                ASClass.prototype.axCoerce = function (v) {
                    return v;
                };
                Object.defineProperty(ASClass.prototype, 'prototype', {
                    get: function () {
                        release || assert(this.dPrototype);
                        return this.dPrototype;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASClass.classInitializer = null;
                return ASClass;
            }(ASObject);
            AS.ASClass = ASClass;
            function createArrayValueFromArgs(sec, args) {
                if (args.length === 1 && typeof args[0] === 'number') {
                    var len = args[0];
                    try {
                        return new Array(len);
                    } catch (e) {
                        sec.throwError('RangeError', AVMX.Errors.ArrayIndexNotIntegerError, len);
                    }
                }
                return Array.apply(Array, args);
            }
            function coerceArray(obj) {
                if (!obj || !obj.sec) {
                    throw new TypeError('Conversion to Array failed');
                }
                return obj.sec.AXArray.axCoerce(obj);
            }
            var ASArray = function (_super) {
                __extends(ASArray, _super);
                function ASArray() {
                    _super.call(this);
                    this.value = createArrayValueFromArgs(this.sec, arguments);
                }
                ASArray.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASArray.prototype;
                    // option flags for sort and sortOn
                    defineNonEnumerableProperty(this, '$BgCASEINSENSITIVE', 1);
                    defineNonEnumerableProperty(this, '$BgDESCENDING', 2);
                    defineNonEnumerableProperty(this, '$BgUNIQUESORT', 4);
                    defineNonEnumerableProperty(this, '$BgRETURNINDEXEDARRAY', 8);
                    defineNonEnumerableProperty(this, '$BgNUMERIC', 16);
                    addPrototypeFunctionAlias(proto, '$Bgpush', asProto.generic_push);
                    addPrototypeFunctionAlias(proto, '$Bgpop', asProto.generic_pop);
                    addPrototypeFunctionAlias(proto, '$Bgshift', asProto.generic_shift);
                    addPrototypeFunctionAlias(proto, '$Bgunshift', asProto.generic_unshift);
                    addPrototypeFunctionAlias(proto, '$Bgreverse', asProto.generic_reverse);
                    addPrototypeFunctionAlias(proto, '$Bgconcat', asProto.generic_concat);
                    addPrototypeFunctionAlias(proto, '$Bgslice', asProto.generic_slice);
                    addPrototypeFunctionAlias(proto, '$Bgsplice', asProto.generic_splice);
                    addPrototypeFunctionAlias(proto, '$Bgjoin', asProto.generic_join);
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.generic_toString);
                    addPrototypeFunctionAlias(proto, '$BgindexOf', asProto.generic_indexOf);
                    addPrototypeFunctionAlias(proto, '$BglastIndexOf', asProto.generic_lastIndexOf);
                    addPrototypeFunctionAlias(proto, '$Bgevery', asProto.generic_every);
                    addPrototypeFunctionAlias(proto, '$Bgsome', asProto.generic_some);
                    addPrototypeFunctionAlias(proto, '$BgforEach', asProto.generic_forEach);
                    addPrototypeFunctionAlias(proto, '$Bgmap', asProto.generic_map);
                    addPrototypeFunctionAlias(proto, '$Bgfilter', asProto.generic_filter);
                    addPrototypeFunctionAlias(proto, '$Bgsort', asProto.generic_sort);
                    addPrototypeFunctionAlias(proto, '$BgsortOn', asProto.generic_sortOn);
                    addPrototypeFunctionAlias(proto, '$BghasOwnProperty', asProto.native_hasOwnProperty);
                    addPrototypeFunctionAlias(proto, '$BgpropertyIsEnumerable', asProto.native_propertyIsEnumerable);
                    addPrototypeFunctionAlias(proto, '$BgtoLocaleString', asProto.generic_toString);
                };
                ASArray.prototype.native_hasOwnProperty = function (nm) {
                    return this.axHasOwnProperty(makeMultiname(nm));
                };
                ASArray.prototype.native_propertyIsEnumerable = function (nm) {
                    if (typeof nm === 'number' || Shumway.isNumeric(nm = AVMX.axCoerceName(nm))) {
                        var descriptor = Object.getOwnPropertyDescriptor(this.value, nm);
                        return !!descriptor && descriptor.enumerable;
                    }
                    _super.prototype.native_propertyIsEnumerable.call(this, nm);
                };
                ASArray.axApply = function (self, args) {
                    return this.sec.createArrayUnsafe(createArrayValueFromArgs(this.sec, args));
                };
                ASArray.axConstruct = function (args) {
                    return this.sec.createArrayUnsafe(createArrayValueFromArgs(this.sec, args));
                };
                ASArray.prototype.push = function () {
                    // Amazingly, AS3 doesn't throw an error if `push` would make the argument too large.
                    // Instead, it just replaces the last element.
                    if (this.value.length + arguments.length > 4294967295) {
                        var limit = 4294967295 - this.value.length;
                        for (var i = 0; i < limit; i++) {
                            this.value.push(arguments[i]);
                        }
                        return 4294967295;
                    }
                    return this.value.push.apply(this.value, arguments);
                };
                ASArray.prototype.generic_push = function () {
                    if (this && this.value instanceof Array) {
                        return this.push.apply(this, arguments);
                    }
                    var n = this.axGetPublicProperty('length') >>> 0;
                    for (var i = 0; i < arguments.length; i++) {
                        this.axSetNumericProperty(n++, arguments[i]);
                    }
                    this.axSetPublicProperty('length', n);
                    return n;
                };
                ASArray.prototype.pop = function () {
                    return this.value.pop();
                };
                ASArray.prototype.generic_pop = function () {
                    if (this && this.value instanceof Array) {
                        return this.value.pop();
                    }
                    var len = this.axGetPublicProperty('length') >>> 0;
                    if (!len) {
                        this.axSetPublicProperty('length', 0);
                        return;
                    }
                    var retVal = this.axGetNumericProperty(len - 1);
                    rn.name = len - 1;
                    rn.namespaces = [AVMX.Namespace.PUBLIC];
                    this.axDeleteProperty(rn);
                    this.axSetPublicProperty('length', len - 1);
                    return retVal;
                };
                ASArray.prototype.shift = function () {
                    return this.value.shift();
                };
                ASArray.prototype.generic_shift = function () {
                    return coerceArray(this).shift();
                };
                ASArray.prototype.unshift = function () {
                    return this.value.unshift.apply(this.value, arguments);
                };
                ASArray.prototype.generic_unshift = function () {
                    var self = coerceArray(this);
                    return self.value.unshift.apply(self.value, arguments);
                };
                ASArray.prototype.reverse = function () {
                    this.value.reverse();
                    return this;
                };
                ASArray.prototype.generic_reverse = function () {
                    return coerceArray(this).reverse();
                };
                ASArray.prototype.concat = function () {
                    var value = this.value.slice();
                    for (var i = 0; i < arguments.length; i++) {
                        var a = arguments[i];
                        // Treat all objects with a `sec` property and a value that's an Array as
                        // concat-spreadable.
                        // TODO: verify that this is correct.
                        if (typeof a === 'object' && a && a.sec && Array.isArray(a.value)) {
                            value.push.apply(value, a.value);
                        } else {
                            value.push(a);
                        }
                    }
                    return this.sec.createArrayUnsafe(value);
                };
                ASArray.prototype.generic_concat = function () {
                    return coerceArray(this).concat.apply(this, arguments);
                };
                ASArray.prototype.slice = function (startIndex, endIndex) {
                    return this.sec.createArray(this.value.slice(startIndex, endIndex));
                };
                ASArray.prototype.generic_slice = function (startIndex, endIndex) {
                    return coerceArray(this).slice(startIndex, endIndex);
                };
                ASArray.prototype.splice = function () {
                    var o = this.value;
                    if (arguments.length === 0) {
                        return undefined;
                    }
                    return this.sec.createArray(o.splice.apply(o, arguments));
                };
                ASArray.prototype.generic_splice = function () {
                    return coerceArray(this).splice.apply(this, arguments);
                };
                ASArray.prototype.join = function (sep) {
                    return this.value.join(sep);
                };
                ASArray.prototype.generic_join = function (sep) {
                    return coerceArray(this).join(sep);
                };
                ASArray.prototype.toString = function () {
                    return this.value.join(',');
                };
                ASArray.prototype.generic_toString = function () {
                    return coerceArray(this).join(',');
                };
                ASArray.prototype.indexOf = function (value, fromIndex) {
                    return this.value.indexOf(value, fromIndex | 0);
                };
                ASArray.prototype.generic_indexOf = function (value, fromIndex) {
                    return coerceArray(this).indexOf(value, fromIndex | 0);
                };
                ASArray.prototype.lastIndexOf = function (value, fromIndex) {
                    return this.value.lastIndexOf(value, arguments.length > 1 ? fromIndex : 2147483647);
                };
                ASArray.prototype.generic_lastIndexOf = function (value, fromIndex) {
                    return coerceArray(this).lastIndexOf(value, arguments.length > 1 ? fromIndex : 2147483647);
                };
                ASArray.prototype.every = function (callbackfn, thisArg) {
                    if (!callbackfn || !callbackfn.value || typeof callbackfn.value !== 'function') {
                        return true;
                    }
                    thisArg = AVMX.ensureBoxedReceiver(this.sec, thisArg, callbackfn);
                    var o = this.value;
                    for (var i = 0; i < o.length; i++) {
                        if (callbackfn.value.call(thisArg, o[i], i, this) !== true) {
                            return false;
                        }
                    }
                    return true;
                };
                ASArray.prototype.generic_every = function (callbackfn, thisArg) {
                    return coerceArray(this).every(callbackfn, thisArg);
                };
                ASArray.prototype.some = function (callbackfn, thisArg) {
                    if (!callbackfn || !callbackfn.value || typeof callbackfn.value !== 'function') {
                        return false;
                    }
                    thisArg = AVMX.ensureBoxedReceiver(this.sec, thisArg, callbackfn);
                    var self = this;
                    return this.value.some(function (currentValue, index, array) {
                        return callbackfn.value.call(thisArg, currentValue, index, self);
                    });
                };
                ASArray.prototype.generic_some = function (callbackfn, thisArg) {
                    return coerceArray(this).some(callbackfn, thisArg);
                };
                ASArray.prototype.forEach = function (callbackfn, thisArg) {
                    if (!callbackfn || !callbackfn.value || typeof callbackfn.value !== 'function') {
                        return;
                    }
                    thisArg = AVMX.ensureBoxedReceiver(this.sec, thisArg, callbackfn);
                    var self = this;
                    this.value.forEach(function (currentValue, index) {
                        callbackfn.value.call(thisArg, currentValue, index, self);
                    });
                };
                ASArray.prototype.generic_forEach = function (callbackfn, thisArg) {
                    return coerceArray(this).forEach(callbackfn, thisArg);
                };
                ASArray.prototype.map = function (callbackfn, thisArg) {
                    if (!callbackfn || !callbackfn.value || typeof callbackfn.value !== 'function') {
                        return this.sec.createArrayUnsafe([]);
                    }
                    thisArg = AVMX.ensureBoxedReceiver(this.sec, thisArg, callbackfn);
                    var self = this;
                    return this.sec.createArrayUnsafe(this.value.map(function (currentValue, index) {
                        return callbackfn.value.call(thisArg, currentValue, index, self);
                    }));
                };
                ASArray.prototype.generic_map = function (callbackfn, thisArg) {
                    return coerceArray(this).map(callbackfn, thisArg);
                };
                ASArray.prototype.filter = function (callbackfn, thisArg) {
                    if (!callbackfn || !callbackfn.value || typeof callbackfn.value !== 'function') {
                        return this.sec.createArrayUnsafe([]);
                    }
                    thisArg = AVMX.ensureBoxedReceiver(this.sec, thisArg, callbackfn);
                    var result = [];
                    var o = this.value;
                    for (var i = 0; i < o.length; i++) {
                        if (callbackfn.value.call(thisArg, o[i], i, this) === true) {
                            result.push(o[i]);
                        }
                    }
                    return this.sec.createArrayUnsafe(result);
                };
                ASArray.prototype.generic_filter = function (callbackfn, thisArg) {
                    return coerceArray(this).filter(callbackfn, thisArg);
                };
                ASArray.prototype.toLocaleString = function () {
                    var value = this.sec.AXArray.axCoerce(this).value;
                    var out = '';
                    for (var i = 0, n = value.length; i < n; i++) {
                        var val = value[i];
                        if (val !== null && val !== undefined) {
                            out += val.toLocaleString();
                        }
                        if (i + 1 < n) {
                            out += ',';
                        }
                    }
                    return out;
                };
                ASArray.prototype.sort = function () {
                    var o = this.value;
                    if (arguments.length === 0) {
                        o.sort();
                        return this;
                    }
                    var compareFunction;
                    var options = 0;
                    if (this.sec.AXFunction.axIsInstanceOf(arguments[0])) {
                        compareFunction = arguments[0].value;
                    } else if (Shumway.isNumber(arguments[0])) {
                        options = arguments[0];
                    }
                    if (Shumway.isNumber(arguments[1])) {
                        options = arguments[1];
                    }
                    if (!options) {
                        // Just passing compareFunction is ok because `undefined` is treated as not passed in JS.
                        o.sort(compareFunction);
                        return this;
                    }
                    if (!compareFunction) {
                        compareFunction = AVMX.axDefaultCompareFunction;
                    }
                    var sortOrder = options & 2    /* DESCENDING */ ? -1 : 1;
                    o.sort(function (a, b) {
                        return AVMX.axCompare(a, b, options, sortOrder, compareFunction);
                    });
                    return this;
                };
                ASArray.prototype.generic_sort = function () {
                    return coerceArray(this).sort.apply(this, arguments);
                };
                ASArray.prototype.sortOn = function (names, options) {
                    if (arguments.length === 0) {
                        this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'Array/http://adobe.com/AS3/2006/builtin::sortOn()', '1', '0');
                    }
                    // The following oddities in how the arguments are used are gleaned from Tamarin, so hush.
                    var o = this.value;
                    // The options we'll end up using.
                    var optionsList = [];
                    if (Shumway.isString(names)) {
                        names = [Multiname.getPublicMangledName(names)];
                        // If the name is a string, coerce `options` to int.
                        optionsList = [options | 0];
                    } else if (names && Array.isArray(names.value)) {
                        names = names.value;
                        for (var i = 0; i < names.length; i++) {
                            names[i] = Multiname.getPublicMangledName(names[i]);
                        }
                        if (options && Array.isArray(options.value)) {
                            options = options.value;
                            // Use the options Array only if it's the same length as names.
                            if (options.length === names.length) {
                                for (var i = 0; i < options.length; i++) {
                                    optionsList[i] = options[i] | 0;
                                }
                            } else {
                                for (var i = 0; i < names.length; i++) {
                                    optionsList[i] = 0;
                                }
                            }
                        } else {
                            var optionsVal = options | 0;
                            for (var i = 0; i < names.length; i++) {
                                optionsList[i] = optionsVal;
                            }
                        }
                    } else {
                        // Not supplying either a String or an Array means nothing is sorted on.
                        return this;
                    }
                    release || assert(optionsList.length === names.length);
                    // For use with uniqueSort and returnIndexedArray once we support them.
                    var optionsVal = optionsList[0];
                    release || Shumway.Debug.assertNotImplemented(!(optionsVal & 4    /* UNIQUESORT */), 'UNIQUESORT');
                    release || Shumway.Debug.assertNotImplemented(!(optionsVal & 8    /* RETURNINDEXEDARRAY */), 'RETURNINDEXEDARRAY');
                    o.sort(function (a, b) {
                        return AVMX.axCompareFields(a, b, names, optionsList);
                    });
                    return this;
                };
                ASArray.prototype.generic_sortOn = function () {
                    return coerceArray(this).sortOn.apply(this, arguments);
                };
                Object.defineProperty(ASArray.prototype, 'length', {
                    get: function () {
                        return this.value.length;
                    },
                    set: function (newLength) {
                        this.value.length = newLength >>> 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASArray.prototype.axGetEnumerableKeys = function () {
                    // Get the numeric Array keys first ...
                    var keys = Object.keys(this.value);
                    // ... then the keys that live on the array object.
                    return keys.concat(_super.prototype.axGetEnumerableKeys.call(this));
                };
                ASArray.prototype.axHasPropertyInternal = function (mn) {
                    var name = mn.name;
                    if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                        release || assert(mn.isRuntimeName());
                        return name in this.value;
                    }
                    if (this.traits.getTrait(mn.namespaces, name)) {
                        return true;
                    }
                    return '$Bg' + name in this;
                };
                ASArray.prototype.axHasOwnProperty = function (mn) {
                    var name = mn.name;
                    if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                        release || assert(mn.isRuntimeName());
                        return this.value.hasOwnProperty(name);
                    }
                    return !!this.traits.getTrait(mn.namespaces, name) || this.hasOwnProperty('$Bg' + name);
                };
                ASArray.prototype.axGetProperty = function (mn) {
                    var name = mn.name;
                    if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                        return this.value[name];
                    }
                    return _super.prototype.axGetProperty.call(this, mn);
                };
                ASArray.prototype.axSetProperty = function (mn, value, bc) {
                    release || AVMX.checkValue(value);
                    var name = mn.name;
                    if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                        this.value[name] = value;
                        return;
                    }
                    _super.prototype.axSetProperty.call(this, mn, value, bc);
                };
                ASArray.prototype.axDeleteProperty = function (mn) {
                    var name = mn.name;
                    if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                        return delete this.value[name];
                    }
                    // Cannot delete array traits.
                    if (this.traits.getTrait(mn.namespaces, name)) {
                        return false;
                    }
                    return delete this['$Bg' + name];
                };
                ASArray.prototype.axGetPublicProperty = function (nm) {
                    if (typeof nm === 'number' || Shumway.isNumeric(nm = AVMX.axCoerceName(nm))) {
                        return this.value[nm];
                    }
                    return this['$Bg' + nm];
                };
                ASArray.prototype.axSetPublicProperty = function (nm, value) {
                    release || AVMX.checkValue(value);
                    if (typeof nm === 'number' || Shumway.isNumeric(nm = AVMX.axCoerceName(nm))) {
                        this.value[nm] = value;
                        return;
                    }
                    this['$Bg' + nm] = value;
                };
                return ASArray;
            }(ASObject);
            AS.ASArray = ASArray;
            var ASFunction = function (_super) {
                __extends(ASFunction, _super);
                function ASFunction() {
                    _super.apply(this, arguments);
                    this._prototypeInitialzed = false;
                }
                ASFunction.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASFunction.prototype;
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$Bgcall', asProto.call);
                    addPrototypeFunctionAlias(proto, '$Bgapply', asProto.apply);
                    defineNonEnumerableProperty(proto, 'value', asProto.native_functionValue);
                };
                ASFunction.prototype.axConstruct = function (args) {
                    var prototype = this.prototype;
                    // AS3 allows setting null/undefined prototypes. In order to make our value checking work,
                    // we need to set a null-prototype that has the right inheritance chain. Since AS3 doesn't
                    // have `__proto__` or `getPrototypeOf`, this is completely hidden from content.
                    if (isNullOrUndefined(prototype)) {
                        prototype = this.sec.AXFunctionUndefinedPrototype;
                    }
                    release || assert(typeof prototype === 'object');
                    release || AVMX.checkValue(prototype);
                    var object = Object.create(prototype);
                    object.__ctorFunction = this;
                    this.value.apply(object, args);
                    return object;
                };
                ASFunction.prototype.axIsInstanceOf = function (obj) {
                    return obj && obj.__ctorFunction === this;
                };
                ASFunction.prototype.native_functionValue = function () {
                };
                Object.defineProperty(ASFunction.prototype, 'prototype', {
                    get: function () {
                        if (!this._prototypeInitialzed) {
                            this._prototype = Object.create(this.sec.AXObject.tPrototype);
                            this._prototypeInitialzed = true;
                        }
                        return this._prototype;
                    },
                    set: function (prototype) {
                        if (isNullOrUndefined(prototype)) {
                            prototype = undefined;
                        } else if (typeof prototype !== 'object' || this.sec.isPrimitive(prototype)) {
                            this.sec.throwError('TypeError', AVMX.Errors.PrototypeTypeError);
                        }
                        this._prototypeInitialzed = true;
                        this._prototype = prototype;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASFunction.prototype, 'length', {
                    get: function () {
                        if (this.value.methodInfo) {
                            return this.value.methodInfo.parameters.length;
                        }
                        return this.value.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASFunction.prototype.toString = function () {
                    return 'function Function() {}';
                };
                ASFunction.prototype.call = function (thisArg) {
                    thisArg = AVMX.ensureBoxedReceiver(this.sec, thisArg, this);
                    return this.value.apply(thisArg, AVMX.sliceArguments(arguments, 1));
                };
                ASFunction.prototype.apply = function (thisArg, argArray) {
                    thisArg = AVMX.ensureBoxedReceiver(this.sec, thisArg, this);
                    return this.value.apply(thisArg, argArray ? argArray.value : undefined);
                };
                ASFunction.prototype.axCall = function (thisArg) {
                    return this.value.apply(thisArg, AVMX.sliceArguments(arguments, 1));
                };
                ASFunction.prototype.axApply = function (thisArg, argArray) {
                    return this.value.apply(thisArg, argArray);
                };
                return ASFunction;
            }(ASObject);
            AS.ASFunction = ASFunction;
            var ASMethodClosure = function (_super) {
                __extends(ASMethodClosure, _super);
                function ASMethodClosure() {
                    _super.apply(this, arguments);
                }
                ASMethodClosure.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASMethodClosure.prototype;
                    defineNonEnumerableProperty(proto, '$Bgcall', asProto.call);
                    defineNonEnumerableProperty(proto, '$Bgapply', asProto.apply);
                };
                ASMethodClosure.Create = function (receiver, method) {
                    var closure = Object.create(this.sec.AXMethodClosure.tPrototype);
                    closure.receiver = receiver;
                    closure.value = method;
                    closure.methodInfo = method.methodInfo;
                    return closure;
                };
                Object.defineProperty(ASMethodClosure.prototype, 'prototype', {
                    get: function () {
                        return null;
                    },
                    set: function (prototype) {
                        this.sec.throwError('ReferenceError', AVMX.Errors.ConstWriteError, 'prototype', 'MethodClosure');
                    },
                    enumerable: true,
                    configurable: true
                });
                ASMethodClosure.prototype.axCall = function (ignoredThisArg) {
                    return this.value.apply(this.receiver, AVMX.sliceArguments(arguments, 1));
                };
                ASMethodClosure.prototype.axApply = function (ignoredThisArg, argArray) {
                    return this.value.apply(this.receiver, argArray);
                };
                ASMethodClosure.prototype.call = function (ignoredThisArg) {
                    return this.value.apply(this.receiver, AVMX.sliceArguments(arguments, 1));
                };
                ASMethodClosure.prototype.apply = function (ignoredThisArg, argArray) {
                    return this.value.apply(this.receiver, argArray ? argArray.value : undefined);
                };
                return ASMethodClosure;
            }(ASFunction);
            AS.ASMethodClosure = ASMethodClosure;
            var ASBoolean = function (_super) {
                __extends(ASBoolean, _super);
                function ASBoolean() {
                    _super.apply(this, arguments);
                }
                ASBoolean.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASBoolean.prototype;
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$BgvalueOf', asProto.valueOf);
                };
                ASBoolean.prototype.toString = function () {
                    return this.value.toString();
                };
                ASBoolean.prototype.valueOf = function () {
                    return this.value.valueOf();
                };
                return ASBoolean;
            }(ASObject);
            AS.ASBoolean = ASBoolean;
            var ASString = function (_super) {
                __extends(ASString, _super);
                function ASString() {
                    _super.apply(this, arguments);
                }
                ASString.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASString.prototype;
                    addPrototypeFunctionAlias(proto, '$BgindexOf', asProto.generic_indexOf);
                    addPrototypeFunctionAlias(proto, '$BglastIndexOf', asProto.generic_lastIndexOf);
                    addPrototypeFunctionAlias(proto, '$BgcharAt', asProto.generic_charAt);
                    addPrototypeFunctionAlias(proto, '$BgcharCodeAt', asProto.generic_charCodeAt);
                    addPrototypeFunctionAlias(proto, '$Bgconcat', asProto.generic_concat);
                    addPrototypeFunctionAlias(proto, '$BglocaleCompare', asProto.generic_localeCompare);
                    addPrototypeFunctionAlias(proto, '$Bgmatch', asProto.generic_match);
                    addPrototypeFunctionAlias(proto, '$Bgreplace', asProto.generic_replace);
                    addPrototypeFunctionAlias(proto, '$Bgsearch', asProto.generic_search);
                    addPrototypeFunctionAlias(proto, '$Bgslice', asProto.generic_slice);
                    addPrototypeFunctionAlias(proto, '$Bgsplit', asProto.generic_split);
                    addPrototypeFunctionAlias(proto, '$Bgsubstring', asProto.generic_substring);
                    addPrototypeFunctionAlias(proto, '$Bgsubstr', asProto.generic_substr);
                    addPrototypeFunctionAlias(proto, '$BgtoLowerCase', asProto.generic_toLowerCase);
                    addPrototypeFunctionAlias(proto, '$BgtoLocaleLowerCase', asProto.generic_toLowerCase);
                    addPrototypeFunctionAlias(proto, '$BgtoUpperCase', asProto.generic_toUpperCase);
                    addPrototypeFunctionAlias(proto, '$BgtoLocaleUpperCase', asProto.generic_toUpperCase);
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.public_toString);
                    addPrototypeFunctionAlias(proto, '$BgvalueOf', asProto.public_valueOf);
                    addPrototypeFunctionAlias(this, '$BgfromCharCode', ASString.fromCharCode);
                };
                ASString.fromCharCode = function () {
                    var charcodes = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        charcodes[_i - 0] = arguments[_i];
                    }
                    return String.fromCharCode.apply(null, charcodes);
                };
                ASString.prototype.indexOf = function (char, i) {
                    return this.value.indexOf(char, i);
                };
                ASString.prototype.lastIndexOf = function (char, i) {
                    return this.value.lastIndexOf(char, i);
                };
                ASString.prototype.charAt = function (index) {
                    return this.value.charAt(index);
                };
                ASString.prototype.charCodeAt = function (index) {
                    return this.value.charCodeAt(index);
                };
                ASString.prototype.concat = function () {
                    return this.value.concat.apply(this.value, arguments);
                };
                ASString.prototype.localeCompare = function (other) {
                    if (arguments.length > 1) {
                        this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'Function/<anonymous>()', 0, 2);
                    }
                    var value = this.value;
                    release || assert(typeof this.value === 'string');
                    other = String(other);
                    if (other === value) {
                        return 0;
                    }
                    var len = Math.min(value.length, other.length);
                    for (var j = 0; j < len; j++) {
                        if (value[j] !== other[j]) {
                            return value.charCodeAt(j) - other.charCodeAt(j);
                        }
                    }
                    return value.length > other.length ? 1 : -1;
                };
                ASString.prototype.match = function (pattern) {
                    if (this.sec.AXRegExp.axIsType(pattern)) {
                        pattern = pattern.value;
                    } else {
                        pattern = AVMX.axCoerceString(pattern);
                    }
                    var result = this.value.match(pattern);
                    if (!result) {
                        return null;
                    }
                    try {
                        return transformJStoASRegExpMatchArray(this.sec, result);
                    } catch (e) {
                        return null;
                    }
                };
                ASString.prototype.replace = function (pattern, repl) {
                    if (this.sec.AXRegExp.axIsType(pattern)) {
                        pattern = pattern.value;
                    } else {
                        pattern = AVMX.axCoerceString(pattern);
                    }
                    if (this.sec.AXFunction.axIsType(repl)) {
                        repl = repl.value;
                    }
                    try {
                        return this.value.replace(pattern, repl);
                    } catch (e) {
                        return this.value;
                    }
                };
                ASString.prototype.search = function (pattern) {
                    if (this.sec.AXRegExp.axIsType(pattern)) {
                        pattern = pattern.value;
                    } else {
                        pattern = AVMX.axCoerceString(pattern);
                    }
                    try {
                        return this.value.search(pattern);
                    } catch (e) {
                        return -1;
                    }
                };
                ASString.prototype.slice = function (start, end) {
                    start = arguments.length < 1 ? 0 : start | 0;
                    end = arguments.length < 2 ? 4294967295 : end | 0;
                    return this.value.slice(start, end);
                };
                ASString.prototype.split = function (separator, limit) {
                    if (this.sec.AXRegExp.axIsType(separator)) {
                        separator = separator.value;
                    } else {
                        separator = AVMX.axCoerceString(separator);
                    }
                    limit = limit === undefined ? -1 : limit | 0;
                    try {
                        return this.sec.createArray(this.value.split(separator, limit));
                    } catch (e) {
                        return this.sec.createArrayUnsafe([this.value]);
                    }
                };
                ASString.prototype.substring = function (start, end) {
                    return this.value.substring(start, end);
                };
                ASString.prototype.substr = function (from, length) {
                    return this.value.substr(from, length);
                };
                ASString.prototype.toLocaleLowerCase = function () {
                    return this.value.toLowerCase();
                };
                ASString.prototype.toLowerCase = function () {
                    if (as3Compatibility) {
                        return as3ToLowerCase(this.value);
                    }
                    return this.value.toLowerCase();
                };
                ASString.prototype.toLocaleUpperCase = function () {
                    return this.value.toUpperCase();
                };
                ASString.prototype.toUpperCase = function () {
                    return this.value.toUpperCase();
                };
                // The String.prototype versions of these methods are generic, so the implementation is
                // different.
                ASString.prototype.generic_indexOf = function (char, i) {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.indexOf.call(receiver, char, i);
                };
                ASString.prototype.generic_lastIndexOf = function (char, i) {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.lastIndexOf.call(receiver, char, i);
                };
                ASString.prototype.generic_charAt = function (index) {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.charAt.call(receiver, index);
                };
                ASString.prototype.generic_charCodeAt = function (index) {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.charCodeAt.call(receiver, index);
                };
                ASString.prototype.generic_concat = function () {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.concat.apply(receiver, arguments);
                };
                ASString.prototype.generic_localeCompare = function (other) {
                    var receiver = this.sec.AXString.axBox(String(this));
                    return receiver.localeCompare.apply(receiver, arguments);
                };
                ASString.prototype.generic_match = function (pattern) {
                    return this.sec.AXString.axBox(String(this)).match(pattern);
                };
                ASString.prototype.generic_replace = function (pattern, repl) {
                    return this.sec.AXString.axBox(String(this)).replace(pattern, repl);
                };
                ASString.prototype.generic_search = function (pattern) {
                    return this.sec.AXString.axBox(String(this)).search(pattern);
                };
                ASString.prototype.generic_slice = function (start, end) {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.slice.call(receiver, start, end);
                };
                ASString.prototype.generic_split = function (separator, limit) {
                    limit = arguments.length < 2 ? 4294967295 : limit | 0;
                    return this.sec.AXString.axBox(String(this)).split(separator, limit);
                };
                ASString.prototype.generic_substring = function (start, end) {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.substring.call(receiver, start, end);
                };
                ASString.prototype.generic_substr = function (from, length) {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.substr.call(receiver, from, length);
                };
                ASString.prototype.generic_toLowerCase = function () {
                    var receiver = this == undefined ? '' : this;
                    if (as3Compatibility) {
                        return as3ToLowerCase(String(receiver));
                    }
                    String.prototype.toLowerCase.call(receiver);
                };
                ASString.prototype.generic_toUpperCase = function () {
                    var receiver = this == undefined ? '' : this;
                    return String.prototype.toUpperCase.call(receiver);
                };
                ASString.prototype.toString = function () {
                    return this.value.toString();
                };
                ASString.prototype.public_toString = function () {
                    if (this === this.sec.AXString.dPrototype) {
                        return '';
                    }
                    if (this.axClass !== this.sec.AXString) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'String.prototype.toString');
                    }
                    return this.value.toString();
                };
                ASString.prototype.valueOf = function () {
                    return this.value.valueOf();
                };
                ASString.prototype.public_valueOf = function () {
                    if (this === this.sec.AXString.dPrototype) {
                        return '';
                    }
                    if (this.axClass !== this.sec.AXString) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'String.prototype.valueOf');
                    }
                    return this.value.valueOf();
                };
                Object.defineProperty(ASString.prototype, 'length', {
                    get: function () {
                        return this.value.length;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASString.classNatives = [String];
                return ASString;
            }(ASObject);
            AS.ASString = ASString;
            var ASNumber = function (_super) {
                __extends(ASNumber, _super);
                function ASNumber() {
                    _super.apply(this, arguments);
                }
                ASNumber.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASNumber.prototype;
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$BgtoLocaleString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$BgvalueOf', asProto.valueOf);
                    addPrototypeFunctionAlias(proto, '$BgtoFixed', asProto.toFixed);
                    addPrototypeFunctionAlias(proto, '$BgtoExponential', asProto.toExponential);
                    addPrototypeFunctionAlias(proto, '$BgtoPrecision', asProto.toPrecision);
                    defineNonEnumerableProperty(this, '$BgNaN', Number.NaN);
                    defineNonEnumerableProperty(this, '$BgNEGATIVE_INFINITY', -1 / 0);
                    defineNonEnumerableProperty(this, '$BgPOSITIVE_INFINITY', 1 / 0);
                    defineNonEnumerableProperty(this, '$BgMAX_VALUE', Number.MAX_VALUE);
                    defineNonEnumerableProperty(this, '$BgMIN_VALUE', Number.MIN_VALUE);
                    defineNonEnumerableProperty(this, '$BgE', Math.E);
                    defineNonEnumerableProperty(this, '$BgLN10', Math.LN10);
                    defineNonEnumerableProperty(this, '$BgLN2', Math.LN2);
                    defineNonEnumerableProperty(this, '$BgLOG10E', Math.LOG10E);
                    defineNonEnumerableProperty(this, '$BgLOG2E', Math.LOG2E);
                    defineNonEnumerableProperty(this, '$BgPI', Math.PI);
                    defineNonEnumerableProperty(this, '$BgSQRT1_2', Math.SQRT2);
                    defineNonEnumerableProperty(this, '$BgSQRT2', Math.SQRT2);
                };
                ASNumber.prototype.toString = function (radix) {
                    if (arguments.length === 0) {
                        radix = 10;
                    } else {
                        radix = radix | 0;
                        if (radix < 2 || radix > 36) {
                            this.sec.throwError('RangeError', AVMX.Errors.InvalidRadixError, radix);
                        }
                    }
                    if (this.axClass !== this.sec.AXNumber) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'Number.prototype.toString');
                    }
                    return this.value.toString(radix);
                };
                ASNumber.prototype.valueOf = function () {
                    if (this.axClass !== this.sec.AXNumber) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'Number.prototype.valueOf');
                    }
                    return this.value;
                };
                ASNumber.prototype.toExponential = function (p) {
                    p = p | 0;
                    if (p < 0 || p > 20) {
                        this.sec.throwError('RangeError', AVMX.Errors.InvalidPrecisionError);
                    }
                    if (this.axClass !== this.sec.AXNumber) {
                        return 'NaN';
                    }
                    return this.value.toExponential(p);
                };
                ASNumber.prototype.toPrecision = function (p) {
                    if (!p) {
                        p = 1;
                    } else {
                        p = p | 0;
                    }
                    if (p < 1 || p > 21) {
                        this.sec.throwError('RangeError', AVMX.Errors.InvalidPrecisionError);
                    }
                    if (this.axClass !== this.sec.AXNumber) {
                        return 'NaN';
                    }
                    return this.value.toPrecision(p);
                };
                ASNumber.prototype.toFixed = function (p) {
                    p = p | 0;
                    if (p < 0 || p > 20) {
                        this.sec.throwError('RangeError', AVMX.Errors.InvalidPrecisionError);
                    }
                    if (this.axClass !== this.sec.AXNumber) {
                        return 'NaN';
                    }
                    return this.value.toFixed(p);
                };
                ASNumber._minValue = function () {
                    return Number.MIN_VALUE;
                };
                // https://bugzilla.mozilla.org/show_bug.cgi?id=564839
                ASNumber.convertStringToDouble = function (s) {
                    var i = s.indexOf(String.fromCharCode(0));
                    if (i >= 0) {
                        return +s.substring(0, i);
                    }
                    return +s;
                };
                ASNumber.classNatives = [Math];
                return ASNumber;
            }(ASObject);
            AS.ASNumber = ASNumber;
            var ASInt = function (_super) {
                __extends(ASInt, _super);
                function ASInt() {
                    _super.apply(this, arguments);
                }
                ASInt.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASInt.prototype;
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$BgtoLocaleString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$BgvalueOf', asProto.valueOf);
                    defineNonEnumerableProperty(this, '$BgMAX_VALUE', 2147483647);
                    defineNonEnumerableProperty(this, '$BgMIN_VALUE', -2147483648);
                };
                ASInt.prototype.toString = function (radix) {
                    if (arguments.length === 0) {
                        radix = 10;
                    } else {
                        radix = radix | 0;
                        if (radix < 2 || radix > 36) {
                            this.sec.throwError('RangeError', AVMX.Errors.InvalidRadixError, radix);
                        }
                    }
                    if (this.axClass !== this.sec.AXNumber) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'Number.prototype.toString');
                    }
                    return this.value.toString(radix);
                };
                ASInt.prototype.valueOf = function () {
                    if (this.axClass !== this.sec.AXNumber) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'Number.prototype.valueOf');
                    }
                    return this.value;
                };
                ASInt.staticNatives = [Math];
                ASInt.instanceNatives = [ASNumber.prototype];
                return ASInt;
            }(ASNumber);
            AS.ASInt = ASInt;
            var ASUint = function (_super) {
                __extends(ASUint, _super);
                function ASUint() {
                    _super.apply(this, arguments);
                }
                ASUint.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASUint.prototype;
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$BgtoLocaleString', asProto.toString);
                    addPrototypeFunctionAlias(proto, '$BgvalueOf', asProto.valueOf);
                    defineNonEnumerableProperty(this, '$BgMAX_VALUE', 4294967295);
                    defineNonEnumerableProperty(this, '$BgMIN_VALUE', 0);
                };
                ASUint.prototype.toString = function (radix) {
                    if (arguments.length === 0) {
                        radix = 10;
                    } else {
                        radix = radix | 0;
                        if (radix < 2 || radix > 36) {
                            this.sec.throwError('RangeError', AVMX.Errors.InvalidRadixError, radix);
                        }
                    }
                    if (this.axClass !== this.sec.AXNumber) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'Number.prototype.toString');
                    }
                    return this.value.toString(radix);
                };
                ASUint.prototype.valueOf = function () {
                    if (this.axClass !== this.sec.AXNumber) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'Number.prototype.valueOf');
                    }
                    return this.value;
                };
                ASUint.staticNatives = [Math];
                ASUint.instanceNatives = [ASNumber.prototype];
                return ASUint;
            }(ASNumber);
            AS.ASUint = ASUint;
            var ASMath = function (_super) {
                __extends(ASMath, _super);
                function ASMath() {
                    _super.apply(this, arguments);
                }
                ASMath.classNatives = [Math];
                ASMath.classInitializer = function () {
                    defineNonEnumerableProperty(this, '$BgE', Math.E);
                    defineNonEnumerableProperty(this, '$BgLN10', Math.LN10);
                    defineNonEnumerableProperty(this, '$BgLN2', Math.LN2);
                    defineNonEnumerableProperty(this, '$BgLOG10E', Math.LOG10E);
                    defineNonEnumerableProperty(this, '$BgLOG2E', Math.LOG2E);
                    defineNonEnumerableProperty(this, '$BgPI', Math.PI);
                    defineNonEnumerableProperty(this, '$BgSQRT1_2', Math.SQRT2);
                    defineNonEnumerableProperty(this, '$BgSQRT2', Math.SQRT2);
                };
                return ASMath;
            }(ASObject);
            AS.ASMath = ASMath;
            var ASRegExp = function (_super) {
                __extends(ASRegExp, _super);
                function ASRegExp(pattern, flags) {
                    _super.call(this);
                    this._dotall = false;
                    this._extended = false;
                    this._captureNames = [];
                    var source;
                    if (pattern === undefined) {
                        pattern = source = '';
                    } else if (this.sec.AXRegExp.axIsType(pattern)) {
                        if (flags) {
                            this.sec.throwError('TypeError', AVMX.Errors.RegExpFlagsArgumentError);
                        }
                        source = pattern.source;
                        pattern = pattern.value;
                    } else {
                        pattern = String(pattern);
                        // Escape all forward slashes.
                        source = pattern.replace(/(^|^[\/]|(?:\\\\)+)\//g, '$1\\/');
                        if (flags) {
                            var f = flags;
                            flags = '';
                            for (var i = 0; i < f.length; i++) {
                                var flag = f[i];
                                switch (flag) {
                                case 's':
                                    // With the s flag set, . will match the newline character.
                                    this._dotall = true;
                                    break;
                                case 'x':
                                    // With the x flag set, spaces in the regular expression, will be ignored as part of
                                    // the pattern.
                                    this._extended = true;
                                    break;
                                case 'g':
                                case 'i':
                                case 'm':
                                    // Only keep valid flags since an ECMAScript compatible RegExp implementation will
                                    // throw on invalid ones. We have to avoid that in ActionScript.
                                    flags += flag;
                                }
                            }
                        }
                        pattern = this._parse(source);
                    }
                    try {
                        this.value = new RegExp(pattern, flags);
                    } catch (e) {
                        // Our pattern pre-parser should have eliminated most errors, but in some cases we can't
                        // meaningfully detect them. If that happens, just catch the error and substitute an
                        // unmatchable pattern here.
                        this.value = new RegExp(ASRegExp.UNMATCHABLE_PATTERN, flags);
                    }
                    this._source = source;
                }
                // Parses and sanitizes a AS3 RegExp pattern to be used in JavaScript. Silently fails and
                // returns an unmatchable pattern of the source turns out to be invalid.
                ASRegExp.prototype._parse = function (pattern) {
                    var result = '';
                    var captureNames = this._captureNames;
                    var parens = [];
                    var atoms = 0;
                    for (var i = 0; i < pattern.length; i++) {
                        var char = pattern[i];
                        switch (char) {
                        case '(':
                            result += char;
                            parens.push(atoms > 1 ? atoms - 1 : atoms);
                            atoms = 0;
                            if (pattern[i + 1] === '?') {
                                switch (pattern[i + 2]) {
                                case ':':
                                case '=':
                                case '!':
                                    result += '?' + pattern[i + 2];
                                    i += 2;
                                    break;
                                default:
                                    if (/\(\?P<([\w$]+)>/.exec(pattern.substr(i))) {
                                        var name = RegExp.$1;
                                        if (name !== 'length') {
                                            captureNames.push(name);
                                        }
                                        if (captureNames.indexOf(name) > -1) {
                                        }
                                        i += RegExp.lastMatch.length - 1;
                                    } else {
                                        return ASRegExp.UNMATCHABLE_PATTERN;
                                    }
                                }
                            } else {
                                captureNames.push(null);
                            }
                            // 406 seems to be the maximum number of capturing groups allowed in a pattern.
                            // Examined by testing.
                            if (captureNames.length > 406) {
                                return ASRegExp.UNMATCHABLE_PATTERN;
                            }
                            break;
                        case ')':
                            if (!parens.length) {
                                return ASRegExp.UNMATCHABLE_PATTERN;
                            }
                            result += char;
                            atoms = parens.pop() + 1;
                            break;
                        case '|':
                            result += char;
                            break;
                        case '\\':
                            result += char;
                            if (/\\|c[A-Z]|x[0-9,a-z,A-Z]{2}|u[0-9,a-z,A-Z]{4}|./.exec(pattern.substr(i + 1))) {
                                result += RegExp.lastMatch;
                                i += RegExp.lastMatch.length;
                            }
                            if (atoms <= 1) {
                                atoms++;
                            }
                            break;
                        case '[':
                            if (/\[[^\]]*\]/.exec(pattern.substr(i))) {
                                result += RegExp.lastMatch;
                                i += RegExp.lastMatch.length - 1;
                                if (atoms <= 1) {
                                    atoms++;
                                }
                            } else {
                                return ASRegExp.UNMATCHABLE_PATTERN;
                            }
                            break;
                        case '{':
                            if (/\{[^\{]*?(?:,[^\{]*?)?\}/.exec(pattern.substr(i))) {
                                result += RegExp.lastMatch;
                                i += RegExp.lastMatch.length - 1;
                            } else {
                                return ASRegExp.UNMATCHABLE_PATTERN;
                            }
                            break;
                        case '.':
                            if (this._dotall) {
                                result += '[\\s\\S]';
                            } else {
                                result += char;
                            }
                            if (atoms <= 1) {
                                atoms++;
                            }
                            break;
                        case '?':
                        case '*':
                        case '+':
                            if (!atoms) {
                                return ASRegExp.UNMATCHABLE_PATTERN;
                            }
                            result += char;
                            if (pattern[i + 1] === '?') {
                                i++;
                                result += '?';
                            }
                            break;
                        case ' ':
                            if (this._extended) {
                                break;
                            }
                        default:
                            result += char;
                            if (atoms <= 1) {
                                atoms++;
                            }
                        }
                        // 32767 seams to be the maximum allowed length for RegExps in SpiderMonkey.
                        // Examined by testing.
                        if (result.length > 32767) {
                            return ASRegExp.UNMATCHABLE_PATTERN;
                        }
                    }
                    if (parens.length) {
                        return ASRegExp.UNMATCHABLE_PATTERN;
                    }
                    return result;
                };
                ASRegExp.prototype.ecmaToString = function () {
                    var out = '/' + this._source + '/';
                    if (this.value.global)
                        out += 'g';
                    if (this.value.ignoreCase)
                        out += 'i';
                    if (this.value.multiline)
                        out += 'm';
                    if (this._dotall)
                        out += 's';
                    if (this._extended)
                        out += 'x';
                    return out;
                };
                ASRegExp.prototype.axCall = function (ignoredThisArg) {
                    return this.exec.apply(this, arguments);
                };
                ASRegExp.prototype.axApply = function (ignoredThisArg, argArray) {
                    return this.exec.apply(this, argArray);
                };
                Object.defineProperty(ASRegExp.prototype, 'source', {
                    get: function () {
                        return this._source;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASRegExp.prototype, 'global', {
                    get: function () {
                        return this.value.global;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASRegExp.prototype, 'ignoreCase', {
                    get: function () {
                        return this.value.ignoreCase;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASRegExp.prototype, 'multiline', {
                    get: function () {
                        return this.value.multiline;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASRegExp.prototype, 'lastIndex', {
                    get: function () {
                        return this.value.lastIndex;
                    },
                    set: function (value) {
                        this.value.lastIndex = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASRegExp.prototype, 'dotall', {
                    get: function () {
                        return this._dotall;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASRegExp.prototype, 'extended', {
                    get: function () {
                        return this._extended;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASRegExp.prototype.exec = function (str) {
                    if (str === void 0) {
                        str = '';
                    }
                    var result = this.value.exec(str);
                    if (!result) {
                        return null;
                    }
                    var axResult = transformJStoASRegExpMatchArray(this.sec, result);
                    var captureNames = this._captureNames;
                    if (captureNames) {
                        for (var i = 0; i < captureNames.length; i++) {
                            var name = captureNames[i];
                            if (name !== null) {
                                // In AS3, non-matched named capturing groups return an empty string.
                                var value = result[i + 1] || '';
                                result[name] = value;
                                axResult.axSetPublicProperty(name, value);
                            }
                        }
                        return axResult;
                    }
                };
                ASRegExp.prototype.test = function (str) {
                    if (str === void 0) {
                        str = '';
                    }
                    return this.exec(str) !== null;
                };
                ASRegExp.UNMATCHABLE_PATTERN = '^(?!)$';
                ASRegExp.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASRegExp.prototype;
                    addPrototypeFunctionAlias(proto, '$BgtoString', asProto.ecmaToString);
                    addPrototypeFunctionAlias(proto, '$Bgexec', asProto.exec);
                    addPrototypeFunctionAlias(proto, '$Bgtest', asProto.test);
                };
                return ASRegExp;
            }(ASObject);
            AS.ASRegExp = ASRegExp;
            var ASError = function (_super) {
                __extends(ASError, _super);
                function ASError(message, id) {
                    _super.call(this);
                    if (arguments.length < 1) {
                        message = '';
                    }
                    this.$Bgmessage = String(message);
                    this._errorID = id | 0;
                }
                ASError.throwError = function (type, id) {
                    var info = AVMX.getErrorInfo(id);
                    var args = [info];
                    for (var i = 2; i < arguments.length; i++) {
                        args.push(arguments[i]);
                    }
                    var message = AVMX.formatErrorMessage.apply(null, args);
                    throw type.axConstruct([
                        message,
                        id
                    ]);
                };
                ASError.classInitializer = function (asClass) {
                    defineNonEnumerableProperty(this, '$Bglength', 1);
                    defineNonEnumerableProperty(this.dPrototype, '$Bgname', this.classInfo.instanceInfo.getName().name);
                    if (asClass === ASError) {
                        defineNonEnumerableProperty(this.dPrototype, '$Bgmessage', 'Error');
                        defineNonEnumerableProperty(this.dPrototype, '$BgtoString', ASError.prototype.toString);
                    }
                };
                ASError.prototype.toString = function () {
                    return this.$Bgmessage !== '' ? this.$Bgname + ': ' + this.$Bgmessage : this.$Bgname;
                };
                Object.defineProperty(ASError.prototype, 'errorID', {
                    get: function () {
                        return this._errorID;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASError.prototype.getStackTrace = function () {
                    // Stack traces are only available in debug builds. We only do opt.
                    return null;
                };
                ASError.getErrorMessage = Shumway.AVMX.getErrorMessage;
                return ASError;
            }(ASObject);
            AS.ASError = ASError;
            var ASDefinitionError = function (_super) {
                __extends(ASDefinitionError, _super);
                function ASDefinitionError() {
                    _super.apply(this, arguments);
                }
                return ASDefinitionError;
            }(ASError);
            AS.ASDefinitionError = ASDefinitionError;
            var ASEvalError = function (_super) {
                __extends(ASEvalError, _super);
                function ASEvalError() {
                    _super.apply(this, arguments);
                }
                return ASEvalError;
            }(ASError);
            AS.ASEvalError = ASEvalError;
            var ASRangeError = function (_super) {
                __extends(ASRangeError, _super);
                function ASRangeError() {
                    _super.apply(this, arguments);
                }
                return ASRangeError;
            }(ASError);
            AS.ASRangeError = ASRangeError;
            var ASReferenceError = function (_super) {
                __extends(ASReferenceError, _super);
                function ASReferenceError() {
                    _super.apply(this, arguments);
                }
                return ASReferenceError;
            }(ASError);
            AS.ASReferenceError = ASReferenceError;
            var ASSecurityError = function (_super) {
                __extends(ASSecurityError, _super);
                function ASSecurityError() {
                    _super.apply(this, arguments);
                }
                return ASSecurityError;
            }(ASError);
            AS.ASSecurityError = ASSecurityError;
            var ASSyntaxError = function (_super) {
                __extends(ASSyntaxError, _super);
                function ASSyntaxError() {
                    _super.apply(this, arguments);
                }
                return ASSyntaxError;
            }(ASError);
            AS.ASSyntaxError = ASSyntaxError;
            var ASTypeError = function (_super) {
                __extends(ASTypeError, _super);
                function ASTypeError() {
                    _super.apply(this, arguments);
                }
                return ASTypeError;
            }(ASError);
            AS.ASTypeError = ASTypeError;
            var ASURIError = function (_super) {
                __extends(ASURIError, _super);
                function ASURIError() {
                    _super.apply(this, arguments);
                }
                return ASURIError;
            }(ASError);
            AS.ASURIError = ASURIError;
            var ASVerifyError = function (_super) {
                __extends(ASVerifyError, _super);
                function ASVerifyError() {
                    _super.apply(this, arguments);
                }
                return ASVerifyError;
            }(ASError);
            AS.ASVerifyError = ASVerifyError;
            var ASUninitializedError = function (_super) {
                __extends(ASUninitializedError, _super);
                function ASUninitializedError() {
                    _super.apply(this, arguments);
                }
                return ASUninitializedError;
            }(ASError);
            AS.ASUninitializedError = ASUninitializedError;
            var ASArgumentError = function (_super) {
                __extends(ASArgumentError, _super);
                function ASArgumentError() {
                    _super.apply(this, arguments);
                }
                return ASArgumentError;
            }(ASError);
            AS.ASArgumentError = ASArgumentError;
            var ASIOError = function (_super) {
                __extends(ASIOError, _super);
                function ASIOError() {
                    _super.apply(this, arguments);
                }
                return ASIOError;
            }(ASError);
            AS.ASIOError = ASIOError;
            var ASEOFError = function (_super) {
                __extends(ASEOFError, _super);
                function ASEOFError() {
                    _super.apply(this, arguments);
                }
                return ASEOFError;
            }(ASError);
            AS.ASEOFError = ASEOFError;
            var ASMemoryError = function (_super) {
                __extends(ASMemoryError, _super);
                function ASMemoryError() {
                    _super.apply(this, arguments);
                }
                return ASMemoryError;
            }(ASError);
            AS.ASMemoryError = ASMemoryError;
            var ASIllegalOperationError = function (_super) {
                __extends(ASIllegalOperationError, _super);
                function ASIllegalOperationError() {
                    _super.apply(this, arguments);
                }
                return ASIllegalOperationError;
            }(ASError);
            AS.ASIllegalOperationError = ASIllegalOperationError;
            /**
             * Transforms a JS value into an AS value.
             */
            function transformJSValueToAS(sec, value, deep) {
                release || assert(typeof value !== 'function');
                if (typeof value !== 'object') {
                    return value;
                }
                if (isNullOrUndefined(value)) {
                    return value;
                }
                if (Array.isArray(value)) {
                    var list = [];
                    for (var i = 0; i < value.length; i++) {
                        var entry = value[i];
                        var axValue = deep ? transformJSValueToAS(sec, entry, true) : entry;
                        list.push(axValue);
                    }
                    return sec.createArray(list);
                }
                return sec.createObjectFromJS(value, deep);
            }
            AS.transformJSValueToAS = transformJSValueToAS;
            /**
             * Transforms an AS value into a JS value.
             */
            function transformASValueToJS(sec, value, deep) {
                if (typeof value !== 'object') {
                    return value;
                }
                if (isNullOrUndefined(value)) {
                    return value;
                }
                if (sec.AXArray.axIsType(value)) {
                    var resultList = [];
                    var list = value.value;
                    for (var i = 0; i < list.length; i++) {
                        var entry = list[i];
                        var jsValue = deep ? transformASValueToJS(sec, entry, true) : entry;
                        resultList.push(jsValue);
                    }
                    return resultList;
                }
                var keys = Object.keys(value);
                var resultObject = {};
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    var jsKey = key;
                    if (!Shumway.isNumeric(key)) {
                        release || assert(key.indexOf('$Bg') === 0);
                        jsKey = key.substr(3);
                    }
                    var v = value[key];
                    if (deep) {
                        v = transformASValueToJS(sec, v, true);
                    }
                    resultObject[jsKey] = v;
                }
                return resultObject;
            }
            AS.transformASValueToJS = transformASValueToJS;
            function transformJStoASRegExpMatchArray(sec, value) {
                var result = sec.createArray(value);
                result.axSetPublicProperty('index', value.index);
                result.axSetPublicProperty('input', value.input);
                return result;
            }
            function walk(sec, holder, name, reviver) {
                var val = holder[name];
                if (Array.isArray(val)) {
                    var v = val;
                    for (var i = 0, limit = v.length; i < limit; i++) {
                        var newElement = walk(sec, v, AVMX.axCoerceString(i), reviver);
                        if (newElement === undefined) {
                            delete v[i];
                        } else {
                            v[i] = newElement;
                        }
                    }
                } else if (val !== null && typeof val !== 'boolean' && typeof val !== 'number' && typeof val !== 'string') {
                    for (var p in val) {
                        if (!val.hasOwnProperty(p) || !Multiname.isPublicQualifiedName(p)) {
                            break;
                        }
                        var newElement = walk(sec, val, p, reviver);
                        if (newElement === undefined) {
                            delete val[p];
                        } else {
                            val[p] = newElement;
                        }
                    }
                }
                return reviver.call(holder, name, val);
            }
            var ASJSON = function (_super) {
                __extends(ASJSON, _super);
                function ASJSON() {
                    _super.apply(this, arguments);
                }
                ASJSON.parse = function (text, reviver) {
                    if (reviver === void 0) {
                        reviver = null;
                    }
                    text = AVMX.axCoerceString(text);
                    if (reviver !== null && !AVMX.axIsCallable(reviver)) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, reviver, 'Function');
                    }
                    if (text === null) {
                        this.sec.throwError('SyntaxError', AVMX.Errors.JSONInvalidParseInput);
                    }
                    try {
                        var unfiltered = transformJSValueToAS(this.sec, JSON.parse(text), true);
                    } catch (e) {
                        this.sec.throwError('SyntaxError', AVMX.Errors.JSONInvalidParseInput);
                    }
                    if (reviver === null) {
                        return unfiltered;
                    }
                    return walk(this.sec, { '': unfiltered }, '', reviver.value);
                };
                ASJSON.stringify = function (value, replacer, space) {
                    if (replacer === void 0) {
                        replacer = null;
                    }
                    if (space === void 0) {
                        space = null;
                    }
                    // We deliberately deviate from ECMA-262 and throw on
                    // invalid replacer parameter.
                    if (replacer !== null) {
                        var sec = typeof replacer === 'object' ? replacer.sec : null;
                        if (!sec || !(sec.AXFunction.axIsType(replacer) || sec.AXArray.axIsType(replacer))) {
                            this.sec.throwError('TypeError', AVMX.Errors.JSONInvalidReplacer);
                        }
                    }
                    var gap;
                    if (typeof space === 'string') {
                        gap = space.length > 10 ? space.substring(0, 10) : space;
                    } else if (typeof space === 'number') {
                        gap = '          '.substring(0, Math.min(10, space | 0));
                    } else {
                        // We follow ECMA-262 and silently ignore invalid space parameter.
                        gap = '';
                    }
                    if (replacer === null) {
                        return this.stringifySpecializedToString(value, null, null, gap);
                    } else if (sec.AXArray.axIsType(replacer)) {
                        return this.stringifySpecializedToString(value, this.computePropertyList(replacer.value), null, gap);
                    } else {
                        return this.stringifySpecializedToString(value, null, replacer.value, gap);
                    }
                };
                // ECMA-262 5th ed, section 15.12.3 stringify, step 4.b
                ASJSON.computePropertyList = function (r) {
                    var propertyList = [];
                    var alreadyAdded = Object.create(null);
                    for (var i = 0, length = r.length; i < length; i++) {
                        if (!r.hasOwnProperty(i)) {
                            continue;
                        }
                        var v = r[i];
                        var item = null;
                        if (typeof v === 'string') {
                            item = v;
                        } else if (typeof v === 'number') {
                            item = AVMX.axCoerceString(v);
                        }
                        if (item !== null && !alreadyAdded[item]) {
                            alreadyAdded[item] = true;
                            propertyList.push(item);
                        }
                    }
                    return propertyList;
                };
                ASJSON.stringifySpecializedToString = function (value, replacerArray, replacerFunction, gap) {
                    try {
                        // In AS3 |JSON.stringify(undefined)| returns "null", while JS returns |undefined|.
                        // TODO: Is there anything to be done in case of a |replacerFunction| function?
                        if (value === undefined) {
                            return 'null';
                        }
                        return JSON.stringify(transformASValueToJS(this.sec, value, true), replacerFunction, gap);
                    } catch (e) {
                        this.sec.throwError('TypeError', AVMX.Errors.JSONCyclicStructure);
                    }
                };
                return ASJSON;
            }(ASObject);
            AS.ASJSON = ASJSON;
            var builtinNativeClasses = Shumway.ObjectUtilities.createMap();
            var nativeClasses = Shumway.ObjectUtilities.createMap();
            var nativeClassLoaderNames = [];
            function initializeBuiltins() {
                builtinNativeClasses['Object'] = ASObject;
                builtinNativeClasses['Class'] = ASClass;
                builtinNativeClasses['Function'] = ASFunction;
                builtinNativeClasses['Boolean'] = ASBoolean;
                builtinNativeClasses['builtin.as$0.MethodClosure'] = ASMethodClosure;
                builtinNativeClasses['Namespace'] = AS.ASNamespace;
                builtinNativeClasses['Number'] = ASNumber;
                builtinNativeClasses['int'] = ASInt;
                builtinNativeClasses['uint'] = ASUint;
                builtinNativeClasses['String'] = ASString;
                builtinNativeClasses['Array'] = ASArray;
                builtinNativeClasses['__AS3__.vec.Vector'] = AS.Vector;
                builtinNativeClasses['__AS3__.vec.Vector$object'] = AS.GenericVector;
                builtinNativeClasses['__AS3__.vec.Vector$int'] = AS.Int32Vector;
                builtinNativeClasses['__AS3__.vec.Vector$uint'] = AS.Uint32Vector;
                builtinNativeClasses['__AS3__.vec.Vector$double'] = AS.Float64Vector;
                builtinNativeClasses['Namespace'] = AS.ASNamespace;
                builtinNativeClasses['QName'] = AS.ASQName;
                builtinNativeClasses['XML'] = AS.ASXML;
                builtinNativeClasses['XMLList'] = AS.ASXMLList;
                builtinNativeClasses['flash.xml.XMLNode'] = AS.flash.xml.XMLNode;
                builtinNativeClasses['flash.xml.XMLDocument'] = AS.flash.xml.XMLDocument;
                builtinNativeClasses['flash.xml.XMLParser'] = AS.flash.xml.XMLParser;
                builtinNativeClasses['flash.xml.XMLTag'] = AS.flash.xml.XMLTag;
                builtinNativeClasses['flash.xml.XMLNodeType'] = AS.flash.xml.XMLNodeType;
                builtinNativeClasses['Math'] = ASMath;
                builtinNativeClasses['Date'] = AS.ASDate;
                builtinNativeClasses['RegExp'] = ASRegExp;
                builtinNativeClasses['JSON'] = ASJSON;
                builtinNativeClasses['flash.utils.Proxy'] = AS.flash.utils.ASProxy;
                builtinNativeClasses['flash.utils.Dictionary'] = AS.flash.utils.Dictionary;
                builtinNativeClasses['flash.utils.ByteArray'] = AS.flash.utils.ByteArray;
                builtinNativeClasses['avmplus.System'] = AS.flash.system.OriginalSystem;
                // Errors
                builtinNativeClasses['Error'] = ASError;
                builtinNativeClasses['DefinitionError'] = ASDefinitionError;
                builtinNativeClasses['EvalError'] = ASEvalError;
                builtinNativeClasses['RangeError'] = ASRangeError;
                builtinNativeClasses['ReferenceError'] = ASReferenceError;
                builtinNativeClasses['SecurityError'] = ASSecurityError;
                builtinNativeClasses['SyntaxError'] = ASSyntaxError;
                builtinNativeClasses['TypeError'] = ASTypeError;
                builtinNativeClasses['URIError'] = ASURIError;
                builtinNativeClasses['VerifyError'] = ASVerifyError;
                builtinNativeClasses['UninitializedError'] = ASUninitializedError;
                builtinNativeClasses['ArgumentError'] = ASArgumentError;
                builtinNativeClasses['flash.errors.IOError'] = ASIOError;
                builtinNativeClasses['flash.errors.EOFError'] = ASEOFError;
                builtinNativeClasses['flash.errors.MemoryError'] = ASMemoryError;
                builtinNativeClasses['flash.errors.IllegalOperationError'] = ASIllegalOperationError;
            }
            AS.initializeBuiltins = initializeBuiltins;
            function registerNativeClass(name, asClass, alias, nsType) {
                if (alias === void 0) {
                    alias = name;
                }
                if (nsType === void 0) {
                    nsType = 0    /* Public */;
                }
                release || assert(!nativeClasses[name], 'Native class: ' + name + ' is already registered.');
                nativeClasses[name] = asClass;
                nativeClassLoaderNames.push({
                    name: name,
                    alias: alias,
                    nsType: nsType
                });
            }
            AS.registerNativeClass = registerNativeClass;
            function registerNativeFunction(path, fun) {
                release || assert(!nativeFunctions[path], 'Native function: ' + path + ' is already registered.');
                nativeFunctions[path] = fun;
            }
            AS.registerNativeFunction = registerNativeFunction;
            registerNativeClass('__AS3__.vec.Vector$object', AS.GenericVector, 'ObjectVector', 2    /* PackageInternal */);
            registerNativeClass('__AS3__.vec.Vector$int', AS.Int32Vector, 'Int32Vector', 2    /* PackageInternal */);
            registerNativeClass('__AS3__.vec.Vector$uint', AS.Uint32Vector, 'Uint32Vector', 2    /* PackageInternal */);
            registerNativeClass('__AS3__.vec.Vector$double', AS.Float64Vector, 'Float64Vector', 2    /* PackageInternal */);
            function FlashUtilScript_getDefinitionByName(sec, name) {
                var simpleName = String(name).replace('::', '.');
                return AVMX.getCurrentABC().env.app.getClass(Multiname.FromSimpleName(simpleName));
            }
            function FlashUtilScript_getTimer(sec) {
                return Date.now() - sec.flash.display.Loader.axClass.runtimeStartTime;
            }
            AS.FlashUtilScript_getTimer = FlashUtilScript_getTimer;
            function FlashNetScript_navigateToURL(sec, request, window_) {
                if (request === null || request === undefined) {
                    sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'request');
                }
                var RequestClass = sec.flash.net.URLRequest.axClass;
                if (!RequestClass.axIsType(request)) {
                    sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, request, 'flash.net.URLRequest');
                }
                var url = request.url;
                if (isNullOrUndefined(url)) {
                    sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'url');
                }
                if (url.toLowerCase().indexOf('fscommand:') === 0) {
                    var fscommand = sec.flash.system.fscommand.value;
                    fscommand(sec, url.substring('fscommand:'.length), window_);
                    return;
                }
                // TODO handle other methods than GET
                Shumway.FileLoadingService.instance.navigateTo(url, window_);
            }
            AS.FlashNetScript_navigateToURL = FlashNetScript_navigateToURL;
            function FlashNetScript_sendToURL(sec, request) {
                if (isNullOrUndefined(request)) {
                    sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'request');
                }
                var RequestClass = sec.flash.net.URLRequest.axClass;
                if (!RequestClass.axIsType(request)) {
                    sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, request, 'flash.net.URLRequest');
                }
                var session = Shumway.FileLoadingService.instance.createSession();
                session.onprogress = function () {
                };
                session.open(request);
            }
            function Toplevel_registerClassAlias(sec, aliasName, classObject) {
                aliasName = AVMX.axCoerceString(aliasName);
                if (!aliasName) {
                    sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'aliasName');
                }
                if (!classObject) {
                    sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'classObject');
                }
                sec.classAliases.registerClassAlias(aliasName, classObject);
            }
            function Toplevel_getClassByAlias(sec, aliasName) {
                aliasName = AVMX.axCoerceString(aliasName);
                if (!aliasName) {
                    sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'aliasName');
                }
                var axClass = sec.classAliases.getClassByAlias(aliasName);
                if (!axClass) {
                    sec.throwError('ReferenceError', AVMX.Errors.ClassNotFoundError, aliasName);
                }
                return axClass;
            }
            registerNativeFunction('FlashUtilScript::getDefinitionByName', FlashUtilScript_getDefinitionByName);
            registerNativeFunction('FlashUtilScript::getTimer', FlashUtilScript_getTimer);
            registerNativeFunction('FlashUtilScript::navigateToURL', FlashNetScript_navigateToURL);
            registerNativeFunction('FlashNetScript::navigateToURL', FlashNetScript_navigateToURL);
            registerNativeFunction('FlashNetScript::sendToURL', FlashNetScript_sendToURL);
            registerNativeFunction('FlashUtilScript::escapeMultiByte', wrapJSGlobalFunction(jsGlobal.escape));
            registerNativeFunction('FlashUtilScript::unescapeMultiByte', wrapJSGlobalFunction(jsGlobal.unescape));
            registerNativeFunction('Toplevel::registerClassAlias', Toplevel_registerClassAlias);
            registerNativeFunction('Toplevel::getClassByAlias', Toplevel_getClassByAlias);
            function getNativesForTrait(trait) {
                var className = null;
                var natives;
                if (trait.holder instanceof AVMX.InstanceInfo) {
                    var instanceInfo = trait.holder;
                    className = instanceInfo.getClassName();
                    var native = builtinNativeClasses[className] || nativeClasses[className];
                    release || assert(native, 'Class native is not defined: ' + className);
                    natives = [native.prototype];
                    if (native.instanceNatives) {
                        pushMany(natives, native.instanceNatives);
                    }
                } else if (trait.holder instanceof AVMX.ClassInfo) {
                    var classInfo = trait.holder;
                    className = classInfo.instanceInfo.getClassName();
                    var native = builtinNativeClasses[className] || nativeClasses[className];
                    release || assert(native, 'Class native is not defined: ' + className);
                    natives = [native];
                    if (native.classNatives) {
                        pushMany(natives, native.classNatives);
                    }
                } else {
                    release || assertUnreachable('Invalid trait type');
                }
                return natives;
            }
            AS.getNativesForTrait = getNativesForTrait;
            function getNativeInitializer(classInfo) {
                var methodInfo = classInfo.instanceInfo.getInitializer();
                var className = classInfo.instanceInfo.getClassName();
                var asClass = builtinNativeClasses[className] || nativeClasses[className];
                if (methodInfo.isNative()) {
                    // Use TS constructor as the initializer function.
                    return asClass;
                }
                //// TODO: Assert eagerly.
                //return function () {
                //  release || assert (!methodInfo.isNative(), "Must supply a constructor for " + classInfo +
                // "."); }
                return null;
            }
            AS.getNativeInitializer = getNativeInitializer;
            /**
             * Searches for a native property in a list of native holders.
             */
            function getMethodOrAccessorNative(trait) {
                var natives = getNativesForTrait(trait);
                var name = trait.getName().name;
                for (var i = 0; i < natives.length; i++) {
                    var native = natives[i];
                    var fullName = name;
                    // We prefix methods that should not be exported with "native_", check to see
                    // if a method exists with that prefix first when looking for native methods.
                    if (!hasOwnProperty(native, name) && hasOwnProperty(native, 'native_' + name)) {
                        fullName = 'native_' + name;
                    }
                    if (hasOwnProperty(native, fullName)) {
                        var value;
                        if (trait.isAccessor()) {
                            var pd = Object.getOwnPropertyDescriptor(native, fullName);
                            if (trait.isGetter()) {
                                value = pd.get;
                            } else {
                                value = pd.set;
                            }
                        } else {
                            release || assert(trait.isMethod());
                            value = native[fullName];
                        }
                        release || assert(value, 'Method or Accessor property exists but it\'s undefined: ' + trait.holder + ' ' + trait);
                        return value;
                    }
                }
                Shumway.Debug.warning('No native method for: ' + trait.holder + ' ' + trait + ', make sure you\'ve got the static keyword for static methods.');
                release || assertUnreachable('Cannot find ' + trait + ' in natives.');
                return null;
            }
            AS.getMethodOrAccessorNative = getMethodOrAccessorNative;
            function tryLinkNativeClass(axClass) {
                var className = axClass.classInfo.instanceInfo.getClassName();
                var asClass = builtinNativeClasses[className] || nativeClasses[className];
                if (asClass) {
                    linkClass(axClass, asClass);
                }
            }
            AS.tryLinkNativeClass = tryLinkNativeClass;
            /**
             * Returns |true| if the symbol is available in debug or release modes. Only symbols
             * followed by the  "!" suffix are available in release builds.
             */
            function containsSymbol(symbols, name) {
                for (var i = 0; i < symbols.length; i++) {
                    var symbol = symbols[i];
                    if (symbol.indexOf(name) >= 0) {
                        var releaseSymbol = symbol[symbol.length - 1] === '!';
                        if (releaseSymbol) {
                            symbol = symbol.slice(0, symbol.length - 1);
                        }
                        if (name !== symbol) {
                            continue;
                        }
                        if (release) {
                            return releaseSymbol;
                        }
                        return true;
                    }
                }
                return false;
            }
            function linkSymbols(symbols, traits, object) {
                for (var i = 0; i < traits.traits.length; i++) {
                    var trait = traits.traits[i];
                    if (!containsSymbol(symbols, trait.getName().name)) {
                        continue;
                    }
                    release || assert(trait.getName().namespace.type !== 3    /* Private */, 'Why are you linking against private members?');
                    if (trait.isConst()) {
                        release || release || notImplemented('Don\'t link against const traits.');
                        return;
                    }
                    var name = trait.getName().name;
                    var qn = trait.getName().getMangledName();
                    if (trait.isSlot()) {
                        Object.defineProperty(object, name, {
                            get: new Function('', 'return this.' + qn + '//# sourceURL=get-' + qn + '.as'),
                            set: new Function('v', 'this.' + qn + ' = v;' + '//# sourceURL=set-' + qn + '.as')
                        });
                    } else if (trait.isGetter()) {
                        release || assert(hasOwnGetter(object, qn), 'There should be an getter method for this symbol.');
                        Object.defineProperty(object, name, { get: new Function('', 'return this.' + qn + '//# sourceURL=get-' + qn + '.as') });
                    } else {
                        notImplemented(trait.toString());
                    }
                }
            }
            function filter(propertyName) {
                return propertyName.indexOf('native_') !== 0;
            }
            var axTrapNames = [
                'axResolveMultiname',
                'axHasProperty',
                'axDeleteProperty',
                'axCallProperty',
                'axCallSuper',
                'axConstructProperty',
                'axHasPropertyInternal',
                'axHasOwnProperty',
                'axSetProperty',
                'axGetProperty',
                'axGetSuper',
                'axSetSuper',
                'axNextNameIndex',
                'axNextName',
                'axNextValue',
                'axGetEnumerableKeys',
                'axHasPublicProperty',
                'axSetPublicProperty',
                'axGetPublicProperty',
                'axCallPublicProperty',
                'axDeletePublicProperty',
                'axSetNumericProperty',
                'axGetNumericProperty',
                'axGetSlot',
                'axSetSlot'
            ];
            function linkClass(axClass, asClass) {
                // Save asClass on the axClass.
                axClass.asClass = asClass;
                // TypeScript's static inheritance can lead to subtle linking bugs. Make sure we don't fall
                // victim to this by checking that we don't inherit non-null static properties.
                if (false && !release && axClass.superClass) {
                    if (asClass.classSymbols) {
                        release || assert(asClass.classSymbols !== axClass.superClass.asClass.classSymbols, 'Make sure class ' + axClass + ' doesn\'t inherit super class\'s classSymbols.');
                    }
                    if (asClass.instanceSymbols) {
                        release || assert(asClass.instanceSymbols !== axClass.superClass.asClass.instanceSymbols, 'Make sure class ' + axClass + ' doesn\'t inherit super class\'s instanceSymbols.');
                    }
                    if (asClass.classInitializer) {
                        release || assert(asClass.classInitializer !== axClass.superClass.asClass.classInitializer, 'Make sure class ' + axClass + ' doesn\'t inherit super class\'s class initializer.');
                    }
                }
                if (asClass.classSymbols) {
                    linkSymbols(asClass.classSymbols, axClass.classInfo.traits, axClass);
                }
                if (asClass.instanceSymbols) {
                    linkSymbols(asClass.instanceSymbols, axClass.classInfo.instanceInfo.traits, axClass.tPrototype);
                }
                // Copy class methods and properties.
                if (asClass.classNatives) {
                    for (var i = 0; i < asClass.classNatives.length; i++) {
                        copyOwnPropertyDescriptors(axClass, asClass.classNatives[i], filter);
                    }
                }
                copyOwnPropertyDescriptors(axClass, asClass, filter, true, true);
                if (axClass.superClass) {
                }
                // Copy instance methods and properties.
                if (asClass.instanceNatives) {
                    for (var i = 0; i < asClass.instanceNatives.length; i++) {
                        copyOwnPropertyDescriptors(axClass.dPrototype, asClass.instanceNatives[i], filter);
                    }
                }
                // Inherit or override prototype descriptors from the template class.
                copyOwnPropertyDescriptors(axClass.dPrototype, asClass.prototype, filter);
                // Copy inherited traps. We want to make sure we copy all the in inherited traps, not just the
                // traps defined in asClass.Prototype.
                copyPropertiesByList(axClass.dPrototype, asClass.prototype, axTrapNames);
                if (asClass.classInitializer) {
                    asClass.classInitializer.call(axClass, asClass);
                    if (!release) {
                        Object.freeze(asClass);
                    }
                }
                AVMX.runtimeWriter && traceASClass(axClass, asClass);
            }
            function traceASClass(axClass, asClass) {
                AVMX.runtimeWriter.enter('Class: ' + axClass.classInfo);
                AVMX.runtimeWriter.enter('Traps:');
                for (var k in asClass.prototype) {
                    if (k.indexOf('ax') !== 0) {
                        continue;
                    }
                    var hasOwn = asClass.hasOwnProperty(k);
                    AVMX.runtimeWriter.writeLn((hasOwn ? 'Own' : 'Inherited') + ' trap: ' + k);
                }
                AVMX.runtimeWriter.leave();
                AVMX.runtimeWriter.leave();
            }
            /**
             * Creates a self patching getter that lazily constructs the class and memoizes
             * to the class's instance constructor.
             */
            function defineClassLoader(applicationDomain, container, mn, classAlias) {
                Object.defineProperty(container, classAlias, {
                    get: function () {
                        AVMX.runtimeWriter && AVMX.runtimeWriter.writeLn('Running Memoizer: ' + mn.name);
                        var axClass = applicationDomain.getClass(mn);
                        release || assert(axClass, 'Class ' + mn + ' is not found.');
                        release || assert(axClass.axConstruct);
                        var loader = function () {
                            return axClass.axConstruct(arguments);
                        };
                        loader.axIsType = function (value) {
                            return axClass.axIsType(value);
                        };
                        loader.axClass = axClass;
                        Object.defineProperty(container, classAlias, {
                            value: loader,
                            writable: false
                        });
                        return loader;
                    },
                    configurable: true
                });
            }
            var createContainersFromPath = function (pathTokens, container) {
                for (var i = 0, j = pathTokens.length; i < j; i++) {
                    if (!container[pathTokens[i]]) {
                        container[pathTokens[i]] = Object.create(null);
                    }
                    container = container[pathTokens[i]];
                }
                return container;
            };
            function makeClassLoader(applicationDomain, container, classPath, aliasPath, nsType) {
                AVMX.runtimeWriter && AVMX.runtimeWriter.writeLn('Defining Memoizer: ' + classPath);
                var aliasPathTokens = aliasPath.split('.');
                var aliasClassName = aliasPathTokens.pop();
                container = createContainersFromPath(aliasPathTokens, container);
                var mn = Multiname.FromFQNString(classPath, nsType);
                defineClassLoader(applicationDomain, container, mn, aliasClassName);
            }
            /**
             * Installs class loaders for all the previously registered native classes.
             */
            function installClassLoaders(applicationDomain, container) {
                for (var i = 0; i < nativeClassLoaderNames.length; i++) {
                    var loaderName = nativeClassLoaderNames[i].name;
                    var loaderAlias = nativeClassLoaderNames[i].alias;
                    var nsType = nativeClassLoaderNames[i].nsType;
                    makeClassLoader(applicationDomain, container, loaderName, loaderAlias, nsType);
                }
            }
            AS.installClassLoaders = installClassLoaders;
            /**
             * Installs all the previously registered native functions on the AXSecurityDomain.
             *
             * Note that this doesn't use memoizers and doesn't run the functions' AS3 script.
             */
            function installNativeFunctions(sec) {
                for (var i in nativeFunctions) {
                    var pathTokens = i.split('.');
                    var funName = pathTokens.pop();
                    var container = createContainersFromPath(pathTokens, sec);
                    container[funName] = sec.boxFunction(nativeFunctions[i]);
                }
            }
            AS.installNativeFunctions = installNativeFunctions;
            var assert = Shumway.Debug.assert;
            var assertNotImplemented = Shumway.Debug.assertNotImplemented;
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var BaseVector = function (_super) {
                __extends(BaseVector, _super);
                function BaseVector() {
                    _super.apply(this, arguments);
                }
                BaseVector.prototype.axGetProperty = function (mn) {
                    var nm = mn.name;
                    nm = typeof nm === 'number' ? nm : AVMX.axCoerceName(nm);
                    if ((nm | 0) === nm || Shumway.isNumeric(nm)) {
                        release || assert(mn.isRuntimeName());
                        return this.axGetNumericProperty(typeof nm === 'number' ? nm : nm | 0);
                    }
                    return _super.prototype.axGetProperty.call(this, mn);
                };
                BaseVector.prototype.axSetProperty = function (mn, value, bc) {
                    release || AVMX.checkValue(value);
                    var nm = mn.name;
                    nm = typeof nm === 'number' ? nm : AVMX.axCoerceName(nm);
                    if ((nm | 0) === nm || Shumway.isNumeric(nm)) {
                        release || assert(mn.isRuntimeName());
                        this.axSetNumericProperty(typeof nm === 'number' ? nm : nm | 0, value);
                        return;
                    }
                    _super.prototype.axSetProperty.call(this, mn, value, bc);
                };
                BaseVector.prototype.axGetPublicProperty = function (nm) {
                    nm = typeof nm === 'number' ? nm : AVMX.axCoerceName(nm);
                    if ((nm | 0) === nm || Shumway.isNumeric(nm)) {
                        return this.axGetNumericProperty(typeof nm === 'number' ? nm : nm | 0);
                    }
                    return this['$Bg' + nm];
                };
                BaseVector.prototype.axSetPublicProperty = function (nm, value) {
                    release || AVMX.checkValue(value);
                    nm = typeof nm === 'number' ? nm : AVMX.axCoerceName(nm);
                    if ((nm | 0) === nm || Shumway.isNumeric(nm)) {
                        this.axSetNumericProperty(typeof nm === 'number' ? nm : nm | 0, value);
                        return;
                    }
                    this['$Bg' + nm] = value;
                };
                BaseVector.prototype.axNextName = function (index) {
                    return index - 1;
                };
                /**
                 * Throws exceptions for the cases where Flash does, and returns false if the callback
                 * is null or undefined. In that case, the calling function returns its default value.
                 */
                BaseVector.prototype.checkVectorMethodArgs = function (callback, thisObject) {
                    if (Shumway.isNullOrUndefined(callback)) {
                        return false;
                    }
                    var sec = this.sec;
                    if (!AVMX.axIsCallable(callback)) {
                        sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, callback, 'Function');
                    }
                    if (callback.axClass === sec.AXMethodClosure && !Shumway.isNullOrUndefined(thisObject)) {
                        sec.throwError('TypeError', AVMX.Errors.ArrayFilterNonNullObjectError);
                    }
                    return true;
                };
                return BaseVector;
            }(AS.ASObject);
            AS.BaseVector = BaseVector;
            var Vector = function (_super) {
                __extends(Vector, _super);
                function Vector() {
                    _super.apply(this, arguments);
                }
                Vector.axIsType = function (x) {
                    return this.dPrototype.isPrototypeOf(x) || this.sec.Int32Vector.axClass.dPrototype.isPrototypeOf(x) || this.sec.Uint32Vector.axClass.dPrototype.isPrototypeOf(x) || this.sec.Float64Vector.axClass.dPrototype.isPrototypeOf(x) || this.sec.ObjectVector.axClass.dPrototype.isPrototypeOf(x);
                };
                return Vector;
            }(AS.ASObject);
            AS.Vector = Vector;
            var GenericVector = function (_super) {
                __extends(GenericVector, _super);
                function GenericVector(length, fixed) {
                    if (length === void 0) {
                        length = 0;
                    }
                    if (fixed === void 0) {
                        fixed = false;
                    }
                    _super.call(this);
                    length = length >>> 0;
                    fixed = !!fixed;
                    this._fixed = !!fixed;
                    this._buffer = new Array(length);
                    this._fill(0, length, this.axClass.defaultValue);
                }
                GenericVector.classInitializer = function () {
                    var proto = this.dPrototype;
                    var tProto = this.tPrototype;
                    // Fix up MOP handlers to not apply to the dynamic prototype, which is a plain object.
                    tProto.axGetProperty = proto.axGetProperty;
                    tProto.axGetNumericProperty = proto.axGetNumericProperty;
                    tProto.axSetProperty = proto.axSetProperty;
                    tProto.axSetNumericProperty = proto.axSetNumericProperty;
                    tProto.axHasPropertyInternal = proto.axHasPropertyInternal;
                    tProto.axNextName = proto.axNextName;
                    tProto.axNextNameIndex = proto.axNextNameIndex;
                    tProto.axNextValue = proto.axNextValue;
                    proto.axGetProperty = AS.ASObject.prototype.axGetProperty;
                    proto.axGetNumericProperty = AS.ASObject.prototype.axGetNumericProperty;
                    proto.axSetProperty = AS.ASObject.prototype.axSetProperty;
                    proto.axSetNumericProperty = AS.ASObject.prototype.axSetNumericProperty;
                    proto.axHasPropertyInternal = AS.ASObject.prototype.axHasPropertyInternal;
                    proto.axNextName = AS.ASObject.prototype.axNextName;
                    proto.axNextNameIndex = AS.ASObject.prototype.axNextNameIndex;
                    proto.axNextValue = AS.ASObject.prototype.axNextValue;
                    var asProto = GenericVector.prototype;
                    defineNonEnumerableProperty(proto, '$Bgjoin', asProto.join);
                    // Same as join, see VectorImpl.as in Tamarin repository.
                    defineNonEnumerableProperty(proto, '$BgtoString', asProto.join);
                    defineNonEnumerableProperty(proto, '$BgtoLocaleString', asProto.toLocaleString);
                    defineNonEnumerableProperty(proto, '$Bgpop', asProto.pop);
                    defineNonEnumerableProperty(proto, '$Bgpush', asProto.push);
                    defineNonEnumerableProperty(proto, '$Bgreverse', asProto.reverse);
                    defineNonEnumerableProperty(proto, '$Bgconcat', asProto.concat);
                    defineNonEnumerableProperty(proto, '$Bgsplice', asProto.splice);
                    defineNonEnumerableProperty(proto, '$Bgslice', asProto.slice);
                    defineNonEnumerableProperty(proto, '$Bgshift', asProto.shift);
                    defineNonEnumerableProperty(proto, '$Bgunshift', asProto.unshift);
                    defineNonEnumerableProperty(proto, '$BgindexOf', asProto.indexOf);
                    defineNonEnumerableProperty(proto, '$BglastIndexOf', asProto.lastIndexOf);
                    defineNonEnumerableProperty(proto, '$BgforEach', asProto.forEach);
                    defineNonEnumerableProperty(proto, '$Bgmap', asProto.map);
                    defineNonEnumerableProperty(proto, '$Bgfilter', asProto.filter);
                    defineNonEnumerableProperty(proto, '$Bgsome', asProto.some);
                    defineNonEnumerableProperty(proto, '$Bgevery', asProto.every);
                    defineNonEnumerableProperty(proto, '$Bgsort', asProto.sort);
                    defineNonEnumerableProperty(proto, 'checkVectorMethodArgs', asProto.checkVectorMethodArgs);
                };
                GenericVector.axApply = function (_, args) {
                    var object = args[0];
                    if (this.axIsType(object)) {
                        return object;
                    }
                    var length = object.axGetPublicProperty('length');
                    if (length !== undefined) {
                        var v = this.axConstruct([
                            length,
                            false
                        ]);
                        for (var i = 0; i < length; i++) {
                            v.axSetNumericProperty(i, object.axGetPublicProperty(i));
                        }
                        return v;
                    }
                    Shumway.Debug.unexpected();
                };
                GenericVector.defaultCompareFunction = function (a, b) {
                    return String(a).localeCompare(String(b));
                };
                GenericVector.compare = function (a, b, options, compareFunction) {
                    release || assertNotImplemented(!(options & GenericVector.CASEINSENSITIVE), 'CASEINSENSITIVE');
                    release || assertNotImplemented(!(options & GenericVector.UNIQUESORT), 'UNIQUESORT');
                    release || assertNotImplemented(!(options & GenericVector.RETURNINDEXEDARRAY), 'RETURNINDEXEDARRAY');
                    var result = 0;
                    if (!compareFunction) {
                        compareFunction = GenericVector.defaultCompareFunction;
                    }
                    if (options & GenericVector.NUMERIC) {
                        a = Shumway.toNumber(a);
                        b = Shumway.toNumber(b);
                        result = a < b ? -1 : a > b ? 1 : 0;
                    } else {
                        result = compareFunction(a, b);
                    }
                    if (options & GenericVector.DESCENDING) {
                        result *= -1;
                    }
                    return result;
                };
                GenericVector.prototype._fill = function (index, length, value) {
                    for (var i = 0; i < length; i++) {
                        this._buffer[index + i] = value;
                    }
                };
                /**
                 * Can't use Array.prototype.toString because it doesn't print |null|s the same way as AS3.
                 */
                GenericVector.prototype.toString = function () {
                    var result = [];
                    for (var i = 0; i < this._buffer.length; i++) {
                        var entry = this._buffer[i];
                        result.push(entry === null ? 'null' : entry + '');
                    }
                    return result.join(',');
                };
                GenericVector.prototype.toLocaleString = function () {
                    var result = [];
                    for (var i = 0; i < this._buffer.length; i++) {
                        var entry = this._buffer[i];
                        if (entry && typeof entry === 'object') {
                            result.push(entry.$BgtoLocaleString());
                        } else {
                            result.push(entry + '');
                        }
                    }
                    return result.join(',');
                };
                GenericVector.prototype.sort = function (sortBehavior) {
                    if (arguments.length === 0) {
                        this._buffer.sort();
                        return this;
                    }
                    if (this.sec.AXFunction.axIsType(sortBehavior)) {
                        this._buffer.sort(sortBehavior.value);
                        return this;
                    }
                    var options = sortBehavior | 0;
                    release || assertNotImplemented(!(options & AS.Int32Vector.UNIQUESORT), 'UNIQUESORT');
                    release || assertNotImplemented(!(options & AS.Int32Vector.RETURNINDEXEDARRAY), 'RETURNINDEXEDARRAY');
                    if (options & GenericVector.NUMERIC) {
                        if (options & GenericVector.DESCENDING) {
                            this._buffer.sort(function (a, b) {
                                return AVMX.axCoerceNumber(b) - AVMX.axCoerceNumber(a);
                            });
                            return this;
                        }
                        this._buffer.sort(function (a, b) {
                            return AVMX.axCoerceNumber(a) - AVMX.axCoerceNumber(b);
                        });
                        return this;
                    }
                    if (options & GenericVector.CASEINSENSITIVE) {
                        if (options & GenericVector.DESCENDING) {
                            this._buffer.sort(function (a, b) {
                                return AVMX.axCoerceString(b).toLowerCase() - AVMX.axCoerceString(a).toLowerCase();
                            });
                            return this;
                        }
                        this._buffer.sort(function (a, b) {
                            return AVMX.axCoerceString(a).toLowerCase() - AVMX.axCoerceString(b).toLowerCase();
                        });
                        return this;
                    }
                    if (options & GenericVector.DESCENDING) {
                        this._buffer.sort(function (a, b) {
                            return b - a;
                        });
                        return this;
                    }
                    this._buffer.sort();
                    return this;
                };
                /**
                 * Executes a |callback| function with three arguments: element, index, the vector itself as
                 * well as passing the |thisObject| as |this| for each of the elements in the vector. If any of
                 * the callbacks return |false| the function terminates, otherwise it returns |true|.
                 */
                GenericVector.prototype.every = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return true;
                    }
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (!callback.axCall(thisObject, this.axGetNumericProperty(i), i, this)) {
                            return false;
                        }
                    }
                    return true;
                };
                /**
                 * Filters the elements for which the |callback| method returns |true|. The |callback| function
                 * is called with three arguments: element, index, the vector itself as well as passing the
                 * |thisObject| as |this| for each of the elements in the vector.
                 */
                GenericVector.prototype.filter = function (callback, thisObject) {
                    var v = this.axClass.axConstruct([
                        0,
                        false
                    ]);
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return v;
                    }
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (callback.call(thisObject, this.axGetNumericProperty(i), i, this)) {
                            v.push(this.axGetNumericProperty(i));
                        }
                    }
                    return v;
                };
                GenericVector.prototype.map = function (callback, thisObject) {
                    var v = this.axClass.axConstruct([
                        this.length,
                        false
                    ]);
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return v;
                    }
                    for (var i = 0; i < this._buffer.length; i++) {
                        v.push(this._coerce(callback.call(thisObject, this.axGetNumericProperty(i), i, this)));
                    }
                    return v;
                };
                GenericVector.prototype.some = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return false;
                    }
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (callback.call(thisObject, this.axGetNumericProperty(i), i, this)) {
                            return true;
                        }
                    }
                    return false;
                };
                GenericVector.prototype.forEach = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return;
                    }
                    for (var i = 0; i < this._buffer.length; i++) {
                        callback.call(thisObject, this.axGetNumericProperty(i), i, this);
                    }
                };
                GenericVector.prototype.join = function (separator) {
                    if (separator === void 0) {
                        separator = ',';
                    }
                    var buffer = this._buffer;
                    var limit = this._buffer.length;
                    var result = '';
                    for (var i = 0; i < limit - 1; i++) {
                        result += buffer[i] + separator;
                    }
                    if (limit > 0) {
                        result += buffer[limit - 1];
                    }
                    return result;
                };
                GenericVector.prototype.indexOf = function (searchElement, fromIndex) {
                    if (fromIndex === void 0) {
                        fromIndex = 0;
                    }
                    return this._buffer.indexOf(searchElement, fromIndex);
                };
                GenericVector.prototype.lastIndexOf = function (searchElement, fromIndex) {
                    if (fromIndex === void 0) {
                        fromIndex = 2147483647;
                    }
                    return this._buffer.lastIndexOf(searchElement, fromIndex);
                };
                GenericVector.prototype.push = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
                    this._checkFixed();
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer.push(this._coerce(arguments[i]));
                    }
                };
                GenericVector.prototype.pop = function () {
                    this._checkFixed();
                    if (this._buffer.length === 0) {
                        return undefined;
                    }
                    return this._buffer.pop();
                };
                GenericVector.prototype.concat = function () {
                    // TODO: need to type check the arguments, but isType doesn't exist.
                    var buffers = [];
                    for (var i = 0; i < arguments.length; i++) {
                        buffers.push(this._coerce(arguments[i])._buffer);
                    }
                    var buffer = this._buffer.concat.apply(this._buffer, buffers);
                    var result = this.axClass.axConstruct([]);
                    result._buffer = buffer;
                    return result;
                };
                GenericVector.prototype.reverse = function () {
                    this._buffer.reverse();
                    return this;
                };
                GenericVector.prototype._coerce = function (v) {
                    return this.axClass.type.axCoerce(v);
                };
                GenericVector.prototype.shift = function () {
                    this._checkFixed();
                    if (this._buffer.length === 0) {
                        return undefined;
                    }
                    return this._buffer.shift();
                };
                GenericVector.prototype.unshift = function () {
                    if (!arguments.length) {
                        return;
                    }
                    this._checkFixed();
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer.unshift(this._coerce(arguments[i]));
                    }
                };
                GenericVector.prototype.slice = function (start, end) {
                    if (start === void 0) {
                        start = 0;
                    }
                    if (end === void 0) {
                        end = 2147483647;
                    }
                    var buffer = this._buffer;
                    var length = buffer.length;
                    var first = Math.min(Math.max(start, 0), length);
                    var last = Math.min(Math.max(end, first), length);
                    var result = this.axClass.axConstruct([
                        last - first,
                        this.fixed
                    ]);
                    result._buffer = buffer.slice(first, last);
                    return result;
                };
                GenericVector.prototype.splice = function (start, deleteCount_) {
                    var buffer = this._buffer;
                    var length = buffer.length;
                    var first = Math.min(Math.max(start, 0), length);
                    var deleteCount = Math.min(Math.max(deleteCount_, 0), length - first);
                    var insertCount = arguments.length - 2;
                    if (deleteCount !== insertCount) {
                        this._checkFixed();
                    }
                    var items = [
                        first,
                        deleteCount
                    ];
                    for (var i = 2; i < insertCount + 2; i++) {
                        items[i] = this._coerce(arguments[i]);
                    }
                    var result = this.axClass.axConstruct([
                        deleteCount,
                        this.fixed
                    ]);
                    result._buffer = buffer.splice.apply(buffer, items);
                    return result;
                };
                Object.defineProperty(GenericVector.prototype, 'length', {
                    get: function () {
                        return this._buffer.length;
                    },
                    set: function (value) {
                        value = value >>> 0;
                        if (value > this._buffer.length) {
                            for (var i = this._buffer.length; i < value; i++) {
                                this._buffer[i] = this.axClass.defaultValue;
                            }
                        } else {
                            this._buffer.length = value;
                        }
                        release || assert(this._buffer.length === value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(GenericVector.prototype, 'fixed', {
                    get: function () {
                        return this._fixed;
                    },
                    set: function (f) {
                        this._fixed = !!f;
                    },
                    enumerable: true,
                    configurable: true
                });
                GenericVector.prototype._checkFixed = function () {
                    if (this._fixed) {
                        this.sec.throwError('RangeError', AVMX.Errors.VectorFixedError);
                    }
                };
                GenericVector.prototype.axGetNumericProperty = function (nm) {
                    release || assert(Shumway.isNumeric(nm));
                    var idx = nm | 0;
                    if (idx < 0 || idx >= this._buffer.length || idx != nm) {
                        this.sec.throwError('RangeError', AVMX.Errors.OutOfRangeError, nm, this._buffer.length);
                    }
                    return this._buffer[idx];
                };
                GenericVector.prototype.axSetNumericProperty = function (nm, v) {
                    release || assert(Shumway.isNumeric(nm));
                    var length = this._buffer.length;
                    var idx = nm | 0;
                    if (idx < 0 || idx > length || idx != nm || idx === length && this._fixed) {
                        this.sec.throwError('RangeError', AVMX.Errors.OutOfRangeError, nm, length);
                    }
                    this._buffer[idx] = this._coerce(v);
                };
                GenericVector.prototype.axHasPropertyInternal = function (mn) {
                    // Optimization for the common case of indexed element accesses.
                    if ((mn.name | 0) === mn.name) {
                        release || assert(mn.isRuntimeName());
                        return mn.name >= 0 && mn.name < this._buffer.length;
                    }
                    var name = AVMX.axCoerceName(mn.name);
                    if (mn.isRuntimeName() && Shumway.isIndex(name)) {
                        var index = name >>> 0;
                        return index >= 0 && index < this._buffer.length;
                    }
                    return this.axResolveMultiname(mn) in this;
                };
                GenericVector.prototype.axNextValue = function (index) {
                    return this._buffer[index - 1];
                };
                GenericVector.prototype.axNextNameIndex = function (index) {
                    var nextNameIndex = index + 1;
                    if (nextNameIndex <= this._buffer.length) {
                        return nextNameIndex;
                    }
                    return 0;
                };
                GenericVector.CASEINSENSITIVE = 1;
                GenericVector.DESCENDING = 2;
                GenericVector.UNIQUESORT = 4;
                GenericVector.RETURNINDEXEDARRAY = 8;
                GenericVector.NUMERIC = 16;
                GenericVector.defaultValue = null;
                return GenericVector;
            }(BaseVector);
            AS.GenericVector = GenericVector;
            var assert = Shumway.Debug.assert;
            var assertNotImplemented = Shumway.Debug.assertNotImplemented;
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var Int32Vector = function (_super) {
                __extends(Int32Vector, _super);
                function Int32Vector(length, fixed) {
                    if (length === void 0) {
                        length = 0;
                    }
                    if (fixed === void 0) {
                        fixed = false;
                    }
                    _super.call(this);
                    length = length >>> 0;
                    this._fixed = !!fixed;
                    this._buffer = new Int32Array(Math.max(Int32Vector.INITIAL_CAPACITY, length + Int32Vector.EXTRA_CAPACITY));
                    this._offset = 0;
                    this._length = length;
                }
                Int32Vector.classInitializer = function () {
                    var proto = this.dPrototype;
                    var tProto = this.tPrototype;
                    // Fix up MOP handlers to not apply to the dynamic prototype, which is a plain object.
                    tProto.axGetProperty = proto.axGetProperty;
                    tProto.axGetNumericProperty = proto.axGetNumericProperty;
                    tProto.axSetProperty = proto.axSetProperty;
                    tProto.axSetNumericProperty = proto.axSetNumericProperty;
                    tProto.axHasPropertyInternal = proto.axHasPropertyInternal;
                    tProto.axNextName = proto.axNextName;
                    tProto.axNextNameIndex = proto.axNextNameIndex;
                    tProto.axNextValue = proto.axNextValue;
                    proto.axGetProperty = AS.ASObject.prototype.axGetProperty;
                    proto.axGetNumericProperty = AS.ASObject.prototype.axGetNumericProperty;
                    proto.axSetProperty = AS.ASObject.prototype.axSetProperty;
                    proto.axSetNumericProperty = AS.ASObject.prototype.axSetNumericProperty;
                    proto.axHasPropertyInternal = AS.ASObject.prototype.axHasPropertyInternal;
                    proto.axNextName = AS.ASObject.prototype.axNextName;
                    proto.axNextNameIndex = AS.ASObject.prototype.axNextNameIndex;
                    proto.axNextValue = AS.ASObject.prototype.axNextValue;
                    var asProto = Int32Vector.prototype;
                    defineNonEnumerableProperty(proto, '$Bgjoin', asProto.join);
                    // Same as join, see VectorImpl.as in Tamarin repository.
                    defineNonEnumerableProperty(proto, '$BgtoString', asProto.join);
                    defineNonEnumerableProperty(proto, '$BgtoLocaleString', asProto.toLocaleString);
                    defineNonEnumerableProperty(proto, '$Bgpop', asProto.pop);
                    defineNonEnumerableProperty(proto, '$Bgpush', asProto.push);
                    defineNonEnumerableProperty(proto, '$Bgreverse', asProto.reverse);
                    defineNonEnumerableProperty(proto, '$Bgconcat', asProto.concat);
                    defineNonEnumerableProperty(proto, '$Bgsplice', asProto.splice);
                    defineNonEnumerableProperty(proto, '$Bgslice', asProto.slice);
                    defineNonEnumerableProperty(proto, '$Bgshift', asProto.shift);
                    defineNonEnumerableProperty(proto, '$Bgunshift', asProto.unshift);
                    defineNonEnumerableProperty(proto, '$BgindexOf', asProto.indexOf);
                    defineNonEnumerableProperty(proto, '$BglastIndexOf', asProto.lastIndexOf);
                    defineNonEnumerableProperty(proto, '$BgforEach', asProto.forEach);
                    defineNonEnumerableProperty(proto, '$Bgmap', asProto.map);
                    defineNonEnumerableProperty(proto, '$Bgfilter', asProto.filter);
                    defineNonEnumerableProperty(proto, '$Bgsome', asProto.some);
                    defineNonEnumerableProperty(proto, '$Bgevery', asProto.every);
                    defineNonEnumerableProperty(proto, '$Bgsort', asProto.sort);
                    defineNonEnumerableProperty(proto, 'checkVectorMethodArgs', asProto.checkVectorMethodArgs);
                };
                Int32Vector.axApply = function (_, args) {
                    var object = args[0];
                    if (this.axIsType(object)) {
                        return object;
                    }
                    var length = object.axGetPublicProperty('length');
                    if (length !== undefined) {
                        var v = this.axConstruct([
                            length,
                            false
                        ]);
                        for (var i = 0; i < length; i++) {
                            v.axSetNumericProperty(i, object.axGetPublicProperty(i));
                        }
                        return v;
                    }
                    Shumway.Debug.unexpected();
                };
                Int32Vector.prototype.internalToString = function () {
                    var str = '';
                    var start = this._offset;
                    var end = start + this._length;
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (i === start) {
                            str += '[';
                        }
                        if (i === end) {
                            str += ']';
                        }
                        str += this._buffer[i];
                        if (i < this._buffer.length - 1) {
                            str += ',';
                        }
                    }
                    if (this._offset + this._length === this._buffer.length) {
                        str += ']';
                    }
                    return str + ': offset: ' + this._offset + ', length: ' + this._length + ', capacity: ' + this._buffer.length;
                };
                Int32Vector.prototype.toString = function () {
                    var str = '';
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ',';
                        }
                    }
                    return str;
                };
                Int32Vector.prototype.toLocaleString = function () {
                    var str = '';
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ',';
                        }
                    }
                    return str;
                };
                // vector.prototype.toString = vector.prototype.internalToString;
                Int32Vector.prototype._view = function () {
                    return this._buffer.subarray(this._offset, this._offset + this._length);
                };
                Int32Vector.prototype._ensureCapacity = function (length) {
                    var minCapacity = this._offset + length;
                    if (minCapacity < this._buffer.length) {
                        return;
                    }
                    if (length <= this._buffer.length) {
                        // New length exceeds bounds at current offset but fits in the buffer, so we center it.
                        var offset = this._buffer.length - length >> 2;
                        this._buffer.set(this._view(), offset);
                        this._offset = offset;
                        return;
                    }
                    // New length doesn't fit at all, resize buffer.
                    var oldCapacity = this._buffer.length;
                    var newCapacity = (oldCapacity * 3 >> 1) + 1;
                    if (newCapacity < minCapacity) {
                        newCapacity = minCapacity;
                    }
                    var buffer = new Int32Array(newCapacity);
                    buffer.set(this._buffer, 0);
                    this._buffer = buffer;
                };
                Int32Vector.prototype.concat = function () {
                    var length = this._length;
                    for (var i = 0; i < arguments.length; i++) {
                        var vector = arguments[i];
                        if (!(vector._buffer instanceof Int32Array)) {
                            assert(false);    // TODO
                        }
                        length += vector._length;
                    }
                    var result = new this.sec.Int32Vector(length);
                    var buffer = result._buffer;
                    buffer.set(this._buffer);
                    var offset = this._length;
                    for (var i = 0; i < arguments.length; i++) {
                        var vector = arguments[i];
                        if (offset + vector._buffer.length < vector._buffer.length) {
                            buffer.set(vector._buffer, offset);
                        } else {
                            buffer.set(vector._buffer.subarray(0, vector._length), offset);
                        }
                        offset += vector._length;
                    }
                    return result;
                };
                /**
                 * Executes a |callback| function with three arguments: element, index, the vector itself as
                 * well as passing the |thisObject| as |this| for each of the elements in the vector. If any of
                 * the callbacks return |false| the function terminates, otherwise it returns |true|.
                 */
                Int32Vector.prototype.every = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return true;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (!callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            return false;
                        }
                    }
                    return true;
                };
                /**
                 * Filters the elements for which the |callback| method returns |true|. The |callback| function
                 * is called with three arguments: element, index, the vector itself as well as passing the
                 * |thisObject| as |this| for each of the elements in the vector.
                 */
                Int32Vector.prototype.filter = function (callback, thisObject) {
                    var v = new this.sec.Int32Vector();
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return v;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            v.push(this._buffer[this._offset + i]);
                        }
                    }
                    return v;
                };
                Int32Vector.prototype.map = function (callback, thisObject) {
                    var v = this.axClass.axConstruct([
                        this.length,
                        false
                    ]);
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return v;
                    }
                    for (var i = 0; i < this._length; i++) {
                        v[i] = callback.call(thisObject, this._buffer[this._offset + i], i, this);
                    }
                    return v;
                };
                Int32Vector.prototype.some = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return false;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            return true;
                        }
                    }
                    return false;
                };
                Int32Vector.prototype.forEach = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return;
                    }
                    for (var i = 0; i < this._length; i++) {
                        callback.call(thisObject, this._buffer[this._offset + i], i, this);
                    }
                };
                Int32Vector.prototype.join = function (separator) {
                    if (separator === void 0) {
                        separator = ',';
                    }
                    var limit = this.length;
                    var buffer = this._buffer;
                    var offset = this._offset;
                    var result = '';
                    for (var i = 0; i < limit - 1; i++) {
                        result += buffer[offset + i] + separator;
                    }
                    if (limit > 0) {
                        result += buffer[offset + limit - 1];
                    }
                    return result;
                };
                Int32Vector.prototype.indexOf = function (searchElement, fromIndex) {
                    if (fromIndex === void 0) {
                        fromIndex = 0;
                    }
                    var length = this._length;
                    var start = fromIndex | 0;
                    if (start < 0) {
                        start = start + length;
                        if (start < 0) {
                            start = 0;
                        }
                    } else if (start >= length) {
                        return -1;
                    }
                    var buffer = this._buffer;
                    var length = this._length;
                    var offset = this._offset;
                    start += offset;
                    var end = offset + length;
                    for (var i = start; i < end; i++) {
                        if (buffer[i] === searchElement) {
                            return i - offset;
                        }
                    }
                    return -1;
                };
                Int32Vector.prototype.lastIndexOf = function (searchElement, fromIndex) {
                    if (fromIndex === void 0) {
                        fromIndex = 2147483647;
                    }
                    var length = this._length;
                    var start = fromIndex | 0;
                    if (start < 0) {
                        start = start + length;
                        if (start < 0) {
                            return -1;
                        }
                    } else if (start >= length) {
                        start = length;
                    }
                    var buffer = this._buffer;
                    var offset = this._offset;
                    start += offset;
                    var end = offset;
                    for (var i = start; i-- > end;) {
                        if (buffer[i] === searchElement) {
                            return i - offset;
                        }
                    }
                    return -1;
                };
                Int32Vector.prototype.push = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
                    this._checkFixed();
                    this._ensureCapacity(this._length + arguments.length);
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + this._length++] = arguments[i];
                    }
                };
                Int32Vector.prototype.pop = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return Int32Vector.DEFAULT_VALUE;
                    }
                    this._length--;
                    return this._buffer[this._offset + this._length];    // TODO: should we potentially reallocate to a smaller buffer here?
                };
                Int32Vector.prototype.reverse = function () {
                    var l = this._offset;
                    var r = this._offset + this._length - 1;
                    var b = this._buffer;
                    while (l < r) {
                        var t = b[l];
                        b[l] = b[r];
                        b[r] = t;
                        l++;
                        r--;
                    }
                    return this;
                };
                Int32Vector.prototype.sort = function (sortBehavior) {
                    if (arguments.length === 0) {
                        Array.prototype.sort.call(this._view());
                        return this;
                    }
                    if (this.sec.AXFunction.axIsType(sortBehavior)) {
                        Array.prototype.sort.call(this._view(), sortBehavior.value);
                        return this;
                    }
                    var options = sortBehavior | 0;
                    release || assertNotImplemented(!(options & Int32Vector.UNIQUESORT), 'UNIQUESORT');
                    release || assertNotImplemented(!(options & Int32Vector.RETURNINDEXEDARRAY), 'RETURNINDEXEDARRAY');
                    if (options & Int32Vector.DESCENDING) {
                        Array.prototype.sort.call(this._view(), function (a, b) {
                            return b - a;
                        });
                    } else {
                        Array.prototype.sort.call(this._view(), function (a, b) {
                            return a - b;
                        });
                    }
                    return this;
                };
                Int32Vector.prototype.shift = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return 0;
                    }
                    this._length--;
                    return this._buffer[this._offset++];
                };
                Int32Vector.prototype.unshift = function () {
                    this._checkFixed();
                    if (!arguments.length) {
                        return;
                    }
                    this._ensureCapacity(this._length + arguments.length);
                    this._slide(arguments.length);
                    this._offset -= arguments.length;
                    this._length += arguments.length;
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + i] = arguments[i];
                    }
                };
                Int32Vector.prototype.slice = function (start, end) {
                    if (start === void 0) {
                        start = 0;
                    }
                    if (end === void 0) {
                        end = 2147483647;
                    }
                    var buffer = this._buffer;
                    var length = this._length;
                    var first = Math.min(Math.max(start, 0), length);
                    var last = Math.min(Math.max(end, first), length);
                    var result = new this.sec.Int32Vector(last - first, this.fixed);
                    result._buffer.set(buffer.subarray(this._offset + first, this._offset + last), result._offset);
                    return result;
                };
                Int32Vector.prototype.splice = function (start, deleteCount_) {
                    var buffer = this._buffer;
                    var length = this._length;
                    var first = Math.min(Math.max(start, 0), length);
                    var startOffset = this._offset + first;
                    var deleteCount = Math.min(Math.max(deleteCount_, 0), length - first);
                    var insertCount = arguments.length - 2;
                    var deletedItems;
                    var result = new this.sec.Int32Vector(deleteCount, this.fixed);
                    if (deleteCount > 0) {
                        deletedItems = buffer.subarray(startOffset, startOffset + deleteCount);
                        result._buffer.set(deletedItems, result._offset);
                    }
                    this._ensureCapacity(length - deleteCount + insertCount);
                    var right = startOffset + deleteCount;
                    var slice = buffer.subarray(right, length);
                    buffer.set(slice, startOffset + insertCount);
                    this._length += insertCount - deleteCount;
                    for (var i = 0; i < insertCount; i++) {
                        buffer[startOffset + i] = arguments[i + 2];
                    }
                    return result;
                };
                Int32Vector.prototype._slide = function (distance) {
                    this._buffer.set(this._view(), this._offset + distance);
                    this._offset += distance;
                };
                Object.defineProperty(Int32Vector.prototype, 'length', {
                    get: function () {
                        return this._length;
                    },
                    set: function (value) {
                        value = value >>> 0;
                        if (value > this._length) {
                            this._ensureCapacity(value);
                            for (var i = this._offset + this._length, j = this._offset + value; i < j; i++) {
                                this._buffer[i] = Int32Vector.DEFAULT_VALUE;
                            }
                        }
                        this._length = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Int32Vector.prototype, 'fixed', {
                    get: function () {
                        return this._fixed;
                    },
                    set: function (f) {
                        this._fixed = !!f;
                    },
                    enumerable: true,
                    configurable: true
                });
                Int32Vector.prototype._checkFixed = function () {
                    if (this._fixed) {
                        this.sec.throwError('RangeError', AVMX.Errors.VectorFixedError);
                    }
                };
                Int32Vector.prototype.axGetNumericProperty = function (nm) {
                    release || assert(Shumway.isNumeric(nm));
                    var length = this._length;
                    var idx = nm | 0;
                    if (idx < 0 || idx >= length || idx != nm) {
                        this.sec.throwError('RangeError', AVMX.Errors.OutOfRangeError, nm, length);
                    }
                    return this._buffer[this._offset + idx];
                };
                Int32Vector.prototype.axSetNumericProperty = function (nm, v) {
                    release || assert(Shumway.isNumeric(nm));
                    var length = this._length;
                    var idx = nm | 0;
                    if (idx < 0 || idx > length || idx != nm || idx === length && this._fixed) {
                        this.sec.throwError('RangeError', AVMX.Errors.OutOfRangeError, nm, length);
                    }
                    if (idx === this._length) {
                        this._ensureCapacity(this._length + 1);
                        this._length++;
                    }
                    this._buffer[this._offset + idx] = v;
                };
                Int32Vector.prototype.axHasPropertyInternal = function (mn) {
                    // Optimization for the common case of indexed element accesses.
                    if ((mn.name | 0) === mn.name) {
                        release || assert(mn.isRuntimeName());
                        return mn.name >= 0 && mn.name < this._length;
                    }
                    var name = AVMX.axCoerceName(mn.name);
                    if (mn.isRuntimeName() && Shumway.isIndex(name)) {
                        var index = name >>> 0;
                        return index >= 0 && index < this._length;
                    }
                    return this.axResolveMultiname(mn) in this;
                };
                Int32Vector.prototype.axNextValue = function (index) {
                    return this._buffer[this._offset + index - 1];
                };
                Int32Vector.prototype.axNextNameIndex = function (index) {
                    var nextNameIndex = index + 1;
                    if (nextNameIndex <= this._length) {
                        return nextNameIndex;
                    }
                    return 0;
                };
                Int32Vector.EXTRA_CAPACITY = 4;
                Int32Vector.INITIAL_CAPACITY = 10;
                Int32Vector.DEFAULT_VALUE = 0;
                Int32Vector.DESCENDING = 2;
                Int32Vector.UNIQUESORT = 4;
                Int32Vector.RETURNINDEXEDARRAY = 8;
                return Int32Vector;
            }(AS.BaseVector);
            AS.Int32Vector = Int32Vector;
            var assert = Shumway.Debug.assert;
            var assertNotImplemented = Shumway.Debug.assertNotImplemented;
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var Uint32Vector = function (_super) {
                __extends(Uint32Vector, _super);
                function Uint32Vector(length, fixed) {
                    if (length === void 0) {
                        length = 0;
                    }
                    if (fixed === void 0) {
                        fixed = false;
                    }
                    _super.call(this);
                    length = length >>> 0;
                    this._fixed = !!fixed;
                    this._buffer = new Uint32Array(Math.max(Uint32Vector.INITIAL_CAPACITY, length + Uint32Vector.EXTRA_CAPACITY));
                    this._offset = 0;
                    this._length = length;
                }
                Uint32Vector.classInitializer = function () {
                    var proto = this.dPrototype;
                    var tProto = this.tPrototype;
                    // Fix up MOP handlers to not apply to the dynamic prototype, which is a plain object.
                    tProto.axGetProperty = proto.axGetProperty;
                    tProto.axGetNumericProperty = proto.axGetNumericProperty;
                    tProto.axSetProperty = proto.axSetProperty;
                    tProto.axSetNumericProperty = proto.axSetNumericProperty;
                    tProto.axHasPropertyInternal = proto.axHasPropertyInternal;
                    tProto.axNextName = proto.axNextName;
                    tProto.axNextNameIndex = proto.axNextNameIndex;
                    tProto.axNextValue = proto.axNextValue;
                    proto.axGetProperty = AS.ASObject.prototype.axGetProperty;
                    proto.axGetNumericProperty = AS.ASObject.prototype.axGetNumericProperty;
                    proto.axSetProperty = AS.ASObject.prototype.axSetProperty;
                    proto.axSetNumericProperty = AS.ASObject.prototype.axSetNumericProperty;
                    proto.axHasPropertyInternal = AS.ASObject.prototype.axHasPropertyInternal;
                    proto.axNextName = AS.ASObject.prototype.axNextName;
                    proto.axNextNameIndex = AS.ASObject.prototype.axNextNameIndex;
                    proto.axNextValue = AS.ASObject.prototype.axNextValue;
                    var asProto = Uint32Vector.prototype;
                    defineNonEnumerableProperty(proto, '$Bgjoin', asProto.join);
                    // Same as join, see VectorImpl.as in Tamarin repository.
                    defineNonEnumerableProperty(proto, '$BgtoString', asProto.join);
                    defineNonEnumerableProperty(proto, '$BgtoLocaleString', asProto.toLocaleString);
                    defineNonEnumerableProperty(proto, '$Bgpop', asProto.pop);
                    defineNonEnumerableProperty(proto, '$Bgpush', asProto.push);
                    defineNonEnumerableProperty(proto, '$Bgreverse', asProto.reverse);
                    defineNonEnumerableProperty(proto, '$Bgconcat', asProto.concat);
                    defineNonEnumerableProperty(proto, '$Bgsplice', asProto.splice);
                    defineNonEnumerableProperty(proto, '$Bgslice', asProto.slice);
                    defineNonEnumerableProperty(proto, '$Bgshift', asProto.shift);
                    defineNonEnumerableProperty(proto, '$Bgunshift', asProto.unshift);
                    defineNonEnumerableProperty(proto, '$BgindexOf', asProto.indexOf);
                    defineNonEnumerableProperty(proto, '$BglastIndexOf', asProto.lastIndexOf);
                    defineNonEnumerableProperty(proto, '$BgforEach', asProto.forEach);
                    defineNonEnumerableProperty(proto, '$Bgmap', asProto.map);
                    defineNonEnumerableProperty(proto, '$Bgfilter', asProto.filter);
                    defineNonEnumerableProperty(proto, '$Bgsome', asProto.some);
                    defineNonEnumerableProperty(proto, '$Bgevery', asProto.every);
                    defineNonEnumerableProperty(proto, '$Bgsort', asProto.sort);
                    defineNonEnumerableProperty(proto, 'checkVectorMethodArgs', asProto.checkVectorMethodArgs);
                };
                Uint32Vector.axApply = function (_, args) {
                    var object = args[0];
                    if (this.axIsType(object)) {
                        return object;
                    }
                    var length = object.axGetPublicProperty('length');
                    if (length !== undefined) {
                        var v = this.axConstruct([
                            length,
                            false
                        ]);
                        for (var i = 0; i < length; i++) {
                            v.axSetNumericProperty(i, object.axGetPublicProperty(i));
                        }
                        return v;
                    }
                    Shumway.Debug.unexpected();
                };
                Uint32Vector.prototype.internalToString = function () {
                    var str = '';
                    var start = this._offset;
                    var end = start + this._length;
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (i === start) {
                            str += '[';
                        }
                        if (i === end) {
                            str += ']';
                        }
                        str += this._buffer[i];
                        if (i < this._buffer.length - 1) {
                            str += ',';
                        }
                    }
                    if (this._offset + this._length === this._buffer.length) {
                        str += ']';
                    }
                    return str + ': offset: ' + this._offset + ', length: ' + this._length + ', capacity: ' + this._buffer.length;
                };
                Uint32Vector.prototype.toString = function () {
                    var str = '';
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ',';
                        }
                    }
                    return str;
                };
                Uint32Vector.prototype.toLocaleString = function () {
                    var str = '';
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ',';
                        }
                    }
                    return str;
                };
                // vector.prototype.toString = vector.prototype.internalToString;
                Uint32Vector.prototype._view = function () {
                    return this._buffer.subarray(this._offset, this._offset + this._length);
                };
                Uint32Vector.prototype._ensureCapacity = function (length) {
                    var minCapacity = this._offset + length;
                    if (minCapacity < this._buffer.length) {
                        return;
                    }
                    if (length <= this._buffer.length) {
                        // New length exceeds bounds at current offset but fits in the buffer, so we center it.
                        var offset = this._buffer.length - length >> 2;
                        this._buffer.set(this._view(), offset);
                        this._offset = offset;
                        return;
                    }
                    // New length doesn't fit at all, resize buffer.
                    var oldCapacity = this._buffer.length;
                    var newCapacity = (oldCapacity * 3 >> 1) + 1;
                    if (newCapacity < minCapacity) {
                        newCapacity = minCapacity;
                    }
                    var buffer = new Uint32Array(newCapacity);
                    buffer.set(this._buffer, 0);
                    this._buffer = buffer;
                };
                Uint32Vector.prototype.concat = function () {
                    var length = this._length;
                    for (var i = 0; i < arguments.length; i++) {
                        var vector = arguments[i];
                        if (!(vector._buffer instanceof Uint32Array)) {
                            assert(false);    // TODO
                        }
                        length += vector._length;
                    }
                    var result = new this.sec.Uint32Vector(length);
                    var buffer = result._buffer;
                    buffer.set(this._buffer);
                    var offset = this._length;
                    for (var i = 0; i < arguments.length; i++) {
                        var vector = arguments[i];
                        if (offset + vector._buffer.length < vector._buffer.length) {
                            buffer.set(vector._buffer, offset);
                        } else {
                            buffer.set(vector._buffer.subarray(0, vector._length), offset);
                        }
                        offset += vector._length;
                    }
                    return result;
                };
                /**
                 * Executes a |callback| function with three arguments: element, index, the vector itself as
                 * well as passing the |thisObject| as |this| for each of the elements in the vector. If any of
                 * the callbacks return |false| the function terminates, otherwise it returns |true|.
                 */
                Uint32Vector.prototype.every = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return true;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (!callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            return false;
                        }
                    }
                    return true;
                };
                /**
                 * Filters the elements for which the |callback| method returns |true|. The |callback| function
                 * is called with three arguments: element, index, the vector itself as well as passing the
                 * |thisObject| as |this| for each of the elements in the vector.
                 */
                Uint32Vector.prototype.filter = function (callback, thisObject) {
                    var v = new this.sec.Uint32Vector();
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return v;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            v.push(this._buffer[this._offset + i]);
                        }
                    }
                    return v;
                };
                Uint32Vector.prototype.map = function (callback, thisObject) {
                    var v = this.axClass.axConstruct([
                        this.length,
                        false
                    ]);
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return v;
                    }
                    for (var i = 0; i < this._length; i++) {
                        v[i] = callback.call(thisObject, this._buffer[this._offset + i], i, this);
                    }
                    return v;
                };
                Uint32Vector.prototype.some = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return false;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            return true;
                        }
                    }
                    return false;
                };
                Uint32Vector.prototype.forEach = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return;
                    }
                    for (var i = 0; i < this._length; i++) {
                        callback.call(thisObject, this._buffer[this._offset + i], i, this);
                    }
                };
                Uint32Vector.prototype.join = function (separator) {
                    if (separator === void 0) {
                        separator = ',';
                    }
                    var limit = this.length;
                    var buffer = this._buffer;
                    var offset = this._offset;
                    var result = '';
                    for (var i = 0; i < limit - 1; i++) {
                        result += buffer[offset + i] + separator;
                    }
                    if (limit > 0) {
                        result += buffer[offset + limit - 1];
                    }
                    return result;
                };
                Uint32Vector.prototype.indexOf = function (searchElement, fromIndex) {
                    if (fromIndex === void 0) {
                        fromIndex = 0;
                    }
                    var length = this._length;
                    var start = fromIndex | 0;
                    if (start < 0) {
                        start = start + length;
                        if (start < 0) {
                            start = 0;
                        }
                    } else if (start >= length) {
                        return -1;
                    }
                    var buffer = this._buffer;
                    var length = this._length;
                    var offset = this._offset;
                    start += offset;
                    var end = offset + length;
                    for (var i = start; i < end; i++) {
                        if (buffer[i] === searchElement) {
                            return i - offset;
                        }
                    }
                    return -1;
                };
                Uint32Vector.prototype.lastIndexOf = function (searchElement, fromIndex) {
                    if (fromIndex === void 0) {
                        fromIndex = 2147483647;
                    }
                    var length = this._length;
                    var start = fromIndex | 0;
                    if (start < 0) {
                        start = start + length;
                        if (start < 0) {
                            return -1;
                        }
                    } else if (start >= length) {
                        start = length;
                    }
                    var buffer = this._buffer;
                    var offset = this._offset;
                    start += offset;
                    var end = offset;
                    for (var i = start; i-- > end;) {
                        if (buffer[i] === searchElement) {
                            return i - offset;
                        }
                    }
                    return -1;
                };
                Uint32Vector.prototype.push = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
                    this._checkFixed();
                    this._ensureCapacity(this._length + arguments.length);
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + this._length++] = arguments[i];
                    }
                };
                Uint32Vector.prototype.pop = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return Uint32Vector.DEFAULT_VALUE;
                    }
                    this._length--;
                    return this._buffer[this._offset + this._length];    // TODO: should we potentially reallocate to a smaller buffer here?
                };
                Uint32Vector.prototype.reverse = function () {
                    var l = this._offset;
                    var r = this._offset + this._length - 1;
                    var b = this._buffer;
                    while (l < r) {
                        var t = b[l];
                        b[l] = b[r];
                        b[r] = t;
                        l++;
                        r--;
                    }
                    return this;
                };
                Uint32Vector.prototype.sort = function (sortBehavior) {
                    if (arguments.length === 0) {
                        Array.prototype.sort.call(this._view());
                        return this;
                    }
                    if (this.sec.AXFunction.axIsType(sortBehavior)) {
                        Array.prototype.sort.call(this._view(), sortBehavior.value);
                        return this;
                    }
                    var options = sortBehavior | 0;
                    release || assertNotImplemented(!(options & Uint32Vector.UNIQUESORT), 'UNIQUESORT');
                    release || assertNotImplemented(!(options & Uint32Vector.RETURNINDEXEDARRAY), 'RETURNINDEXEDARRAY');
                    if (options & Uint32Vector.DESCENDING) {
                        Array.prototype.sort.call(this._view(), function (a, b) {
                            return b - a;
                        });
                    } else {
                        Array.prototype.sort.call(this._view(), function (a, b) {
                            return a - b;
                        });
                    }
                    return this;
                };
                Uint32Vector.prototype.shift = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return 0;
                    }
                    this._length--;
                    return this._buffer[this._offset++];
                };
                Uint32Vector.prototype.unshift = function () {
                    this._checkFixed();
                    if (!arguments.length) {
                        return;
                    }
                    this._ensureCapacity(this._length + arguments.length);
                    this._slide(arguments.length);
                    this._offset -= arguments.length;
                    this._length += arguments.length;
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + i] = arguments[i];
                    }
                };
                Uint32Vector.prototype.slice = function (start, end) {
                    if (start === void 0) {
                        start = 0;
                    }
                    if (end === void 0) {
                        end = 2147483647;
                    }
                    var buffer = this._buffer;
                    var length = this._length;
                    var first = Math.min(Math.max(start, 0), length);
                    var last = Math.min(Math.max(end, first), length);
                    var result = new this.sec.Uint32Vector(last - first, this.fixed);
                    result._buffer.set(buffer.subarray(this._offset + first, this._offset + last), result._offset);
                    return result;
                };
                Uint32Vector.prototype.splice = function (start, deleteCount_) {
                    var buffer = this._buffer;
                    var length = this._length;
                    var first = Math.min(Math.max(start, 0), length);
                    var startOffset = this._offset + first;
                    var deleteCount = Math.min(Math.max(deleteCount_, 0), length - first);
                    var insertCount = arguments.length - 2;
                    var deletedItems;
                    var result = new this.sec.Uint32Vector(deleteCount, this.fixed);
                    if (deleteCount > 0) {
                        deletedItems = buffer.subarray(startOffset, startOffset + deleteCount);
                        result._buffer.set(deletedItems, result._offset);
                    }
                    this._ensureCapacity(length - deleteCount + insertCount);
                    var right = startOffset + deleteCount;
                    var slice = buffer.subarray(right, length);
                    buffer.set(slice, startOffset + insertCount);
                    this._length += insertCount - deleteCount;
                    for (var i = 0; i < insertCount; i++) {
                        buffer[startOffset + i] = arguments[i + 2];
                    }
                    return result;
                };
                Uint32Vector.prototype._slide = function (distance) {
                    this._buffer.set(this._view(), this._offset + distance);
                    this._offset += distance;
                };
                Object.defineProperty(Uint32Vector.prototype, 'length', {
                    get: function () {
                        return this._length;
                    },
                    set: function (value) {
                        value = value >>> 0;
                        if (value > this._length) {
                            this._ensureCapacity(value);
                            for (var i = this._offset + this._length, j = this._offset + value; i < j; i++) {
                                this._buffer[i] = Uint32Vector.DEFAULT_VALUE;
                            }
                        }
                        this._length = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Uint32Vector.prototype, 'fixed', {
                    get: function () {
                        return this._fixed;
                    },
                    set: function (f) {
                        this._fixed = !!f;
                    },
                    enumerable: true,
                    configurable: true
                });
                Uint32Vector.prototype._checkFixed = function () {
                    if (this._fixed) {
                        this.sec.throwError('RangeError', AVMX.Errors.VectorFixedError);
                    }
                };
                Uint32Vector.prototype.axGetNumericProperty = function (nm) {
                    release || assert(Shumway.isNumeric(nm));
                    var length = this._length;
                    var idx = nm | 0;
                    if (idx < 0 || idx >= length || idx != nm) {
                        this.sec.throwError('RangeError', AVMX.Errors.OutOfRangeError, nm, length);
                    }
                    return this._buffer[this._offset + idx];
                };
                Uint32Vector.prototype.axSetNumericProperty = function (nm, v) {
                    release || assert(Shumway.isNumeric(nm));
                    var length = this._length;
                    var idx = nm | 0;
                    if (idx < 0 || idx > length || idx != nm || idx === length && this._fixed) {
                        this.sec.throwError('RangeError', AVMX.Errors.OutOfRangeError, nm, length);
                    }
                    if (idx === this._length) {
                        this._ensureCapacity(this._length + 1);
                        this._length++;
                    }
                    this._buffer[this._offset + idx] = v;
                };
                Uint32Vector.prototype.axHasPropertyInternal = function (mn) {
                    // Optimization for the common case of indexed element accesses.
                    if ((mn.name | 0) === mn.name) {
                        release || assert(mn.isRuntimeName());
                        return mn.name >= 0 && mn.name < this._length;
                    }
                    var name = AVMX.axCoerceName(mn.name);
                    if (mn.isRuntimeName() && Shumway.isIndex(name)) {
                        var index = name >>> 0;
                        return index >= 0 && index < this._length;
                    }
                    return this.axResolveMultiname(mn) in this;
                };
                Uint32Vector.prototype.axNextValue = function (index) {
                    return this._buffer[this._offset + index - 1];
                };
                Uint32Vector.prototype.axNextNameIndex = function (index) {
                    var nextNameIndex = index + 1;
                    if (nextNameIndex <= this._length) {
                        return nextNameIndex;
                    }
                    return 0;
                };
                Uint32Vector.EXTRA_CAPACITY = 4;
                Uint32Vector.INITIAL_CAPACITY = 10;
                Uint32Vector.DEFAULT_VALUE = 0;
                Uint32Vector.DESCENDING = 2;
                Uint32Vector.UNIQUESORT = 4;
                Uint32Vector.RETURNINDEXEDARRAY = 8;
                return Uint32Vector;
            }(AS.BaseVector);
            AS.Uint32Vector = Uint32Vector;
            var assert = Shumway.Debug.assert;
            var assertNotImplemented = Shumway.Debug.assertNotImplemented;
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var Float64Vector = function (_super) {
                __extends(Float64Vector, _super);
                function Float64Vector(length, fixed) {
                    if (length === void 0) {
                        length = 0;
                    }
                    if (fixed === void 0) {
                        fixed = false;
                    }
                    _super.call(this);
                    length = length >>> 0;
                    this._fixed = !!fixed;
                    this._buffer = new Float64Array(Math.max(Float64Vector.INITIAL_CAPACITY, length + Float64Vector.EXTRA_CAPACITY));
                    this._offset = 0;
                    this._length = length;
                }
                Float64Vector.classInitializer = function () {
                    var proto = this.dPrototype;
                    var tProto = this.tPrototype;
                    // Fix up MOP handlers to not apply to the dynamic prototype, which is a plain object.
                    tProto.axGetProperty = proto.axGetProperty;
                    tProto.axGetNumericProperty = proto.axGetNumericProperty;
                    tProto.axSetProperty = proto.axSetProperty;
                    tProto.axSetNumericProperty = proto.axSetNumericProperty;
                    tProto.axHasPropertyInternal = proto.axHasPropertyInternal;
                    tProto.axNextName = proto.axNextName;
                    tProto.axNextNameIndex = proto.axNextNameIndex;
                    tProto.axNextValue = proto.axNextValue;
                    proto.axGetProperty = AS.ASObject.prototype.axGetProperty;
                    proto.axGetNumericProperty = AS.ASObject.prototype.axGetNumericProperty;
                    proto.axSetProperty = AS.ASObject.prototype.axSetProperty;
                    proto.axSetNumericProperty = AS.ASObject.prototype.axSetNumericProperty;
                    proto.axHasPropertyInternal = AS.ASObject.prototype.axHasPropertyInternal;
                    proto.axNextName = AS.ASObject.prototype.axNextName;
                    proto.axNextNameIndex = AS.ASObject.prototype.axNextNameIndex;
                    proto.axNextValue = AS.ASObject.prototype.axNextValue;
                    var asProto = Float64Vector.prototype;
                    defineNonEnumerableProperty(proto, '$Bgjoin', asProto.join);
                    // Same as join, see VectorImpl.as in Tamarin repository.
                    defineNonEnumerableProperty(proto, '$BgtoString', asProto.join);
                    defineNonEnumerableProperty(proto, '$BgtoLocaleString', asProto.toLocaleString);
                    defineNonEnumerableProperty(proto, '$Bgpop', asProto.pop);
                    defineNonEnumerableProperty(proto, '$Bgpush', asProto.push);
                    defineNonEnumerableProperty(proto, '$Bgreverse', asProto.reverse);
                    defineNonEnumerableProperty(proto, '$Bgconcat', asProto.concat);
                    defineNonEnumerableProperty(proto, '$Bgsplice', asProto.splice);
                    defineNonEnumerableProperty(proto, '$Bgslice', asProto.slice);
                    defineNonEnumerableProperty(proto, '$Bgshift', asProto.shift);
                    defineNonEnumerableProperty(proto, '$Bgunshift', asProto.unshift);
                    defineNonEnumerableProperty(proto, '$BgindexOf', asProto.indexOf);
                    defineNonEnumerableProperty(proto, '$BglastIndexOf', asProto.lastIndexOf);
                    defineNonEnumerableProperty(proto, '$BgforEach', asProto.forEach);
                    defineNonEnumerableProperty(proto, '$Bgmap', asProto.map);
                    defineNonEnumerableProperty(proto, '$Bgfilter', asProto.filter);
                    defineNonEnumerableProperty(proto, '$Bgsome', asProto.some);
                    defineNonEnumerableProperty(proto, '$Bgevery', asProto.every);
                    defineNonEnumerableProperty(proto, '$Bgsort', asProto.sort);
                    defineNonEnumerableProperty(proto, 'checkVectorMethodArgs', asProto.checkVectorMethodArgs);
                };
                Float64Vector.axApply = function (_, args) {
                    var object = args[0];
                    if (this.axIsType(object)) {
                        return object;
                    }
                    var length = object.axGetPublicProperty('length');
                    if (length !== undefined) {
                        var v = this.axConstruct([
                            length,
                            false
                        ]);
                        for (var i = 0; i < length; i++) {
                            v.axSetNumericProperty(i, object.axGetPublicProperty(i));
                        }
                        return v;
                    }
                    Shumway.Debug.unexpected();
                };
                Float64Vector.prototype.internalToString = function () {
                    var str = '';
                    var start = this._offset;
                    var end = start + this._length;
                    for (var i = 0; i < this._buffer.length; i++) {
                        if (i === start) {
                            str += '[';
                        }
                        if (i === end) {
                            str += ']';
                        }
                        str += this._buffer[i];
                        if (i < this._buffer.length - 1) {
                            str += ',';
                        }
                    }
                    if (this._offset + this._length === this._buffer.length) {
                        str += ']';
                    }
                    return str + ': offset: ' + this._offset + ', length: ' + this._length + ', capacity: ' + this._buffer.length;
                };
                Float64Vector.prototype.toString = function () {
                    var str = '';
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ',';
                        }
                    }
                    return str;
                };
                Float64Vector.prototype.toLocaleString = function () {
                    var str = '';
                    for (var i = 0; i < this._length; i++) {
                        str += this._buffer[this._offset + i];
                        if (i < this._length - 1) {
                            str += ',';
                        }
                    }
                    return str;
                };
                // vector.prototype.toString = vector.prototype.internalToString;
                Float64Vector.prototype._view = function () {
                    return this._buffer.subarray(this._offset, this._offset + this._length);
                };
                Float64Vector.prototype._ensureCapacity = function (length) {
                    var minCapacity = this._offset + length;
                    if (minCapacity < this._buffer.length) {
                        return;
                    }
                    if (length <= this._buffer.length) {
                        // New length exceeds bounds at current offset but fits in the buffer, so we center it.
                        var offset = this._buffer.length - length >> 2;
                        this._buffer.set(this._view(), offset);
                        this._offset = offset;
                        return;
                    }
                    // New length doesn't fit at all, resize buffer.
                    var oldCapacity = this._buffer.length;
                    var newCapacity = (oldCapacity * 3 >> 1) + 1;
                    if (newCapacity < minCapacity) {
                        newCapacity = minCapacity;
                    }
                    var buffer = new Float64Array(newCapacity);
                    buffer.set(this._buffer, 0);
                    this._buffer = buffer;
                };
                Float64Vector.prototype.concat = function () {
                    var length = this._length;
                    for (var i = 0; i < arguments.length; i++) {
                        var vector = arguments[i];
                        if (!(vector._buffer instanceof Float64Array)) {
                            assert(false);    // TODO
                        }
                        length += vector._length;
                    }
                    var result = new this.sec.Float64Vector(length);
                    var buffer = result._buffer;
                    buffer.set(this._buffer);
                    var offset = this._length;
                    for (var i = 0; i < arguments.length; i++) {
                        var vector = arguments[i];
                        if (offset + vector._buffer.length < vector._buffer.length) {
                            buffer.set(vector._buffer, offset);
                        } else {
                            buffer.set(vector._buffer.subarray(0, vector._length), offset);
                        }
                        offset += vector._length;
                    }
                    return result;
                };
                /**
                 * Executes a |callback| function with three arguments: element, index, the vector itself as
                 * well as passing the |thisObject| as |this| for each of the elements in the vector. If any of
                 * the callbacks return |false| the function terminates, otherwise it returns |true|.
                 */
                Float64Vector.prototype.every = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return true;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (!callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            return false;
                        }
                    }
                    return true;
                };
                /**
                 * Filters the elements for which the |callback| method returns |true|. The |callback| function
                 * is called with three arguments: element, index, the vector itself as well as passing the
                 * |thisObject| as |this| for each of the elements in the vector.
                 */
                Float64Vector.prototype.filter = function (callback, thisObject) {
                    var v = new this.sec.Float64Vector();
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return v;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            v.push(this._buffer[this._offset + i]);
                        }
                    }
                    return v;
                };
                Float64Vector.prototype.map = function (callback, thisObject) {
                    var v = this.axClass.axConstruct([
                        this.length,
                        false
                    ]);
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return v;
                    }
                    for (var i = 0; i < this._length; i++) {
                        v[i] = callback.call(thisObject, this._buffer[this._offset + i], i, this);
                    }
                    return v;
                };
                Float64Vector.prototype.some = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return false;
                    }
                    for (var i = 0; i < this._length; i++) {
                        if (callback.call(thisObject, this._buffer[this._offset + i], i, this)) {
                            return true;
                        }
                    }
                    return false;
                };
                Float64Vector.prototype.forEach = function (callback, thisObject) {
                    if (!this.checkVectorMethodArgs(callback, thisObject)) {
                        return;
                    }
                    for (var i = 0; i < this._length; i++) {
                        callback.call(thisObject, this._buffer[this._offset + i], i, this);
                    }
                };
                Float64Vector.prototype.join = function (separator) {
                    if (separator === void 0) {
                        separator = ',';
                    }
                    var limit = this.length;
                    var buffer = this._buffer;
                    var offset = this._offset;
                    var result = '';
                    for (var i = 0; i < limit - 1; i++) {
                        result += buffer[offset + i] + separator;
                    }
                    if (limit > 0) {
                        result += buffer[offset + limit - 1];
                    }
                    return result;
                };
                Float64Vector.prototype.indexOf = function (searchElement, fromIndex) {
                    if (fromIndex === void 0) {
                        fromIndex = 0;
                    }
                    var length = this._length;
                    var start = fromIndex | 0;
                    if (start < 0) {
                        start = start + length;
                        if (start < 0) {
                            start = 0;
                        }
                    } else if (start >= length) {
                        return -1;
                    }
                    var buffer = this._buffer;
                    var length = this._length;
                    var offset = this._offset;
                    start += offset;
                    var end = offset + length;
                    for (var i = start; i < end; i++) {
                        if (buffer[i] === searchElement) {
                            return i - offset;
                        }
                    }
                    return -1;
                };
                Float64Vector.prototype.lastIndexOf = function (searchElement, fromIndex) {
                    if (fromIndex === void 0) {
                        fromIndex = 2147483647;
                    }
                    var length = this._length;
                    var start = fromIndex | 0;
                    if (start < 0) {
                        start = start + length;
                        if (start < 0) {
                            return -1;
                        }
                    } else if (start >= length) {
                        start = length;
                    }
                    var buffer = this._buffer;
                    var offset = this._offset;
                    start += offset;
                    var end = offset;
                    for (var i = start; i-- > end;) {
                        if (buffer[i] === searchElement) {
                            return i - offset;
                        }
                    }
                    return -1;
                };
                Float64Vector.prototype.push = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
                    this._checkFixed();
                    this._ensureCapacity(this._length + arguments.length);
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + this._length++] = arguments[i];
                    }
                };
                Float64Vector.prototype.pop = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return Float64Vector.DEFAULT_VALUE;
                    }
                    this._length--;
                    return this._buffer[this._offset + this._length];    // TODO: should we potentially reallocate to a smaller buffer here?
                };
                Float64Vector.prototype.reverse = function () {
                    var l = this._offset;
                    var r = this._offset + this._length - 1;
                    var b = this._buffer;
                    while (l < r) {
                        var t = b[l];
                        b[l] = b[r];
                        b[r] = t;
                        l++;
                        r--;
                    }
                    return this;
                };
                Float64Vector.prototype.sort = function (sortBehavior) {
                    if (arguments.length === 0) {
                        Array.prototype.sort.call(this._view());
                        return this;
                    }
                    if (this.sec.AXFunction.axIsType(sortBehavior)) {
                        Array.prototype.sort.call(this._view(), sortBehavior.value);
                        return this;
                    }
                    var options = sortBehavior | 0;
                    release || assertNotImplemented(!(options & Float64Vector.UNIQUESORT), 'UNIQUESORT');
                    release || assertNotImplemented(!(options & Float64Vector.RETURNINDEXEDARRAY), 'RETURNINDEXEDARRAY');
                    if (options & Float64Vector.DESCENDING) {
                        Array.prototype.sort.call(this._view(), function (a, b) {
                            return b - a;
                        });
                    } else {
                        Array.prototype.sort.call(this._view(), function (a, b) {
                            return a - b;
                        });
                    }
                    return this;
                };
                Float64Vector.prototype.shift = function () {
                    this._checkFixed();
                    if (this._length === 0) {
                        return 0;
                    }
                    this._length--;
                    return this._buffer[this._offset++];
                };
                Float64Vector.prototype.unshift = function () {
                    this._checkFixed();
                    if (!arguments.length) {
                        return;
                    }
                    this._ensureCapacity(this._length + arguments.length);
                    this._slide(arguments.length);
                    this._offset -= arguments.length;
                    this._length += arguments.length;
                    for (var i = 0; i < arguments.length; i++) {
                        this._buffer[this._offset + i] = arguments[i];
                    }
                };
                Float64Vector.prototype.slice = function (start, end) {
                    if (start === void 0) {
                        start = 0;
                    }
                    if (end === void 0) {
                        end = 2147483647;
                    }
                    var buffer = this._buffer;
                    var length = this._length;
                    var first = Math.min(Math.max(start, 0), length);
                    var last = Math.min(Math.max(end, first), length);
                    var result = new this.sec.Float64Vector(last - first, this.fixed);
                    result._buffer.set(buffer.subarray(this._offset + first, this._offset + last), result._offset);
                    return result;
                };
                Float64Vector.prototype.splice = function (start, deleteCount_) {
                    var buffer = this._buffer;
                    var length = this._length;
                    var first = Math.min(Math.max(start, 0), length);
                    var startOffset = this._offset + first;
                    var deleteCount = Math.min(Math.max(deleteCount_, 0), length - first);
                    var insertCount = arguments.length - 2;
                    var deletedItems;
                    var result = new this.sec.Float64Vector(deleteCount, this.fixed);
                    if (deleteCount > 0) {
                        deletedItems = buffer.subarray(startOffset, startOffset + deleteCount);
                        result._buffer.set(deletedItems, result._offset);
                    }
                    this._ensureCapacity(length - deleteCount + insertCount);
                    var right = startOffset + deleteCount;
                    var slice = buffer.subarray(right, length);
                    buffer.set(slice, startOffset + insertCount);
                    this._length += insertCount - deleteCount;
                    for (var i = 0; i < insertCount; i++) {
                        buffer[startOffset + i] = arguments[i + 2];
                    }
                    return result;
                };
                Float64Vector.prototype._slide = function (distance) {
                    this._buffer.set(this._view(), this._offset + distance);
                    this._offset += distance;
                };
                Object.defineProperty(Float64Vector.prototype, 'length', {
                    get: function () {
                        return this._length;
                    },
                    set: function (value) {
                        value = value >>> 0;
                        if (value > this._length) {
                            this._ensureCapacity(value);
                            for (var i = this._offset + this._length, j = this._offset + value; i < j; i++) {
                                this._buffer[i] = Float64Vector.DEFAULT_VALUE;
                            }
                        }
                        this._length = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Float64Vector.prototype, 'fixed', {
                    get: function () {
                        return this._fixed;
                    },
                    set: function (f) {
                        this._fixed = !!f;
                    },
                    enumerable: true,
                    configurable: true
                });
                Float64Vector.prototype._checkFixed = function () {
                    if (this._fixed) {
                        this.sec.throwError('RangeError', AVMX.Errors.VectorFixedError);
                    }
                };
                Float64Vector.prototype.axGetNumericProperty = function (nm) {
                    release || assert(Shumway.isNumeric(nm));
                    var length = this._length;
                    var idx = nm | 0;
                    if (idx < 0 || idx >= length || idx != nm) {
                        this.sec.throwError('RangeError', AVMX.Errors.OutOfRangeError, nm, length);
                    }
                    return this._buffer[this._offset + idx];
                };
                Float64Vector.prototype.axSetNumericProperty = function (nm, v) {
                    release || assert(Shumway.isNumeric(nm));
                    var length = this._length;
                    var idx = nm | 0;
                    if (idx < 0 || idx > length || idx != nm || idx === length && this._fixed) {
                        this.sec.throwError('RangeError', AVMX.Errors.OutOfRangeError, nm, length);
                    }
                    if (idx === this._length) {
                        this._ensureCapacity(this._length + 1);
                        this._length++;
                    }
                    this._buffer[this._offset + idx] = v;
                };
                Float64Vector.prototype.axHasPropertyInternal = function (mn) {
                    // Optimization for the common case of indexed element accesses.
                    if ((mn.name | 0) === mn.name) {
                        release || assert(mn.isRuntimeName());
                        return mn.name >= 0 && mn.name < this._length;
                    }
                    var name = AVMX.axCoerceName(mn.name);
                    if (mn.isRuntimeName() && Shumway.isIndex(name)) {
                        var index = name >>> 0;
                        return index >= 0 && index < this._length;
                    }
                    return this.axResolveMultiname(mn) in this;
                };
                Float64Vector.prototype.axNextValue = function (index) {
                    return this._buffer[this._offset + index - 1];
                };
                Float64Vector.prototype.axNextNameIndex = function (index) {
                    var nextNameIndex = index + 1;
                    if (nextNameIndex <= this._length) {
                        return nextNameIndex;
                    }
                    return 0;
                };
                Float64Vector.EXTRA_CAPACITY = 4;
                Float64Vector.INITIAL_CAPACITY = 10;
                Float64Vector.DEFAULT_VALUE = 0;
                Float64Vector.DESCENDING = 2;
                Float64Vector.UNIQUESORT = 4;
                Float64Vector.RETURNINDEXEDARRAY = 8;
                return Float64Vector;
            }(AS.BaseVector);
            AS.Float64Vector = Float64Vector;
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            function isXMLType(val, sec) {
                return typeof val === 'object' && val && (val.axClass === sec.AXXML || val.axClass === sec.AXXMLList || val.axClass === sec.AXQName || val.axClass === sec.AXNamespace);
            }
            AS.isXMLType = isXMLType;
            function isXMLCollection(sec, val) {
                return typeof val === 'object' && val && (val.axClass === sec.AXXML || val.axClass === sec.AXXMLList);
            }
            AS.isXMLCollection = isXMLCollection;
            // 10.1 ToString
            function toString(node, sec) {
                if (!node || node.axClass !== sec.AXXML) {
                    return AVMX.axCoerceString(node);
                }
                switch (node._kind) {
                case 3    /* Text */:
                case 2    /* Attribute */:
                    return node._value;
                default:
                    if (node.hasSimpleContent()) {
                        var s = '';
                        for (var i = 0; i < node._children.length; i++) {
                            var child = node._children[i];
                            if (child._kind === 4    /* Comment */ || child._kind === 5    /* ProcessingInstruction */) {
                                continue;
                            }
                            s += toString(child, sec);
                        }
                        return s;
                    }
                    return toXMLString(sec, node);
                }
            }
            // 10.2.1.1 EscapeElementValue ( s )
            function escapeElementValue(sec, s) {
                if (isXMLCollection(sec, s)) {
                    return s.toXMLString();
                }
                s = AVMX.axCoerceString(s);
                var i = 0, ch;
                while (i < s.length && (ch = s[i]) !== '&' && ch !== '<' && ch !== '>') {
                    i++;
                }
                if (i >= s.length) {
                    return s;
                }
                var buf = s.substring(0, i);
                while (i < s.length) {
                    ch = s[i++];
                    switch (ch) {
                    case '&':
                        buf += '&amp;';
                        break;
                    case '<':
                        buf += '&lt;';
                        break;
                    case '>':
                        buf += '&gt;';
                        break;
                    default:
                        buf += ch;
                        break;
                    }
                }
                return buf;
            }
            AS.escapeElementValue = escapeElementValue;
            // 10.2.1.2 EscapeAttributeValue ( s )
            function escapeAttributeValue(s) {
                s = String(s);
                var i = 0, ch;
                while (i < s.length && (ch = s[i]) !== '&' && ch !== '<' && ch !== '"' && ch !== '\n' && ch !== '\r' && ch !== '\t') {
                    i++;
                }
                if (i >= s.length) {
                    return s;
                }
                var buf = s.substring(0, i);
                while (i < s.length) {
                    ch = s[i++];
                    switch (ch) {
                    case '&':
                        buf += '&amp;';
                        break;
                    case '<':
                        buf += '&lt;';
                        break;
                    case '"':
                        buf += '&quot;';
                        break;
                    case '\n':
                        buf += '&#xA;';
                        break;
                    case '\r':
                        buf += '&#xD;';
                        break;
                    case '\t':
                        buf += '&#x9;';
                        break;
                    default:
                        buf += ch;
                        break;
                    }
                }
                return buf;
            }
            AS.escapeAttributeValue = escapeAttributeValue;
            function isWhitespace(s, index) {
                var ch = s[index];
                return ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t';
            }
            function isWhitespaceString(s) {
                release || assert(typeof s === 'string');
                for (var i = 0; i < s.length; i++) {
                    var ch = s[i];
                    if (!(ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t')) {
                        return false;
                    }
                }
                return true;
            }
            function trimWhitespaces(s) {
                var i = 0;
                while (i < s.length && isWhitespace(s, i)) {
                    i++;
                }
                if (i >= s.length) {
                    return '';
                }
                var j = s.length - 1;
                while (isWhitespace(s, j)) {
                    j--;
                }
                return i === 0 && j === s.length - 1 ? s : s.substring(i, j + 1);
            }
            var indentStringCache = [];
            function getIndentString(indent) {
                if (indent > 0) {
                    if (indentStringCache[indent] !== undefined) {
                        return indentStringCache[indent];
                    }
                    var s = '';
                    for (var i = 0; i < indent; i++) {
                        s += ' ';
                    }
                    indentStringCache[indent] = s;
                    return s;
                }
                return '';
            }
            function generateUniquePrefix(namespaces) {
                var i = 1, newPrefix;
                while (true) {
                    newPrefix = '_ns' + i;
                    if (!namespaces.some(function (ns) {
                            return ns.prefix === newPrefix;
                        })) {
                        return newPrefix;
                    }
                    i++;
                }
            }
            // 10.2 ToXMLString
            function toXMLString(sec, node) {
                if (node === null || node === undefined) {
                    throw new TypeError();
                }
                return escapeElementValue(sec, node);
            }
            // 10.3 ToXML
            function toXML(v, sec) {
                if (v === null) {
                    sec.throwError('TypeError', AVMX.Errors.ConvertNullToObjectError);
                }
                if (v === undefined) {
                    sec.throwError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                }
                if (v.axClass === sec.AXXML) {
                    return v;
                }
                if (v.axClass === sec.AXXMLList) {
                    if (v._children.length !== 1) {
                        sec.throwError('TypeError', AVMX.Errors.XMLMarkupMustBeWellFormed);
                    }
                    return v._children[0];
                }
                // The E4X spec says we must throw a TypeError for non-Boolean, Number, or String objects.
                // Flash thinks otherwise.
                var x = sec.xmlParser.parseFromString(AVMX.axCoerceString(v));
                var length = x._children.length;
                if (length === 0) {
                    return createXML(sec, 3    /* Text */);
                }
                if (length === 1) {
                    x._children[0]._parent = null;
                    return x._children[0];
                }
                sec.throwError('TypeError', AVMX.Errors.XMLMarkupMustBeWellFormed);
            }
            // 10.4 ToXMLList
            function toXMLList(value, targetList) {
                // toXMLList is supposed to just return value if it's an XMLList already. For optimization
                // purposes, we handle that case at the callsites.
                release || assert(typeof value !== 'object' || value && value.axClass !== targetList.axClass);
                if (value === null) {
                    targetList.sec.throwError('TypeError', AVMX.Errors.ConvertNullToObjectError);
                }
                if (value === undefined) {
                    targetList.sec.throwError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                }
                if (value.axClass === targetList.sec.AXXML) {
                    targetList.append(value);
                    return;
                }
                // The E4X spec says we must throw a TypeError for non-Boolean, Number, or String objects.
                // Flash thinks otherwise.
                var defaultNamespace = getDefaultNamespace(targetList.sec);
                var parentString = '<parent xmlns="' + escapeAttributeValue(defaultNamespace.uri) + '">' + value + '</parent>';
                var x = toXML(parentString, targetList.sec);
                var children = x._children;
                if (!children) {
                    return;
                }
                for (var i = 0; i < children.length; i++) {
                    var v = children[i];
                    v._parent = null;
                    targetList.append(v);
                }
            }
            // 10.6 ToXMLName
            function toXMLName(mn, sec) {
                if (mn === undefined) {
                    return anyMultiname;
                }
                var name;
                // convert argument to a value of type AttributeName or a QName object
                // according to the following:
                if (typeof mn === 'object' && mn !== null) {
                    if (mn instanceof AVMX.Multiname) {
                        return mn;
                    }
                    if (mn.axClass === sec.AXQName) {
                        // Object - If the input argument is a QName object,
                        // return its Multiname.
                        return mn.name;
                    }
                    // Object - Otherwise, convert the input argument to a string using ToString.
                    name = String(mn);
                } else if (typeof mn === 'number') {
                    name = mn + '';
                } else if (typeof mn === 'string') {
                    // String - Create a QName object or AttributeName from the String
                    // as specified below in section 10.6.1. See below.
                    if (mn === '*') {
                        name = null;
                    } else {
                        name = mn;
                    }
                } else {
                    sec.throwError('TypeError', AVMX.Errors.XMLInvalidName, mn);
                }
                // ... then convert the result to a QName object or AttributeName
                // as specified in section 10.6.1.
                if (name && name[0] === '@') {
                    // If the first character of s is "@", ToXMLName creates an
                    // AttributeName using the ToAttributeName operator.
                    name = name.substr(1);
                    if (name === '*') {
                        name = null;
                    }
                    return new AVMX.Multiname(null, 0, 13    /* QNameA */, [AVMX.Namespace.PUBLIC], name);
                }
                return new AVMX.Multiname(null, 0, 7    /* QName */, [AVMX.Namespace.PUBLIC], name);
            }
            function coerceE4XMultiname(mn, sec) {
                var out = tmpMultiname;
                out.kind = mn.kind;
                // Queries of the foo[new QName('bar')] sort create this situation.
                if (mn.name && mn.name.axClass === sec.AXQName) {
                    mn = mn.name.name;
                }
                if (mn.isQName()) {
                    out.name = mn.name;
                    out.namespaces = mn.namespaces;
                } else {
                    if (mn.isAnyNamespace()) {
                        out.namespaces = mn.namespaces;
                    } else {
                        var defaultNS = getDefaultNamespace(sec);
                        var namespaces = mn.namespaces;
                        var containsDefaultNS = false;
                        for (var i = 0; i < namespaces.length; i++) {
                            var ns = namespaces[i];
                            if (ns.uri === defaultNS.uri && ns.prefix === defaultNS.prefix && ns.type === defaultNS.type) {
                                containsDefaultNS = true;
                                break;
                            }
                        }
                        if (!containsDefaultNS) {
                            out.namespaces = mn.namespaces.concat(defaultNS);
                        } else {
                            out.namespaces = mn.namespaces;
                        }
                    }
                }
                var name = mn.name;
                if (mn.isAnyName() || name === '*' || name === null) {
                    out.name = null;
                } else if (name.length > 1 && name[0] === '@') {
                    if (!out.isAttribute()) {
                        if (name === '@*') {
                            out.name = null;
                        } else {
                            out.name = name.substr(1);
                        }
                        out.kind = out.namespaces.length === 1 ? 13    /* QNameA */ : 14    /* MultinameA */;
                    } else {
                        out.name = name;
                    }
                } else {
                    out.name = name;
                }
                return out;
            }
            // 12.1 GetDefaultNamespace
            function getDefaultNamespace(sec) {
                var scope = AVMX.getCurrentScope();
                while (scope) {
                    if (scope.defaultNamespace) {
                        return scope.defaultNamespace;
                    }
                    scope = scope.parent;
                }
                // The outermost default xml namespace is stored in sec.AXNamespace.defaultNamespace.
                return sec.AXNamespace.defaultNamespace;
            }
            /**
             * 13.3.5.4 [[GetNamespace]] ( [ InScopeNamespaces ] )
             *
             * The [[GetNamespace]] method is an internal method that returns a Namespace object with a URI
             * matching the URI of this QName. InScopeNamespaces is an optional parameter. If
             * InScopeNamespaces is unspecified, it is set to the empty set. If one or more Namespaces
             * exists in InScopeNamespaces with a URI matching the URI of this QName, one of the matching
             * Namespaces will be returned. If no such namespace exists in InScopeNamespaces,
             * [[GetNamespace]] creates and returns a new Namespace with a URI matching that of this QName.
             * For implementations that preserve prefixes in QNames, [[GetNamespace]] may return a
             * Namespace that also has a matching prefix. The input argument InScopeNamespaces is a set of
             * Namespace objects.
             */
            function GetNamespace(mn, inScopeNamespaces) {
                release || assert(mn.isQName());
                var uri = mn.uri;
                for (var i = 0; inScopeNamespaces && i < inScopeNamespaces.length; i++) {
                    if (uri === inScopeNamespaces[i].uri) {
                        return inScopeNamespaces[i];
                    }
                }
                return mn.namespaces[0];
            }
            // 13.1.2.1 isXMLName ( value )
            function isXMLName(v, sec) {
                try {
                    var qn = sec.AXQName.Create(v);
                } catch (e) {
                    return false;
                }
                // FIXME scan v to see if it is a valid lexeme and return false if not
                return true;
            }
            AS.isXMLName = isXMLName;
            var tmpMultiname = new AVMX.Multiname(null, 0, 7    /* QName */, [], null);
            var anyMultiname = new AVMX.Multiname(null, 0, 7    /* QName */, [], null);
            release || Object.seal(anyMultiname);
            var XMLParserBase = function () {
                function XMLParserBase() {
                }
                XMLParserBase.prototype.resolveEntities = function (s) {
                    return s.replace(/&([^;]+);/g, function (all, entity) {
                        if (entity.substring(0, 2) === '#x') {
                            return String.fromCharCode(parseInt(entity.substring(2), 16));
                        } else if (entity.substring(0, 1) === '#') {
                            return String.fromCharCode(parseInt(entity.substring(1), 10));
                        }
                        switch (entity) {
                        case 'lt':
                            return '<';
                        case 'gt':
                            return '>';
                        case 'amp':
                            return '&';
                        case 'quot':
                            return '"';
                        }
                        // throw "Unknown entity: " + entity;
                        return all;
                    });
                };
                XMLParserBase.prototype.parseContent = function (s, start) {
                    var pos = start, name, attributes = [];
                    function skipWs() {
                        while (pos < s.length && isWhitespace(s, pos)) {
                            ++pos;
                        }
                    }
                    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '>' && s[pos] !== '/') {
                        ++pos;
                    }
                    name = s.substring(start, pos);
                    skipWs();
                    while (pos < s.length && s[pos] !== '>' && s[pos] !== '/' && s[pos] !== '?') {
                        skipWs();
                        var attrName = '', attrValue = '';
                        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '=') {
                            attrName += s[pos];
                            ++pos;
                        }
                        skipWs();
                        if (s[pos] !== '=') {
                            return null;
                        }
                        ++pos;
                        skipWs();
                        var attrEndChar = s[pos];
                        if (attrEndChar !== '"' && attrEndChar !== '\'') {
                            return null;
                        }
                        var attrEndIndex = s.indexOf(attrEndChar, ++pos);
                        if (attrEndIndex < 0) {
                            return null;
                        }
                        attrValue = s.substring(pos, attrEndIndex);
                        attributes.push({
                            name: attrName,
                            value: this.resolveEntities(attrValue)
                        });
                        pos = attrEndIndex + 1;
                        skipWs();
                    }
                    return {
                        name: name,
                        attributes: attributes,
                        parsed: pos - start
                    };
                };
                XMLParserBase.prototype.parseProcessingInstruction = function (s, start) {
                    var pos = start, name, value;
                    function skipWs() {
                        while (pos < s.length && isWhitespace(s, pos)) {
                            ++pos;
                        }
                    }
                    while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== '>' && s[pos] !== '/') {
                        ++pos;
                    }
                    name = s.substring(start, pos);
                    skipWs();
                    var attrStart = pos;
                    while (pos < s.length && (s[pos] !== '?' || s[pos + 1] != '>')) {
                        ++pos;
                    }
                    value = s.substring(attrStart, pos);
                    return {
                        name: name,
                        value: value,
                        parsed: pos - start
                    };
                };
                XMLParserBase.prototype.parseXml = function (s) {
                    var i = 0;
                    while (i < s.length) {
                        var ch = s[i];
                        var j = i;
                        if (ch === '<') {
                            ++j;
                            var ch2 = s[j], q;
                            switch (ch2) {
                            case '/':
                                ++j;
                                q = s.indexOf('>', j);
                                if (q < 0) {
                                    this.onError(-9    /* UnterminatedElement */);
                                    return;
                                }
                                this.onEndElement(s.substring(j, q));
                                j = q + 1;
                                break;
                            case '?':
                                ++j;
                                var pi = this.parseProcessingInstruction(s, j);
                                if (s.substring(j + pi.parsed, j + pi.parsed + 2) != '?>') {
                                    this.onError(-3    /* UnterminatedXmlDeclaration */);
                                    return;
                                }
                                this.onPi(pi.name, pi.value);
                                j += pi.parsed + 2;
                                break;
                            case '!':
                                if (s.substring(j + 1, j + 3) === '--') {
                                    q = s.indexOf('-->', j + 3);
                                    if (q < 0) {
                                        this.onError(-5    /* UnterminatedComment */);
                                        return;
                                    }
                                    this.onComment(s.substring(j + 3, q));
                                    j = q + 3;
                                } else if (s.substring(j + 1, j + 8) === '[CDATA[') {
                                    q = s.indexOf(']]>', j + 8);
                                    if (q < 0) {
                                        this.onError(-2    /* UnterminatedCdat */);
                                        return;
                                    }
                                    this.onCdata(s.substring(j + 8, q));
                                    j = q + 3;
                                } else if (s.substring(j + 1, j + 8) === 'DOCTYPE') {
                                    var q2 = s.indexOf('[', j + 8), complexDoctype = false;
                                    q = s.indexOf('>', j + 8);
                                    if (q < 0) {
                                        this.onError(-4    /* UnterminatedDoctypeDeclaration */);
                                        return;
                                    }
                                    if (q2 > 0 && q > q2) {
                                        q = s.indexOf(']>', j + 8);
                                        if (q < 0) {
                                            this.onError(-4    /* UnterminatedDoctypeDeclaration */);
                                            return;
                                        }
                                        complexDoctype = true;
                                    }
                                    var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));
                                    this.onDoctype(doctypeContent);
                                    // XXX pull entities ?
                                    j = q + (complexDoctype ? 2 : 1);
                                } else {
                                    this.onError(-6    /* MalformedElement */);
                                    return;
                                }
                                break;
                            default:
                                var content = this.parseContent(s, j);
                                if (content === null) {
                                    this.onError(-6    /* MalformedElement */);
                                    return;
                                }
                                var isClosed = false;
                                if (s.substring(j + content.parsed, j + content.parsed + 2) === '/>') {
                                    isClosed = true;
                                } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== '>') {
                                    this.onError(-9    /* UnterminatedElement */);
                                    return;
                                }
                                this.onBeginElement(content.name, content.attributes, isClosed);
                                j += content.parsed + (isClosed ? 2 : 1);
                                break;
                            }
                        } else {
                            do {
                            } while (j++ < s.length && s[j] !== '<');
                            var text = s.substring(i, j);
                            this.onText(this.resolveEntities(text));
                        }
                        i = j;
                    }
                };
                XMLParserBase.prototype.onPi = function (name, value) {
                };
                XMLParserBase.prototype.onComment = function (text) {
                };
                XMLParserBase.prototype.onCdata = function (text) {
                };
                XMLParserBase.prototype.onDoctype = function (doctypeContent) {
                };
                XMLParserBase.prototype.onText = function (text) {
                };
                XMLParserBase.prototype.onBeginElement = function (name, attributes, isEmpty) {
                };
                XMLParserBase.prototype.onEndElement = function (name) {
                };
                XMLParserBase.prototype.onError = function (code) {
                };
                return XMLParserBase;
            }();
            AS.XMLParserBase = XMLParserBase;
            var XMLParser = function (_super) {
                __extends(XMLParser, _super);
                function XMLParser(sec) {
                    _super.call(this);
                    this.sec = sec;
                    this.scopes = [];
                }
                XMLParser.prototype.isWhitespacePreserved = function () {
                    var scopes = this.scopes;
                    for (var j = scopes.length - 1; j >= 0; --j) {
                        if (scopes[j].space === 'preserve') {
                            return true;
                        }
                    }
                    return false;
                };
                XMLParser.prototype.lookupDefaultNs = function () {
                    var scopes = this.scopes;
                    for (var j = scopes.length - 1; j >= 0; --j) {
                        if ('xmlns' in scopes[j]) {
                            return scopes[j].xmlns;
                        }
                    }
                    return '';
                };
                XMLParser.prototype.lookupNs = function (prefix) {
                    var scopes = this.scopes;
                    for (var j = scopes.length - 1; j >= 0; --j) {
                        if (prefix in scopes[j].lookup) {
                            return scopes[j].lookup[prefix];
                        }
                    }
                    return undefined;
                };
                XMLParser.prototype.getName = function (name, resolveDefaultNs) {
                    var j = name.indexOf(':');
                    if (j >= 0) {
                        var prefix = name.substring(0, j);
                        var localName = name.substring(j + 1);
                        var namespace = this.lookupNs(prefix);
                        if (namespace === undefined) {
                            this.sec.throwError('TypeError', AVMX.Errors.XMLPrefixNotBound, prefix, localName);
                        }
                        return {
                            name: namespace + '::' + localName,
                            localName: localName,
                            prefix: prefix,
                            namespace: namespace
                        };
                    } else if (resolveDefaultNs) {
                        return {
                            name: name,
                            localName: name,
                            prefix: '',
                            namespace: this.lookupDefaultNs()
                        };
                    } else {
                        return {
                            name: name,
                            localName: name,
                            prefix: '',
                            namespace: ''
                        };
                    }
                };
                XMLParser.prototype.onError = function (code) {
                    switch (code) {
                    case -6    /* MalformedElement */:
                        this.sec.throwError('TypeError', AVMX.Errors.XMLMalformedElement);
                        return;
                    case -9    /* UnterminatedElement */:
                        this.sec.throwError('TypeError', AVMX.Errors.XMLUnterminatedElement);
                        return;
                    case -4    /* UnterminatedDoctypeDeclaration */:
                        this.sec.throwError('TypeError', AVMX.Errors.XMLUnterminatedDocTypeDecl);
                        return;
                    case -2    /* UnterminatedCdat */:
                        this.sec.throwError('TypeError', AVMX.Errors.XMLUnterminatedCData);
                        return;
                    case -5    /* UnterminatedComment */:
                        this.sec.throwError('TypeError', AVMX.Errors.XMLUnterminatedComment);
                        return;
                    case -3    /* UnterminatedXmlDeclaration */:
                        this.sec.throwError('TypeError', AVMX.Errors.XMLUnterminatedXMLDecl);
                        return;
                    }
                };
                XMLParser.prototype.onPi = function (name, value) {
                    this.pi(name, value);
                };
                XMLParser.prototype.onComment = function (text) {
                    this.comment(text);
                };
                XMLParser.prototype.onCdata = function (text) {
                    this.cdata(text);
                };
                XMLParser.prototype.onDoctype = function (doctypeContent) {
                    this.doctype(doctypeContent);
                };
                XMLParser.prototype.onText = function (text) {
                    this.text(text, this.isWhitespacePreserved());
                };
                XMLParser.prototype.onBeginElement = function (name, contentAttributes, isEmpty) {
                    var scopes = this.scopes;
                    var scope = {
                        namespaces: [],
                        lookup: Object.create(null),
                        inScopes: null
                    };
                    for (var q = 0; q < contentAttributes.length; ++q) {
                        var attribute = contentAttributes[q];
                        var attributeName = attribute.name;
                        if (attributeName.substring(0, 6) === 'xmlns:') {
                            var prefix = attributeName.substring(6);
                            var uri = attribute.value;
                            if (this.lookupNs(prefix) !== uri) {
                                scope.lookup[prefix] = trimWhitespaces(uri);
                                var ns = AVMX.internPrefixedNamespace(0    /* Public */, uri, prefix);
                                scope.namespaces.push(ns);
                            }
                            contentAttributes[q] = null;
                        } else if (attributeName === 'xmlns') {
                            var uri = attribute.value;
                            if (this.lookupDefaultNs() !== uri) {
                                scope['xmlns'] = trimWhitespaces(uri);
                                var ns = AVMX.internNamespace(0    /* Public */, uri);
                                scope.namespaces.push(ns);
                            }
                            contentAttributes[q] = null;
                        } else if (attributeName.substring(0, 4) === 'xml:') {
                            var xmlAttrName = attributeName.substring(4);
                            scope[xmlAttrName] = trimWhitespaces(attribute.value);
                        } else {
                        }
                    }
                    // build list of all namespaces including ancestors'
                    var inScopeNamespaces = [];
                    scope.namespaces.forEach(function (ns) {
                        if (!ns.prefix || scope.lookup[ns.prefix] === ns.uri) {
                            inScopeNamespaces.push(ns);
                        }
                    });
                    scopes[scopes.length - 1].inScopes.forEach(function (ns) {
                        if (ns.prefix && !(ns.prefix in scope.lookup) || !ns.prefix && !('xmlns' in scope)) {
                            inScopeNamespaces.push(ns);
                        }
                    });
                    scope.inScopes = inScopeNamespaces;
                    scopes.push(scope);
                    var attributes = [];
                    for (q = 0; q < contentAttributes.length; ++q) {
                        attribute = contentAttributes[q];
                        if (attribute) {
                            attributes.push({
                                name: this.getName(attribute.name, false),
                                value: attribute.value
                            });
                        }
                    }
                    this.beginElement(this.getName(name, true), attributes, inScopeNamespaces, isEmpty);
                    if (isEmpty) {
                        scopes.pop();
                    }
                };
                XMLParser.prototype.onEndElement = function (name) {
                    this.endElement(this.getName(name, true));
                    this.scopes.pop();
                };
                XMLParser.prototype.beginElement = function (name, attrs, namespaces, isEmpty) {
                    var parent = this.currentElement;
                    this.elementsStack.push(parent);
                    this.currentElement = createXML(this.sec, 1    /* Element */, name.namespace, name.localName, name.prefix);
                    for (var i = 0; i < attrs.length; ++i) {
                        var rawAttr = attrs[i];
                        var attr = createXML(this.sec, 2    /* Attribute */, rawAttr.name.namespace, rawAttr.name.localName, rawAttr.name.prefix);
                        attr._value = rawAttr.value;
                        attr._parent = this.currentElement;
                        this.currentElement._attributes.push(attr);
                    }
                    for (var i = 0; i < namespaces.length; ++i) {
                        this.currentElement._inScopeNamespaces.push(namespaces[i]);
                    }
                    parent.insert(parent._children.length, this.currentElement);
                    if (isEmpty) {
                        this.currentElement = this.elementsStack.pop();
                    }
                };
                XMLParser.prototype.endElement = function (name) {
                    this.currentElement = this.elementsStack.pop();
                };
                XMLParser.prototype.text = function (text, isWhitespacePreserve) {
                    if (this.sec.AXXML.ignoreWhitespace) {
                        text = trimWhitespaces(text);
                    }
                    // TODO: do an in-depth analysis of what isWhitespacePreserve is about.
                    if (text.length === 0 || isWhitespacePreserve && this.sec.AXXML.ignoreWhitespace) {
                        return;
                    }
                    var node = createXML(this.sec);
                    node._value = text;
                    this.currentElement.insert(this.currentElement._children.length, node);
                };
                XMLParser.prototype.cdata = function (text) {
                    var node = createXML(this.sec);
                    node._value = text;
                    this.currentElement.insert(this.currentElement._children.length, node);
                };
                XMLParser.prototype.comment = function (text) {
                    if (this.sec.AXXML.ignoreComments) {
                        return;
                    }
                    var node = createXML(this.sec, 4    /* Comment */, '', '');
                    node._value = text;
                    this.currentElement.insert(this.currentElement._children.length, node);
                };
                XMLParser.prototype.pi = function (name, value) {
                    if (this.sec.AXXML.ignoreProcessingInstructions) {
                        return;
                    }
                    var node = createXML(this.sec, 5    /* ProcessingInstruction */, '', name);
                    node._value = value;
                    this.currentElement.insert(this.currentElement._children.length, node);
                };
                XMLParser.prototype.doctype = function (text) {
                };
                XMLParser.prototype.parseFromString = function (s, mimeType) {
                    // placeholder
                    var currentElement = this.currentElement = createXML(this.sec, 1    /* Element */, '', '', '');
                    this.elementsStack = [];
                    var defaultNs = getDefaultNamespace(this.sec);
                    var scopes = [{
                            namespaces: [],
                            lookup: {
                                'xmlns': 'http://www.w3.org/2000/xmlns/',
                                'xml': 'http://www.w3.org/XML/1998/namespace'
                            },
                            inScopes: [defaultNs],
                            space: 'default',
                            xmlns: defaultNs.uri
                        }];
                    this.scopes = scopes;
                    this.parseXml(s);
                    this.currentElement = null;
                    if (this.elementsStack.length > 0) {
                        var nm = this.elementsStack.pop()._name.name;
                        this.sec.throwError('TypeError', AVMX.Errors.XMLUnterminatedElementTag, nm, nm);
                    }
                    this.elementsStack = null;
                    return currentElement;
                };
                return XMLParser;
            }(XMLParserBase);
            AS.XMLParser = XMLParser;
            var ASNamespace = function (_super) {
                __extends(ASNamespace, _super);
                /**
                 * 13.2.2 The Namespace Constructor
                 *
                 * Namespace ()
                 * Namespace (uriValue)
                 * Namespace (prefixValue, uriValue)
                 */
                function ASNamespace(uriOrPrefix_, uri_) {
                    _super.call(this);
                    // 1. Create a new Namespace object n
                    var uri = '';
                    var prefix = '';
                    // 2. If prefixValue is not specified and uriValue is not specified
                    if (arguments.length === 0) {
                    } else if (arguments.length === 1) {
                        var uriValue = uriOrPrefix_;
                        if (uriValue instanceof AVMX.Namespace) {
                            this._ns = uriValue;
                            return;
                        }
                        release || AVMX.checkValue(uriValue);
                        if (uriValue && typeof uriValue === 'object') {
                            // Non-spec'ed, but very useful:
                            // a. If Type(uriValue) is Object and uriValue.[[Class]] == "Namespace"
                            if (uriValue.axClass === this.sec.AXNamespace) {
                                var uriValueAsNamespace = uriValue;
                                // i. Let n.prefix = uriValue.prefix
                                prefix = uriValueAsNamespace.prefix;
                                // ii. Let n.uri = uriValue.uri
                                uri = uriValueAsNamespace.uri;
                            } else if (uriValue.axClass === this.sec.AXQName && uriValue.uri !== null) {
                                // i. Let n.uri = uriValue.uri
                                uri = uriValue.uri;
                            }
                        } else {
                            // i. Let n.uri = ToString(uriValue)
                            uri = toString(uriValue, this.sec);
                            // ii. If (n.uri is the empty string), let n.prefix be the empty string
                            if (uri === '') {
                                prefix = '';
                            } else {
                                prefix = undefined;
                            }
                        }
                    } else {
                        var prefixValue = uriOrPrefix_;
                        var uriValue = uri_;
                        // a. If Type(uriValue) is Object and uriValue.[[Class]] == "QName" and uriValue.uri is not
                        // null
                        if (Shumway.isObject(uriValue) && uriValue.axClass === this.sec.AXQName && uriValue.uri !== null) {
                            // i. Let n.uri = uriValue.uri
                            uri = uriValue.uri;
                        } else {
                            // i. Let n.uri = ToString(uriValue)
                            uri = toString(uriValue, this.sec);
                        }
                        // c. If n.uri is the empty string
                        if (uri === '') {
                            // i. If prefixValue is undefined or ToString(prefixValue) is the empty string
                            if (prefixValue === undefined || toString(prefixValue, this.sec) === '') {
                                // 1. Let n.prefix be the empty string
                                prefix = '';
                            } else {
                                // ii. Else throw a TypeError exception
                                this.sec.throwError('TypeError', AVMX.Errors.XMLNamespaceWithPrefixAndNoURI, prefixValue);
                            }
                        } else if (prefixValue === undefined) {
                            prefix = undefined;
                        } else if (isXMLName(prefixValue, this.sec) === false) {
                            // i. Let n.prefix = undefined
                            prefix = undefined;
                        } else {
                            prefix = toString(prefixValue, this.sec);
                        }
                    }
                    // 5. Return n
                    this._ns = AVMX.internPrefixedNamespace(0    /* Public */, uri, prefix);
                }
                ASNamespace.classInitializer = function () {
                    defineNonEnumerableProperty(this, '$Bglength', 2);
                    var proto = this.dPrototype;
                    var asProto = ASNamespace.prototype;
                    defineNonEnumerableProperty(proto, '$BgtoString', asProto.toString);
                };
                /**
                 * 13.2.1 The Namespace Constructor Called as a Function
                 *
                 * Namespace ()
                 * Namespace (uriValue)
                 * Namespace (prefixValue, uriValue)
                 */
                ASNamespace.axApply = function (self, args) {
                    var a = args[0];
                    var b = args[1];
                    // 1. If (prefixValue is not specified and Type(uriValue) is Object and
                    // uriValue.[[Class]] == "Namespace")
                    if (args.length === 1 && Shumway.isObject(a) && a.axClass === this.sec.AXNamespace) {
                        // a. Return uriValue
                        return a;
                    }
                    // 2. Create and return a new Namespace object exactly as if the Namespace constructor had
                    // been called with the same arguments (section 13.2.2).
                    switch (args.length) {
                    case 0:
                        return this.sec.AXNamespace.Create();
                    case 1:
                        return this.sec.AXNamespace.Create(a);
                    default:
                        return this.sec.AXNamespace.Create(a, b);
                    }
                };
                ASNamespace.Create = function (uriOrPrefix_, uri_) {
                    var ns = Object.create(this.sec.AXNamespace.tPrototype);
                    // The initializer relies on arguments.length being correct.
                    ns.axInitializer.apply(ns, arguments);
                    return ns;
                };
                ASNamespace.FromNamespace = function (ns) {
                    var result = Object.create(this.sec.AXNamespace.tPrototype);
                    result._ns = ns;
                    return result;
                };
                // E4X 11.5.1 The Abstract Equality Comparison Algorithm, step 3.c.
                ASNamespace.prototype.equals = function (other) {
                    return other && other.axClass === this.axClass && other._ns.uri === this._ns.uri || typeof other === 'string' && this._ns.uri === other;
                };
                Object.defineProperty(ASNamespace.prototype, 'prefix', {
                    get: function () {
                        return this._ns.prefix;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASNamespace.prototype, 'uri', {
                    get: function () {
                        return this._ns.uri;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASNamespace.prototype.toString = function () {
                    if (this === this.axClass.dPrototype) {
                        return '';
                    }
                    return this._ns.uri;
                };
                ASNamespace.prototype.valueOf = function () {
                    if (this === this.axClass.dPrototype) {
                        return '';
                    }
                    return this._ns.uri;
                };
                ASNamespace.instanceConstructor = ASNamespace;
                ASNamespace.defaultNamespace = AVMX.Namespace.PUBLIC;
                return ASNamespace;
            }(AS.ASObject);
            AS.ASNamespace = ASNamespace;
            var ASQName = function (_super) {
                __extends(ASQName, _super);
                /**
                 * 13.3.2 The QName Constructor
                 *
                 * new QName ()
                 * new QName (Name)
                 * new QName (Namespace, Name)
                 */
                function ASQName(nameOrNS_, name_) {
                    _super.call(this);
                    var name;
                    var namespace;
                    if (arguments.length === 0) {
                        name = '';
                    } else if (arguments.length === 1) {
                        name = nameOrNS_;
                    } else {
                        namespace = nameOrNS_;
                        name = name_;
                    }
                    // 1. If (Type(Name) is Object and Name.[[Class]] == "QName")
                    if (name && name.axClass === this.sec.AXQName) {
                        // a. If (Namespace is not specified), return a copy of Name
                        if (arguments.length < 2) {
                            release || assert(name !== tmpMultiname);
                            this.name = name.name;
                            return;
                        } else {
                            name = name.localName;
                        }
                    }
                    // 2. If (Name is undefined or not specified)
                    if (name === undefined) {
                        // a. Let Name = ""
                        name = '';
                    } else {
                        name = toString(name, this.sec);
                    }
                    // 4. If (Namespace is undefined or not specified)
                    if (namespace === undefined) {
                        // a. If Name = "*"
                        if (name === '*') {
                            // i. Let Namespace = null
                            namespace = null;
                        } else {
                            // i. Let Namespace = GetDefaultNamespace()
                            namespace = getDefaultNamespace(this.sec);
                        }
                    }
                    // 5. Let q be a new QName with q.localName = Name
                    var localName = name;
                    var ns = null;
                    // 6. If Namespace == null
                    if (namespace !== null) {
                        // a. Let Namespace be a new Namespace created as if by calling the constructor new
                        // Namespace(Namespace)
                        if (namespace.axClass !== this.sec.AXNamespace) {
                            namespace = this.sec.AXNamespace.Create(namespace);
                        }
                        ns = namespace._ns;
                    }
                    // 8. Return q
                    this.name = new AVMX.Multiname(null, 0, 7    /* QName */, [ns], localName);
                }
                ASQName.classInitializer = function () {
                    defineNonEnumerableProperty(this, '$Bglength', 2);
                    var proto = this.dPrototype;
                    var asProto = ASQName.prototype;
                    defineNonEnumerableProperty(proto, '$BgtoString', asProto.ecmaToString);
                };
                ASQName.Create = function (nameOrNS_, name_, isAttribute) {
                    var name = Object.create(this.sec.AXQName.tPrototype);
                    // The initializer relies on arguments.length being correct.
                    name.axInitializer.apply(name, arguments);
                    return name;
                };
                ASQName.FromMultiname = function (mn) {
                    var name = Object.create(this.sec.AXQName.tPrototype);
                    name.name = mn;
                    return name;
                };
                /**
                 * 13.3.1 The QName Constructor Called as a Function
                 *
                 * QName ( )
                 * QName ( Name )
                 * QName ( Namespace , Name )
                 */
                ASQName.axApply = function (self, args) {
                    var nameOrNS_ = args[0];
                    var name_ = args[1];
                    // 1. If Namespace is not specified and Type(Name) is Object and Name.[[Class]] == “QName”
                    if (args.length === 1 && nameOrNS_ && nameOrNS_.axClass === this.sec.AXQName) {
                        // a. Return Name
                        return nameOrNS_;
                    }
                    // 2. Create and return a new QName object exactly as if the QName constructor had been
                    // called with the same arguments (section 13.3.2).
                    switch (args.length) {
                    case 0:
                        return this.sec.AXQName.Create();
                    case 1:
                        return this.sec.AXQName.Create(nameOrNS_);
                    default:
                        return this.sec.AXQName.Create(nameOrNS_, name_);
                    }
                };
                // E4X 11.5.1 The Abstract Equality Comparison Algorithm, step 3.b.
                ASQName.prototype.equals = function (other) {
                    return other && other.axClass === this.sec.AXQName && other.uri === this.uri && other.name.name === this.name.name || typeof other === 'string' && this.toString() === other;
                };
                Object.defineProperty(ASQName.prototype, 'localName', {
                    get: function () {
                        return this.name.name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASQName.prototype, 'uri', {
                    get: function () {
                        var namespaces = this.name.namespaces;
                        return namespaces.length > 1 ? '' : namespaces[0] ? namespaces[0].uri : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASQName.prototype.ecmaToString = function () {
                    if (this && this === this.sec.AXQName.dPrototype) {
                        return '';
                    }
                    if (!(this && this.axClass === this.sec.AXQName)) {
                        this.sec.throwError('TypeError', AVMX.Errors.InvokeOnIncompatibleObjectError, 'QName.prototype.toString');
                    }
                    return this.toString();
                };
                ASQName.prototype.toString = function () {
                    var uri = this.uri;
                    if (uri === '') {
                        return this.name.name;
                    }
                    if (uri === null) {
                        return '*::' + this.name.name;
                    }
                    uri = uri + '';
                    var cc = uri.charCodeAt(uri.length - 1);
                    // strip the version mark, if there is one
                    var base_uri = uri;
                    if (cc >= 57344 && cc <= 63743) {
                        base_uri = uri.substr(0, uri.length - 1);
                    }
                    if (base_uri === '') {
                        return this.name.name;
                    }
                    return base_uri + '::' + this.name.name;
                };
                ASQName.prototype.valueOf = function () {
                    return this;
                };
                Object.defineProperty(ASQName.prototype, 'prefix', {
                    /**
                     * 13.3.5.3 [[Prefix]]
                     * The [[Prefix]] property is an optional internal property that is not directly visible to
                     * users. It may be used by implementations that preserve prefixes in qualified names. The
                     * value of the [[Prefix]] property is a value of type string or undefined. If the [[Prefix]]
                     * property is undefined, the prefix associated with this QName is unknown.
                     */
                    get: function () {
                        return this.name.namespaces[0] ? this.name.namespaces[0].prefix : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                return ASQName;
            }(AS.ASObject);
            AS.ASQName = ASQName;
            var ASXML_FLAGS;
            (function (ASXML_FLAGS) {
                ASXML_FLAGS[ASXML_FLAGS['FLAG_IGNORE_COMMENTS'] = 1] = 'FLAG_IGNORE_COMMENTS';
                ASXML_FLAGS[ASXML_FLAGS['FLAG_IGNORE_PROCESSING_INSTRUCTIONS'] = 2] = 'FLAG_IGNORE_PROCESSING_INSTRUCTIONS';
                ASXML_FLAGS[ASXML_FLAGS['FLAG_IGNORE_WHITESPACE'] = 4] = 'FLAG_IGNORE_WHITESPACE';
                ASXML_FLAGS[ASXML_FLAGS['FLAG_PRETTY_PRINTING'] = 8] = 'FLAG_PRETTY_PRINTING';
                ASXML_FLAGS[ASXML_FLAGS['ALL'] = 15] = 'ALL';
            }(ASXML_FLAGS || (ASXML_FLAGS = {})));
            var ASXMLKindNames = [
                null,
                'element',
                'attribute',
                'text',
                'comment',
                'processing-instruction'
            ];
            var ASXML = function (_super) {
                __extends(ASXML, _super);
                function ASXML(value) {
                    _super.call(this);
                    this._parent = null;
                    if (Shumway.isNullOrUndefined(value)) {
                        value = '';
                    }
                    if (typeof value === 'string' && value.length === 0) {
                        this._kind = 3    /* Text */;
                        this._value = '';
                        return;
                    }
                    var x = toXML(value, this.sec);
                    if (isXMLType(value, this.sec)) {
                        x = x._deepCopy();
                    }
                    this._kind = x._kind;
                    this._name = x._name;
                    this._value = x._value;
                    this._attributes = x._attributes;
                    this._inScopeNamespaces = x._inScopeNamespaces;
                    var children = x._children;
                    this._children = children;
                    if (children) {
                        for (var i = 0; i < children.length; i++) {
                            var child = children[i];
                            child._parent = this;
                        }
                    }
                }
                ASXML.classInitializer = function () {
                    defineNonEnumerableProperty(this, '$Bglength', 1);
                    var proto = this.dPrototype;
                    var asProto = ASXML.prototype;
                    AS.addPrototypeFunctionAlias(proto, '$BgvalueOf', asProto.valueOf);
                    defineNonEnumerableProperty(proto, '$BghasOwnProperty', asProto.native_hasOwnProperty);
                    defineNonEnumerableProperty(proto, '$BgpropertyIsEnumerable', asProto.native_propertyIsEnumerable);
                    AS.addPrototypeFunctionAlias(this, '$Bgsettings', ASXML.native_settings);
                    AS.addPrototypeFunctionAlias(this, '$BgsetSettings', ASXML.native_setSettings);
                    AS.addPrototypeFunctionAlias(this, '$BgdefaultSettings', ASXML.native_defaultSettings);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    AS.addPrototypeFunctionAlias(proto, '$BgaddNamespace', asProto.addNamespace);
                    AS.addPrototypeFunctionAlias(proto, '$BgappendChild', asProto.appendChild);
                    AS.addPrototypeFunctionAlias(proto, '$Bgattribute', asProto.attribute);
                    AS.addPrototypeFunctionAlias(proto, '$Bgattributes', asProto.attributes);
                    AS.addPrototypeFunctionAlias(proto, '$Bgchild', asProto.child);
                    AS.addPrototypeFunctionAlias(proto, '$BgchildIndex', asProto.childIndex);
                    AS.addPrototypeFunctionAlias(proto, '$Bgchildren', asProto.children);
                    AS.addPrototypeFunctionAlias(proto, '$Bgcomments', asProto.comments);
                    AS.addPrototypeFunctionAlias(proto, '$Bgcontains', asProto.contains);
                    AS.addPrototypeFunctionAlias(proto, '$Bgcopy', asProto.copy);
                    AS.addPrototypeFunctionAlias(proto, '$Bgdescendants', asProto.descendants);
                    AS.addPrototypeFunctionAlias(proto, '$Bgelements', asProto.elements);
                    AS.addPrototypeFunctionAlias(proto, '$BghasComplexContent', asProto.hasComplexContent);
                    AS.addPrototypeFunctionAlias(proto, '$BghasSimpleContent', asProto.hasSimpleContent);
                    AS.addPrototypeFunctionAlias(proto, '$BginScopeNamespaces', asProto.inScopeNamespaces);
                    AS.addPrototypeFunctionAlias(proto, '$BginsertChildAfter', asProto.insertChildAfter);
                    AS.addPrototypeFunctionAlias(proto, '$BginsertChildBefore', asProto.insertChildBefore);
                    AS.addPrototypeFunctionAlias(proto, '$Bglength', asProto.length);
                    AS.addPrototypeFunctionAlias(proto, '$BglocalName', asProto.localName);
                    AS.addPrototypeFunctionAlias(proto, '$Bgname', asProto.name);
                    AS.addPrototypeFunctionAlias(proto, '$Bgnamespace', asProto.namespace);
                    AS.addPrototypeFunctionAlias(proto, '$BgnamespaceDeclarations', asProto.namespaceDeclarations);
                    AS.addPrototypeFunctionAlias(proto, '$BgnodeKind', asProto.nodeKind);
                    AS.addPrototypeFunctionAlias(proto, '$Bgnormalize', asProto.normalize);
                    AS.addPrototypeFunctionAlias(proto, '$Bgparent', asProto.parent);
                    AS.addPrototypeFunctionAlias(proto, '$BgprocessingInstructions', asProto.processingInstructions);
                    AS.addPrototypeFunctionAlias(proto, '$BgprependChild', asProto.prependChild);
                    AS.addPrototypeFunctionAlias(proto, '$BgremoveNamespace', asProto.removeNamespace);
                    AS.addPrototypeFunctionAlias(proto, '$Bgreplace', asProto.replace);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetChildren', asProto.setChildren);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetLocalName', asProto.setLocalName);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetName', asProto.setName);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetNamespace', asProto.setNamespace);
                    AS.addPrototypeFunctionAlias(proto, '$Bgtext', asProto.text);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoXMLString', asProto.toXMLString);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoJSON', asProto.toJSON);
                };
                ASXML.Create = function (value) {
                    var xml = Object.create(this.sec.AXXML.tPrototype);
                    xml.axInitializer(value);
                    return xml;
                };
                ASXML.resetSettings = function () {
                    this._flags = ASXML_FLAGS.ALL;
                };
                ASXML.native_settings = function () {
                    var settings = Object.create(this.sec.AXObject.tPrototype);
                    settings.$BgignoreComments = this.ignoreComments;
                    settings.$BgignoreProcessingInstructions = this.ignoreProcessingInstructions;
                    settings.$BgignoreWhitespace = this.ignoreWhitespace;
                    settings.$BgprettyPrinting = this.prettyPrinting;
                    settings.$BgprettyIndent = this.prettyIndent;
                    return settings;
                };
                ASXML.native_setSettings = function (o) {
                    if (Shumway.isNullOrUndefined(o)) {
                        this.ignoreComments = true;
                        this.ignoreProcessingInstructions = true;
                        this.ignoreWhitespace = true;
                        this.prettyPrinting = true;
                        this.prettyIndent = 2;
                        return;
                    }
                    if (typeof o.$BgignoreComments === 'boolean') {
                        this.ignoreComments = o.$BgignoreComments;
                    }
                    if (typeof o.$BgignoreProcessingInstructions === 'boolean') {
                        this.ignoreProcessingInstructions = o.$BgignoreProcessingInstructions;
                    }
                    if (typeof o.$BgignoreWhitespace === 'boolean') {
                        this.ignoreWhitespace = o.$BgignoreWhitespace;
                    }
                    if (o.$BgprettyPrinting === 'boolean') {
                        this.prettyPrinting = o.$BgprettyPrinting;
                    }
                    if (o.$BgprettyIndent === 'number') {
                        this.prettyIndent = o.$BgprettyIndent;
                    }
                };
                ASXML.native_defaultSettings = function () {
                    return {
                        __proto__: this.sec.AXObject.tPrototype,
                        $BgignoreComments: true,
                        $BgignoreProcessingInstructions: true,
                        $BgignoreWhitespace: true,
                        $BgprettyPrinting: true,
                        $BgprettyIndent: 2
                    };
                };
                ASXML.axApply = function (self, args) {
                    var value = args[0];
                    // 13.5.1 The XMLList Constructor Called as a Function
                    if (Shumway.isNullOrUndefined(value)) {
                        value = '';
                    }
                    return toXML(value, this.sec);
                };
                ASXML.prototype.valueOf = function () {
                    return this;
                };
                // E4X 11.5.1 The Abstract Equality Comparison Algorithm, steps 1-4.
                ASXML.prototype.equals = function (other) {
                    // Steps 1,2.
                    if (other && other.axClass === this.sec.AXXMLList) {
                        return other.equals(this);
                    }
                    // Step 3.
                    if (other && other.axClass === this.sec.AXXML) {
                        // Step 3.a.i.
                        var otherXML = other;
                        if ((this._kind === 3    /* Text */ || this._kind === 2    /* Attribute */) && otherXML.hasSimpleContent() || (otherXML._kind === 3    /* Text */ || otherXML._kind === 2    /* Attribute */) && this.hasSimpleContent()) {
                            return this.toString() === other.toString();
                        }
                        // Step 3.a.ii.
                        return this._deepEquals(other);
                    }
                    // Step 4.
                    return this.hasSimpleContent() && this.toString() === AVMX.axCoerceString(other);    // The remaining steps are implemented by other means in the interpreter/compiler.
                };
                ASXML.prototype.init = function (kind, mn) {
                    this._name = mn;
                    this._kind = kind;
                    // E4X [[Class]]
                    this._parent = null;
                    switch (kind) {
                    case 1    /* Element */:
                        this._inScopeNamespaces = [];
                        this._attributes = [];
                        this._children = [];
                        // child nodes go here
                        break;
                    case 4    /* Comment */:
                    case 5    /* ProcessingInstruction */:
                    case 2    /* Attribute */:
                    case 3    /* Text */:
                        this._value = '';
                        break;
                    default:
                        break;
                    }
                    return this;
                };
                // 9.1.1.9 [[Equals]] (V)
                ASXML.prototype._deepEquals = function (V) {
                    // Step 1.
                    if (!V || V.axClass !== this.sec.AXXML) {
                        return false;
                    }
                    var other = V;
                    // Step 2.
                    if (this._kind !== other._kind) {
                        return false;
                    }
                    // Steps 3-4.
                    if (!!this._name !== !!other._name || this._name && !this._name.equalsQName(other._name)) {
                        return false;
                    }
                    // Not in the spec, but a substantial optimization.
                    if (this._kind !== 1    /* Element */) {
                        // Step 7.
                        // This only affects non-Element nodes, so moved up here.
                        if (this._value !== other._value) {
                            return false;
                        }
                        return true;
                    }
                    // Step 5.
                    var attributes = this._attributes;
                    var otherAttributes = other._attributes;
                    if (attributes.length !== otherAttributes.length) {
                        return false;
                    }
                    // Step 6.
                    var children = this._children;
                    var otherChildren = other._children;
                    if (children.length !== otherChildren.length) {
                        return false;
                    }
                    // Step 8.
                    attribOuter:
                        for (var i = 0; i < attributes.length; i++) {
                            var attribute = attributes[i];
                            for (var j = 0; j < otherAttributes.length; j++) {
                                var otherAttribute = otherAttributes[j];
                                if (otherAttribute._name.equalsQName(attribute._name) && otherAttribute._value === attribute._value) {
                                    continue attribOuter;
                                }
                            }
                            return false;
                        }
                    // Step 9.
                    for (var i = 0; i < children.length; i++) {
                        if (!children[i].equals(otherChildren[i])) {
                            return false;
                        }
                    }
                    // Step 10.
                    return true;
                };
                // 9.1.1.7 [[DeepCopy]] ( )
                ASXML.prototype._deepCopy = function () {
                    var kind = this._kind;
                    var clone = this.sec.AXXML.Create();
                    clone._kind = kind;
                    clone._name = this._name;
                    switch (kind) {
                    case 1    /* Element */:
                        clone._inScopeNamespaces = this._inScopeNamespaces.slice();
                        clone._attributes = this._attributes.map(function (attr) {
                            attr = attr._deepCopy();
                            attr._parent = clone;
                            return attr;
                        });
                        clone._children = this._children.map(function (child) {
                            child = child._deepCopy();
                            child._parent = clone;
                            return child;
                        });
                        break;
                    case 4    /* Comment */:
                    case 5    /* ProcessingInstruction */:
                    case 2    /* Attribute */:
                    case 3    /* Text */:
                        clone._value = this._value;
                        break;
                    default:
                        break;
                    }
                    return clone;
                };
                // 9.1.1.10 [[ResolveValue]] ( )
                ASXML.prototype.resolveValue = function () {
                    return this;
                };
                ASXML.prototype._addInScopeNamespace = function (ns) {
                    if (this._inScopeNamespaces.some(function (ins) {
                            return ins.uri === ns.uri && ins.prefix === ns.prefix;
                        })) {
                        return;
                    }
                    this._inScopeNamespaces.push(ns);
                };
                Object.defineProperty(ASXML, 'ignoreComments', {
                    get: function () {
                        return !!(this._flags & ASXML_FLAGS.FLAG_IGNORE_COMMENTS);
                    },
                    set: function (newIgnore) {
                        newIgnore = !!newIgnore;
                        if (newIgnore) {
                            this._flags |= ASXML_FLAGS.FLAG_IGNORE_COMMENTS;
                        } else {
                            this._flags &= ~ASXML_FLAGS.FLAG_IGNORE_COMMENTS;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASXML, 'ignoreProcessingInstructions', {
                    get: function () {
                        return !!(this._flags & ASXML_FLAGS.FLAG_IGNORE_PROCESSING_INSTRUCTIONS);
                    },
                    set: function (newIgnore) {
                        newIgnore = !!newIgnore;
                        if (newIgnore) {
                            this._flags |= ASXML_FLAGS.FLAG_IGNORE_PROCESSING_INSTRUCTIONS;
                        } else {
                            this._flags &= ~ASXML_FLAGS.FLAG_IGNORE_PROCESSING_INSTRUCTIONS;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASXML, 'ignoreWhitespace', {
                    get: function () {
                        return !!(this._flags & ASXML_FLAGS.FLAG_IGNORE_WHITESPACE);
                    },
                    set: function (newIgnore) {
                        newIgnore = !!newIgnore;
                        if (newIgnore) {
                            this._flags |= ASXML_FLAGS.FLAG_IGNORE_WHITESPACE;
                        } else {
                            this._flags &= ~ASXML_FLAGS.FLAG_IGNORE_WHITESPACE;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASXML, 'prettyPrinting', {
                    get: function () {
                        return !!(this._flags & ASXML_FLAGS.FLAG_PRETTY_PRINTING);
                    },
                    set: function (newPretty) {
                        newPretty = !!newPretty;
                        if (newPretty) {
                            this._flags |= ASXML_FLAGS.FLAG_PRETTY_PRINTING;
                        } else {
                            this._flags &= ~ASXML_FLAGS.FLAG_PRETTY_PRINTING;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASXML, 'prettyIndent', {
                    get: function () {
                        return this._prettyIndent;
                    },
                    set: function (newIndent) {
                        newIndent = newIndent | 0;
                        this._prettyIndent = newIndent;
                    },
                    enumerable: true,
                    configurable: true
                });
                ASXML.prototype.toString = function () {
                    if (this === this.axClass.dPrototype) {
                        return '';
                    }
                    if (this.hasComplexContent()) {
                        return this.toXMLString();
                    }
                    return toString(this, this.sec);
                };
                // 13.4.4.14 XML.prototype.hasOwnProperty ( P )
                ASXML.prototype.native_hasOwnProperty = function (P) {
                    if (this === this.axClass.dPrototype) {
                        return AS.ASObject.prototype.native_hasOwnProperty.call(this, P);
                    }
                    var mn = toXMLName(P, this.sec);
                    if (this.hasProperty(mn)) {
                        return true;
                    }
                    return this.axHasOwnProperty(mn);
                };
                // 13.4.4.30 XML.prototype.propertyIsEnumerable ( P )
                ASXML.prototype.native_propertyIsEnumerable = function (P) {
                    if (P === void 0) {
                        P = undefined;
                    }
                    return String(P) === '0';
                };
                ASXML.prototype.addNamespace = function (ns) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // 13.4.4.2 XML.prototype.addNamespace ( namespace )
                    this._addInScopeNamespace(ns);
                    return this;
                };
                ASXML.prototype.appendChild = function (child) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    this.insert(this._children.length, child);
                    return this;
                };
                ASXML.prototype.attribute = function (arg) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    if (Shumway.isNullOrUndefined(arg) && arguments.length > 0) {
                        this.sec.throwError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                    }
                    if (arg && arg.axClass === this.sec.AXQName) {
                        return this.getProperty(arg.name);
                    }
                    arg = AVMX.axCoerceString(arg);
                    if (arg === '*' || arguments.length === 0) {
                        arg = null;
                    }
                    tmpMultiname.name = arg;
                    tmpMultiname.namespaces = [AVMX.Namespace.PUBLIC];
                    tmpMultiname.kind = 13    /* QNameA */;
                    return this.getProperty(tmpMultiname);
                };
                ASXML.prototype.attributes = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    var list = this.sec.AXXMLList.CreateList(this, this._name);
                    Array.prototype.push.apply(list._children, this._attributes);
                    return list;
                };
                // 13.4.4.6
                ASXML.prototype.child = function (propertyName) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // Step 1.
                    if (Shumway.isIndex(propertyName)) {
                        var list = this.sec.AXXMLList.CreateList(null, null);
                        if (this._children && propertyName < this._children.length) {
                            list.append(this._children[propertyName | 0]);
                        }
                        return list;
                    }
                    // Steps 2-3.
                    var mn;
                    if (propertyName && propertyName.axClass === this.sec.AXQName) {
                        mn = propertyName.name;
                    } else {
                        mn = tmpMultiname;
                        mn.kind = 7    /* QName */;
                        mn.name = toString(propertyName, this.sec);
                    }
                    return this.getProperty(mn);
                };
                ASXML.prototype.childIndex = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // 13.4.4.7 XML.prototype.childIndex ( )
                    if (!this._parent || this._kind === 2    /* Attribute */) {
                        return -1;
                    }
                    return this._parent._children.indexOf(this);
                };
                ASXML.prototype.children = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    var xl = this.sec.AXXMLList.CreateList(this, this._name);
                    xl._children = this._children.concat();
                    return xl;
                };
                ASXML.prototype.comments = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // 13.4.4.9 XML.prototype.comments ( )
                    var xl = this.sec.AXXMLList.CreateList(this, this._name);
                    this._children && this._children.forEach(function (v, i) {
                        if (v._kind === 4    /* Comment */) {
                            xl.append(v);
                        }
                    });
                    return xl;
                };
                ASXML.prototype.contains = function (value) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // 13.4.4.10 XML.prototype.contains ( value )
                    return this === value;
                };
                ASXML.prototype.copy = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    return this._deepCopy();
                };
                // 9.1.1.8 [[Descendants]] (P)
                ASXML.prototype.descendants = function (name) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    var xl = this.sec.AXXMLList.CreateList(this, this._name);
                    return this.descendantsInto(toXMLName(name, this.sec), xl);
                };
                ASXML.prototype.elements = function (name) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // 13.4.4.13 XML.prototype.elements ( [ name ] )
                    return this.getProperty(toXMLName(name, this.sec));
                };
                ASXML.prototype.hasComplexContent = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // 13.4.4.15 XML.prototype.hasComplexContent( )
                    if (this._kind === 2    /* Attribute */ || this._kind === 4    /* Comment */ || this._kind === 5    /* ProcessingInstruction */ || this._kind === 3    /* Text */) {
                        return false;
                    }
                    return this._children.some(function (child) {
                        return child._kind === 1    /* Element */;
                    });
                };
                ASXML.prototype.hasSimpleContent = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // 13.4.4.16 XML.prototype.hasSimpleContent()
                    if (this._kind === 4    /* Comment */ || this._kind === 5    /* ProcessingInstruction */) {
                        return false;
                    }
                    if (this._kind !== 1    /* Element */) {
                        return true;
                    }
                    if (!this._children && this._children.length === 0) {
                        return true;
                    }
                    return this._children.every(function (child) {
                        return child._kind !== 1    /* Element */;
                    });
                };
                // 13.4.4.17
                ASXML.prototype.inScopeNamespaces = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    var namespaces = this._inScopeNamespacesImpl();
                    var result = [];
                    for (var i = 0; i < namespaces.length; i++) {
                        var AXNamespace = this.sec.AXNamespace;
                        result[i] = AXNamespace.FromNamespace(namespaces[i]);
                    }
                    return this.sec.AXArray.axBox(result);
                };
                ASXML.prototype._inScopeNamespacesImpl = function () {
                    // Step 1.
                    var y = this;
                    // Step 2.
                    var inScopeNS = [];
                    var inScopeNSMap = inScopeNS;
                    // Step 3.
                    while (y !== null) {
                        // Step 3.a.
                        var namespaces = y._inScopeNamespaces;
                        for (var i = 0; namespaces && i < namespaces.length; i++) {
                            var ns = namespaces[i];
                            if (!inScopeNSMap[ns.prefix]) {
                                inScopeNSMap[ns.prefix] = ns;
                                inScopeNS.push(ns);
                            }
                        }
                        // Step 3.b.
                        y = y._parent;
                    }
                    return inScopeNS;
                };
                // 13.4.4.18
                ASXML.prototype.insertChildAfter = function (child1, child2) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // Step 1.
                    if (this._kind > 1    /* Element */) {
                        return;
                    }
                    // Step 2.
                    if (child1 == null) {
                        this.insert(0, child2);
                        return this;
                    }
                    // Step 3.
                    // The spec doesn't mention it, but Tamarin seems to unpack single-entry XMLLists here.
                    if (child1.axClass === this.sec.AXXMLList && child1._children.length === 1) {
                        child1 = child1._children[0];
                    }
                    if (child1.axClass === this.sec.AXXML) {
                        for (var i = 0; i < this._children.length; i++) {
                            var child = this._children[i];
                            if (child === child1) {
                                this.insert(i + 1, child2);
                                return this;
                            }
                        }
                    }    // Step 4 (implicit).
                };
                // 13.4.4.19
                ASXML.prototype.insertChildBefore = function (child1, child2) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // Step 1.
                    if (this._kind > 1    /* Element */) {
                        return;
                    }
                    // Step 2.
                    if (child1 == null) {
                        this.insert(this._children.length, child2);
                        return this;
                    }
                    // Step 3.
                    // The spec doesn't mention it, but Tamarin seems to unpack single-entry XMLLists here.
                    if (child1.axClass === this.sec.AXXMLList && child1._children.length === 1) {
                        child1 = child1._children[0];
                    }
                    if (child1.axClass === this.sec.AXXML) {
                        for (var i = 0; i < this._children.length; i++) {
                            var child = this._children[i];
                            if (child === child1) {
                                this.insert(i, child2);
                                return this;
                            }
                        }
                    }    // Step 4 (implicit).
                };
                // XML.[[Length]]
                ASXML.prototype.length = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    if (!this._children) {
                        return 0;
                    }
                    return this._children.length;
                };
                ASXML.prototype.localName = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    return this._name.name;
                };
                ASXML.prototype.name = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    return this.sec.AXQName.FromMultiname(this._name);
                };
                // 13.4.4.23
                ASXML.prototype.namespace = function (prefix) {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // Step 4.a.
                    if (arguments.length === 0 && this._kind >= 3    /* Text */) {
                        return null;
                    }
                    // Steps 1-3.
                    var inScopeNS = this._inScopeNamespacesImpl();
                    // Step 4.
                    if (arguments.length === 0) {
                        // Step 4.b.
                        return this.sec.AXNamespace.FromNamespace(GetNamespace(this._name, inScopeNS));
                    }
                    // Step 5.a.
                    prefix = AVMX.axCoerceString(prefix);
                    // Step 5.b-c.
                    for (var i = 0; i < inScopeNS.length; i++) {
                        var ns = inScopeNS[i];
                        if (ns.prefix === prefix) {
                            return this.sec.AXNamespace.FromNamespace(ns);
                        }
                    }    // Step 5.b alternate clause implicit.
                };
                ASXML.prototype.namespaceDeclarations = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    release || release || notImplemented('public.XML::namespaceDeclarations');
                    return;
                };
                ASXML.prototype.nodeKind = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    return ASXMLKindNames[this._kind];
                };
                ASXML.prototype.normalize = function () {
                    if (!this || this.axClass !== this.sec.AXXML) {
                        this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, this, 'XML');
                    }
                    // Steps 1-2.
                    for (var i = 0; i < this._children.length;) {
                        var child = this._children[i];
                        // Step 2.a.
                        if (child._kind === 1    /* Element */) {
                            child.normalize();
                            i++;
                        } else if (child._kind === 3    /* Text */) {
                            // Step 2.b.i.
                            while (i + 1 < this._children.length) {
                                var nextChild = this._children[i + 1];
                                if (nextChild._kind !== 3    /* Text */) {
                                    break;
                                }
                                child._value += nextChild._value;
                                this.removeByIndex(i + 1);
                            }
                            // Step 2.b.ii.
                            // The spec says to only remove 0-length nodes, but Tamarin removes whitespace-only
                            // nodes, too.
                            if (child._value.length === 0 || isWhitespaceString(child._value)) {
                                this.removeByIndex(i);
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                    return this;
                };
                ASXML.prototype.removeByIndex = function (index) {
                    var child = this._children[index];
                    child._parent = null;
                    this._children.splice(index, 1);
                };
                ASXML.prototype.parent = function () {
                    // Absurdly, and in difference to what the spec says, parent() returns `undefined` for null.
                    return this._parent || undefined;
                };
                // 13.4.4.28 XML.prototype.processingInstructions ( [ name ] )
                ASXML.prototype.processingInstructions = function (name) {
                    // Step 1 (implicit).
                    // Step 3.
                    var list = this.sec.AXXMLList.CreateList(this, this._name);
                    list._targetObject = this;
                    list._targetProperty = null;
                    // Steps 2,4-5.
                    return this.processingInstructionsInto(toXMLName(name, this.sec), list);
                };
                ASXML.prototype.processingInstructionsInto = function (name, list) {
                    var localName = name || '*';
                    // Step 4.
                    var children = this._children;
                    if (!children) {
                        return list;
                    }
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child._kind === 5    /* ProcessingInstruction */ && (localName === '*' || child._name.name === localName)) {
                            list._children.push(child);
                        }
                    }
                    // Step 5.
                    return list;
                };
                // 13.4.4.29
                ASXML.prototype.prependChild = function (child) {
                    this.insert(0, child);
                    return this;
                };
                ASXML.prototype.removeNamespace = function (ns) {
                    release || release || notImplemented('public.XML::removeNamespace');
                    return;
                };
                // 13.4.4.32 XML.prototype.replace
                ASXML.prototype.replace = function (propertyName, value) {
                    // Step 1.
                    if (this._kind !== 1    /* Element */) {
                        return;
                    }
                    var c;
                    // Step 2.
                    if (!value || value.axClass !== this.axClass && value.axClass !== this.sec.AXXMLList) {
                        c = AVMX.axCoerceString(value);
                    } else {
                        c = value._deepCopy();
                    }
                    // Step 4.
                    var mn = toXMLName(propertyName, this.sec);
                    if (Shumway.isIndex(mn.name)) {
                        this._replaceByIndex(mn.name | 0, c);
                        // Step 10.
                        return this;
                    }
                    var isAnyName = mn.isAnyName();
                    // Step 5 (Implicit).
                    // Step 6.
                    var i = -1;
                    // Step 7.
                    var children = this._children;
                    for (var k = children.length; k--;) {
                        // Step 7.a.
                        var child = children[k];
                        if (isAnyName || child._kind === 1    /* Element */ && child._name.matches(mn)) {
                            // Step 7.a.i.
                            if (i !== -1) {
                                this.deleteByIndex(i);
                            }
                            // Step 7.a.i.
                            i = k;
                        }
                    }
                    // Step 8.
                    if (i === -1) {
                        // Step 10.
                        return this;
                    }
                    // Step 9.
                    this._replaceByIndex(i, c);
                    // Step 10.
                    return this;
                };
                // 9.1.1.12 [[Replace]] (P, V)
                ASXML.prototype._replaceByIndex = function (p, v) {
                    // Step 1.
                    if (this._kind > 1    /* Element */) {
                        return this;
                    }
                    // Steps 2-3. (Implicit, guaranteed by assert).
                    release || assert(typeof p === 'number' && p >>> 0 === p);
                    // Step 4.
                    var children = this._children;
                    if (p > children.length) {
                        p = children.length;
                    }
                    // Step 5.
                    if (v && v.axClass === this.axClass && v._kind !== 2    /* Attribute */) {
                        // Step 5.a.
                        if (v._kind === 1    /* Element */) {
                            var a = this;
                            while (a) {
                                if (a === v) {
                                    this.sec.throwError('Error', AVMX.Errors.XMLIllegalCyclicalLoop);
                                }
                                a = a._parent;
                            }
                        }
                        // Step 5.b.
                        v._parent = this;
                        // Step 5.c.
                        if (children[p]) {
                            children[p]._parent = null;
                        }
                        // Step 5.d.
                        children[p] = v;
                    } else if (v && v.axClass === this.sec.AXXMLList) {
                        // Inlined steps.
                        if (v._children.length === 0) {
                            this.deleteByIndex(p);
                        } else {
                            var n = v._children.length;
                            if (p < children.length) {
                                children[p]._parent = null;
                                for (var i = children.length - 1; i > p; i--) {
                                    children[i + n] = children[i];
                                }
                            }
                            for (var i = 0; i < n; i++) {
                                var child = v._children[i];
                                child._parent = this;
                                children[i + p] = child;
                            }
                        }
                    } else {
                        // Step 7.a.
                        var s = AVMX.axCoerceString(v);
                        // Step 7.b.
                        var t = this.axClass.Create();
                        t._kind = 3    /* Text */;
                        t._value = s;
                        t._parent = this;
                        // Step 7.c.
                        if (children[p]) {
                            children[p]._parent = null;
                        }
                        // Step 7.d.
                        children[p] = t;
                    }
                };
                ASXML.prototype.setChildren = function (value) {
                    this.setProperty(anyMultiname, value);
                    return this;
                };
                // 13.4.4.34 XML.prototype.setLocalName( name )
                ASXML.prototype.setLocalName = function (name_) {
                    // Step 1.
                    if (this._kind === 3    /* Text */ || this._kind === 4    /* Comment */) {
                        return;
                    }
                    var name;
                    // Step 2.
                    if (name_ && name_.axClass === this.sec.AXQName) {
                        name = name_.localName;
                    } else {
                        // Step 3.
                        name = AVMX.axCoerceString(name_);
                    }
                    // Step 4.
                    this._name.name = name;
                };
                // 13.4.4.35 XML.prototype.setName( name )
                ASXML.prototype.setName = function (name_) {
                    // Step 1.
                    if (this._kind === 3    /* Text */ || this._kind === 4    /* Comment */) {
                        return;
                    }
                    // Step 2.
                    if (name_ && name_.axClass === this.sec.AXQName && name_.uri === null) {
                        name_ = name_.localName;
                    }
                    // Step 3.
                    var name = this.sec.AXQName.Create(name_).name;
                    // Step 4.
                    if (this._kind === 5    /* ProcessingInstruction */) {
                        release || assert(name.namespaces[0].type === 0    /* Public */);
                        name.namespaces[0] = AVMX.Namespace.PUBLIC;
                    }
                    // Step 5.
                    this._name = name;
                    // Steps 6-8.
                    var node = this;
                    if (this._kind === 2    /* Attribute */) {
                        if (this._parent === null) {
                            return;
                        }
                        node = this._parent;
                    }
                    node.addInScopeNamespace(name.namespaces[0]);
                };
                ASXML.prototype.setNamespace = function (ns) {
                    // Step 1.
                    if (this._kind === 3    /* Text */ || this._kind === 4    /* Comment */ || this._kind === 5    /* ProcessingInstruction */) {
                        return;
                    }
                    // Step 2.
                    var ns2 = this.sec.AXNamespace.Create(ns)._ns;
                    // Step 3.
                    this._name.namespaces = [ns2];
                    // Step 4.
                    if (this._kind === 2    /* Attribute */) {
                        if (this._parent) {
                            this._parent.addInScopeNamespace(ns2);
                        }
                    } else if (this._kind === 1    /* Element */) {
                        this.addInScopeNamespace(ns2);
                    }
                };
                ASXML.prototype.text = function () {
                    // 13.4.4.37 XML.prototype.text ( );
                    var xl = this.sec.AXXMLList.CreateList(this, this._name);
                    this._children && this._children.forEach(function (v, i) {
                        if (v._kind === 3    /* Text */) {
                            xl.append(v);
                        }
                    });
                    return xl;
                };
                ASXML.prototype.toXMLString = function () {
                    return this.toXMLStringImpl();
                };
                ASXML.prototype.toXMLStringImpl = function (ancestorNamespaces, indentLevel) {
                    var node = this;
                    var sec = this.sec;
                    // 10.2.1 ToXMLString Applied to the XML Type
                    var prettyPrinting = sec.AXXML.prettyPrinting;
                    indentLevel |= 0;
                    var s = prettyPrinting ? getIndentString(indentLevel) : '';
                    var kind = node._kind;
                    switch (kind) {
                    // 4. If x.[[Class]] == "text",
                    case 3    /* Text */:
                        return prettyPrinting ? s + escapeElementValue(sec, trimWhitespaces(node._value)) : escapeElementValue(sec, node._value);
                    // 5. If x.[[Class]] == "attribute", return the result of concatenating s and
                    // EscapeAttributeValue(x.[[Value]])
                    case 2    /* Attribute */:
                        return s + escapeAttributeValue(node._value);
                    // 6. If x.[[Class]] == "comment", return the result of concatenating s, the string "<!--",
                    // x.[[Value]] and the string "-->"
                    case 4    /* Comment */:
                        return s + '<!--' + node._value + '-->';
                    // 7 If x.[[Class]] == "processing-instruction", return the result of concatenating s, the
                    // string "<?", x.[[Name]].localName, the space <SP> character, x.[[Value]] and the string
                    // "?>"
                    case 5    /* ProcessingInstruction */:
                        return s + '<?' + node._name.name + ' ' + node._value + '?>';
                    default:
                        release || assert(kind === 1    /* Element */);
                        break;
                    }
                    ancestorNamespaces = ancestorNamespaces || [];
                    var namespaceDeclarations = [];
                    // 10. For each ns in x.[[InScopeNamespaces]]
                    for (var i = 0; node._inScopeNamespaces && i < node._inScopeNamespaces.length; i++) {
                        var ns = node._inScopeNamespaces[i];
                        if (ancestorNamespaces.every(function (ans) {
                                return ans.uri !== ns.uri || ans.prefix !== ns.prefix;
                            })) {
                            namespaceDeclarations.push(ns);
                        }
                    }
                    // 11. For each name in the set of names consisting of x.[[Name]] and the name of each
                    // attribute in x.[[Attributes]]
                    var currentNamespaces = ancestorNamespaces.concat(namespaceDeclarations);
                    var namespace = GetNamespace(node._name, currentNamespaces);
                    if (namespace.prefix === undefined) {
                        // Let namespace.prefix be an arbitrary implementation defined namespace prefix, such that
                        // there is no ns2 ∈ (AncestorNamespaces ∪ namespaceDeclarations) with namespace.prefix ==
                        // ns2.prefix
                        var newPrefix = generateUniquePrefix(currentNamespaces);
                        var ns2 = AVMX.internPrefixedNamespace(0    /* Public */, namespace.uri, newPrefix);
                        // Let namespaceDeclarations = namespaceDeclarations ∪ { namespace }
                        namespaceDeclarations.push(ns2);
                        currentNamespaces.push(ns2);
                    }
                    // 12. Let s be the result of concatenating s and the string "<"
                    // 13. If namespace.prefix is not the empty string,
                    //   a. Let s be the result of concatenating s, namespace.prefix and the string ":"
                    // 14. Let s be the result of concatenating s and x.[[Name]].localName
                    var elementName = (namespace.prefix ? namespace.prefix + ':' : '') + node._name.name;
                    s += '<' + elementName;
                    node._attributes && node._attributes.forEach(function (attr) {
                        var name = attr._name;
                        var namespace = GetNamespace(name, currentNamespaces);
                        if (namespace.prefix === undefined) {
                            // Let namespace.prefix be an arbitrary implementation defined namespace prefix, such that
                            // there is no ns2 ∈ (AncestorNamespaces ∪ namespaceDeclarations) with namespace.prefix ==
                            // ns2.prefix
                            var newPrefix = generateUniquePrefix(currentNamespaces);
                            var ns2 = AVMX.internPrefixedNamespace(0    /* Public */, namespace.uri, newPrefix);
                            // Let namespaceDeclarations = namespaceDeclarations ∪ { namespace }
                            namespaceDeclarations.push(ns2);
                            currentNamespaces.push(ns2);
                        }
                    });
                    for (var i = 0; i < namespaceDeclarations.length; i++) {
                        var namespace = namespaceDeclarations[i];
                        if (namespace.uri === '') {
                            continue;
                        }
                        var attributeName = namespace.prefix ? 'xmlns:' + namespace.prefix : 'xmlns';
                        s += ' ' + attributeName + '="' + escapeAttributeValue(namespace.uri) + '"';
                    }
                    node._attributes && node._attributes.forEach(function (attr) {
                        var name = attr._name;
                        var namespace = GetNamespace(name, ancestorNamespaces);
                        var attributeName = namespace.prefix ? namespace.prefix + ':' + name.name : name.name;
                        s += ' ' + attributeName + '="' + escapeAttributeValue(attr._value) + '"';
                    });
                    // 17. If x.[[Length]] == 0
                    if (node._children.length === 0) {
                        //   a. Let s be the result of concatenating s and "/>"
                        s += '/>';
                        //   b. Return s
                        return s;
                    }
                    // 18. Let s be the result of concatenating s and the string ">"
                    s += '>';
                    // 19. Let indentChildren = ((x.[[Length]] > 1) or (x.[[Length]] == 1 and x[0].[[Class]] is
                    // not equal to "text"))
                    var indentChildren = node._children.length > 1 || node._children.length === 1 && node._children[0]._kind !== 3    /* Text */;
                    var nextIndentLevel = prettyPrinting && indentChildren ? indentLevel + sec.AXXML._prettyIndent : 0;
                    node._children.forEach(function (childNode, i) {
                        if (prettyPrinting && indentChildren) {
                            s += '\n';
                        }
                        s += childNode.toXMLStringImpl(currentNamespaces, nextIndentLevel);
                    });
                    if (prettyPrinting && indentChildren) {
                        s += '\n' + getIndentString(indentLevel);
                    }
                    s += '</' + elementName + '>';
                    return s;
                };
                ASXML.prototype.toJSON = function (k) {
                    return 'XML';
                };
                ASXML.prototype.axGetEnumerableKeys = function () {
                    if (this === this.axClass.dPrototype) {
                        return _super.prototype.axGetEnumerableKeys.call(this);
                    }
                    var keys = [];
                    for (var i = 0; i < this._children.length; i++) {
                        keys.push(this._children[i]._name.name);
                    }
                    return keys;
                };
                // 9.1.1.2 [[Put]] (P, V)
                ASXML.prototype.setProperty = function (mn, v) {
                    release || assert(mn instanceof AVMX.Multiname);
                    // Step 1. (Step 3 in Tamarin source.)
                    var sec = this.sec;
                    if (!mn.isAnyName() && !mn.isAttribute() && mn.name === mn.name >>> 0) {
                        sec.throwError('TypeError', AVMX.Errors.XMLAssignmentToIndexedXMLNotAllowed);
                    }
                    // Step 2. (Step 4 in Tamarin source.)
                    if (this._kind === 3    /* Text */ || this._kind === 4    /* Comment */ || this._kind === 5    /* ProcessingInstruction */ || this._kind === 2    /* Attribute */) {
                        return;
                    }
                    // Step 3.
                    var c;
                    if (!isXMLType(v, sec) || v._kind === 3    /* Text */ || v._kind === 2    /* Attribute */) {
                        c = toString(v, sec);
                    } else {
                        c = v._deepCopy();
                    }
                    // Step 5 (implicit, mn is always a Multiname here).
                    // Step 6 (7 in Tamarin).
                    if (mn.isAttribute()) {
                        // Step 6.a (omitted, as in Tamarin).
                        // Step 6.b.
                        if (c && c.axClass === sec.AXXMLList) {
                            // Step 6.b.i.
                            if (c._children.length === 0) {
                                c = '';
                            } else {
                                // Step 6.b.ii.1.
                                var s = toString(c._children[0], sec);
                                // Step 6.b.ii.2.
                                for (var j = 1; j < c._children.length; j++) {
                                    s += ' ' + toString(c._children[j], sec);
                                }
                                // Step 6.b.ii.3.
                                c = s;
                            }
                        } else {
                            c = AVMX.axCoerceString(c);
                        }
                        // Step 6.d.
                        var a = null;
                        // Step 6.e.
                        var attributes = this._attributes;
                        var newAttributes = this._attributes = [];
                        for (var j = 0; attributes && j < attributes.length; j++) {
                            var attribute = attributes[j];
                            if (attribute._name.matches(mn)) {
                                // Step 6.e.1.
                                if (!a) {
                                    a = attribute;
                                } else {
                                    attribute._parent = null;
                                    continue;
                                }
                            }
                            newAttributes.push(attribute);
                        }
                        // Step 6.f.
                        if (!a) {
                            // Wildcard attribute names shouldn't cause any attributes to be *added*, so we can bail
                            // here. Tamarin doesn't do this, and it's not entirely clear to me how they avoid
                            // adding attributes, but this works and doesn't regress any tests.
                            if (mn.isAnyName()) {
                                return;
                            }
                            var uri = '';
                            if (mn.namespaces.length === 1) {
                                uri = mn.namespaces[0].uri;
                            }
                            a = createXML(sec, 2    /* Attribute */, uri, mn.name);
                            a._parent = this;
                            newAttributes.push(a);
                        }
                        // Step 6.g.
                        a._value = c;
                        // Step 6.h.
                        return;
                    }
                    var i;
                    var isAny = mn.isAnyName();
                    var primitiveAssign = !isXMLType(c, sec) && !isAny && mn.name !== '*';
                    var isAnyNamespace = mn.isAnyNamespace();
                    for (var k = this._children.length - 1; k >= 0; k--) {
                        if ((isAny || this._children[k]._kind === 1    /* Element */ && this._children[k]._name.name === mn.name) && (isAnyNamespace || this._children[k]._kind === 1    /* Element */ && this._children[k]._name.matches(mn))) {
                            if (i !== undefined) {
                                this.deleteByIndex(i);
                            }
                            i = k;
                        }
                    }
                    if (i === undefined) {
                        i = this._children.length;
                        if (primitiveAssign) {
                            var ns = mn.namespaces[0];
                            var uri = null;
                            var prefix;
                            if (ns.uri !== null) {
                                uri = ns.uri;
                                prefix = ns.prefix;
                            }
                            if (uri === null) {
                                var defaultNamespace = getDefaultNamespace(sec);
                                uri = defaultNamespace.uri;
                                prefix = defaultNamespace.prefix;
                            }
                            var y = createXML(sec, 1    /* Element */, uri, mn.name, prefix);
                            y._parent = this;
                            this._replaceByIndex(i, y);
                            var ns = y._name.namespace;
                            y.addInScopeNamespace(ns);
                        }
                    }
                    if (primitiveAssign) {
                        // Blow away kids of x[i].
                        var subChildren = this._children[i]._children;
                        for (var j = subChildren.length; j--;) {
                            subChildren[j]._parent = null;
                        }
                        subChildren.length = 0;
                        var s = toString(c, sec);
                        if (s !== '') {
                            this._children[i]._replaceByIndex(0, s);
                        }
                    } else {
                        this._replaceByIndex(i, c);
                    }
                };
                ASXML.prototype.axSetProperty = function (mn, value, bc) {
                    if (this === this.axClass.dPrototype) {
                        release || AVMX.checkValue(value);
                        this[this.axResolveMultiname(mn)] = value;
                        return;
                    }
                    this.setProperty(coerceE4XMultiname(mn, this.sec), value);
                };
                // 9.1.1.1 XML.[[Get]] (P)
                ASXML.prototype.getProperty = function (mn) {
                    release || assert(mn instanceof AVMX.Multiname);
                    // Step 1.
                    var nm = mn.name;
                    if (Shumway.isIndex(nm)) {
                        // this is a shortcut to the E4X logic that wants us to create a new
                        // XMLList with of size 1 and access it with the given index.
                        if ((nm | 0) === 0) {
                            return this;
                        }
                        return null;
                    }
                    // Step 2 (implicit).
                    // Step 3.
                    var list = this.sec.AXXMLList.CreateList(this, mn);
                    var length = 0;
                    var anyName = mn.isAnyName();
                    var anyNamespace = mn.isAnyNamespace();
                    // Step 4.
                    if (mn.isAttribute()) {
                        for (var i = 0; this._attributes && i < this._attributes.length; i++) {
                            var v = this._attributes[i];
                            if ((anyName || v._name.name === nm) && (anyNamespace || v._name.matches(mn))) {
                                list._children[length++] = v;
                                assert(list._children[0]);
                            }
                        }
                        return list;
                    }
                    // Step 5.
                    for (var i = 0; this._children && i < this._children.length; i++) {
                        var v = this._children[i];
                        if ((anyName || v._kind === 1    /* Element */ && v._name.name === nm) && (anyNamespace || v._name.matches(mn))) {
                            list._children[length++] = v;
                            assert(list._children[0]);
                        }
                    }
                    // Step 6.
                    return list;
                };
                ASXML.prototype.axGetProperty = function (mn) {
                    if (this === this.axClass.dPrototype) {
                        var value = this[this.axResolveMultiname(mn)];
                        release || AVMX.checkValue(value);
                        return value;
                    }
                    return this.getProperty(coerceE4XMultiname(mn, this.sec));
                };
                // 9.1.1.6 [[HasProperty]] (P) (well, very roughly)
                ASXML.prototype.hasProperty = function (mn) {
                    if (Shumway.isIndex(mn.name)) {
                        // this is a shortcut to the E4X logic that wants us to create a new
                        // XMLList of size 1 and access it with the given index.
                        return (mn.name | 0) === 0;
                    }
                    var name = toXMLName(mn, this.sec);
                    var anyName = name.isAnyName();
                    var anyNamespace = name.isAnyNamespace();
                    if (mn.isAttribute()) {
                        for (var i = 0; this._attributes && i < this._attributes.length; i++) {
                            var v = this._attributes[i];
                            if (anyName || v._name.matches(name)) {
                                return true;
                            }
                        }
                        return false;
                    }
                    for (var i = 0; i < this._children.length; i++) {
                        var v = this._children[i];
                        if ((anyName || v._kind === 1    /* Element */ && v._name.name === name.name) && (anyNamespace || v._kind === 1    /* Element */ && v._name.matches(name))) {
                            return true;
                        }
                    }
                };
                ASXML.prototype.deleteProperty = function (mn) {
                    if (Shumway.isIndex(mn.name)) {
                        // This hasn't ever been implemented and silently does nothing in Tamarin (and Rhino).
                        return true;
                    }
                    var name = toXMLName(mn, this.sec);
                    var localName = name.name;
                    var anyName = mn.isAnyName();
                    var anyNamespace = mn.isAnyNamespace();
                    if (mn.isAttribute()) {
                        var attributes = this._attributes;
                        if (attributes) {
                            var newAttributes = this._attributes = [];
                            for (var i = 0; i < attributes.length; i++) {
                                var node = attributes[i];
                                var attrName = node._name;
                                if ((anyName || attrName.name === localName) && (anyNamespace || attrName.matches(name))) {
                                    node._parent = null;
                                } else {
                                    newAttributes.push(node);
                                }
                            }
                        }
                    } else {
                        if (this._children.some(function (v, i) {
                                return (anyName || v._kind === 1    /* Element */ && v._name.name === name.name) && (anyNamespace || v._kind === 1    /* Element */ && v._name.matches(name));
                            })) {
                            return true;
                        }
                    }
                };
                ASXML.prototype.axHasProperty = function (mn) {
                    if (this === this.axClass.dPrototype) {
                        return _super.prototype.axHasPropertyInternal.call(this, mn);
                    }
                    return this.axHasPropertyInternal(mn);
                };
                ASXML.prototype.axHasPropertyInternal = function (mn) {
                    if (this.hasProperty(mn)) {
                        return true;
                    }
                    // HACK if child with specific name is not present, check object's attributes.
                    // The presence of the attribute/method can be checked during with(), see #850.
                    return !!this[this.axResolveMultiname(mn)];
                };
                ASXML.prototype.axDeleteProperty = function (mn) {
                    if (this.deleteProperty(mn)) {
                        return true;
                    }
                    // HACK if child with specific name is not present, check object's attributes.
                    // The presence of the attribute/method can be checked during with(), see #850.
                    return delete this[this.axResolveMultiname(mn)];
                };
                ASXML.prototype.axCallProperty = function (mn, args) {
                    var method = this[this.axResolveMultiname(mn)];
                    // The method might be dynamically defined on XML.prototype.
                    if (!method) {
                        method = this['$Bg' + mn.name];
                    }
                    // Check if the method exists before calling it.
                    if (method) {
                        AVMX.validateCall(this.sec, method, args.length);
                        return method.axApply(this, args);
                    }
                    // Otherwise, 11.2.2.1 CallMethod ( r , args )
                    // If f == undefined and Type(base) is XMLList and base.[[Length]] == 1
                    //   ii. Return the result of calling CallMethod(r0, args) recursively
                    // f. If f == undefined and Type(base) is XML and base.hasSimpleContent () == true
                    //   i. Let r0 be a new Reference with base object = ToObject(ToString(base)) and property
                    // name = P ii. Return the result of calling CallMethod(r0, args) recursively
                    if (this.hasSimpleContent()) {
                        return this.sec.box(toString(this, this.sec)).axCallProperty(mn, args);
                    }
                    this.sec.throwError('TypeError', AVMX.Errors.CallOfNonFunctionError, 'value');
                };
                ASXML.prototype._delete = function (key, isMethod) {
                    release || release || notImplemented('XML.[[Delete]]');
                };
                ASXML.prototype.deleteByIndex = function (p) {
                    var i = p >>> 0;
                    if (String(i) !== String(p)) {
                        throw 'TypeError in XML.prototype.deleteByIndex(): invalid index ' + p;
                    }
                    var children = this._children;
                    if (p < children.length && children[p]) {
                        children[p]._parent = null;
                        children.splice(p, 1);
                    }
                };
                // 9.1.1.11 [[Insert]] (P, V)
                ASXML.prototype.insert = function (p, v) {
                    // Step 1.
                    if (this._kind > 1    /* Element */) {
                        return;
                    }
                    // Steps 2-3 (Guaranteed by assert).
                    release || assert(typeof p === 'number' && Shumway.isIndex(p));
                    var i = p;
                    // Step 4.
                    if (v && v.axClass === this.axClass) {
                        var a = this;
                        while (a) {
                            if (a === v) {
                                this.sec.throwError('TypeError', AVMX.Errors.XMLIllegalCyclicalLoop);
                            }
                            a = a._parent;
                        }
                    }
                    // Step 5.
                    var n = 1;
                    // Step 6.
                    if (v && v.axClass === this.sec.AXXMLList) {
                        n = v._children.length;
                        // Step 7.
                        if (n === 0) {
                            return;
                        }
                    }
                    // Step 8.
                    var ownChildren = this._children;
                    for (var j = ownChildren.length - 1; j >= i; j--) {
                        ownChildren[j + n] = ownChildren[j];
                        assert(ownChildren[0]);
                    }
                    // Step 9 (implicit).
                    // Step 10.
                    if (v && v.axClass === this.sec.AXXMLList) {
                        n = v._children.length;
                        for (var j = 0; j < n; j++) {
                            v._children[j]._parent = this;
                            ownChildren[i + j] = v._children[j];
                        }
                    } else {
                        //x.replace(i, v), inlined;
                        if (!(v && v.axClass === this.axClass)) {
                            v = this.sec.AXXML.Create(v);
                        }
                        v._parent = this;
                        if (!ownChildren) {
                            this._children = ownChildren = [];
                        }
                        ownChildren[i] = v;
                        assert(ownChildren[0]);
                    }
                };
                // 9.1.1.13 [[AddInScopeNamespace]] ( N )
                ASXML.prototype.addInScopeNamespace = function (ns) {
                    if (this._kind === 3    /* Text */ || this._kind === 4    /* Comment */ || this._kind === 5    /* ProcessingInstruction */ || this._kind === 2    /* Attribute */) {
                        return;
                    }
                    var prefix = ns.prefix;
                    if (prefix !== undefined) {
                        if (prefix === '' && this._name.uri === '') {
                            return;
                        }
                        var match = null;
                        this._inScopeNamespaces.forEach(function (v, i) {
                            if (v.prefix === prefix) {
                                match = v;
                            }
                        });
                        if (match !== null && match.uri !== ns.uri) {
                            this._inScopeNamespaces.forEach(function (v, i) {
                                if (v.prefix === match.prefix) {
                                    this._inScopeNamespaces[i] = ns;    // replace old with new
                                }
                            });
                        }
                        if (this._name.prefix === prefix) {
                            this._name.prefix = undefined;
                        }
                        this._attributes.forEach(function (v, i) {
                            if (v._name.prefix === prefix) {
                                v._name.prefix = undefined;
                            }
                        });
                    }
                };
                ASXML.prototype.descendantsInto = function (name, xl) {
                    if (this._kind !== 1    /* Element */) {
                        return xl;
                    }
                    var length = xl._children.length;
                    var isAny = name.isAnyName();
                    if (name.isAttribute()) {
                        // Get attributes
                        this._attributes.forEach(function (v, i) {
                            if (isAny || v._name.matches(name)) {
                                xl._children[length++] = v;
                                assert(xl._children[0]);
                            }
                        });
                    } else {
                        // Get children
                        this._children.forEach(function (v, i) {
                            if (isAny || v._name.matches(name)) {
                                xl._children[length++] = v;
                                assert(xl._children[0]);
                            }
                        });
                    }
                    // Descend
                    this._children.forEach(function (v, i) {
                        v.descendantsInto(name, xl);
                    });
                    return xl;
                };
                ASXML.instanceConstructor = ASXML;
                ASXML._flags = ASXML_FLAGS.ALL;
                ASXML._prettyIndent = 2;
                return ASXML;
            }(AS.ASObject);
            AS.ASXML = ASXML;
            function createXML(sec, kind, uri, name, prefix) {
                if (kind === void 0) {
                    kind = 3    /* Text */;
                }
                if (uri === void 0) {
                    uri = '';
                }
                if (name === void 0) {
                    name = '';
                }
                var xml = sec.AXXML.Create();
                var ns = AVMX.internPrefixedNamespace(0    /* Public */, uri, prefix || '');
                var mn = new AVMX.Multiname(null, 0, kind === 2    /* Attribute */ ? 13    /* QNameA */ : 7    /* QName */, [ns], name, null);
                xml.init(kind, mn);
                return xml;
            }
            var ASXMLList = function (_super) {
                __extends(ASXMLList, _super);
                function ASXMLList(value) {
                    _super.call(this);
                    this._children = [];
                    if (Shumway.isNullOrUndefined(value)) {
                        value = '';
                    }
                    if (!value) {
                        return;
                    }
                    if (value && value.axClass === this.sec.AXXMLList) {
                        var children = value._children;
                        for (var i = 0; i < children.length; i++) {
                            var child = children[i];
                            this._children[i] = child;
                            assert(this._children[0]);
                        }
                    } else {
                        toXMLList(value, this);
                    }
                }
                ASXMLList.classInitializer = function () {
                    defineNonEnumerableProperty(this, '$Bglength', 1);
                    var proto = this.dPrototype;
                    var asProto = ASXMLList.prototype;
                    defineNonEnumerableProperty(proto, '$BgvalueOf', Object.prototype['$BgvalueOf']);
                    defineNonEnumerableProperty(proto, '$BghasOwnProperty', asProto.native_hasOwnProperty);
                    defineNonEnumerableProperty(proto, '$BgpropertyIsEnumerable', asProto.native_propertyIsEnumerable);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    AS.addPrototypeFunctionAlias(proto, '$BgaddNamespace', asProto.addNamespace);
                    AS.addPrototypeFunctionAlias(proto, '$BgappendChild', asProto.appendChild);
                    AS.addPrototypeFunctionAlias(proto, '$Bgattribute', asProto.attribute);
                    AS.addPrototypeFunctionAlias(proto, '$Bgattributes', asProto.attributes);
                    AS.addPrototypeFunctionAlias(proto, '$Bgchild', asProto.child);
                    AS.addPrototypeFunctionAlias(proto, '$BgchildIndex', asProto.childIndex);
                    AS.addPrototypeFunctionAlias(proto, '$Bgchildren', asProto.children);
                    AS.addPrototypeFunctionAlias(proto, '$Bgcomments', asProto.comments);
                    AS.addPrototypeFunctionAlias(proto, '$Bgcontains', asProto.contains);
                    AS.addPrototypeFunctionAlias(proto, '$Bgcopy', asProto.copy);
                    AS.addPrototypeFunctionAlias(proto, '$Bgdescendants', asProto.descendants);
                    AS.addPrototypeFunctionAlias(proto, '$Bgelements', asProto.elements);
                    AS.addPrototypeFunctionAlias(proto, '$BghasComplexContent', asProto.hasComplexContent);
                    AS.addPrototypeFunctionAlias(proto, '$BghasSimpleContent', asProto.hasSimpleContent);
                    AS.addPrototypeFunctionAlias(proto, '$BginScopeNamespaces', asProto.inScopeNamespaces);
                    AS.addPrototypeFunctionAlias(proto, '$BginsertChildAfter', asProto.insertChildAfter);
                    AS.addPrototypeFunctionAlias(proto, '$BginsertChildBefore', asProto.insertChildBefore);
                    AS.addPrototypeFunctionAlias(proto, '$Bglength', asProto.length);
                    AS.addPrototypeFunctionAlias(proto, '$BglocalName', asProto.localName);
                    AS.addPrototypeFunctionAlias(proto, '$Bgname', asProto.name);
                    AS.addPrototypeFunctionAlias(proto, '$Bgnamespace', asProto.namespace);
                    AS.addPrototypeFunctionAlias(proto, '$BgnamespaceDeclarations', asProto.namespaceDeclarations);
                    AS.addPrototypeFunctionAlias(proto, '$BgnodeKind', asProto.nodeKind);
                    AS.addPrototypeFunctionAlias(proto, '$Bgnormalize', asProto.normalize);
                    AS.addPrototypeFunctionAlias(proto, '$Bgparent', asProto.parent);
                    AS.addPrototypeFunctionAlias(proto, '$BgprocessingInstructions', asProto.processingInstructions);
                    AS.addPrototypeFunctionAlias(proto, '$BgprependChild', asProto.prependChild);
                    AS.addPrototypeFunctionAlias(proto, '$BgremoveNamespace', asProto.removeNamespace);
                    AS.addPrototypeFunctionAlias(proto, '$Bgreplace', asProto.replace);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetChildren', asProto.setChildren);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetLocalName', asProto.setLocalName);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetName', asProto.setName);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetNamespace', asProto.setNamespace);
                    AS.addPrototypeFunctionAlias(proto, '$Bgtext', asProto.text);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoXMLString', asProto.toXMLString);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoJSON', asProto.toJSON);
                };
                ASXMLList.axApply = function (self, args) {
                    var value = args[0];
                    // 13.5.1 The XMLList Constructor Called as a Function
                    if (Shumway.isNullOrUndefined(value)) {
                        value = '';
                    }
                    if (value && value.axClass === this.sec.AXXMLList) {
                        return value;
                    }
                    var list = this.sec.AXXMLList.Create();
                    toXMLList(value, list);
                    return list;
                };
                // 11.4.1 The Addition Operator ( + )
                ASXMLList.addXML = function (left, right) {
                    var result;
                    if (left.axClass === left.sec.AXXML) {
                        result = left.sec.AXXMLList.Create();
                        result.append(left);
                    } else {
                        result = left;
                    }
                    result.append(right);
                    return result;
                };
                ASXMLList.Create = function (value) {
                    var list = Object.create(this.sec.AXXMLList.tPrototype);
                    list.axInitializer(value);
                    return list;
                };
                ASXMLList.CreateList = function (targetObject, targetProperty) {
                    var list = this.Create();
                    list._targetObject = targetObject;
                    list._targetProperty = targetProperty;
                    return list;
                };
                ASXMLList.prototype.valueOf = function () {
                    return this;
                };
                // E4X 11.5.1 The Abstract Equality Comparison Algorithm, steps 1-2.
                // (but really 9.2.1.9 [[Equals]] (V))
                ASXMLList.prototype.equals = function (other) {
                    var children = this._children;
                    // Step 1.
                    if (other === undefined && children.length === 0) {
                        return true;
                    }
                    // Step 2.
                    if (other && other.axClass === this.sec.AXXMLList) {
                        var otherChildren = other._children;
                        // Step 2.a.
                        if (otherChildren.length !== children.length) {
                            return false;
                        }
                        // Step 2.b.
                        for (var i = 0; i < children.length; i++) {
                            if (!children[i].equals(otherChildren[i])) {
                                return false;
                            }
                        }
                        // Step 2.c.
                        return true;
                    }
                    // Steps 3-4.
                    return children.length === 1 && children[0].equals(other);
                };
                ASXMLList.prototype.toString = function () {
                    if (this.hasComplexContent()) {
                        return this.toXMLString();
                    }
                    var s = '';
                    for (var i = 0; i < this._children.length; i++) {
                        s += toString(this._children[i], this.sec);
                    }
                    return s;
                };
                // 9.2.1.7 [[DeepCopy]] ( )
                ASXMLList.prototype._deepCopy = function () {
                    var xl = this.sec.AXXMLList.CreateList(this._targetObject, this._targetProperty);
                    var length = this._children.length;
                    for (var i = 0; i < length; i++) {
                        xl._children[i] = this._children[i]._deepCopy();
                        assert(xl._children[0]);
                    }
                    return xl;
                };
                ASXMLList.prototype._shallowCopy = function () {
                    var xl = this.sec.AXXMLList.CreateList(this._targetObject, this._targetProperty);
                    var length = this._children.length;
                    for (var i = 0; i < length; i++) {
                        xl._children[i] = this._children[i];
                        assert(xl._children[0]);
                    }
                    return xl;
                };
                // 13.5.4.12 XMLList.prototype.hasOwnProperty ( P )
                ASXMLList.prototype.native_hasOwnProperty = function (P) {
                    P = AVMX.axCoerceString(P);
                    if (this === this.sec.AXXMLList.dPrototype) {
                        return AS.ASObject.prototype.native_hasOwnProperty.call(this, P);
                    }
                    if (Shumway.isIndex(P)) {
                        return (P | 0) < this._children.length;
                    }
                    var mn = toXMLName(P, this.sec);
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        var node = children[i];
                        if (node._kind === 1    /* Element */) {
                            if (node.hasProperty(mn)) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                // 13.5.4.19 XMLList.prototype.propertyIsEnumerable ( P )
                ASXMLList.prototype.native_propertyIsEnumerable = function (P) {
                    return Shumway.isIndex(P) && (P | 0) < this._children.length;
                };
                ASXMLList.prototype.attribute = function (arg) {
                    if (Shumway.isNullOrUndefined(arg) && arguments.length > 0) {
                        this.sec.throwError('TypeError', AVMX.Errors.ConvertUndefinedToObjectError);
                    }
                    if (arg && arg.axClass === this.sec.AXQName) {
                        return this.getProperty(arg.name);
                    }
                    arg = AVMX.axCoerceString(arg);
                    if (arg === '*' || arguments.length === 0) {
                        arg = null;
                    }
                    tmpMultiname.name = arg;
                    tmpMultiname.namespaces = [AVMX.Namespace.PUBLIC];
                    tmpMultiname.kind = 13    /* QNameA */;
                    return this.getProperty(tmpMultiname);
                };
                ASXMLList.prototype.attributes = function () {
                    // 13.5.4.3 XMLList.prototype.attributes ( )
                    tmpMultiname.name = null;
                    tmpMultiname.namespaces = [];
                    tmpMultiname.kind = 13    /* QNameA */;
                    return this.getProperty(tmpMultiname);
                };
                ASXMLList.prototype.child = function (propertyName) {
                    if (Shumway.isIndex(propertyName)) {
                        var list = this.sec.AXXMLList.CreateList(this._targetObject, this._targetProperty);
                        if ((propertyName | 0) < this._children.length) {
                            list._children[0] = this._children[propertyName | 0]._deepCopy();
                            assert(list._children[0]);
                        }
                        return list;
                    }
                    return this.getProperty(toXMLName(propertyName, this.sec));
                };
                ASXMLList.prototype.children = function () {
                    // 13.5.4.4 XMLList.prototype.child ( propertyName )
                    return this.getProperty(anyMultiname);
                };
                // 9.2.1.8 [[Descendants]] (P)
                ASXMLList.prototype.descendants = function (name_) {
                    var name = toXMLName(name_, this.sec);
                    var list = this.sec.AXXMLList.CreateList(this._targetObject, this._targetProperty);
                    for (var i = 0; i < this._children.length; i++) {
                        var child = this._children[i];
                        if (child._kind === 1    /* Element */) {
                            child.descendantsInto(name, list);
                        }
                    }
                    return list;
                };
                ASXMLList.prototype.comments = function () {
                    // 13.5.4.6 XMLList.prototype.comments ( )
                    var xl = this.sec.AXXMLList.CreateList(this._targetObject, this._targetProperty);
                    this._children.forEach(function (child) {
                        if (child._kind === 1    /* Element */) {
                            var r = child.comments();
                            Array.prototype.push.apply(xl._children, r._children);
                        }
                    });
                    return xl;
                };
                // 13.5.4.8 XMLList.prototype.contains ( value )
                ASXMLList.prototype.contains = function (value) {
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.equals(value)) {
                            return true;
                        }
                    }
                    return false;
                };
                ASXMLList.prototype.copy = function () {
                    // 13.5.4.9 XMLList.prototype.copy ( )
                    return this._deepCopy();
                };
                ASXMLList.prototype.elements = function (name) {
                    // 13.5.4.11 XMLList.prototype.elements ( [ name ] )
                    var mn = toXMLName(name, this.sec);
                    var xl = this.sec.AXXMLList.CreateList(this._targetObject, mn);
                    this._children.forEach(function (child) {
                        if (child._kind === 1    /* Element */) {
                            var r = child.elements(mn);
                            Array.prototype.push.apply(xl._children, r._children);
                        }
                    });
                    return xl;
                };
                ASXMLList.prototype.hasComplexContent = function () {
                    // 13.5.4.13 XMLList.prototype.hasComplexContent( )
                    switch (this._children.length) {
                    case 0:
                        return false;
                    case 1:
                        return this._children[0].hasComplexContent();
                    default:
                        return this._children.some(function (child) {
                            return child._kind === 1    /* Element */;
                        });
                    }
                };
                ASXMLList.prototype.hasSimpleContent = function () {
                    // 13.5.4.14 XMLList.prototype.hasSimpleContent( )
                    switch (this._children.length) {
                    case 0:
                        return true;
                    case 1:
                        return this._children[0].hasSimpleContent();
                    default:
                        return this._children.every(function (child) {
                            return child._kind !== 1    /* Element */;
                        });
                    }
                };
                ASXMLList.prototype.length = function () {
                    return this._children.length;
                };
                ASXMLList.prototype.name = function () {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'name');
                    }
                    return this._children[0].name();
                };
                // 13.5.4.16 XMLList.prototype.normalize ( )
                ASXMLList.prototype.normalize = function () {
                    // Steps 1-2.
                    for (var i = 0; i < this._children.length;) {
                        var child = this._children[i];
                        // Step 2.a.
                        if (child._kind === 1    /* Element */) {
                            child.normalize();
                            i++;
                        } else if (child._kind === 3    /* Text */) {
                            // Step 2.b.i.
                            for (i++; i < this._children.length;) {
                                var nextChild = this._children[i];
                                if (nextChild._kind !== 3    /* Text */) {
                                    break;
                                }
                                child._value += nextChild._value;
                                this.removeByIndex(i);
                            }
                            // Step 2.b.ii.
                            if (child._value.length === 0) {
                                this.removeByIndex(i);
                            } else {
                                i++;
                            }
                        } else {
                            i++;
                        }
                    }
                    return this;
                };
                ASXMLList.prototype.parent = function () {
                    // 13.5.4.17 XMLList.prototype.parent ( )
                    var children = this._children;
                    if (children.length === 0) {
                        return undefined;
                    }
                    var parent = children[0]._parent;
                    for (var i = 1; i < children.length; i++) {
                        if (children[i]._parent !== parent) {
                            return undefined;
                        }
                    }
                    return parent;
                };
                // 13.5.4.18 XMLList.prototype.processingInstructions ( [ name ] )
                ASXMLList.prototype.processingInstructions = function (name_) {
                    // (Numbering in the spec starts at 6.)
                    // Step 6 (implicit).
                    // Step 7.
                    var name = toXMLName(name_, this.sec);
                    // Step 8.
                    var list = this.sec.AXXMLList.CreateList(this._targetObject, this._targetProperty);
                    list._targetObject = this;
                    list._targetProperty = null;
                    // Step 9.
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        children[i].processingInstructionsInto(name, list);
                    }
                    // Step 10.
                    return list;
                };
                ASXMLList.prototype.text = function () {
                    // 13.5.4.20 XMLList.prototype.text ( )
                    var xl = this.sec.AXXMLList.CreateList(this._targetObject, this._targetProperty);
                    this._children.forEach(function (v, i) {
                        if (v._kind === 1    /* Element */) {
                            var gq = v.text();
                            if (gq._children.length > 0) {
                                xl._children.push(gq);
                            }
                        }
                    });
                    return xl;
                };
                ASXMLList.prototype.toXMLString = function () {
                    // 10.2.2 ToXMLString Applied to the XMLList Type
                    var sec = this.sec;
                    return this._children.map(function (childNode) {
                        return toXMLString(sec, childNode);
                    }).join(sec.AXXML.prettyPrinting ? '\n' : '');
                };
                ASXMLList.prototype.toJSON = function (k) {
                    return 'XMLList';
                };
                ASXMLList.prototype.addNamespace = function (ns) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'addNamespace');
                    }
                    var xml = this._children[0];
                    xml.addNamespace(ns);
                    return xml;
                };
                ASXMLList.prototype.appendChild = function (child) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'appendChild');
                    }
                    var xml = this._children[0];
                    xml.appendChild(child);
                    return xml;
                };
                // 9.2.1.6 [[append]] (V)
                ASXMLList.prototype.append = function (V) {
                    // Step 1.
                    var children = this._children;
                    var i = children.length;
                    // Step 2.
                    var n = 1;
                    // Step 3.
                    if (V && V.axClass === this.sec.AXXMLList) {
                        this._targetObject = V._targetObject;
                        this._targetProperty = V._targetProperty;
                        var valueChildren = V._children;
                        n = valueChildren.length;
                        if (n === 0) {
                            return;
                        }
                        for (var j = 0; j < valueChildren.length; j++) {
                            children[i + j] = valueChildren[j];
                        }
                        return;
                    }
                    release || assert(V.axClass === this.sec.AXXML);
                    // Step 4.
                    children[i] = V;    // Step 5 (implicit).
                };
                ASXMLList.prototype.childIndex = function () {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'childIndex');
                    }
                    return this._children[0].childIndex();
                };
                ASXMLList.prototype.inScopeNamespaces = function () {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'inScopeNamespaces');
                    }
                    return this._children[0].inScopeNamespaces();
                };
                ASXMLList.prototype.insertChildAfter = function (child1, child2) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'insertChildAfter');
                    }
                    return this._children[0].insertChildAfter(child1, child2);
                };
                ASXMLList.prototype.insertChildBefore = function (child1, child2) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'insertChildBefore');
                    }
                    return this._children[0].insertChildBefore(child1, child2);
                };
                ASXMLList.prototype.nodeKind = function () {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'nodeKind');
                    }
                    return this._children[0].nodeKind();
                };
                ASXMLList.prototype.namespace = function (prefix) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'namespace');
                    }
                    var firstChild = this._children[0];
                    return arguments.length ? firstChild.namespace(prefix) : firstChild.namespace();
                };
                ASXMLList.prototype.localName = function () {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'localName');
                    }
                    return this._children[0].localName();
                };
                ASXMLList.prototype.namespaceDeclarations = function () {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'namespaceDeclarations');
                    }
                    return this._children[0].namespaceDeclarations();
                };
                ASXMLList.prototype.prependChild = function (value) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'prependChild');
                    }
                    return this._children[0].prependChild(value);
                };
                ASXMLList.prototype.removeNamespace = function (ns) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'removeNamespace');
                    }
                    return this._children[0].removeNamespace(ns);
                };
                ASXMLList.prototype.replace = function (propertyName, value) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'replace');
                    }
                    return this._children[0].replace(propertyName, value);
                };
                ASXMLList.prototype.setChildren = function (value) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'setChildren');
                    }
                    return this._children[0].setChildren(value);
                };
                ASXMLList.prototype.setLocalName = function (name) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'setLocalName');
                    }
                    return this._children[0].setLocalName(name);
                };
                ASXMLList.prototype.setName = function (name) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'setName');
                    }
                    return this._children[0].setName(name);
                };
                ASXMLList.prototype.setNamespace = function (ns) {
                    if (this._children.length !== 1) {
                        this.sec.throwError('TypeError', AVMX.Errors.XMLOnlyWorksWithOneItemLists, 'setNamespace');
                    }
                    return this._children[0].setNamespace(ns);
                };
                ASXMLList.prototype.axGetEnumerableKeys = function () {
                    if (this === this.axClass.dPrototype) {
                        return _super.prototype.axGetEnumerableKeys.call(this);
                    }
                    return Object.keys(this._children);
                };
                // 9.2.1.1 [[Get]] (P)
                ASXMLList.prototype.getProperty = function (mn) {
                    var nm = mn.name;
                    if (Shumway.isIndex(nm)) {
                        return this._children[nm | 0];
                    }
                    var isAnyName = nm === null || nm === '*';
                    var isAnyNamespace = mn.isAnyNamespace();
                    var isAttribute = mn.isAttribute();
                    var xl = this.sec.AXXMLList.CreateList(this._targetObject, mn);
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        var v = children[i];
                        if (v._kind === 1    /* Element */) {
                            // i. Let gq be the result of calling the [[Get]] method of x[i] with argument P
                            // We do this inline instead to reduce the amount of temporarily created XMLLists.
                            if (isAttribute) {
                                var attributes = v._attributes;
                                for (var j = 0; attributes && j < attributes.length; j++) {
                                    var v = attributes[j];
                                    if ((isAnyName || v._name.name === nm) && (isAnyNamespace || v._name.matches(mn))) {
                                        xl._children.push(v);
                                    }
                                }
                            } else {
                                var descendants = v._children;
                                for (var j = 0; descendants && j < descendants.length; j++) {
                                    var v = descendants[j];
                                    if ((isAnyName || v._kind === 1    /* Element */ && v._name.name === nm) && (isAnyNamespace || v._name.matches(mn))) {
                                        xl._children.push(v);
                                    }
                                }
                            }
                        }
                    }
                    return xl;
                };
                ASXMLList.prototype.axGetProperty = function (mn) {
                    if (this === this.axClass.dPrototype) {
                        var value = this[this.axResolveMultiname(mn)];
                        release || AVMX.checkValue(value);
                        return value;
                    }
                    return this.getProperty(coerceE4XMultiname(mn, this.sec));
                };
                ASXMLList.prototype.axGetPublicProperty = function (nm) {
                    if (this === this.axClass.dPrototype) {
                        var value = this[AVMX.Multiname.getPublicMangledName(nm)];
                        release || AVMX.checkValue(value);
                        return value;
                    }
                    if (Shumway.isIndex(nm)) {
                        return this._children[nm | 0];
                    }
                    tmpMultiname.name = nm;
                    tmpMultiname.namespaces = [AVMX.Namespace.PUBLIC];
                    tmpMultiname.kind = 7    /* QName */;
                    return this.getProperty(tmpMultiname);
                };
                ASXMLList.prototype.hasProperty = function (mn) {
                    if (Shumway.isIndex(mn.name)) {
                        return Number(mn.name) < this._children.length;
                    }
                    // TODO scan children on property presence?
                    return true;
                };
                ASXMLList.prototype.axHasProperty = function (mn) {
                    return this.hasProperty(mn);
                };
                ASXMLList.prototype.axHasPropertyInternal = function (mn) {
                    return this.hasProperty(mn);
                };
                // 9.1.1.10 [[ResolveValue]] ( )
                ASXMLList.prototype.resolveValue = function () {
                    return this;
                };
                // 9.2.1.2 [[Put]] (P, V)
                ASXMLList.prototype.setProperty = function (mn, value) {
                    // Steps 1-2.
                    if (Shumway.isIndex(mn.name)) {
                        var i = mn.name | 0;
                        // Step 2.b.
                        var r = null;
                        // Step 2.a.
                        if (this._targetObject) {
                            r = this._targetObject.resolveValue();
                            if (r === null) {
                                return;
                            }
                        }
                        // Step 2.c.
                        var length = this._children.length;
                        if (i >= length) {
                            // Step 2.c.i.
                            if (r && r.axClass === this.sec.AXXMLList) {
                                // Step 2.c.i.1.
                                if (r._children.length !== 1) {
                                    return;
                                }
                                // Step 2.c.i.2.
                                r = r._children[0];
                            }
                            release || assert(r === null || r.axClass === this.sec.AXXML);
                            // Step 2.c.ii.
                            if (r && r._kind !== 1    /* Element */) {
                                return;
                            }
                            // Step 2.c.iii.
                            var y = this.sec.AXXML.Create();
                            y._parent = r;
                            var yName = this._targetProperty;
                            var yKind = 3    /* Text */;
                            // Step 2.c.iv.
                            if (this._targetProperty && this._targetProperty.isAttribute()) {
                                if (r.hasProperty(this._targetProperty)) {
                                    return;
                                }
                                yKind = 2    /* Attribute */;
                            } else if (!this._targetProperty || this._targetProperty.name === null) {
                                yName = null;
                                yKind = 3    /* Text */;
                            } else {
                                yKind = 1    /* Element */;
                            }
                            y.init(yKind, yName);
                            // Step 2.c.vii.
                            i = length;
                            // Step 2.c.viii.
                            if (y._kind !== 2    /* Attribute */) {
                                // Step 2.c.viii.1.
                                if (r !== null) {
                                    var j;
                                    // Step 2.c.viii.1.a.
                                    if (i > 0) {
                                        var lastChild = this._children[i - 1];
                                        var rLength = r._children.length - 1;
                                        for (j = 0; j < rLength; j++) {
                                            if (r._children[j] === lastChild) {
                                                release || assert(r._children[0]);
                                                break;
                                            }
                                        }
                                    } else {
                                        j = r._children.length - 1;
                                    }
                                    // Step 2.c.viii.1.c.
                                    r._children[j + 1] = y;
                                    assert(r._children[0]);
                                    y._parent = r;
                                }
                                // Step 2.c.viii.2.
                                if (value && value.axClass === this.sec.AXXML) {
                                    y._name = value._name;
                                } else if (value && value.axClass === this.sec.AXXMLList) {
                                    y._name = value._targetProperty;
                                }
                                // Step 2.c.ix.
                                this.append(y);
                            }
                        }
                        // Step 2.d.
                        if (!isXMLType(value, this.sec) || value._kind === 3    /* Text */ || value._kind === 2    /* Attribute */) {
                            value = value + '';
                        }
                        var currentChild = this._children[i];
                        var childKind = currentChild._kind;
                        var parent = currentChild._parent;
                        // Step 2.e.
                        if (childKind === 2    /* Attribute */) {
                            var indexInParent = parent._children.indexOf(currentChild);
                            parent.setProperty(currentChild._name, false);
                            this._children[i] = parent._children[indexInParent];
                            assert(this._children[0]);
                            return;
                        }
                        // Step 2.f.
                        if (value && value.axClass === this.sec.AXXMLList) {
                            // Step 2.f.i.
                            var c = value._shallowCopy();
                            var cLength = c._children.length;
                            // Step 2.f.ii. (implemented above.)
                            // Step 2.f.iii.
                            if (parent !== null) {
                                // Step 2.f.iii.1.
                                var q = parent._children.indexOf(currentChild);
                                // Step 2.f.iii.2.
                                parent._replaceByIndex(q, c);
                                // Step 2.f.iii.3.
                                for (var j = 0; j < cLength; j++) {
                                    c._children[j] = parent._children[q + j];
                                }
                            }
                            // Step 2.f.iv.
                            if (cLength === 0) {
                                for (var j = i + 1; j < length; j++) {
                                    this._children[j - 1] = this._children[j];
                                    assert(this._children[0]);
                                }
                                // Step 2.f.vii. (only required if we're shrinking the XMLList).
                                this._children.length--;
                            } else {
                                for (var j = length - 1; j > i; j--) {
                                    this._children[j + cLength - 1] = this._children[j];
                                    assert(this._children[0]);
                                }
                            }
                            // Step 2.f.vi.
                            for (var j = 0; j < cLength; j++) {
                                this._children[i + j] = c._children[j];
                                assert(this._children[0]);
                            }
                            return;
                        }
                        // Step 2.g.
                        if (childKind >= 3    /* Text */ || value && value.axClass === this.sec.AXXML) {
                            // Step 2.g.i. (implemented above.)
                            // Step 2.g.ii.
                            if (parent !== null) {
                                // Step 2.g.ii.1.
                                var q = parent._children.indexOf(currentChild);
                                // Step 2.g.ii.2.
                                parent._replaceByIndex(q, value);
                                // Step 2.g.ii.3.
                                value = parent._children[q];
                            }
                            // Step 2.g.iii.
                            if (typeof value === 'string') {
                                var t = this.sec.AXXML.Create(value);
                                this._children[i] = t;
                                assert(this._children[0]);
                            } else {
                                release || assert(this.sec.AXXML.axIsType(value));
                                this._children[i] = value;
                                assert(this._children[0]);
                            }
                            return;
                        }
                        // Step 2.h.
                        currentChild.setProperty(anyMultiname, value);
                        return;
                    }
                    // Step 3.
                    if (this._children.length === 0) {
                        // Step 3.a.i.
                        r = this.resolveValue();
                        // Step 3.a.ii.
                        if (r === null || r._children.length !== 1) {
                            return;
                        }
                        // Step 3.a.iii.
                        this.append(r._children[0]);
                    }
                    // Step 3.b.
                    if (this._children.length === 1) {
                        this._children[0].setProperty(mn, value);
                        // Step 4.
                        return;
                    }
                    // Not in the spec, but in Flash.
                    this.sec.throwError('TypeError', AVMX.Errors.XMLAssigmentOneItemLists);
                };
                ASXMLList.prototype.axSetProperty = function (mn, value, bc) {
                    if (this === this.axClass.dPrototype) {
                        release || AVMX.checkValue(value);
                        this[this.axResolveMultiname(mn)] = value;
                        return;
                    }
                    this.setProperty(coerceE4XMultiname(mn, this.sec), value);
                };
                // 9.2.1.3 [[Delete]] (P)
                ASXMLList.prototype.axDeleteProperty = function (mn) {
                    var name = mn.name;
                    // Steps 1-2.
                    if (Shumway.isIndex(name)) {
                        var i = name | 0;
                        // Step 2.a.
                        if (i >= this._children.length) {
                            return true;
                        }
                        // Step 2.b.
                        this.removeByIndex(i);
                        return true;
                    }
                    // Step 3.
                    for (var i = 0; i < this._children.length; i++) {
                        var child = this._children[i];
                        if (child._kind === 1    /* Element */) {
                            child.deleteProperty(mn);
                        }
                    }
                    // Step 4.
                    return true;
                };
                ASXMLList.prototype.removeByIndex = function (index) {
                    var child = this._children[index];
                    var parent = child._parent;
                    if (parent) {
                        child._parent = null;
                        parent._children.splice(parent._children.indexOf(child), 1);
                    }
                    this._children.splice(index, 1);
                };
                ASXMLList.prototype.axCallProperty = function (mn, args) {
                    var method = this[this.axResolveMultiname(mn)];
                    // Check if the method exists before calling it.
                    if (method) {
                        AVMX.validateCall(this.sec, method, args.length);
                        return method.axApply(this, args);
                    }
                    // Otherwise, 11.2.2.1 CallMethod ( r , args )
                    // If f == undefined and Type(base) is XMLList and base.[[Length]] == 1
                    //   ii. Return the result of calling CallMethod(r0, args) recursively
                    if (this._children.length === 1) {
                        return this._children[0].axCallProperty(mn, args);
                    }
                    this.sec.throwError('TypeError', AVMX.Errors.CallOfNonFunctionError, 'value');
                };
                ASXMLList.instanceConstructor = ASXMLList;
                return ASXMLList;
            }(AS.ASObject);
            AS.ASXMLList = ASXMLList;
            var flash;
            (function (flash) {
                var xml;
                (function (xml) {
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var XMLSpecialChars;
                    (function (XMLSpecialChars) {
                        XMLSpecialChars[XMLSpecialChars['APOS'] = 39] = 'APOS';
                        XMLSpecialChars[XMLSpecialChars['AMP'] = 38] = 'AMP';
                        XMLSpecialChars[XMLSpecialChars['QUOT'] = 34] = 'QUOT';
                        XMLSpecialChars[XMLSpecialChars['LT'] = 60] = 'LT';
                        XMLSpecialChars[XMLSpecialChars['GT'] = 62] = 'GT';
                    }(XMLSpecialChars || (XMLSpecialChars = {})));
                    var XMLNode = function (_super) {
                        __extends(XMLNode, _super);
                        function XMLNode(type, value) {
                            type = type >>> 0;
                            value = axCoerceString(value);
                            _super.call(this);
                        }
                        // Static   JS -> AS Bindings
                        // Static   AS -> JS Bindings
                        XMLNode.escapeXML = function (value) {
                            value = axCoerceString(value);
                            var i = 0, length = value.length, ch;
                            while (i < length) {
                                ch = value.charCodeAt(i);
                                if (ch === XMLSpecialChars.APOS || ch === XMLSpecialChars.AMP || ch === XMLSpecialChars.QUOT || ch === XMLSpecialChars.LT || ch === XMLSpecialChars.GT) {
                                    break;
                                }
                                i++;
                            }
                            if (i >= length) {
                                return value;
                            }
                            var parts = [value.substring(0, i)];
                            while (i < length) {
                                switch (ch) {
                                case XMLSpecialChars.APOS:
                                    parts.push('&apos;');
                                    break;
                                case XMLSpecialChars.AMP:
                                    parts.push('&amp;');
                                    break;
                                case XMLSpecialChars.QUOT:
                                    parts.push('&quot;');
                                    break;
                                case XMLSpecialChars.LT:
                                    parts.push('&lt;');
                                    break;
                                case XMLSpecialChars.GT:
                                    parts.push('&gt;');
                                    break;
                                }
                                ++i;
                                var j = i;
                                while (i < length) {
                                    ch = value.charCodeAt(i);
                                    if (ch === XMLSpecialChars.APOS || ch === XMLSpecialChars.AMP || ch === XMLSpecialChars.QUOT || ch === XMLSpecialChars.LT || ch === XMLSpecialChars.GT) {
                                        break;
                                    }
                                    i++;
                                }
                                if (j < i) {
                                    parts.push(value.substring(j, i));
                                }
                            }
                            return parts.join('');
                        };
                        return XMLNode;
                    }(AS.ASObject);
                    xml.XMLNode = XMLNode;
                    var XMLDocument = function (_super) {
                        __extends(XMLDocument, _super);
                        function XMLDocument(text) {
                            if (text === void 0) {
                                text = null;
                            }
                            text = axCoerceString(text);
                            _super.call(this, 1, '');
                        }
                        return XMLDocument;
                    }(flash.xml.XMLNode);
                    xml.XMLDocument = XMLDocument;
                    var XMLTag = function (_super) {
                        __extends(XMLTag, _super);
                        function XMLTag() {
                            _super.call(this);
                            this._type = 0;
                            this._value = null;
                            this._empty = false;
                            this._attrs = null;
                        }
                        Object.defineProperty(XMLTag.prototype, 'type', {
                            // Static   JS -> AS Bindings
                            // Static   AS -> JS Bindings
                            // Instance JS -> AS Bindings
                            // Instance AS -> JS Bindings
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                value = value >>> 0;
                                this._type = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(XMLTag.prototype, 'empty', {
                            get: function () {
                                return this._empty;
                            },
                            set: function (value) {
                                value = !!value;
                                this._empty = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(XMLTag.prototype, 'value', {
                            get: function () {
                                return this._value;
                            },
                            set: function (v) {
                                v = axCoerceString(v);
                                this._value = v;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(XMLTag.prototype, 'attrs', {
                            get: function () {
                                return this._attrs;
                            },
                            set: function (value) {
                                this._attrs = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        return XMLTag;
                    }(AS.ASObject);
                    xml.XMLTag = XMLTag;
                    var XMLNodeType = function (_super) {
                        __extends(XMLNodeType, _super);
                        function XMLNodeType() {
                            _super.call(this);
                        }
                        return XMLNodeType;
                    }(AS.ASObject);
                    xml.XMLNodeType = XMLNodeType;
                    function isWhitespace(s) {
                        for (var i = 0; i < s.length; i++) {
                            var ch = s[i];
                            if (!(ch === ' ' || ch === '\n' || ch === '\r' || ch === '\t')) {
                                return false;
                            }
                        }
                        return true;
                    }
                    var XMLParserForXMLDocument = function (_super) {
                        __extends(XMLParserForXMLDocument, _super);
                        function XMLParserForXMLDocument(sec) {
                            _super.call(this);
                            this.sec = sec;
                            this.queue = [];
                            this.ignoreWhitespace = false;
                        }
                        XMLParserForXMLDocument.prototype.onError = function (code) {
                            this.queue.push(code);
                        };
                        XMLParserForXMLDocument.prototype.onPi = function (name, value) {
                            Shumway.Debug.warning('Unhandled XMLParserForXMLDocument.onPi');
                        };
                        XMLParserForXMLDocument.prototype.onComment = function (text) {
                            Shumway.Debug.warning('Unhandled XMLParserForXMLDocument.onComment');
                        };
                        XMLParserForXMLDocument.prototype.onCdata = function (text) {
                            this.queue.push({
                                type: 4,
                                value: text
                            });
                        };
                        XMLParserForXMLDocument.prototype.onDoctype = function (doctypeContent) {
                            Shumway.Debug.warning('Unhandled XMLParserForXMLDocument.onDoctype');
                        };
                        XMLParserForXMLDocument.prototype.onBeginElement = function (name, attributes, isEmpty) {
                            var attrObj = this.sec.createObject();
                            attributes.forEach(function (a) {
                                attrObj.axSetPublicProperty(a.name, a.value);
                            });
                            this.queue.push({
                                type: 1,
                                value: name,
                                empty: isEmpty,
                                attrs: attrObj
                            });
                        };
                        XMLParserForXMLDocument.prototype.onEndElement = function (name) {
                            this.queue.push({
                                type: 1,
                                value: '/' + name
                            });
                        };
                        XMLParserForXMLDocument.prototype.onText = function (text) {
                            if (this.ignoreWhitespace && isWhitespace(text)) {
                                return;
                            }
                            this.queue.push({
                                type: 3,
                                value: text
                            });
                        };
                        return XMLParserForXMLDocument;
                    }(AS.XMLParserBase);
                    var XMLParser = function (_super) {
                        __extends(XMLParser, _super);
                        function XMLParser() {
                            _super.call(this);
                        }
                        XMLParser.prototype.startParse = function (source, ignoreWhite) {
                            source = axCoerceString(source);
                            ignoreWhite = !!ignoreWhite;
                            var parser = new XMLParserForXMLDocument(this.sec);
                            parser.ignoreWhitespace = ignoreWhite;
                            parser.parseXml(source);
                            this.queue = parser.queue;
                        };
                        XMLParser.prototype.getNext = function (tag) {
                            if (this.queue.length === 0) {
                                return -1    /* EndOfDocument */;
                            }
                            var nextItem = this.queue.shift();
                            if (typeof nextItem === 'number') {
                                return nextItem;
                            }
                            var parseResult = nextItem;
                            tag.type = parseResult.type;
                            tag.value = parseResult.value;
                            tag.empty = parseResult.empty || false;
                            tag.attrs = parseResult.attrs || null;
                            return 0    /* NoError */;
                        };
                        return XMLParser;
                    }(AS.ASObject);
                    xml.XMLParser = XMLParser;
                }(xml = flash.xml || (flash.xml = {})));
            }(flash = AS.flash || (AS.flash = {})));
            var assert = Shumway.Debug.assert;
            function createNullOrUndefinedDescription(sec, o) {
                return {
                    __proto__: sec.objectPrototype,
                    $Bgname: o === undefined ? 'void' : 'null',
                    $BgisDynamic: false,
                    $BgisFinal: true,
                    $BgisStatic: false,
                    $Bgtraits: {
                        __proto__: sec.objectPrototype,
                        $Bgvariables: null,
                        $Bgaccessors: null,
                        $Bgmetadata: sec.createArray([]),
                        $Bgconstructor: null,
                        $Bginterfaces: sec.createArray([]),
                        $Bgmethods: null,
                        $Bgbases: sec.createArray([])
                    }
                };
            }
            function describeTypeJSON(sec, o, flags) {
                // Class traits aren't returned for numeric primitives, undefined, null, bound methods, or
                // non-class-constructor functions.
                var isInt = (o | 0) === o;
                var nullOrUndefined = Shumway.isNullOrUndefined(o);
                if (flags & 512    /* USE_ITRAITS */ && (nullOrUndefined || isInt)) {
                    return null;
                }
                if (nullOrUndefined) {
                    return createNullOrUndefinedDescription(sec, o);
                }
                // Use the object's own sec if we're not dealing with a primitive to make sure
                // type checks are correct.
                if (o.sec) {
                    sec = o.sec;
                }
                o = sec.box(o);
                if (sec.AXFunction.axIsType(o)) {
                    if (sec.AXMethodClosure.axIsType(o)) {
                        if (flags & 512    /* USE_ITRAITS */) {
                            return null;
                        }
                    } else if ('receiver' in o) {
                        return null;
                    }
                }
                var cls = o.hasOwnProperty('classInfo') ? o : o.axClass;
                release || assert(cls, 'No class found for object ' + o);
                var describeClass = cls === o && !(flags & 512    /* USE_ITRAITS */);
                var info = cls.classInfo;
                var description = sec.createObject();
                // For numeric literals that fit into ints, special case the name.
                if (isInt) {
                    description.$Bgname = 'int';
                } else {
                    description.$Bgname = info.instanceInfo.getName().toFQNString(true);
                }
                // More special casing for bound methods. See bug 1057750.
                description.$BgisDynamic = describeClass || !(info.instanceInfo.flags & 1    /* ClassSealed */);
                description.$BgisFinal = describeClass || !!(info.instanceInfo.flags & 2    /* ClassFinal */);
                //TODO: verify that `isStatic` is false for all instances, true for classes
                description.$BgisStatic = describeClass;
                if (flags & 256    /* INCLUDE_TRAITS */) {
                    description.$Bgtraits = addTraits(cls, info, describeClass, flags);
                }
                return description;
            }
            AS.describeTypeJSON = describeTypeJSON;
            var tmpName = new AVMX.Multiname(null, 0, 7    /* QName */, [AVMX.Namespace.PUBLIC], null);
            var tmpAttr = new AVMX.Multiname(null, 0, 13    /* QNameA */, [AVMX.Namespace.PUBLIC], null);
            function describeType(sec, value, flags) {
                // Ensure that the XML classes have been initialized:
                tmpName.name = 'XML';
                var xmlClass = sec.application.getClass(tmpName);
                var classDescription = describeTypeJSON(sec, value, flags);
                var x = xmlClass.Create('<type/>');
                tmpAttr.name = 'name';
                x.setProperty(tmpAttr, classDescription.$Bgname);
                var bases = classDescription.$Bgtraits.$Bgbases.value;
                if (bases.length) {
                    tmpAttr.name = 'base';
                    x.setProperty(tmpAttr, bases[0]);
                }
                tmpAttr.name = 'isDynamic';
                x.setProperty(tmpAttr, classDescription.$BgisDynamic.toString());
                tmpAttr.name = 'isFinal';
                x.setProperty(tmpAttr, classDescription.$BgisFinal.toString());
                tmpAttr.name = 'isStatic';
                x.setProperty(tmpAttr, classDescription.$BgisStatic.toString());
                describeTraits(x, classDescription.$Bgtraits);
                var instanceDescription = describeTypeJSON(sec, value, flags | 512    /* USE_ITRAITS */);
                if (instanceDescription) {
                    var e = xmlClass.Create('<factory/>');
                    tmpAttr.name = 'type';
                    e.setProperty(tmpAttr, instanceDescription.$Bgname);
                    if (describeTraits(e, instanceDescription.$Bgtraits)) {
                        x.appendChild(e);
                    }
                }
                return x;
            }
            AS.describeType = describeType;
            function describeTraits(x, traits) {
                var traitsCount = 0;
                var bases = traits.$Bgbases && traits.$Bgbases.value;
                for (var i = 0; bases && i < bases.length; i++) {
                    var base = bases[i];
                    var e = x.sec.AXXML.Create('<extendsClass type="' + AS.escapeAttributeValue(base) + '"/>');
                    x.appendChild(e);
                    traitsCount++;
                }
                var interfaces = traits.$Bginterfaces && traits.$Bginterfaces.value;
                for (var i = 0; interfaces && i < interfaces.length; i++) {
                    var e = x.sec.AXXML.Create('<implementsInterface type="' + AS.escapeAttributeValue(interfaces[i]) + '"/>');
                    x.appendChild(e);
                    traitsCount++;
                }
                if (traits.$Bgconstructor !== null) {
                    var e = x.sec.AXXML.Create('<constructor/>');
                    describeParams(e, traits.$Bgconstructor);
                    x.appendChild(e);
                    traitsCount++;
                }
                var variables = traits.$Bgvariables && traits.$Bgvariables.value;
                for (var i = 0; variables && i < variables.length; i++) {
                    var variable = variables[i];
                    var nodeName = variable.$Bgaccess === 'readonly' ? 'constant' : 'variable';
                    var e = x.sec.AXXML.Create('<' + nodeName + ' name="' + AS.escapeAttributeValue(variable.$Bgname) + '" type="' + variable.$Bgtype + '"/>');
                    finishTraitDescription(variable, e, x);
                    traitsCount++;
                }
                var accessors = traits.$Bgaccessors && traits.$Bgaccessors.value;
                for (var i = 0; accessors && i < accessors.length; i++) {
                    var accessor = accessors[i];
                    var e = x.sec.AXXML.Create('<accessor ' + 'name="' + AS.escapeAttributeValue(accessor.$Bgname) + '" access="' + accessor.$Bgaccess + '" type="' + AS.escapeAttributeValue(accessor.$Bgtype) + '" declaredBy="' + AS.escapeAttributeValue(accessor.$BgdeclaredBy) + '"/>');
                    finishTraitDescription(accessor, e, x);
                    traitsCount++;
                }
                var methods = traits.$Bgmethods && traits.$Bgmethods.value;
                for (var i = 0; methods && i < methods.length; i++) {
                    var method = methods[i];
                    var e = x.sec.AXXML.Create('<method ' + 'name="' + AS.escapeAttributeValue(method.$Bgname) + '" declaredBy="' + AS.escapeAttributeValue(method.$BgdeclaredBy) + '" returnType="' + AS.escapeAttributeValue(method.$BgreturnType) + '"/>');
                    describeParams(e, method.$Bgparameters.value);
                    finishTraitDescription(method, e, x);
                    traitsCount++;
                }
                describeMetadataXML(x, traits.$Bgmetadata);
                return traitsCount > 0;
            }
            function finishTraitDescription(trait, traitXML, traitsListXML) {
                if (trait.$Bguri !== null) {
                    tmpAttr.name = 'uri';
                    traitXML.setProperty(tmpAttr, trait.$Bguri);
                }
                if (trait.$Bgmetadata !== null) {
                    describeMetadataXML(traitXML, trait.$Bgmetadata);
                }
                traitsListXML.appendChild(traitXML);
            }
            function describeParams(x, parameters) {
                if (!parameters) {
                    return;
                }
                for (var i = 0; i < parameters.length; i++) {
                    var p = parameters[i];
                    var f = x.sec.AXXML.Create('<parameter index="' + (i + 1) + '" type="' + AS.escapeAttributeValue(p.$Bgtype) + '" optional="' + p.$Bgoptional + '"/>');
                    x.appendChild(f);
                }
            }
            function describeMetadataXML(x, metadata_) {
                if (!metadata_) {
                    return;
                }
                var metadata = metadata_.value;
                for (var i = 0; i < metadata.length; i++) {
                    var md = metadata[i];
                    var m = x.sec.AXXML.Create('<metadata name="' + AS.escapeAttributeValue(md.$Bgname) + '"/>');
                    var values = md.$Bgvalue.value;
                    for (var j = 0; j < values.length; j++) {
                        var value = values[j];
                        var a = x.sec.AXXML.Create('<arg key="' + AS.escapeAttributeValue(value.$Bgkey) + '" value="' + AS.escapeAttributeValue(value.$Bgvalue) + '"/>');
                        m.appendChild(a);
                    }
                    x.appendChild(m);
                }
            }
            function describeMetadataList(sec, list) {
                if (!list) {
                    return null;
                }
                var result = sec.createArray([]);
                for (var i = 0; i < list.length; i++) {
                    var metadata = list[i];
                    var key = metadata.getName();
                    // Filter out the [native] metadata nodes. These are implementation details Flash doesn't
                    // expose, so we don't, either.
                    if (key === 'native') {
                        continue;
                    }
                    result.push(describeMetadata(sec, metadata));
                }
                return result;
            }
            function describeMetadata(sec, metadata) {
                var result = sec.createObject();
                result.$Bgname = metadata.name;
                var values = [];
                result.$Bgvalue = sec.createArray(values);
                for (var i = 0; i < metadata.keys.length; i++) {
                    var val = sec.createObject();
                    val.$Bgvalue = metadata.getValueAt(i);
                    val.$Bgkey = metadata.getKeyAt(i);
                    values.push(val);
                }
                return result;
            }
            function addTraits(cls, info, describingClass, flags) {
                var sec = cls.sec;
                var includeBases = flags & 2    /* INCLUDE_BASES */;
                var includeMethods = flags & 32    /* INCLUDE_METHODS */ && !describingClass;
                var obj = sec.createObject();
                var variablesVal = obj.$Bgvariables = flags & 8    /* INCLUDE_VARIABLES */ ? sec.createArray([]) : null;
                var accessorsVal = obj.$Bgaccessors = flags & 16    /* INCLUDE_ACCESSORS */ ? sec.createArray([]) : null;
                var metadataList = null;
                // Somewhat absurdly, class metadata is only included when describing instances.
                if (flags & 64    /* INCLUDE_METADATA */ && !describingClass) {
                    var metadata = info.trait.getMetadata();
                    if (metadata) {
                        metadataList = describeMetadataList(sec, metadata);
                    }
                }
                // This particular metadata list is always created, even if no metadata exists.
                obj.$Bgmetadata = metadataList || sec.createArray([]);
                // TODO: fill in.
                obj.$Bgconstructor = null;
                if (flags & 4    /* INCLUDE_INTERFACES */) {
                    obj.$Bginterfaces = sec.createArray([]);
                    if (!describingClass) {
                        var interfacesVal = obj.$Bginterfaces.value;
                        var interfaces = cls.classInfo.instanceInfo.getInterfaces(cls);
                        interfaces.forEach(function (iface) {
                            return interfacesVal.push(iface.name.toFQNString(true));
                        });
                    }
                } else {
                    obj.$Bginterfaces = null;
                }
                var methodsVal = obj.$Bgmethods = includeMethods ? sec.createArray([]) : null;
                var basesVal = obj.$Bgbases = includeBases ? sec.createArray([]) : null;
                var encounteredKeys = Object.create(null);
                // Needed for accessor-merging.
                var encounteredGetters = Object.create(null);
                var encounteredSetters = Object.create(null);
                var addBase = false;
                var isInterface = info.instanceInfo.isInterface();
                while (cls) {
                    var className = cls.classInfo.instanceInfo.getName().toFQNString(true);
                    if (includeBases && addBase && !describingClass) {
                        basesVal.push(className);
                    } else {
                        addBase = true;
                    }
                    if (flags & 1024    /* HIDE_OBJECT */ && cls === sec.AXObject) {
                        break;
                    }
                    if (!describingClass) {
                        describeTraits(sec, cls.classInfo.instanceInfo.traits.traits, isInterface);
                    } else {
                        describeTraits(sec, cls.classInfo.traits.traits, isInterface);
                    }
                    cls = cls.superClass;
                }
                release || assert(cls === sec.AXObject || isInterface);
                // When describing Class objects, the bases to add are always Class and Object.
                if (describingClass) {
                    // When describing Class objects, accessors are ignored. *Except* the `prototype` accessor.
                    if (flags & 16    /* INCLUDE_ACCESSORS */) {
                        var val = sec.createObject();
                        val.$Bgname = 'prototype';
                        val.$Bgtype = '*';
                        val.$Bgaccess = 'readonly';
                        val.$Bgmetadata = null;
                        val.$Bguri = null;
                        val.$BgdeclaredBy = 'Class';
                        accessorsVal.push(val);
                    }
                    if (includeBases) {
                        basesVal.pop();
                        basesVal.push('Class', 'Object');
                        cls = sec.AXClass;
                    }
                }
                // Having a hot function closed over isn't all that great, but moving this out would involve
                // passing lots and lots of arguments. We might do that if performance becomes an issue.
                function describeTraits(sec, traits, isInterface) {
                    release || assert(traits, 'No traits array found on class' + cls.name);
                    // All types share some fields, but setting them in one place changes the order in which
                    // they're defined - and hence show up in iteration. While it is somewhat unlikely that
                    // real content relies on that order, tests certainly do, so we duplicate the code.
                    for (var i = 0; i < traits.length; i++) {
                        var t = traits[i];
                        var mn = t.getName();
                        var ns = mn.namespace;
                        // Hide all non-public members whose namespace doesn't have a URI specified.
                        // Or, if HIDE_NSURI_METHODS is set, hide those, too, because bugs in Flash.
                        // For interfaces, include all traits. We should've made sure to only have
                        // public methods in them during bytecode parsing/verification.
                        if (!isInterface && (!ns.isPublic() && !ns.uri || flags & 1    /* HIDE_NSURI_METHODS */ && ns.uri)) {
                            continue;
                        }
                        // Strip the namespace off of interface methods. They're always treated as public.
                        var name = isInterface ? mn.name : mn.toFQNString(true);
                        if (encounteredGetters[name] !== encounteredSetters[name]) {
                            var val = encounteredKeys[name];
                            val.$Bgaccess = 'readwrite';
                            if (t.kind === 2    /* Getter */) {
                                var type = t.getMethodInfo().getType();
                                val.$Bgtype = type ? type.name.toFQNString(true) : '*';
                            }
                            continue;
                        }
                        if (encounteredKeys[name]) {
                            continue;
                        }
                        //TODO: check why we have public$$_init in `Object`
                        var val = sec.createObject();
                        encounteredKeys[name] = val;
                        var metadata = t.getMetadata();
                        switch (t.kind) {
                        case 6    /* Const */:
                        case 0    /* Slot */:
                            if (!(flags & 8    /* INCLUDE_VARIABLES */)) {
                                continue;
                            }
                            val.$Bgname = name;
                            val.$Bguri = ns.reflectedURI;
                            var typeName = t.getTypeName();
                            val.$Bgtype = typeName ? typeName.toFQNString(true) : '*';
                            val.$Bgaccess = 'readwrite';
                            val.$Bgmetadata = flags & 64    /* INCLUDE_METADATA */ ? describeMetadataList(sec, metadata) : null;
                            variablesVal.push(val);
                            break;
                        case 1    /* Method */:
                            if (!includeMethods) {
                                continue;
                            }
                            var returnType = t.getMethodInfo().getType();
                            val.$BgreturnType = returnType ? returnType.name.toFQNString(true) : '*';
                            val.$Bgmetadata = flags & 64    /* INCLUDE_METADATA */ ? describeMetadataList(sec, metadata) : null;
                            val.$Bgname = name;
                            val.$Bguri = ns.reflectedURI;
                            var parametersVal = val.$Bgparameters = sec.createArray([]);
                            var parameters = t.getMethodInfo().parameters;
                            for (var j = 0; j < parameters.length; j++) {
                                var param = parameters[j];
                                var paramVal = sec.createObject();
                                paramVal.$Bgtype = param.type ? param.getType().toFQNString(true) : '*';
                                paramVal.$Bgoptional = 'value' in param;
                                parametersVal.push(paramVal);
                            }
                            val.$BgdeclaredBy = className;
                            methodsVal.push(val);
                            break;
                        case 2    /* Getter */:
                        case 3    /* Setter */:
                            if (!(flags & 16    /* INCLUDE_ACCESSORS */) || describingClass) {
                                continue;
                            }
                            val.$Bgname = name;
                            if (t.kind === 2    /* Getter */) {
                                var returnType = t.getMethodInfo().getType();
                                val.$Bgtype = returnType ? returnType.name.toFQNString(true) : '*';
                                encounteredGetters[name] = val;
                            } else {
                                var paramType = t.getMethodInfo().parameters[0].getType();
                                val.$Bgtype = paramType ? paramType.toFQNString(true) : '*';
                                encounteredSetters[name] = val;
                            }
                            val.$Bgaccess = t.kind === 2    /* Getter */ ? 'readonly' : 'writeonly';
                            val.$Bgmetadata = flags & 64    /* INCLUDE_METADATA */ ? describeMetadataList(sec, metadata) : null;
                            val.$Bguri = ns.reflectedURI;
                            val.$BgdeclaredBy = className;
                            accessorsVal.push(val);
                            break;
                        default:
                            release || assert(false, 'Unknown trait type: ' + t.kind);
                            break;
                        }
                    }
                }
                // `methods` and `variables` are the only list that are `null`-ed if empty.
                if (!methodsVal || methodsVal.value.length === 0) {
                    obj.$Bgmethods = null;
                }
                if (!variablesVal || variablesVal.value.length === 0) {
                    obj.$Bgvariables = null;
                }
                return obj;
            }
            var assert = Shumway.Debug.assert;
            var flash;
            (function (flash) {
                var utils;
                (function (utils) {
                    /**
                     * TODO: We need a more robust Dictionary implementation that doesn't only give you back
                     * string keys when enumerating.
                     */
                    var Dictionary = function (_super) {
                        __extends(Dictionary, _super);
                        function Dictionary(weakKeys) {
                            if (weakKeys === void 0) {
                                weakKeys = false;
                            }
                            _super.call(this);
                            this.map = new WeakMap();
                            this.keys = null;
                            this.weakKeys = !!weakKeys;
                            if (!weakKeys) {
                                this.keys = [];
                            }
                            this.primitiveMap = Object.create(null);
                        }
                        Dictionary.makePrimitiveKey = function (key) {
                            if (typeof key === 'string' || typeof key === 'number') {
                                return key;
                            }
                            release || assert(typeof key === 'object' || typeof key === 'function', typeof key);
                            return undefined;
                        };
                        Dictionary.prototype.toJSON = function () {
                            return 'Dictionary';
                        };
                        Dictionary.prototype.axGetProperty = function (mn) {
                            if (this === this.axClass.dPrototype) {
                                return _super.prototype.axGetProperty.call(this, mn);
                            }
                            var key = Dictionary.makePrimitiveKey(mn.name);
                            if (key !== undefined) {
                                return this.primitiveMap[key];
                            }
                            return this.map.get(Object(mn.name));
                        };
                        Dictionary.prototype.axSetProperty = function (mn, value, bc) {
                            if (this === this.axClass.dPrototype) {
                                _super.prototype.axSetProperty.call(this, mn, value, bc);
                                return;
                            }
                            var key = Dictionary.makePrimitiveKey(mn.name);
                            if (key !== undefined) {
                                this.primitiveMap[key] = value;
                                return;
                            }
                            this.map.set(Object(mn.name), value);
                            if (!this.weakKeys && this.keys.indexOf(mn.name) < 0) {
                                this.keys.push(mn.name);
                            }
                        };
                        // TODO: Not implemented yet.
                        // public axCallProperty(mn: Multiname, args: any []) {
                        //   release || release || notImplemented("axCallProperty");
                        // }
                        Dictionary.prototype.axHasPropertyInternal = function (mn) {
                            if (this === this.axClass.dPrototype) {
                                return _super.prototype.axHasProperty.call(this, mn);
                            }
                            var key = Dictionary.makePrimitiveKey(mn.name);
                            if (key !== undefined) {
                                return key in this.primitiveMap;
                            }
                            return this.map.has(Object(mn.name));
                        };
                        Dictionary.prototype.axDeleteProperty = function (mn) {
                            if (this === this.axClass.dPrototype) {
                                return _super.prototype.axDeleteProperty.call(this, mn);
                            }
                            var key = Dictionary.makePrimitiveKey(mn.name);
                            if (key !== undefined) {
                                delete this.primitiveMap[key];
                            }
                            this.map.delete(Object(mn.name));
                            var i;
                            if (!this.weakKeys && (i = this.keys.indexOf(mn.name)) >= 0) {
                                this.keys.splice(i, 1);
                            }
                            return true;
                        };
                        Dictionary.prototype.axGetPublicProperty = function (nm) {
                            if (this === this.axClass.dPrototype) {
                                return _super.prototype.axGetPublicProperty.call(this, nm);
                            }
                            var key = Dictionary.makePrimitiveKey(nm);
                            if (key !== undefined) {
                                return this.primitiveMap[key];
                            }
                            return this.map.get(Object(nm));
                        };
                        Dictionary.prototype.axGetEnumerableKeys = function () {
                            if (this === this.axClass.dPrototype) {
                                return _super.prototype.axGetEnumerableKeys.call(this);
                            }
                            var primitiveMapKeys = [];
                            for (var k in this.primitiveMap) {
                                primitiveMapKeys.push(k);
                            }
                            if (this.weakKeys) {
                                // TODO implement workaround for flashx.textLayout.external.WeakRef
                                return primitiveMapKeys;    // assuming all weak ref objects are gone
                            }
                            if (this.keys) {
                                return primitiveMapKeys.concat(this.keys);
                            }
                            return primitiveMapKeys.slice();
                        };
                        Dictionary.classInitializer = function () {
                            var proto = this.dPrototype;
                            var asProto = Dictionary.prototype;
                            AS.addPrototypeFunctionAlias(proto, '$BgtoJSON', asProto.toJSON);
                        };
                        return Dictionary;
                    }(AS.ASObject);
                    utils.Dictionary = Dictionary;
                }(utils = flash.utils || (flash.utils = {})));
            }(flash = AS.flash || (AS.flash = {})));
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var flash;
            (function (flash) {
                var utils;
                (function (utils) {
                    var proxyNamespace = AVMX.internNamespace(0    /* Public */, 'http://www.adobe.com/2006/actionscript/flash/proxy');
                    var proxyPrefix = '$' + proxyNamespace.mangledName;
                    /**
                     * The Proxy class lets you override the default behavior of ActionScript operations
                     * (such as retrieving and modifying properties) on an object.
                     */
                    var ASProxy = function (_super) {
                        __extends(ASProxy, _super);
                        function ASProxy() {
                            _super.apply(this, arguments);
                        }
                        ASProxy.classInitializer = function () {
                            var proto = this.dPrototype;
                            var asProto = ASProxy.prototype;
                            defineNonEnumerableProperty(proto, proxyPrefix + 'getProperty', asProto.native_getProperty);
                            defineNonEnumerableProperty(proto, proxyPrefix + 'setProperty', asProto.native_setProperty);
                            defineNonEnumerableProperty(proto, proxyPrefix + 'callProperty', asProto.native_callProperty);
                            defineNonEnumerableProperty(proto, proxyPrefix + 'hasProperty', asProto.native_hasProperty);
                            defineNonEnumerableProperty(proto, proxyPrefix + 'deleteProperty', asProto.native_deleteProperty);
                            defineNonEnumerableProperty(proto, proxyPrefix + 'getDescendants', asProto.native_getDescendants);
                            defineNonEnumerableProperty(proto, proxyPrefix + 'nextNameIndex', asProto.native_nextNameIndex);
                            defineNonEnumerableProperty(proto, proxyPrefix + 'nextName', asProto.native_nextName);
                            defineNonEnumerableProperty(proto, proxyPrefix + 'nextValue', asProto.native_nextValue);
                        };
                        ASProxy.prototype.native_getProperty = function () {
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxyGetPropertyError);
                        };
                        ASProxy.prototype.native_setProperty = function () {
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxySetPropertyError);
                        };
                        ASProxy.prototype.native_callProperty = function () {
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxyCallPropertyError);
                        };
                        ASProxy.prototype.native_hasProperty = function () {
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxyHasPropertyError);
                        };
                        ASProxy.prototype.native_deleteProperty = function () {
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxyDeletePropertyError);
                        };
                        ASProxy.prototype.native_getDescendants = function () {
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxyGetDescendantsError);
                        };
                        ASProxy.prototype.native_nextNameIndex = function () {
                            // Enumeration traverses the prototype chain. For proxies, this causes problems
                            // because a Proxy-extending class has the MOP override for `axNextNameIndex`, but can't
                            // have the `nextNameIndex` hook defined and thus hits this default hook. In that case,
                            // we'd incorrectly throw an error instead of just returning null if we didn't
                            // special-case here.
                            if (this === this.axClass.dPrototype) {
                                return;
                            }
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxyNextNameIndexError);
                        };
                        ASProxy.prototype.native_nextName = function () {
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxyNextNameError);
                        };
                        ASProxy.prototype.native_nextValue = function () {
                            this.sec.throwError('flash.errors.IllegalOperationError', AVMX.Errors.ProxyNextValueError);
                        };
                        ASProxy.prototype.axGetProperty = function (mn) {
                            var value;
                            var trait = typeof mn.name === 'string' ? this.traits.getTrait(mn.namespaces, mn.name) : null;
                            if (trait) {
                                var name = trait.name.getMangledName();
                                value = this[name];
                                if (typeof value === 'function') {
                                    return this.axGetMethod(name);
                                }
                            } else {
                                value = this[proxyPrefix + 'getProperty'](this.sec.AXQName.FromMultiname(mn));
                            }
                            return value;
                        };
                        ASProxy.prototype.axGetNumericProperty = function (name) {
                            return this[proxyPrefix + 'getProperty'](+name + '');
                        };
                        ASProxy.prototype.axSetNumericProperty = function (name, value) {
                            this[proxyPrefix + 'setProperty'](+name + '', value);
                        };
                        ASProxy.prototype.axSetProperty = function (mn, value, bc) {
                            var trait = typeof mn.name === 'string' ? this.traits.getTrait(mn.namespaces, mn.name) : null;
                            if (trait) {
                                _super.prototype.axSetProperty.call(this, mn, value, bc);
                                return;
                            }
                            this[proxyPrefix + 'setProperty'](this.sec.AXQName.FromMultiname(mn), value);
                        };
                        ASProxy.prototype.axCallProperty = function (mn, args, isLex) {
                            var trait = typeof mn.name === 'string' ? this.traits.getTrait(mn.namespaces, mn.name) : null;
                            if (trait) {
                                return _super.prototype.axCallProperty.call(this, mn, args, isLex);
                            }
                            var callArgs = [this.sec.AXQName.FromMultiname(mn)].concat(args);
                            return this[proxyPrefix + 'callProperty'].apply(this, callArgs);
                        };
                        ASProxy.prototype.axHasProperty = function (mn) {
                            return this.axHasOwnProperty(mn);
                        };
                        ASProxy.prototype.axHasPublicProperty = function (nm) {
                            rn.name = nm;
                            if (this.axHasPropertyInternal(rn)) {
                                return true;
                            }
                            return this[proxyPrefix + 'hasProperty'](nm);
                        };
                        ASProxy.prototype.axHasOwnProperty = function (mn) {
                            var trait = typeof mn.name === 'string' ? this.traits.getTrait(mn.namespaces, mn.name) : null;
                            if (trait) {
                                return true;
                            }
                            return this[proxyPrefix + 'hasProperty'](this.sec.AXQName.FromMultiname(mn));
                        };
                        ASProxy.prototype.axDeleteProperty = function (mn) {
                            var trait = typeof mn.name === 'string' ? this.traits.getTrait(mn.namespaces, mn.name) : null;
                            if (trait) {
                                return delete this[trait.name.getMangledName()];
                            }
                            return this[proxyPrefix + 'deleteProperty'](this.sec.AXQName.FromMultiname(mn));
                        };
                        ASProxy.prototype.axNextName = function (index) {
                            return this[proxyPrefix + 'nextName'](index);
                        };
                        ASProxy.prototype.axNextValue = function (index) {
                            return this[proxyPrefix + 'nextValue'](index);
                        };
                        ASProxy.prototype.axNextNameIndex = function (index) {
                            return this[proxyPrefix + 'nextNameIndex'](index);
                        };
                        return ASProxy;
                    }(AS.ASObject);
                    utils.ASProxy = ASProxy;
                }(utils = flash.utils || (flash.utils = {})));
            }(flash = AS.flash || (AS.flash = {})));
            var rn = new AVMX.Multiname(null, 0, 17    /* RTQNameL */, [], null);
            var ASDate = function (_super) {
                __extends(ASDate, _super);
                function ASDate(yearOrTimevalue, month, date, hour, minute, second, millisecond) {
                    if (date === void 0) {
                        date = 1;
                    }
                    if (hour === void 0) {
                        hour = 0;
                    }
                    if (minute === void 0) {
                        minute = 0;
                    }
                    if (second === void 0) {
                        second = 0;
                    }
                    if (millisecond === void 0) {
                        millisecond = 0;
                    }
                    _super.call(this);
                    switch (arguments.length) {
                    case 0:
                        this.value = new Date();
                        break;
                    case 1:
                        this.value = new Date(yearOrTimevalue);
                        break;
                    case 2:
                        this.value = new Date(yearOrTimevalue, month);
                        break;
                    case 3:
                        this.value = new Date(yearOrTimevalue, month, date);
                        break;
                    case 4:
                        this.value = new Date(yearOrTimevalue, month, date, hour);
                        break;
                    case 5:
                        this.value = new Date(yearOrTimevalue, month, date, hour, minute);
                        break;
                    case 6:
                        this.value = new Date(yearOrTimevalue, month, date, hour, minute, second);
                        break;
                    default:
                        this.value = new Date(yearOrTimevalue, month, date, hour, minute, second, millisecond);
                        break;
                    }
                }
                ASDate.parse = function (date) {
                    return Date.parse(date);
                };
                ASDate.UTC = function (year, month, date, hour, minute, second, millisecond) {
                    if (date === void 0) {
                        date = 1;
                    }
                    if (hour === void 0) {
                        hour = 0;
                    }
                    if (minute === void 0) {
                        minute = 0;
                    }
                    if (second === void 0) {
                        second = 0;
                    }
                    if (millisecond === void 0) {
                        millisecond = 0;
                    }
                    return Date.parse.apply(null, arguments);
                };
                ASDate.axCoerce = function (value) {
                    return this.axConstruct([value]);
                };
                ASDate.prototype.toString = function () {
                    if (!(this.value instanceof Date)) {
                        return 'Invalid Date';
                    }
                    // JS formats dates differently, so a little surgery is required here:
                    // We need to move the year to the end, get rid of the timezone name, and remove leading 0
                    // from the day.
                    var dateStr = this.value.toString();
                    var parts = dateStr.split(' ');
                    // Detect invalid dates. Not 100% sure all JS engines always print 'Invalid Date' here,
                    // so we just check how many parts the resulting string has, with some margin for error.
                    if (parts.length < 4) {
                        return 'Invalid Date';
                    }
                    parts.length = 6;
                    // Get rid of the timezone, which might contain spaces.
                    parts.push(parts.splice(3, 1)[0]);
                    // Move Year to the end.
                    if (parts[2][0] === '0') {
                        parts[2] = parts[2][1];
                    }
                    return parts.join(' ');
                };
                ASDate.prototype.toDateString = function () {
                    if (!(this.value instanceof Date)) {
                        return 'Invalid Date';
                    }
                    var dateStr = this.value.toDateString();
                    var parts = dateStr.split(' ');
                    // Detect invalid dates. Not 100% sure all JS engines always print 'Invalid Date' here,
                    // so we just check how many parts the resulting string has, with some margin for error.
                    if (parts.length < 4) {
                        return 'Invalid Date';
                    }
                    if (parts[2][0] === '0') {
                        parts[2] = parts[2][1];
                    }
                    return parts.join(' ');
                };
                ASDate.prototype.toJSON = function () {
                    return !(this.value instanceof Date) ? 'Invalid Date' : this.value.toString();
                };
                ASDate.prototype.valueOf = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.valueOf();
                };
                ASDate.prototype.setTime = function (value) {
                    if (value === void 0) {
                        value = 0;
                    }
                    return !(this.value instanceof Date) ? NaN : this.value.setTime(value);
                };
                ASDate.prototype.toTimeString = function () {
                    return !(this.value instanceof Date) ? 'Invalid Date' : this.value.toTimeString();
                };
                ASDate.prototype.toLocaleString = function () {
                    return !(this.value instanceof Date) ? 'Invalid Date' : this.value.toLocaleString();
                };
                ASDate.prototype.toLocaleDateString = function () {
                    return !(this.value instanceof Date) ? 'Invalid Date' : this.value.toLocaleDateString();
                };
                ASDate.prototype.toLocaleTimeString = function () {
                    return !(this.value instanceof Date) ? 'Invalid Date' : this.value.toLocaleTimeString();
                };
                ASDate.prototype.toUTCString = function () {
                    return !(this.value instanceof Date) ? 'Invalid Date' : this.value.toUTCString();
                };
                ASDate.prototype.getUTCFullYear = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getUTCFullYear();
                };
                ASDate.prototype.getUTCMonth = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getUTCMonth();
                };
                ASDate.prototype.getUTCDate = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getUTCDate();
                };
                ASDate.prototype.getUTCDay = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getUTCDay();
                };
                ASDate.prototype.getUTCHours = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getUTCHours();
                };
                ASDate.prototype.getUTCMinutes = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getUTCMinutes();
                };
                ASDate.prototype.getUTCSeconds = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getUTCSeconds();
                };
                ASDate.prototype.getUTCMilliseconds = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getUTCMilliseconds();
                };
                ASDate.prototype.getFullYear = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getFullYear();
                };
                ASDate.prototype.getMonth = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getMonth();
                };
                ASDate.prototype.getDate = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getDate();
                };
                ASDate.prototype.getDay = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getDay();
                };
                ASDate.prototype.getHours = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getHours();
                };
                ASDate.prototype.getMinutes = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getMinutes();
                };
                ASDate.prototype.getSeconds = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getSeconds();
                };
                ASDate.prototype.getMilliseconds = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getMilliseconds();
                };
                ASDate.prototype.getTimezoneOffset = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getTimezoneOffset();
                };
                ASDate.prototype.getTime = function () {
                    return !(this.value instanceof Date) ? NaN : this.value.getTime();
                };
                ASDate.prototype.setFullYear = function (year, month, date) {
                    return !(this.value instanceof Date) ? NaN : this.value.setFullYear.apply(this.value, arguments);
                };
                ASDate.prototype.setMonth = function (month, date) {
                    return !(this.value instanceof Date) ? NaN : this.value.setMonth.apply(this.value, arguments);
                };
                ASDate.prototype.setDate = function (date) {
                    return !(this.value instanceof Date) ? NaN : this.value.setDate.apply(this.value, arguments);
                };
                ASDate.prototype.setHours = function (hour, minutes, seconds, milliseconds) {
                    return !(this.value instanceof Date) ? NaN : this.value.setHours.apply(this.value, arguments);
                };
                ASDate.prototype.setMinutes = function (minutes, seconds, milliseconds) {
                    return !(this.value instanceof Date) ? NaN : this.value.setMinutes.apply(this.value, arguments);
                };
                ASDate.prototype.setSeconds = function (seconds, milliseconds) {
                    return !(this.value instanceof Date) ? NaN : this.value.setSeconds.apply(this.value, arguments);
                };
                ASDate.prototype.setMilliseconds = function (milliseconds) {
                    return !(this.value instanceof Date) ? NaN : this.value.setMilliseconds.apply(this.value, arguments);
                };
                ASDate.prototype.setUTCFullYear = function (year, month, date) {
                    return !(this.value instanceof Date) ? NaN : this.value.setUTCFullYear.apply(this.value, arguments);
                };
                ASDate.prototype.setUTCMonth = function (month, date) {
                    return !(this.value instanceof Date) ? NaN : this.value.setUTCMonth.apply(this.value, arguments);
                };
                ASDate.prototype.setUTCDate = function (date) {
                    return !(this.value instanceof Date) ? NaN : this.value.setUTCDate.apply(this.value, arguments);
                };
                ASDate.prototype.setUTCHours = function (hour, minutes, seconds, milliseconds) {
                    return !(this.value instanceof Date) ? NaN : this.value.setUTCHours.apply(this.value, arguments);
                };
                ASDate.prototype.setUTCMinutes = function (minutes, seconds, milliseconds) {
                    return !(this.value instanceof Date) ? NaN : this.value.setUTCMinutes.apply(this.value, arguments);
                };
                ASDate.prototype.setUTCSeconds = function (seconds, milliseconds) {
                    return !(this.value instanceof Date) ? NaN : this.value.setUTCSeconds.apply(this.value, arguments);
                };
                ASDate.prototype.setUTCMilliseconds = function (milliseconds) {
                    return !(this.value instanceof Date) ? NaN : this.value.setUTCMilliseconds.apply(this.value, arguments);
                };
                Object.defineProperty(ASDate.prototype, 'fullYear', {
                    get: function () {
                        return this.value.getFullYear();
                    },
                    set: function (value) {
                        this.value.setFullYear(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'month', {
                    get: function () {
                        return this.value.getMonth();
                    },
                    set: function (value) {
                        this.value.setMonth(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'date', {
                    get: function () {
                        return this.value.getDate();
                    },
                    set: function (value) {
                        this.value.setDate(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'hours', {
                    get: function () {
                        return this.value.getHours();
                    },
                    set: function (value) {
                        this.value.setHours(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'minutes', {
                    get: function () {
                        return this.value.getMinutes();
                    },
                    set: function (value) {
                        this.value.setMinutes(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'seconds', {
                    get: function () {
                        return this.value.getSeconds();
                    },
                    set: function (value) {
                        this.value.setSeconds(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'milliseconds', {
                    get: function () {
                        return this.value.getMilliseconds();
                    },
                    set: function (value) {
                        this.value.setMilliseconds(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'fullYearUTC', {
                    get: function () {
                        return this.value.getUTCFullYear();
                    },
                    set: function (value) {
                        this.value.setUTCFullYear(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'monthUTC', {
                    get: function () {
                        return this.value.getUTCMonth();
                    },
                    set: function (value) {
                        this.value.setUTCMonth(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'dateUTC', {
                    get: function () {
                        return this.value.getUTCDate();
                    },
                    set: function (value) {
                        this.value.setUTCDate(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'hoursUTC', {
                    get: function () {
                        return this.value.getUTCHours();
                    },
                    set: function (value) {
                        this.value.setUTCHours(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'minutesUTC', {
                    get: function () {
                        return this.value.getUTCMinutes();
                    },
                    set: function (value) {
                        this.value.setUTCMinutes(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'secondsUTC', {
                    get: function () {
                        return this.value.getUTCSeconds();
                    },
                    set: function (value) {
                        this.value.setUTCSeconds(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'millisecondsUTC', {
                    get: function () {
                        return this.value.getUTCMilliseconds();
                    },
                    set: function (value) {
                        this.value.setUTCMilliseconds(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'time', {
                    get: function () {
                        return this.value.getTime();
                    },
                    set: function (value) {
                        this.value.setTime(value);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'timezoneOffset', {
                    get: function () {
                        return this.value.getTimezoneOffset();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'day', {
                    get: function () {
                        return this.value.getDay();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ASDate.prototype, 'dayUTC', {
                    get: function () {
                        return this.value.getUTCDay();
                    },
                    enumerable: true,
                    configurable: true
                });
                ASDate.classInitializer = function () {
                    var proto = this.dPrototype;
                    var asProto = ASDate.prototype;
                    AS.addPrototypeFunctionAlias(proto, '$BgtoString', asProto.toString);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoLocaleString', asProto.toString);
                    AS.addPrototypeFunctionAlias(proto, '$BgvalueOf', asProto.valueOf);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoDateString', asProto.toDateString);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoTimeString', asProto.toTimeString);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoLocaleString', asProto.toLocaleString);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoLocaleDateString', asProto.toLocaleDateString);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoLocaleTimeString', asProto.toLocaleTimeString);
                    AS.addPrototypeFunctionAlias(proto, '$BgtoUTCString', asProto.toUTCString);
                    // NB: The default AS implementation of |toJSON| is not ES5-compliant, but
                    // the native JS one obviously is.
                    AS.addPrototypeFunctionAlias(proto, '$BgtoJSON', asProto.toJSON);
                    AS.addPrototypeFunctionAlias(proto, '$BggetUTCFullYear', asProto.getUTCFullYear);
                    AS.addPrototypeFunctionAlias(proto, '$BggetUTCMonth', asProto.getUTCMonth);
                    AS.addPrototypeFunctionAlias(proto, '$BggetUTCDate', asProto.getUTCDate);
                    AS.addPrototypeFunctionAlias(proto, '$BggetUTCDay', asProto.getUTCDay);
                    AS.addPrototypeFunctionAlias(proto, '$BggetUTCHours', asProto.getUTCHours);
                    AS.addPrototypeFunctionAlias(proto, '$BggetUTCMinutes', asProto.getUTCMinutes);
                    AS.addPrototypeFunctionAlias(proto, '$BggetUTCSeconds', asProto.getUTCSeconds);
                    AS.addPrototypeFunctionAlias(proto, '$BggetUTCMilliseconds', asProto.getUTCMilliseconds);
                    AS.addPrototypeFunctionAlias(proto, '$BggetFullYear', asProto.getFullYear);
                    AS.addPrototypeFunctionAlias(proto, '$BggetMonth', asProto.getMonth);
                    AS.addPrototypeFunctionAlias(proto, '$BggetDate', asProto.getDate);
                    AS.addPrototypeFunctionAlias(proto, '$BggetDay', asProto.getDay);
                    AS.addPrototypeFunctionAlias(proto, '$BggetHours', asProto.getHours);
                    AS.addPrototypeFunctionAlias(proto, '$BggetMinutes', asProto.getMinutes);
                    AS.addPrototypeFunctionAlias(proto, '$BggetSeconds', asProto.getSeconds);
                    AS.addPrototypeFunctionAlias(proto, '$BggetMilliseconds', asProto.getMilliseconds);
                    AS.addPrototypeFunctionAlias(proto, '$BggetTimezoneOffset', asProto.getTimezoneOffset);
                    AS.addPrototypeFunctionAlias(proto, '$BggetTime', asProto.getTime);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetFullYear', asProto.setFullYear);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetMonth', asProto.setMonth);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetDate', asProto.setDate);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetHours', proto.setHours);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetMinutes', asProto.setMinutes);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetSeconds', asProto.setSeconds);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetMilliseconds', asProto.setMilliseconds);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetUTCFullYear', asProto.setUTCFullYear);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetUTCMonth', asProto.setUTCMonth);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetUTCDate', asProto.setUTCDate);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetUTCHours', asProto.setUTCHours);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetUTCMinutes', asProto.setUTCMinutes);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetUTCSeconds', asProto.setUTCSeconds);
                    AS.addPrototypeFunctionAlias(proto, '$BgsetUTCMilliseconds', asProto.setUTCMilliseconds);
                };
                return ASDate;
            }(AS.ASObject);
            AS.ASDate = ASDate;
            var notImplemented = Shumway.Debug.notImplemented;
            var unexpected = Shumway.Debug.unexpected;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var assert = Shumway.Debug.assert;
            var flash;
            (function (flash) {
                var net;
                (function (net) {
                    (function (AMFEncoding) {
                        AMFEncoding[AMFEncoding['AMF0'] = 0] = 'AMF0';
                        AMFEncoding[AMFEncoding['AMF3'] = 3] = 'AMF3';
                        AMFEncoding[AMFEncoding['DEFAULT'] = 3] = 'DEFAULT';
                    }(net.AMFEncoding || (net.AMFEncoding = {})));
                    var AMFEncoding = net.AMFEncoding;
                    var ObjectEncoding = function (_super) {
                        __extends(ObjectEncoding, _super);
                        function ObjectEncoding() {
                            _super.apply(this, arguments);
                        }
                        Object.defineProperty(ObjectEncoding, 'dynamicPropertyWriter', {
                            get: function () {
                                release || release || notImplemented('public flash.net.ObjectEncoding::get dynamicPropertyWriter');
                                return null;
                            },
                            set: function (value) {
                                release || release || notImplemented('public flash.net.ObjectEncoding::set dynamicPropertyWriter');
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ObjectEncoding.AMF0 = AMFEncoding.AMF0;
                        ObjectEncoding.AMF3 = AMFEncoding.AMF3;
                        ObjectEncoding.DEFAULT = AMFEncoding.DEFAULT;
                        return ObjectEncoding;
                    }(AS.ASObject);
                    net.ObjectEncoding = ObjectEncoding;
                }(net = flash.net || (flash.net = {})));
                var utils;
                (function (utils) {
                    var ByteArray = function (_super) {
                        __extends(ByteArray, _super);
                        function ByteArray(source) {
                            _super.call(this);
                            if (this._symbol) {
                                source = this._symbol;
                            }
                            var buffer;
                            var length = 0;
                            if (source) {
                                if (source instanceof ArrayBuffer) {
                                    buffer = source.slice();
                                } else if (Array.isArray(source)) {
                                    buffer = new Uint8Array(source).buffer;
                                } else if ('buffer' in source) {
                                    if (source.buffer instanceof ArrayBuffer) {
                                        buffer = new Uint8Array(source.buffer).buffer;
                                    } else if (source.buffer instanceof Uint8Array) {
                                        var begin = source.buffer.byteOffset;
                                        buffer = source.buffer.buffer.slice(begin, begin + source.buffer.length);
                                    } else {
                                        release || assert(source.buffer instanceof ArrayBuffer);
                                        buffer = source.buffer.slice();
                                    }
                                } else {
                                    Shumway.Debug.unexpected('Source type.');
                                }
                                length = buffer.byteLength;
                            } else {
                                buffer = new ArrayBuffer(ByteArray.INITIAL_SIZE);
                            }
                            this._buffer = buffer;
                            this._length = length;
                            this._position = 0;
                            this._resetViews();
                            this._objectEncoding = ByteArray.defaultObjectEncoding;
                            this._littleEndian = false;
                            // AS3 is bigEndian by default.
                            this._bitBuffer = 0;
                            this._bitLength = 0;
                        }
                        ByteArray.classInitializer = function () {
                            var proto = DataBuffer.prototype;
                            Shumway.ObjectUtilities.defineNonEnumerableProperty(proto, '$BgtoJSON', proto.toJSON);
                        };
                        Object.defineProperty(ByteArray, 'defaultObjectEncoding', {
                            get: function () {
                                return this._defaultObjectEncoding;
                            },
                            set: function (version) {
                                version = version >>> 0;
                                this._defaultObjectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ByteArray.prototype.toJSON = function () {
                            return 'ByteArray';
                        };
                        ByteArray.prototype.readObject = function () {
                            switch (this._objectEncoding) {
                            case flash.net.ObjectEncoding.AMF0:
                                return AVMX.AMF0.read(this);
                            case flash.net.ObjectEncoding.AMF3:
                                return AVMX.AMF3.read(this);
                            default:
                                unexpected('Object Encoding');
                            }
                        };
                        ByteArray.prototype.writeObject = function (object) {
                            switch (this._objectEncoding) {
                            case flash.net.ObjectEncoding.AMF0:
                                return AVMX.AMF0.write(this, object);
                            case flash.net.ObjectEncoding.AMF3:
                                return AVMX.AMF3.write(this, object);
                            default:
                                unexpected('Object Encoding');
                            }
                        };
                        ByteArray.prototype.axGetPublicProperty = function (nm) {
                            if (typeof nm === 'number' || Shumway.isNumeric(nm = AVMX.axCoerceName(nm))) {
                                return this.axGetNumericProperty(nm);
                            }
                            return this['$Bg' + nm];
                        };
                        ByteArray.prototype.axGetNumericProperty = function (nm) {
                            release || assert(typeof nm === 'number');
                            return this.getValue(nm);
                        };
                        ByteArray.prototype.axSetPublicProperty = function (nm, value) {
                            release || AVMX.checkValue(value);
                            if (typeof nm === 'number' || Shumway.isNumeric(nm = AVMX.axCoerceName(nm))) {
                                this.axSetNumericProperty(nm, value);
                                return;
                            }
                            this['$Bg' + nm] = value;
                        };
                        ByteArray.prototype.axSetNumericProperty = function (nm, value) {
                            release || assert(typeof nm === 'number');
                            this.setValue(nm, value);
                        };
                        ByteArray.prototype.axGetProperty = function (mn) {
                            var name = mn.name;
                            if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                                release || assert(mn.isRuntimeName());
                                return this.getValue(+name);
                            }
                            return _super.prototype.axGetProperty.call(this, mn);
                        };
                        ByteArray.prototype.axSetProperty = function (mn, value, bc) {
                            release || AVMX.checkValue(value);
                            var name = mn.name;
                            if (typeof name === 'number' || Shumway.isNumeric(name = AVMX.axCoerceName(name))) {
                                release || assert(mn.isRuntimeName());
                                this.setValue(+name, value);
                                return;
                            }
                            _super.prototype.axSetProperty.call(this, mn, value, bc);
                        };
                        ByteArray.classNatives = [DataBuffer];
                        ByteArray.instanceNatives = [DataBuffer.prototype];
                        /* The initial size of the backing, in bytes. Doubled every OOM. */
                        ByteArray.INITIAL_SIZE = 128;
                        ByteArray._defaultObjectEncoding = flash.net.ObjectEncoding.DEFAULT;
                        return ByteArray;
                    }(AS.ASObject);
                    utils.ByteArray = ByteArray;
                }(utils = flash.utils || (flash.utils = {})));
            }(flash = AS.flash || (AS.flash = {})));
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var defineNonEnumerableProperty = Shumway.ObjectUtilities.defineNonEnumerableProperty;
            var flash;
            (function (flash) {
                var system;
                (function (system) {
                    var IME = function (_super) {
                        __extends(IME, _super);
                        function IME() {
                            _super.call(this);
                        }
                        Object.defineProperty(IME, 'enabled', {
                            get: function () {
                                release || release || somewhatImplemented('public flash.system.IME::static get enabled');
                                return false;
                            },
                            set: function (enabled) {
                                release || release || somewhatImplemented('public flash.system.IME::static set enabled');
                                enabled = !!enabled;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(IME, 'conversionMode', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.IME::static get conversionMode');
                                return 'UNKNOWN';
                            },
                            set: function (mode) {
                                mode = AVMX.axCoerceString(mode);
                                release || somewhatImplemented('public flash.system.IME::static set conversionMode');
                            },
                            enumerable: true,
                            configurable: true
                        });
                        IME.setCompositionString = function (composition) {
                            composition = AVMX.axCoerceString(composition);
                            release || somewhatImplemented('public flash.system.IME::static setCompositionString');
                        };
                        IME.doConversion = function () {
                            release || somewhatImplemented('public flash.system.IME::static doConversion');
                        };
                        IME.compositionSelectionChanged = function (start, end) {
                            start = start | 0;
                            end = end | 0;
                            release || somewhatImplemented('public flash.system.IME::static compositionSelectionChanged');
                        };
                        IME.compositionAbandoned = function () {
                            release || somewhatImplemented('public flash.system.IME::static compositionAbandoned');
                        };
                        Object.defineProperty(IME, 'isSupported', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.IME::static get isSupported');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        return IME;
                    }(AS.ASObject);
                    system.IME = IME;
                    var System = function (_super) {
                        __extends(System, _super);
                        function System() {
                            _super.apply(this, arguments);
                        }
                        System.classInitializer = function () {
                            defineNonEnumerableProperty(this, '$Bgargv', this.sec.createArray([]));
                        };
                        Object.defineProperty(System, 'ime', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.System::get ime');
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        System.setClipboard = function (string) {
                            string = AVMX.axCoerceString(string);
                            if (Shumway.ClipboardService.instance === null) {
                                Shumway.Debug.warning('setClipboard is only available in the Firefox extension');
                                return;
                            }
                            Shumway.ClipboardService.instance.setClipboard(string);
                        };
                        Object.defineProperty(System, 'totalMemoryNumber', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.System::get totalMemoryNumber');
                                return 1024 * 1024 * 2;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(System, 'freeMemory', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.System::get freeMemory');
                                return 1024 * 1024;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(System, 'privateMemory', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.System::get privateMemory');
                                return 1024 * 1024;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(System, 'useCodePage', {
                            get: function () {
                                return this._useCodePage;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.system.System::set useCodePage');
                                this._useCodePage = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(System, 'vmVersion', {
                            get: function () {
                                return '1.0 Shumway - Mozilla Research';
                            },
                            enumerable: true,
                            configurable: true
                        });
                        System.pause = function () {
                        };
                        System.resume = function () {
                        };
                        System.exit = function (code) {
                        };
                        System.gc = function () {
                        };
                        System.pauseForGCIfCollectionImminent = function (imminence) {
                            if (imminence === void 0) {
                                imminence = 0.75;
                            }    // Not gonna happen, probably ever.
                        };
                        System.disposeXML = function (node) {
                        };
                        Object.defineProperty(System, 'swfVersion', {
                            get: function () {
                                return 19;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(System, 'apiVersion', {
                            get: function () {
                                return 26;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        System.getArgv = function () {
                            return [];
                        };
                        System.getRunmode = function () {
                            return 'mixed';
                        };
                        System._useCodePage = false;
                        return System;
                    }(AS.ASObject);
                    system.System = System;
                    system.OriginalSystem = System;
                }(system = flash.system || (flash.system = {})));
            }(flash = AS.flash || (AS.flash = {})));
        }(AS = AVMX.AS || (AVMX.AS = {})));
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
}(Shumway || (Shumway = {})));
// Do this here temporarily until we find a nicer place.
Shumway.AVMX.AS.initializeBuiltins();
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file implements the AMF0 and AMF3 serialization protocols secified in:
 * http://wwwimages.adobe.com/www.adobe.com/content/dam/Adobe/en/devnet/amf/pdf/amf-file-format-spec.pdf
 */
var Shumway;
(function (Shumway) {
    var AVMX;
    (function (AVMX) {
        var assert = Shumway.Debug.assert;
        var AMF3ReferenceTables = function () {
            function AMF3ReferenceTables() {
                this.strings = [];
                this.objects = [];
                this.traits = [];
                /**
                 * Trait names are kept in sync with |traits| and are used to optimize fetching public trait names.
                 */
                this.traitNames = [];
            }
            return AMF3ReferenceTables;
        }();
        var ClassAliases = function () {
            function ClassAliases() {
                this._classMap = new WeakMap();
                this._nameMap = Object.create(null);
            }
            ClassAliases.prototype.getAliasByClass = function (axClass) {
                return this._classMap.get(axClass);
            };
            ClassAliases.prototype.getClassByAlias = function (alias) {
                return this._nameMap[alias];
            };
            ClassAliases.prototype.registerClassAlias = function (alias, axClass) {
                this._classMap.set(axClass, alias);
                release || assert(!this._nameMap[alias] || this._nameMap[alias] === axClass);
                this._nameMap[alias] = axClass;
            };
            return ClassAliases;
        }();
        AVMX.ClassAliases = ClassAliases;
        function writeString(ba, s) {
            if (s.length > 65535) {
                throw 'AMF short string exceeded';
            }
            if (!s.length) {
                ba.writeByte(0);
                ba.writeByte(0);
                return;
            }
            var bytes = Shumway.StringUtilities.utf8decode(s);
            ba.writeByte(bytes.length >> 8 & 255);
            ba.writeByte(bytes.length & 255);
            for (var i = 0; i < bytes.length; i++) {
                ba.writeByte(bytes[i]);
            }
        }
        function readString(ba) {
            var byteLength = ba.readByte() << 8 | ba.readByte();
            if (!byteLength) {
                return '';
            }
            var buffer = new Uint8Array(byteLength);
            for (var i = 0; i < byteLength; i++) {
                buffer[i] = ba.readByte();
            }
            return Shumway.StringUtilities.utf8encode(buffer);
        }
        function writeDouble(ba, value) {
            var buffer = new ArrayBuffer(8);
            var view = new DataView(buffer);
            view.setFloat64(0, value, false);
            for (var i = 0; i < buffer.byteLength; i++) {
                ba.writeByte(view.getUint8(i));
            }
        }
        function readDouble(ba) {
            var buffer = new ArrayBuffer(8);
            var view = new DataView(buffer);
            for (var i = 0; i < buffer.byteLength; i++) {
                view.setUint8(i, ba.readByte());
            }
            return view.getFloat64(0, false);
        }
        var AMF0 = function () {
            function AMF0() {
            }
            AMF0.write = function (ba, value) {
                switch (typeof value) {
                case 'boolean':
                    ba.writeByte(1    /* BOOLEAN */);
                    ba.writeByte(value ? 1 : 0);
                    break;
                case 'number':
                    ba.writeByte(0    /* NUMBER */);
                    writeDouble(ba, value);
                    break;
                case 'undefined':
                    ba.writeByte(6    /* UNDEFINED */);
                    break;
                case 'string':
                    ba.writeByte(2    /* STRING */);
                    writeString(ba, value);
                    break;
                case 'object':
                    var object = value;
                    release || assert(object === null || AVMX.AXBasePrototype.isPrototypeOf(object));
                    if (object === null) {
                        ba.writeByte(5    /* NULL */);
                    } else if (ba.sec.AXArray.axIsType(object)) {
                        var array = object.value;
                        ba.writeByte(8    /* ECMA_ARRAY */);
                        ba.writeByte(array.length >>> 24 & 255);
                        ba.writeByte(array.length >> 16 & 255);
                        ba.writeByte(array.length >> 8 & 255);
                        ba.writeByte(array.length & 255);
                        // REDUX: What about sparse arrays?
                        AVMX.forEachPublicProperty(object, function (key, value) {
                            writeString(ba, key);
                            this.write(ba, value);
                        }, this);
                        ba.writeByte(0);
                        ba.writeByte(0);
                        ba.writeByte(9    /* OBJECT_END */);
                    } else {
                        ba.writeByte(3    /* OBJECT */);
                        AVMX.forEachPublicProperty(object, function (key, value) {
                            writeString(ba, key);
                            this.write(ba, value);
                        }, this);
                        ba.writeByte(0);
                        ba.writeByte(0);
                        ba.writeByte(9    /* OBJECT_END */);
                    }
                    return;
                }
            };
            AMF0.read = function (ba) {
                var marker = ba.readByte();
                switch (marker) {
                case 0    /* NUMBER */:
                    return readDouble(ba);
                case 1    /* BOOLEAN */:
                    return !!ba.readByte();
                case 2    /* STRING */:
                    return readString(ba);
                case 3    /* OBJECT */:
                    var object = ba.sec.createObject();
                    while (true) {
                        var key = readString(ba);
                        if (!key.length)
                            break;
                        object.axSetPublicProperty(key, this.read(ba));
                    }
                    if (ba.readByte() !== 9    /* OBJECT_END */) {
                        throw 'AMF0 End marker is not found';
                    }
                    return object;
                case 5    /* NULL */:
                    return null;
                case 6    /* UNDEFINED */:
                    return undefined;
                case 8    /* ECMA_ARRAY */:
                    var array = ba.sec.createArray([]);
                    array.length = ba.readByte() << 24 | ba.readByte() << 16 | ba.readByte() << 8 | ba.readByte();
                    while (true) {
                        var key = readString(ba);
                        if (!key.length)
                            break;
                        array.axSetPublicProperty(key, this.read(ba));
                    }
                    if (ba.readByte() !== 9    /* OBJECT_END */) {
                        throw 'AMF0 End marker is not found';
                    }
                    return array;
                case 10    /* STRICT_ARRAY */:
                    var array = ba.sec.createArray([]);
                    var length = array.length = ba.readByte() << 24 | ba.readByte() << 16 | ba.readByte() << 8 | ba.readByte();
                    for (var i = 0; i < length; i++) {
                        array.axSetPublicProperty(i, this.read(ba));
                    }
                    return array;
                case 17    /* AVMPLUS */:
                    return readAMF3Value(ba, new AMF3ReferenceTables());
                default:
                    throw 'AMF0 Unknown marker ' + marker;
                }
            };
            return AMF0;
        }();
        AVMX.AMF0 = AMF0;
        function readU29(ba) {
            var b1 = ba.readByte();
            if ((b1 & 128) === 0) {
                return b1;
            }
            var b2 = ba.readByte();
            if ((b2 & 128) === 0) {
                return (b1 & 127) << 7 | b2;
            }
            var b3 = ba.readByte();
            if ((b3 & 128) === 0) {
                return (b1 & 127) << 14 | (b2 & 127) << 7 | b3;
            }
            var b4 = ba.readByte();
            return (b1 & 127) << 22 | (b2 & 127) << 15 | (b3 & 127) << 8 | b4;
        }
        function writeU29(ba, value) {
            if ((value & 4294967168) === 0) {
                ba.writeByte(value & 127);
            } else if ((value & 4294950912) === 0) {
                ba.writeByte(128 | value >> 7 & 127);
                ba.writeByte(value & 127);
            } else if ((value & 4292870144) === 0) {
                ba.writeByte(128 | value >> 14 & 127);
                ba.writeByte(128 | value >> 7 & 127);
                ba.writeByte(value & 127);
            } else if ((value & 3221225472) === 0) {
                ba.writeByte(128 | value >> 22 & 127);
                ba.writeByte(128 | value >> 15 & 127);
                ba.writeByte(128 | value >> 8 & 127);
                ba.writeByte(value & 255);
            } else {
                throw 'AMF3 U29 range';
            }
        }
        function readUTF8(ba, references) {
            var u29s = readU29(ba);
            if (u29s === 1) {
                return '';
            }
            var strings = references.strings;
            if ((u29s & 1) === 0) {
                return strings[u29s >> 1];
            }
            var byteLength = u29s >> 1;
            var buffer = new Uint8Array(byteLength);
            for (var i = 0; i < byteLength; i++) {
                buffer[i] = ba.readByte();
            }
            var value = Shumway.StringUtilities.utf8encode(buffer);
            strings.push(value);
            return value;
        }
        function writeUTF8(ba, s, references) {
            if (s === '') {
                ba.writeByte(1);
                // empty string
                return;
            }
            var strings = references.strings;
            var index = strings.indexOf(s);
            if (index >= 0) {
                writeU29(ba, index << 1);
                return;
            }
            strings.push(s);
            var bytes = Shumway.StringUtilities.utf8decode(s);
            writeU29(ba, 1 | bytes.length << 1);
            for (var i = 0; i < bytes.length; i++) {
                ba.writeByte(bytes[i]);
            }
        }
        function readAMF3Value(ba, references) {
            var marker = ba.readByte();
            switch (marker) {
            case 1    /* NULL */:
                return null;
            case 0    /* UNDEFINED */:
                return undefined;
            case 2    /* FALSE */:
                return false;
            case 3    /* TRUE */:
                return true;
            case 4    /* INTEGER */:
                return readU29(ba);
            case 5    /* DOUBLE */:
                return readDouble(ba);
            case 6    /* STRING */:
                return readUTF8(ba, references);
            case 8    /* DATE */:
                var u29o = readU29(ba);
                release || assert((u29o & 1) === 1);
                return ba.sec.AXDate.axConstruct([readDouble(ba)]);
            case 10    /* OBJECT */:
                var u29o = readU29(ba);
                if ((u29o & 1) === 0) {
                    return references.objects[u29o >> 1];
                }
                if ((u29o & 4) !== 0) {
                    throw 'AMF3 Traits-Ext is not supported';
                }
                var axClass;
                var traits;
                var isDynamic = true;
                var traitNames;
                if ((u29o & 2) === 0) {
                    traits = references.traits[u29o >> 2];
                    traitNames = references.traitNames[u29o >> 2];
                } else {
                    var alias = readUTF8(ba, references);
                    if (alias) {
                        traits = axClass = ba.sec.classAliases.getClassByAlias(alias);
                    }
                    isDynamic = (u29o & 8) !== 0;
                    traitNames = [];
                    for (var i = 0, j = u29o >> 4; i < j; i++) {
                        traitNames.push(readUTF8(ba, references));
                    }
                    references.traits.push(traits);
                    references.traitNames.push(traitNames);
                }
                var object = axClass ? axClass.axConstruct([]) : ba.sec.createObject();
                references.objects.push(object);
                // Read trait properties.
                for (var i = 0; i < traitNames.length; i++) {
                    var value = readAMF3Value(ba, references);
                    object.axSetPublicProperty(traitNames[i], value);
                }
                // Read dynamic properties.
                if (isDynamic) {
                    while (true) {
                        var key = readUTF8(ba, references);
                        if (key === '')
                            break;
                        var value = readAMF3Value(ba, references);
                        object.axSetPublicProperty(key, value);
                    }
                }
                return object;
            case 9    /* ARRAY */:
                var u29o = readU29(ba);
                if ((u29o & 1) === 0) {
                    return references.objects[u29o >> 1];
                }
                var array = ba.sec.createArray([]);
                references.objects.push(array);
                var densePortionLength = u29o >> 1;
                while (true) {
                    var key = readUTF8(ba, references);
                    if (!key.length)
                        break;
                    var value = readAMF3Value(ba, references);
                    array.axSetPublicProperty(key, value);
                }
                for (var i = 0; i < densePortionLength; i++) {
                    var value = readAMF3Value(ba, references);
                    array.axSetPublicProperty(i, value);
                }
                return array;
            default:
                throw 'AMF3 Unknown marker ' + marker;
            }
        }
        /**
         * Tries to write a reference to a previously written object.
         */
        function tryWriteAndStartTrackingReference(ba, object, references) {
            var objects = references.objects;
            var index = objects.indexOf(object);
            if (index < 0) {
                objects.push(object);
                return false;
            }
            writeU29(ba, index << 1);
            return true;
        }
        var MAX_INT = 268435456 - 1;
        // 2^28 - 1
        var MIN_INT = -268435456;
        // -2^28
        function writeAMF3Value(ba, value, references) {
            switch (typeof value) {
            case 'boolean':
                ba.writeByte(value ? 3    /* TRUE */ : 2    /* FALSE */);
                break;
            case 'number':
                var useInteger = value === (value | 0);
                if (useInteger) {
                    if (value > MAX_INT || value < MIN_INT) {
                        useInteger = false;
                    }
                }
                if (useInteger) {
                    ba.writeByte(4    /* INTEGER */);
                    writeU29(ba, value);
                } else {
                    ba.writeByte(5    /* DOUBLE */);
                    writeDouble(ba, value);
                }
                break;
            case 'undefined':
                ba.writeByte(0    /* UNDEFINED */);
                break;
            case 'string':
                ba.writeByte(6    /* STRING */);
                writeUTF8(ba, value, references);
                break;
            case 'object':
                if (value === null) {
                    ba.writeByte(1    /* NULL */);
                } else if (ba.sec.AXArray.axIsType(value)) {
                    var array = value;
                    ba.writeByte(9    /* ARRAY */);
                    if (tryWriteAndStartTrackingReference(ba, array, references)) {
                        break;
                    }
                    var densePortionLength = 0;
                    while (array.axHasPublicProperty(densePortionLength)) {
                        ++densePortionLength;
                    }
                    writeU29(ba, densePortionLength << 1 | 1);
                    AVMX.forEachPublicProperty(array, function (i, value) {
                        if (Shumway.isNumeric(i) && i >= 0 && i < densePortionLength) {
                            return;
                        }
                        writeUTF8(ba, i, references);
                        writeAMF3Value(ba, value, references);
                    });
                    writeUTF8(ba, '', references);
                    for (var j = 0; j < densePortionLength; j++) {
                        writeAMF3Value(ba, array.axGetPublicProperty(j), references);
                    }
                } else if (ba.sec.AXDate.axIsType(value)) {
                    ba.writeByte(8    /* DATE */);
                    if (tryWriteAndStartTrackingReference(ba, value, references))
                        break;
                    writeU29(ba, 1);
                    writeDouble(ba, value.valueOf());
                } else {
                    var object = value;
                    // TODO Vector, Dictionary, ByteArray and XML support
                    ba.writeByte(10    /* OBJECT */);
                    if (tryWriteAndStartTrackingReference(ba, object, references)) {
                        break;
                    }
                    var isDynamic = true;
                    var axClass = object.axClass;
                    if (axClass) {
                        var classInfo = axClass.classInfo;
                        isDynamic = !classInfo.instanceInfo.isSealed();
                        var alias = ba.sec.classAliases.getAliasByClass(axClass) || '';
                        var traitsRef = references.traits.indexOf(axClass);
                        var traitNames = null;
                        if (traitsRef < 0) {
                            // Write traits since we haven't done so yet.
                            traitNames = classInfo.instanceInfo.runtimeTraits.getSlotPublicTraitNames();
                            references.traits.push(axClass);
                            references.traitNames.push(traitNames);
                            writeU29(ba, (isDynamic ? 11 : 3) + (traitNames.length << 4));
                            writeUTF8(ba, alias, references);
                            // Write trait names.
                            for (var i = 0; i < traitNames.length; i++) {
                                writeUTF8(ba, traitNames[i], references);
                            }
                        } else {
                            // Write a reference to the previously written traits.
                            traitNames = references.traitNames[traitsRef];
                            writeU29(ba, 1 + (traitsRef << 2));
                        }
                        // Write the actual trait values.
                        for (var i = 0; i < traitNames.length; i++) {
                            writeAMF3Value(ba, object.axGetPublicProperty(traitNames[i]), references);
                        }
                    } else {
                        // REDUX: I don't understand in what situations we wouldn't have a class definition, ask Yury.
                        // object with no class definition
                        writeU29(ba, 11);
                        writeUTF8(ba, '', references);    // empty alias name
                    }
                    // Write dynamic properties.
                    if (isDynamic) {
                        AVMX.forEachPublicProperty(object, function (i, value) {
                            writeUTF8(ba, i, references);
                            writeAMF3Value(ba, value, references);
                        });
                        writeUTF8(ba, '', references);
                    }
                }
                return;
            }
        }
        var AMF3 = function () {
            function AMF3() {
            }
            AMF3.write = function (ba, object) {
                writeAMF3Value(ba, object, new AMF3ReferenceTables());
            };
            AMF3.read = function (ba) {
                return readAMF3Value(ba, new AMF3ReferenceTables());
            };
            return AMF3;
        }();
        AVMX.AMF3 = AMF3;
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='../../build/ts/tools.d.ts' />
///<reference path='module.ts' />
///<reference path='errors.ts' />
///<reference path='settings.ts' />
///<reference path='abc/stream.ts' />
///<reference path='abc/ops.ts' />
///<reference path='abc/lazy.ts' />
///<reference path='int.ts' />
///<reference path='run.ts' />
///<reference path='nat.ts' />
// ///<reference path='compiler/verifier.ts' />
// ///<reference path='compiler/baseline.ts' />
///<reference path='natives/GenericVector.ts' />
///<reference path='natives/int32Vector.ts' />
///<reference path='natives/uint32Vector.ts' />
///<reference path='natives/float64Vector.ts' />
///<reference path='natives/xml.ts' />
///<reference path='natives/xml-document.ts' />
///<reference path='natives/describeType.ts' />
///<reference path='natives/dictionary.ts' />
///<reference path='natives/proxy.ts' />
///<reference path='natives/date.ts' />
///<reference path='natives/byteArray.ts' />
///<reference path='natives/system.ts' />
///<reference path='amf.ts' />
//# sourceMappingURL=avm2.js.map
console.timeEnd('Load AVM2 Dependencies');
console.time('Load SWF Parser');
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='references.ts'/>
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var Parser;
        (function (Parser) {
            var LowLevel;
            (function (LowLevel) {
                function parseBbox(stream) {
                    stream.align();
                    var bits = stream.readUb(5);
                    var xMin = stream.readSb(bits);
                    var xMax = stream.readSb(bits);
                    var yMin = stream.readSb(bits);
                    var yMax = stream.readSb(bits);
                    stream.align();
                    return {
                        xMin: xMin,
                        xMax: xMax,
                        yMin: yMin,
                        yMax: yMax
                    };
                }
                function parseRgb(stream) {
                    return (stream.readUi8() << 24 | stream.readUi8() << 16 | stream.readUi8() << 8 | 255) >>> 0;
                }
                LowLevel.parseRgb = parseRgb;
                function parseRgba(stream) {
                    return stream.readUi8() << 24 | stream.readUi8() << 16 | stream.readUi8() << 8 | stream.readUi8();
                }
                function parseArgb(stream) {
                    return stream.readUi8() | stream.readUi8() << 24 | stream.readUi8() << 16 | stream.readUi8() << 8;
                }
                function parseMatrix(stream) {
                    var matrix = {
                        a: 1,
                        b: 0,
                        c: 0,
                        d: 1,
                        tx: 0,
                        ty: 0
                    };
                    stream.align();
                    var hasScale = stream.readUb(1);
                    if (hasScale) {
                        var bits = stream.readUb(5);
                        matrix.a = stream.readFb(bits);
                        matrix.d = stream.readFb(bits);
                    }
                    var hasRotate = stream.readUb(1);
                    if (hasRotate) {
                        var bits = stream.readUb(5);
                        matrix.b = stream.readFb(bits);
                        matrix.c = stream.readFb(bits);
                    }
                    var bits = stream.readUb(5);
                    matrix.tx = stream.readSb(bits);
                    matrix.ty = stream.readSb(bits);
                    stream.align();
                    return matrix;
                }
                function parseColorTransform(stream, hasAlpha) {
                    var cxform = {
                        redMultiplier: 255,
                        greenMultiplier: 255,
                        blueMultiplier: 255,
                        alphaMultiplier: 255,
                        redOffset: 0,
                        greenOffset: 0,
                        blueOffset: 0,
                        alphaOffset: 0
                    };
                    stream.align();
                    var hasOffsets = stream.readUb(1);
                    var hasMultipliers = stream.readUb(1);
                    var bits = stream.readUb(4);
                    if (hasMultipliers) {
                        cxform.redMultiplier = stream.readSb(bits);
                        cxform.greenMultiplier = stream.readSb(bits);
                        cxform.blueMultiplier = stream.readSb(bits);
                        if (hasAlpha) {
                            cxform.alphaMultiplier = stream.readSb(bits);
                        }
                    }
                    if (hasOffsets) {
                        cxform.redOffset = stream.readSb(bits);
                        cxform.greenOffset = stream.readSb(bits);
                        cxform.blueOffset = stream.readSb(bits);
                        if (hasAlpha) {
                            cxform.alphaOffset = stream.readSb(bits);
                        }
                    }
                    stream.align();
                    return cxform;
                }
                function parsePlaceObjectTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.actionBlocksPrecedence = stream.pos;
                    if (tagCode === 4    /* CODE_PLACE_OBJECT */) {
                        tag.symbolId = stream.readUi16();
                        tag.depth = stream.readUi16();
                        tag.flags |= 4    /* HasMatrix */;
                        tag.matrix = parseMatrix(stream);
                        if (stream.pos < tagEnd) {
                            tag.flags |= 8    /* HasColorTransform */;
                            tag.cxform = parseColorTransform(stream, false);
                        }
                        return tag;
                    }
                    var flags = tag.flags = tagCode > 26    /* CODE_PLACE_OBJECT2 */ ? stream.readUi16() : stream.readUi8();
                    tag.depth = stream.readUi16();
                    if (flags & 2048    /* HasClassName */) {
                        tag.className = stream.readString(-1);
                    }
                    if (flags & 2    /* HasCharacter */) {
                        tag.symbolId = stream.readUi16();
                    }
                    if (flags & 4    /* HasMatrix */) {
                        tag.matrix = parseMatrix(stream);
                    }
                    if (flags & 8    /* HasColorTransform */) {
                        tag.cxform = parseColorTransform(stream, true);
                    }
                    if (flags & 16    /* HasRatio */) {
                        tag.ratio = stream.readUi16();
                    }
                    if (flags & 32    /* HasName */) {
                        tag.name = stream.readString(-1);
                    }
                    if (flags & 64    /* HasClipDepth */) {
                        tag.clipDepth = stream.readUi16();
                    }
                    if (flags & 256    /* HasFilterList */) {
                        var count = stream.readUi8();
                        var filters = tag.filters = [];
                        while (count--) {
                            filters.push(parseFilter(stream));
                        }
                    }
                    if (flags & 512    /* HasBlendMode */) {
                        tag.blendMode = stream.readUi8();
                    }
                    if (flags & 1024    /* HasCacheAsBitmap */) {
                        tag.bmpCache = stream.readUi8();
                    }
                    if (flags & 8192    /* HasVisible */) {
                        tag.visibility = stream.readBool();
                    }
                    if (flags & 16384    /* OpaqueBackground */) {
                        tag.backgroundColor = parseArgb(stream);
                    }
                    if (flags & 128    /* HasClipActions */) {
                        var reserved = stream.readUi16();
                        var allFlags = swfVersion >= 6 ? stream.readUi32() : stream.readUi16();
                        var allEvents = tag.events = [];
                        var events;
                        while (events = parseEvents(stream, swfVersion)) {
                            if (stream.pos > tagEnd) {
                                Shumway.Debug.warning('PlaceObject handler attempted to read clip events beyond tag end');
                                stream.pos = tagEnd;
                                break;
                            }
                            allEvents.push(events);
                        }
                        ;
                    }
                    return tag;
                }
                function parseEvents(stream, swfVersion) {
                    var flags = swfVersion >= 6 ? stream.readUi32() : stream.readUi16();
                    if (!flags) {
                        // `true` means this is the EndOfEvents marker.
                        return null;
                    }
                    var events = {};
                    // The Construct event is only allowed in 7+. It can't be set in < 6, so mask it out for 6.
                    if (swfVersion === 6) {
                        flags = flags & ~262144    /* Construct */;
                    }
                    events.flags = flags;
                    var length = stream.readUi32();
                    if (flags & 131072    /* KeyPress */) {
                        events.keyCode = stream.readUi8();
                        length--;
                    }
                    var end = stream.pos + length;
                    events.actionsBlock = stream.bytes.subarray(stream.pos, end);
                    stream.pos = end;
                    return events;
                }
                function parseFilter(stream) {
                    var filter = {};
                    var type = filter.type = stream.readUi8();
                    switch (type) {
                    case 0:
                    case 2:
                    case 3:
                    case 4:
                    case 7:
                        var glow = filter;
                        var count;
                        if (type === 4 || type === 7) {
                            count = stream.readUi8();
                        } else {
                            count = type === 3 ? 2 : 1;
                        }
                        var colors = glow.colors = [];
                        var i = count;
                        while (i--) {
                            colors.push(parseRgba(stream));
                        }
                        if (type === 4 || type === 7) {
                            var ratios = glow.ratios = [];
                            var i = count;
                            while (i--) {
                                ratios.push(stream.readUi8());
                            }
                        }
                        glow.blurX = stream.readFixed();
                        glow.blurY = stream.readFixed();
                        if (type !== 2) {
                            glow.angle = stream.readFixed();
                            glow.distance = stream.readFixed();
                        }
                        glow.strength = stream.readFixed8();
                        glow.inner = !!stream.readUb(1);
                        glow.knockout = !!stream.readUb(1);
                        glow.compositeSource = !!stream.readUb(1);
                        if (type === 3 || type === 4 || type === 7) {
                            glow.onTop = !!stream.readUb(1);
                            glow.quality = stream.readUb(4);
                        } else {
                            glow.quality = stream.readUb(5);
                        }
                        return glow;
                    case 1:
                        var blur = filter;
                        blur.blurX = stream.readFixed();
                        blur.blurY = stream.readFixed();
                        blur.quality = stream.readUb(5);
                        stream.readUb(3);
                        return blur;
                    case 5:
                        var conv = filter;
                        var matrixX = conv.matrixX = stream.readUi8();
                        var matrixY = conv.matrixY = stream.readUi8();
                        conv.divisor = stream.readFloat();
                        conv.bias = stream.readFloat();
                        var matrix = conv.matrix = [];
                        var i = matrixX * matrixY;
                        while (i--) {
                            matrix.push(stream.readFloat());
                        }
                        conv.color = parseRgba(stream);
                        var reserved = stream.readUb(6);
                        conv.clamp = !!stream.readUb(1);
                        conv.preserveAlpha = !!stream.readUb(1);
                        return conv;
                    case 6:
                        var cm = filter;
                        var matrix = cm.matrix = [];
                        var i = 20;
                        while (i--) {
                            matrix.push(stream.readFloat());
                        }
                        return cm;
                    default:
                    }
                    return filter;
                }
                function parseRemoveObjectTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    if (tagCode === 5    /* CODE_REMOVE_OBJECT */) {
                        tag.depth = stream.readUi16();
                        tag.symbolId = stream.readUi16();
                    } else {
                        tag.depth = stream.readUi16();
                    }
                    return tag;
                }
                function parseDefineImageTag(stream, swfVersion, tagCode, tagEnd, jpegTables) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var imgData;
                    if (tagCode > 21    /* CODE_DEFINE_BITS_JPEG2 */) {
                        var alphaDataOffset = stream.readUi32();
                        if (tagCode === 90    /* CODE_DEFINE_BITS_JPEG4 */) {
                            tag.deblock = stream.readFixed8();
                        }
                        alphaDataOffset += stream.pos;
                        imgData = tag.imgData = stream.bytes.subarray(stream.pos, alphaDataOffset);
                        tag.alphaData = stream.bytes.subarray(alphaDataOffset, tagEnd);
                        stream.pos = tagEnd;
                    } else {
                        imgData = tag.imgData = stream.bytes.subarray(stream.pos, tagEnd);
                        stream.pos = tagEnd;
                    }
                    switch (imgData[0] << 8 | imgData[1]) {
                    case 65496:
                    case 65497:
                        tag.mimeType = 'image/jpeg';
                        break;
                    case 35152:
                        tag.mimeType = 'image/png';
                        break;
                    case 18249:
                        tag.mimeType = 'image/gif';
                        break;
                    default:
                        tag.mimeType = 'application/octet-stream';
                    }
                    if (tagCode === 6    /* CODE_DEFINE_BITS */) {
                        tag.jpegTables = { data: jpegTables };
                    }
                    return tag;
                }
                LowLevel.parseDefineImageTag = parseDefineImageTag;
                function parseDefineButtonTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var characters = tag.characters = [];
                    var character;
                    if (tagCode == 7    /* CODE_DEFINE_BUTTON */) {
                        while (character = parseButtonCharacter(stream, swfVersion, tagCode)) {
                            characters.push(character);
                        }
                        ;
                        tag.actionsData = stream.bytes.subarray(stream.pos, tagEnd);
                        stream.pos = tagEnd;
                    } else {
                        var trackFlags = stream.readUi8();
                        tag.trackAsMenu = !!(trackFlags >> 7 & 1);
                        var actionOffset = stream.readUi16();
                        while (character = parseButtonCharacter(stream, swfVersion, tagCode)) {
                            characters.push(character);
                        }
                        ;
                        if (!!actionOffset) {
                            var buttonActions = tag.buttonActions = [];
                            while (stream.pos < tagEnd) {
                                var action = parseButtonCondAction(stream, tagEnd);
                                // Ignore actions that exceed the tag length.
                                if (stream.pos > tagEnd) {
                                    break;
                                }
                                buttonActions.push(action);
                            }
                            stream.pos = tagEnd;
                        }
                    }
                    return tag;
                }
                function parseButtonCharacter(stream, swfVersion, tagCode) {
                    var flags = stream.readUi8();
                    if (!flags) {
                        return null;
                    }
                    var character = {};
                    if (swfVersion < 8) {
                        // Clear HasBlendMode and HasFilterList flags.
                        flags &= ~(512    /* HasBlendMode */ | 256    /* HasFilterList */);
                    }
                    character.flags = flags;
                    character.symbolId = stream.readUi16();
                    character.depth = stream.readUi16();
                    character.matrix = parseMatrix(stream);
                    if (tagCode === 34    /* CODE_DEFINE_BUTTON2 */) {
                        character.cxform = parseColorTransform(stream, true);
                    }
                    if (character.flags & 16    /* HasFilterList */) {
                        var count = stream.readUi8();
                        var filters = character.filters = [];
                        var i = count;
                        while (i--) {
                            filters.push(parseFilter(stream));
                        }
                    }
                    if (character.flags & 32    /* HasBlendMode */) {
                        character.blendMode = stream.readUi8();
                    }
                    return character;
                }
                function parseButtonCondAction(stream, tagEnd) {
                    var start = stream.pos;
                    var tagSize = stream.readUi16();
                    // If no tagSize is given, read to the tag's end.
                    var end = tagSize ? start + tagSize : tagEnd;
                    var conditions = stream.readUi16();
                    stream.pos = end;
                    return {
                        // The 7 upper bits hold a key code the button should respond to.
                        keyCode: (conditions & 65024) >> 9,
                        // The lower 9 bits hold state transition flags. See the enum in AVM1Button for details.
                        stateTransitionFlags: conditions & 511,
                        // If no tagSize is given, pass `0` to readBinary.
                        actionsData: stream.bytes.subarray(start + 4, end)
                    };
                }
                function parseDefineBinaryDataTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    stream.pos += 4;
                    // Reserved
                    tag.data = stream.bytes.subarray(stream.pos, tagEnd);
                    stream.pos = tagEnd;
                    return tag;
                }
                function parseDefineFontTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var firstOffset = stream.readUi16();
                    var glyphCount = firstOffset / 2;
                    var restOffsets = [];
                    var i = glyphCount - 1;
                    while (i--) {
                        restOffsets.push(stream.readUi16());
                    }
                    tag.offsets = [firstOffset].concat(restOffsets);
                    var glyphs = tag.glyphs = [];
                    var i = glyphCount;
                    while (i--) {
                        glyphs.push(parseGlyph(stream, swfVersion, tagCode));
                    }
                    return tag;
                }
                LowLevel.parseDefineFontTag = parseDefineFontTag;
                function parseGlyph(stream, swfVersion, tagCode) {
                    stream.align();
                    var fillBits = stream.readUb(4);
                    var lineBits = stream.readUb(4);
                    return parseShapeRecords(stream, swfVersion, tagCode, false, fillBits, lineBits, false);
                }
                function parseDefineTextTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    tag.bbox = parseBbox(stream);
                    tag.matrix = parseMatrix(stream);
                    var glyphBits = stream.readUi8();
                    var advanceBits = stream.readUi8();
                    var records = tag.records = [];
                    var record;
                    while (record = parseTextRecord(stream, swfVersion, tagCode, glyphBits, advanceBits)) {
                        records.push(record);
                    }
                    return tag;
                }
                function parseTextRecord(stream, swfVersion, tagCode, glyphBits, advanceBits) {
                    stream.align();
                    var flags = stream.readUb(8);
                    if (!flags) {
                        return null;
                    }
                    var record = {};
                    record.flags = flags;
                    if (flags & 8    /* HasFont */) {
                        record.fontId = stream.readUi16();
                    }
                    if (flags & 4    /* HasColor */) {
                        record.color = tagCode === 33    /* CODE_DEFINE_TEXT2 */ ? parseRgba(stream) : parseRgb(stream);
                    }
                    if (flags & 1    /* HasMoveX */) {
                        record.moveX = stream.readSi16();
                    }
                    if (flags & 2    /* HasMoveY */) {
                        record.moveY = stream.readSi16();
                    }
                    if (flags & 8    /* HasFont */) {
                        record.fontHeight = stream.readUi16();
                    }
                    var glyphCount = stream.readUi8();
                    if (swfVersion <= 6) {
                        glyphCount = glyphCount;    // & 0x7f ???;
                    }
                    var entries = record.entries = [];
                    var i = glyphCount;
                    while (i--) {
                        entries.push({
                            glyphIndex: stream.readUb(glyphBits),
                            advance: stream.readSb(advanceBits)
                        });
                    }
                    return record;
                }
                function parseDefineSoundTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var soundFlags = stream.readUi8();
                    tag.soundFormat = soundFlags >> 4 & 15;
                    tag.soundRate = soundFlags >> 2 & 3;
                    tag.soundSize = soundFlags >> 1 & 1;
                    tag.soundType = soundFlags & 1;
                    tag.samplesCount = stream.readUi32();
                    tag.soundData = stream.bytes.subarray(stream.pos, tagEnd);
                    stream.pos = tagEnd;
                    return tag;
                }
                function parseStartSoundTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    if (tagCode == 15    /* CODE_START_SOUND */) {
                        tag.soundId = stream.readUi16();
                    }
                    if (tagCode == 89    /* CODE_START_SOUND2 */) {
                        tag.soundClassName = stream.readString(-1);
                    }
                    tag.soundInfo = parseSoundInfo(stream);
                    return tag;
                }
                function parseSoundInfo(stream) {
                    var info = {};
                    var flags = info.flags = stream.readUi8();
                    if (flags & 1    /* HasInPoint */) {
                        info.inPoint = stream.readUi32();
                    }
                    if (flags & 2    /* HasOutPoint */) {
                        info.outPoint = stream.readUi32();
                    }
                    if (flags & 4    /* HasLoops */) {
                        info.loopCount = stream.readUi16();
                    }
                    if (flags & 8    /* HasEnvelope */) {
                        var envelopeCount = stream.readUi8();
                        var envelopes = info.envelopes = [];
                        var i = envelopeCount;
                        while (i--) {
                            envelopes.push({
                                pos44: stream.readUi32(),
                                volumeLeft: stream.readUi16(),
                                volumeRight: stream.readUi16()
                            });
                        }
                    }
                    return info;
                }
                function parseSoundStreamHeadTag(stream, tagEnd) {
                    var tag = {};
                    var playbackFlags = stream.readUi8();
                    tag.playbackRate = playbackFlags >> 2 & 3;
                    tag.playbackSize = playbackFlags >> 1 & 1;
                    tag.playbackType = playbackFlags & 1;
                    var streamFlags = stream.readUi8();
                    var streamCompression = tag.streamCompression = streamFlags >> 4 & 15;
                    tag.streamRate = streamFlags >> 2 & 3;
                    tag.streamSize = streamFlags >> 1 & 1;
                    tag.streamType = streamFlags & 1;
                    tag.samplesCount = stream.readUi16();
                    if (streamCompression == 2 && tagEnd - stream.pos >= 2) {
                        tag.latencySeek = stream.readSi16();
                    }
                    return tag;
                }
                LowLevel.parseSoundStreamHeadTag = parseSoundStreamHeadTag;
                function parseDefineBitmapTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var format = tag.format = stream.readUi8();
                    tag.width = stream.readUi16();
                    tag.height = stream.readUi16();
                    tag.hasAlpha = tagCode === 36    /* CODE_DEFINE_BITS_LOSSLESS2 */;
                    if (format === 3) {
                        tag.colorTableSize = stream.readUi8();
                    }
                    tag.bmpData = stream.bytes.subarray(stream.pos, tagEnd);
                    stream.pos = tagEnd;
                    return tag;
                }
                LowLevel.parseDefineBitmapTag = parseDefineBitmapTag;
                function parseDefineEditTextTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    tag.bbox = parseBbox(stream);
                    var flags = tag.flags = stream.readUi16();
                    if (flags & 1    /* HasFont */) {
                        tag.fontId = stream.readUi16();
                    }
                    if (flags & 32768    /* HasFontClass */) {
                        tag.fontClass = stream.readString(-1);
                    }
                    if (flags & 1    /* HasFont */) {
                        tag.fontHeight = stream.readUi16();
                    }
                    if (flags & 4    /* HasColor */) {
                        tag.color = parseRgba(stream);
                    }
                    if (flags & 2    /* HasMaxLength */) {
                        tag.maxLength = stream.readUi16();
                    }
                    if (flags & 8192    /* HasLayout */) {
                        tag.align = stream.readUi8();
                        tag.leftMargin = stream.readUi16();
                        tag.rightMargin = stream.readUi16();
                        tag.indent = stream.readSi16();
                        tag.leading = stream.readSi16();
                    }
                    tag.variableName = stream.readString(-1);
                    if (flags & 128    /* HasText */) {
                        tag.initialText = stream.readString(-1);
                    }
                    return tag;
                }
                function parseDefineFont2Tag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var flags = tag.flags = stream.readUi8();
                    var wide = !!(flags & 4    /* WideOrHasFontData */);
                    if (swfVersion > 5) {
                        tag.language = stream.readUi8();
                    } else {
                        // Clear ShiftJis flag.
                        flags = tag.flags = flags & ~64    /* ShiftJis */;
                        // Skip reserved byte.
                        stream.pos += 1;
                        tag.language = 0;
                    }
                    var nameLength = stream.readUi8();
                    tag.name = stream.readString(nameLength);
                    if (tagCode === 75    /* CODE_DEFINE_FONT3 */) {
                        tag.resolution = 20;
                    }
                    var glyphCount = stream.readUi16();
                    // The SWF format docs doesn't say that, but the DefineFont{2,3} tag ends here for device fonts.
                    if (glyphCount === 0) {
                        return tag;
                    }
                    var startpos = stream.pos;
                    var offsets = tag.offsets = [];
                    var i = glyphCount;
                    if (flags & 8    /* WideOffset */) {
                        while (i--) {
                            offsets.push(stream.readUi32());
                        }
                        tag.mapOffset = stream.readUi32();
                    } else {
                        while (i--) {
                            offsets.push(stream.readUi16());
                        }
                        tag.mapOffset = stream.readUi16();
                    }
                    var glyphs = tag.glyphs = [];
                    var i = glyphCount;
                    while (i--) {
                        var dist = tag.offsets[glyphCount - i] + startpos - stream.pos;
                        // when just one byte difference between two offsets, just read that and insert an empty glyph.
                        if (dist === 1) {
                            stream.pos += 1;
                            glyphs.push([]);
                            continue;
                        }
                        glyphs.push(parseGlyph(stream, swfVersion, tagCode));
                    }
                    var codes = tag.codes = [];
                    var i = glyphCount;
                    while (i--) {
                        codes.push(wide ? stream.readUi16() : stream.readUi8());
                    }
                    if (flags & 128    /* HasLayout */) {
                        tag.ascent = stream.readUi16();
                        tag.descent = stream.readUi16();
                        tag.leading = stream.readSi16();
                        var advance = tag.advance = [];
                        var i = glyphCount;
                        while (i--) {
                            advance.push(stream.readSi16());
                        }
                        var bbox = tag.bbox = [];
                        var i = glyphCount;
                        while (i--) {
                            bbox.push(parseBbox(stream));
                        }
                        var kerningCount = stream.readUi16();
                        var kernings = tag.kerning = [];
                        var i = kerningCount;
                        // DefineFont2 tags tend to have a wrong kerning count so we have to make sure here that there is enough unread
                        // data remaining before parsing the next kerning record. If not, we have to bail out earlier in the following
                        // loop to avoid reading out of bound.
                        while (i-- && tagEnd - stream.pos >= (wide ? 4 : 2) + 2) {
                            kernings.push(parseKerning(stream, wide));
                        }
                    }
                    return tag;
                }
                LowLevel.parseDefineFont2Tag = parseDefineFont2Tag;
                function parseKerning(stream, wide) {
                    var kerning = {};
                    if (wide) {
                        kerning.code1 = stream.readUi16();
                        kerning.code2 = stream.readUi16();
                    } else {
                        kerning.code1 = stream.readUi8();
                        kerning.code2 = stream.readUi8();
                    }
                    kerning.adjustment = stream.readUi16();
                    return kerning;
                }
                function parseDefineFont4Tag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    var flags = tag.flags = stream.readUi8();
                    tag.name = stream.readString(-1);
                    if (flags & 4    /* WideOrHasFontData */) {
                        tag.data = stream.bytes.subarray(stream.pos, tagEnd);
                        stream.pos = tagEnd;
                    }
                    return tag;
                }
                LowLevel.parseDefineFont4Tag = parseDefineFont4Tag;
                function parseDefineScalingGridTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.symbolId = stream.readUi16();
                    tag.splitter = parseBbox(stream);
                    return tag;
                }
                function parseDefineSceneTag(stream, tagCode) {
                    var tag = { code: tagCode };
                    var sceneCount = stream.readEncodedU32();
                    var scenes = tag.scenes = [];
                    var i = sceneCount;
                    while (i--) {
                        scenes.push({
                            offset: stream.readEncodedU32(),
                            name: stream.readString(-1)
                        });
                    }
                    var labelCount = stream.readEncodedU32();
                    var labels = tag.labels = [];
                    var i = labelCount;
                    while (i--) {
                        labels.push({
                            frame: stream.readEncodedU32(),
                            name: stream.readString(-1)
                        });
                    }
                    return tag;
                }
                LowLevel.parseDefineSceneTag = parseDefineSceneTag;
                function parseDefineShapeTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    tag.lineBounds = parseBbox(stream);
                    var flags = 0;
                    var isMorph = tagCode === 46    /* CODE_DEFINE_MORPH_SHAPE */ || tagCode === 84    /* CODE_DEFINE_MORPH_SHAPE2 */;
                    if (isMorph) {
                        flags |= 8    /* IsMorph */;
                        tag.lineBoundsMorph = parseBbox(stream);
                    }
                    var canHaveStrokes = tagCode === 83    /* CODE_DEFINE_SHAPE4 */ || tagCode === 84    /* CODE_DEFINE_MORPH_SHAPE2 */;
                    if (canHaveStrokes) {
                        var fillBounds = tag.fillBounds = parseBbox(stream);
                        if (isMorph) {
                            tag.fillBoundsMorph = parseBbox(stream);
                        }
                        flags |= stream.readUi8() & 7;
                    }
                    tag.flags = flags;
                    if (isMorph) {
                        stream.pos += 4;
                    }
                    tag.fillStyles = parseFillStyles(stream, swfVersion, tagCode, isMorph);
                    tag.lineStyles = parseLineStyles(stream, swfVersion, tagCode, isMorph, canHaveStrokes);
                    stream.align();
                    var fillBits = stream.readUb(4);
                    var lineBits = stream.readUb(4);
                    tag.records = parseShapeRecords(stream, swfVersion, tagCode, isMorph, fillBits, lineBits, canHaveStrokes);
                    if (isMorph) {
                        stream.align();
                        fillBits = stream.readUb(4);
                        lineBits = stream.readUb(4);
                        tag.recordsMorph = parseShapeRecords(stream, swfVersion, tagCode, isMorph, fillBits, lineBits, canHaveStrokes);
                    }
                    return tag;
                }
                function parseShapeRecords(stream, swfVersion, tagCode, isMorph, fillBits, lineBits, hasStrokes) {
                    var records = [];
                    var bits;
                    do {
                        var record = {};
                        var type = record.type = stream.readUb(1);
                        var flags = stream.readUb(5);
                        if (!(type || flags)) {
                            break;
                        }
                        if (type) {
                            var bits = (flags & 15) + 2;
                            flags = (flags & 240) << 1;
                            if (flags & 32    /* IsStraight */) {
                                var isGeneral = record.isGeneral = stream.readUb(1);
                                if (isGeneral) {
                                    flags |= 64    /* IsGeneral */;
                                    record.deltaX = stream.readSb(bits);
                                    record.deltaY = stream.readSb(bits);
                                } else {
                                    var isVertical = record.isVertical = stream.readUb(1);
                                    if (isVertical) {
                                        flags |= 128    /* IsVertical */;
                                        record.deltaY = stream.readSb(bits);
                                    } else {
                                        record.deltaX = stream.readSb(bits);
                                    }
                                }
                            } else {
                                record.controlDeltaX = stream.readSb(bits);
                                record.controlDeltaY = stream.readSb(bits);
                                record.anchorDeltaX = stream.readSb(bits);
                                record.anchorDeltaY = stream.readSb(bits);
                            }
                        } else {
                            if (tagCode <= 2    /* CODE_DEFINE_SHAPE */) {
                                // Clear HasNewStyles flag.
                                flags &= ~16    /* HasNewStyles */;
                            }
                            if (flags & 1    /* Move */) {
                                bits = stream.readUb(5);
                                record.moveX = stream.readSb(bits);
                                record.moveY = stream.readSb(bits);
                            }
                            if (flags & 2    /* HasFillStyle0 */) {
                                record.fillStyle0 = stream.readUb(fillBits);
                            }
                            if (flags & 4    /* HasFillStyle1 */) {
                                record.fillStyle1 = stream.readUb(fillBits);
                            }
                            if (flags & 8    /* HasLineStyle */) {
                                record.lineStyle = stream.readUb(lineBits);
                            }
                            if (flags & 16    /* HasNewStyles */) {
                                record.fillStyles = parseFillStyles(stream, swfVersion, tagCode, isMorph);
                                record.lineStyles = parseLineStyles(stream, swfVersion, tagCode, isMorph, hasStrokes);
                                stream.align();
                                fillBits = stream.readUb(4);
                                lineBits = stream.readUb(4);
                            }
                        }
                        record.flags = flags;
                        records.push(record);
                    } while (true);
                    return records;
                }
                function parseFillStyles(stream, swfVersion, tagCode, isMorph) {
                    var count = stream.readUi8();
                    if (tagCode > 2    /* CODE_DEFINE_SHAPE */ && count === 255) {
                        count = stream.readUi16();
                    }
                    var styles = [];
                    var i = count;
                    while (i--) {
                        styles.push(parseFillStyle(stream, swfVersion, tagCode, isMorph));
                    }
                    return styles;
                }
                function parseFillStyle(stream, swfVersion, tagCode, isMorph) {
                    var style = {};
                    var type = style.type = stream.readUi8();
                    switch (type) {
                    case 0:
                        var solid = style;
                        solid.color = tagCode > 22    /* CODE_DEFINE_SHAPE2 */ || isMorph ? parseRgba(stream) : parseRgb(stream);
                        if (isMorph) {
                            solid.colorMorph = parseRgba(stream);
                        }
                        return solid;
                    case 16:
                    case 18:
                    case 19:
                        var gradient = style;
                        gradient.matrix = parseMatrix(stream);
                        if (isMorph) {
                            gradient.matrixMorph = parseMatrix(stream);
                        }
                        if (tagCode === 83    /* CODE_DEFINE_SHAPE4 */) {
                            gradient.spreadMode = stream.readUb(2);
                            gradient.interpolationMode = stream.readUb(2);
                        } else {
                            stream.readUb(4);
                        }
                        var count = stream.readUb(4);
                        var records = gradient.records = [];
                        var j = count;
                        while (j--) {
                            records.push(parseGradientRecord(stream, tagCode, isMorph));
                        }
                        if (type === 19) {
                            gradient.focalPoint = stream.readSi16();
                            if (isMorph) {
                                gradient.focalPointMorph = stream.readSi16();
                            }
                        }
                        return gradient;
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                        var pattern = style;
                        pattern.bitmapId = stream.readUi16();
                        pattern.condition = type === 64 || type === 67;
                        pattern.matrix = parseMatrix(stream);
                        if (isMorph) {
                            pattern.matrixMorph = parseMatrix(stream);
                        }
                        return pattern;
                    }
                    return style;
                }
                function parseGradientRecord(stream, tagCode, isMorph) {
                    var record = {};
                    record.ratio = stream.readUi8();
                    if (tagCode > 22    /* CODE_DEFINE_SHAPE2 */) {
                        record.color = parseRgba(stream);
                    } else {
                        record.color = parseRgb(stream);
                    }
                    if (isMorph) {
                        record.ratioMorph = stream.readUi8();
                        record.colorMorph = parseRgba(stream);
                    }
                    return record;
                }
                function parseLineStyles(stream, swfVersion, tagCode, isMorph, hasStrokes) {
                    var count = stream.readUi8();
                    if (tagCode > 2    /* CODE_DEFINE_SHAPE */ && count === 255) {
                        count = stream.readUi16();
                    }
                    var styles = [];
                    var i = count;
                    while (i--) {
                        var style = {};
                        style.width = stream.readUi16();
                        if (isMorph) {
                            style.widthMorph = stream.readUi16();
                        }
                        if (hasStrokes) {
                            stream.align();
                            style.startCapsStyle = stream.readUb(2);
                            var jointStyle = style.jointStyle = stream.readUb(2);
                            var hasFill = style.hasFill = stream.readUb(1);
                            style.noHscale = !!stream.readUb(1);
                            style.noVscale = !!stream.readUb(1);
                            style.pixelHinting = !!stream.readUb(1);
                            stream.readUb(5);
                            style.noClose = !!stream.readUb(1);
                            style.endCapsStyle = stream.readUb(2);
                            if (jointStyle === 2) {
                                style.miterLimitFactor = stream.readFixed8();
                            }
                            if (hasFill) {
                                style.fillStyle = parseFillStyle(stream, swfVersion, tagCode, isMorph);
                            } else {
                                style.color = parseRgba(stream);
                                if (isMorph) {
                                    style.colorMorph = parseRgba(stream);
                                }
                            }
                        } else {
                            if (tagCode > 22    /* CODE_DEFINE_SHAPE2 */) {
                                style.color = parseRgba(stream);
                            } else {
                                style.color = parseRgb(stream);
                            }
                            if (isMorph) {
                                style.colorMorph = parseRgba(stream);
                            }
                        }
                        styles.push(style);
                    }
                    return styles;
                }
                function parseDefineVideoStreamTag(stream, swfVersion, tagCode) {
                    var tag = { code: tagCode };
                    tag.id = stream.readUi16();
                    tag.numFrames = stream.readUi16();
                    tag.width = stream.readUi16();
                    tag.height = stream.readUi16();
                    stream.readUb(4);
                    tag.deblocking = stream.readUb(3);
                    tag.smoothing = !!stream.readUb(1);
                    tag.codecId = stream.readUi8();
                    return tag;
                }
                function parseVideoFrameTag(stream, swfVersion, tagCode, tagEnd) {
                    var tag = { code: tagCode };
                    tag.streamId = stream.readUi16();
                    tag.frameNum = stream.readUi16();
                    tag.videoData = stream.bytes.subarray(stream.pos, tagEnd);
                    stream.pos = tagEnd;
                    return tag;
                }
                LowLevel.tagHandlers = {
                    /* End */
                    0: undefined,
                    /* ShowFrame */
                    1: undefined,
                    /* DefineShape */
                    2: parseDefineShapeTag,
                    /* PlaceObject */
                    4: parsePlaceObjectTag,
                    /* RemoveObject */
                    5: parseRemoveObjectTag,
                    /* DefineBits */
                    6: parseDefineImageTag,
                    /* DefineButton */
                    7: parseDefineButtonTag,
                    /* JPEGTables */
                    8: undefined,
                    /* SetBackgroundColor */
                    9: undefined,
                    /* DefineFont */
                    10: parseDefineFontTag,
                    /* DefineText */
                    11: parseDefineTextTag,
                    /* DoAction */
                    12: undefined,
                    /* DefineFontInfo */
                    13: undefined,
                    /* DefineSound */
                    14: parseDefineSoundTag,
                    /* StartSound */
                    15: parseStartSoundTag,
                    /* DefineButtonSound */
                    17: undefined,
                    /* SoundStreamHead */
                    18: undefined,
                    /* SoundStreamBlock */
                    19: undefined,
                    /* DefineBitsLossless */
                    20: parseDefineBitmapTag,
                    /* DefineBitsJPEG2 */
                    21: parseDefineImageTag,
                    /* DefineShape2 */
                    22: parseDefineShapeTag,
                    /* DefineButtonCxform */
                    23: undefined,
                    /* Protect */
                    24: undefined,
                    /* PlaceObject2 */
                    26: parsePlaceObjectTag,
                    /* RemoveObject2 */
                    28: parseRemoveObjectTag,
                    /* DefineShape3 */
                    32: parseDefineShapeTag,
                    /* DefineText2 */
                    33: parseDefineTextTag,
                    /* DefineButton2 */
                    34: parseDefineButtonTag,
                    /* DefineBitsJPEG3 */
                    35: parseDefineImageTag,
                    /* DefineBitsLossless2 */
                    36: parseDefineBitmapTag,
                    /* DefineEditText */
                    37: parseDefineEditTextTag,
                    /* DefineSprite */
                    39: undefined,
                    /* FrameLabel */
                    43: undefined,
                    /* SoundStreamHead2 */
                    45: undefined,
                    /* DefineMorphShape */
                    46: parseDefineShapeTag,
                    /* DefineFont2 */
                    48: parseDefineFont2Tag,
                    /* ExportAssets */
                    56: undefined,
                    /* ImportAssets */
                    57: undefined,
                    /* EnableDebugger */
                    58: undefined,
                    /* DoInitAction */
                    59: undefined,
                    /* DefineVideoStream */
                    60: parseDefineVideoStreamTag,
                    /* VideoFrame */
                    61: parseVideoFrameTag,
                    /* DefineFontInfo2 */
                    62: undefined,
                    /* EnableDebugger2 */
                    64: undefined,
                    /* ScriptLimits */
                    65: undefined,
                    /* SetTabIndex */
                    66: undefined,
                    /* FileAttributes */
                    69: undefined,
                    /* PlaceObject3 */
                    70: parsePlaceObjectTag,
                    /* ImportAssets2 */
                    71: undefined,
                    /* DoABC (undoc) */
                    72: undefined,
                    /* DefineFontAlignZones */
                    73: undefined,
                    /* CSMTextSettings */
                    74: undefined,
                    /* DefineFont3 */
                    75: parseDefineFont2Tag,
                    /* SymbolClass */
                    76: undefined,
                    /* Metadata */
                    77: undefined,
                    /* DefineScalingGrid */
                    78: parseDefineScalingGridTag,
                    /* DoABC */
                    82: undefined,
                    /* DefineShape4 */
                    83: parseDefineShapeTag,
                    /* DefineMorphShape2 */
                    84: parseDefineShapeTag,
                    /* DefineSceneAndFrameLabelData */
                    86: parseDefineSceneTag,
                    /* DefineBinaryData */
                    87: parseDefineBinaryDataTag,
                    /* DefineFontName */
                    88: undefined,
                    /* StartSound2 */
                    89: parseStartSoundTag,
                    /* DefineBitsJPEG4 */
                    90: parseDefineImageTag,
                    /* DefineFont4 */
                    91: parseDefineFont4Tag
                };
                function parseHeader(stream) {
                    var bits = stream.readUb(5);
                    var xMin = stream.readSb(bits);
                    var xMax = stream.readSb(bits);
                    var yMin = stream.readSb(bits);
                    var yMax = stream.readSb(bits);
                    stream.align();
                    var frameRateFraction = stream.readUi8();
                    var frameRate = stream.readUi8() + frameRateFraction / 256;
                    var frameCount = stream.readUi16();
                    return {
                        frameRate: frameRate,
                        frameCount: frameCount,
                        bounds: new Shumway.Bounds(xMin, yMin, xMax, yMax)
                    };
                }
                LowLevel.parseHeader = parseHeader;
            }(LowLevel = Parser.LowLevel || (Parser.LowLevel = {})));
            var assert = Shumway.Debug.assert;
            var notImplemented = Shumway.Debug.notImplemented;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var roundToMultipleOfFour = Shumway.IntegerUtilities.roundToMultipleOfFour;
            var Inflate = Shumway.ArrayUtilities.Inflate;
            /** @const */
            var FACTOR_5BBP = 255 / 31;
            /*
             * Returns a Uint8Array of ARGB values. The source image is color mapped meaning
             * that the buffer is first prefixed with a color table:
             *
             * +--------------|--------------------------------------------------+
             * | Color Table  |  Image Data (byte indices into the color table)  |
             * +--------------|--------------------------------------------------+
             *
             * Color Table entries are either in RGB or RGBA format.
             *
             * There are two variations of these file formats, with or without alpha.
             *
             * Row pixels always start at 32 bit alinged offsets, the color table as
             * well as the end of each row may be padded so that the next row of pixels
             * is aligned.
             */
            function parseColorMapped(tag) {
                var width = tag.width, height = tag.height;
                var hasAlpha = tag.hasAlpha;
                var padding = roundToMultipleOfFour(width) - width;
                var colorTableLength = tag.colorTableSize + 1;
                var colorTableEntrySize = hasAlpha ? 4 : 3;
                var colorTableSize = roundToMultipleOfFour(colorTableLength * colorTableEntrySize);
                var dataSize = colorTableSize + (width + padding) * height;
                var bytes = Inflate.inflate(tag.bmpData, dataSize, true);
                var view = new Uint32Array(width * height);
                // TODO: Figure out why this fails.
                // Make sure we've deflated enough bytes.
                // stream.ensure(dataSize);
                var p = colorTableSize, i = 0, offset = 0;
                if (hasAlpha) {
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            offset = bytes[p++] << 2;
                            var a = bytes[offset + 3];
                            // A
                            var r = bytes[offset + 0];
                            // R
                            var g = bytes[offset + 1];
                            // G
                            var b = bytes[offset + 2];
                            // B
                            view[i++] = b << 24 | g << 16 | r << 8 | a;
                        }
                        p += padding;
                    }
                } else {
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            offset = bytes[p++] * colorTableEntrySize;
                            var a = 255;
                            // A
                            var r = bytes[offset + 0];
                            // R
                            var g = bytes[offset + 1];
                            // G
                            var b = bytes[offset + 2];
                            // B
                            view[i++] = b << 24 | g << 16 | r << 8 | a;
                        }
                        p += padding;
                    }
                }
                release || assert(p === dataSize, 'We should be at the end of the data buffer now.');
                release || assert(i === width * height, 'Should have filled the entire image.');
                return new Uint8Array(view.buffer);
            }
            /**
             * Returns a Uint8Array of ARGB values. The data is already stored in premultiplied ARGB
             * so there's not much to do unless there's no alpha in which case we expand it here.
             */
            function parse24BPP(tag) {
                var width = tag.width, height = tag.height;
                var hasAlpha = tag.hasAlpha;
                // Even without alpha, 24BPP is stored as 4 bytes, probably for alignment reasons.
                var dataSize = height * width * 4;
                var bytes = Inflate.inflate(tag.bmpData, dataSize, true);
                if (hasAlpha) {
                    return bytes;
                }
                var view = new Uint32Array(width * height);
                var length = width * height, p = 0;
                // TODO: Looks like we can probably get away with just setting alpha to 0xff instead of
                // reading the entire buffer.
                for (var i = 0; i < length; i++) {
                    p++;
                    // Reserved, always zero.
                    var r = bytes[p++];
                    var g = bytes[p++];
                    var b = bytes[p++];
                    view[i] = b << 24 | g << 16 | r << 8 | 255;
                }
                release || assert(p === dataSize, 'We should be at the end of the data buffer now.');
                return new Uint8Array(view.buffer);
            }
            function parse15BPP(tag) {
                release || notImplemented('parse15BPP');
                /*
                  case FORMAT_15BPP:
                    var colorType = 0x02;
                    var bytesPerLine = ((width * 2) + 3) & ~3;
                    var stream = createInflatedStream(bmpData, bytesPerLine * height);
            
                    for (var y = 0, i = 0; y < height; ++y) {
                      stream.ensure(bytesPerLine);
                      for (var x = 0; x < width; ++x, i += 4) {
                        var word = stream.readUi16();
                        // Extracting RGB color components and changing values range
                        // from 0..31 to 0..255.
                        data[i] = 0 | (FACTOR_5BBP * ((word >> 10) & 0x1f));
                        data[i + 1] = 0 | (FACTOR_5BBP * ((word >> 5) & 0x1f));
                        data[i + 2] = 0 | (FACTOR_5BBP * (word & 0x1f));
                        data[i + 3] = 255;
                      }
                      stream += bytesPerLine;
                    }
                    break;
                  */
                return null;
            }
            function defineBitmap(tag) {
                SWF.enterTimeline('defineBitmap');
                var data;
                var type = Shumway.ImageType.None;
                switch (tag.format) {
                case 3    /* FORMAT_COLORMAPPED */:
                    data = parseColorMapped(tag);
                    type = Shumway.ImageType.PremultipliedAlphaARGB;
                    break;
                case 5    /* FORMAT_24BPP */:
                    data = parse24BPP(tag);
                    type = Shumway.ImageType.PremultipliedAlphaARGB;
                    break;
                case 4    /* FORMAT_15BPP */:
                    data = parse15BPP(tag);
                    type = Shumway.ImageType.PremultipliedAlphaARGB;
                    break;
                default:
                    release || assertUnreachable('invalid bitmap format');
                }
                SWF.leaveTimeline();
                return {
                    definition: {
                        type: 'image',
                        id: tag.id,
                        width: tag.width,
                        height: tag.height,
                        mimeType: 'application/octet-stream',
                        data: data,
                        dataType: type,
                        image: null
                    },
                    type: 'image'
                };
            }
            Parser.defineBitmap = defineBitmap;
            function defineButton(tag, dictionary) {
                var characters = tag.characters;
                var states = {
                    up: [],
                    over: [],
                    down: [],
                    hitTest: []
                };
                var i = 0, character;
                while (character = characters[i++]) {
                    var characterItem = dictionary[character.symbolId];
                    // The Flash Player ignores references to undefined symbols here. So should we.
                    // TODO: What should happen if the symbol gets defined later in the file?
                    if (characterItem) {
                        var cmd = {
                            symbolId: characterItem.id,
                            code: 4    /* CODE_PLACE_OBJECT */,
                            depth: character.depth,
                            flags: character.matrix ? 4    /* HasMatrix */ : 0,
                            matrix: character.matrix
                        };
                        if (character.flags & 1    /* StateUp */)
                            states.up.push(cmd);
                        if (character.flags & 2    /* StateOver */)
                            states.over.push(cmd);
                        if (character.flags & 4    /* StateDown */)
                            states.down.push(cmd);
                        if (character.flags & 8    /* StateHitTest */)
                            states.hitTest.push(cmd);
                    } else {
                        release || Shumway.Debug.warning('undefined character in button ' + tag.id);
                    }
                }
                var button = {
                    type: 'button',
                    id: tag.id,
                    buttonActions: tag.buttonActions,
                    states: states
                };
                return button;
            }
            Parser.defineButton = defineButton;
            var pow = Math.pow;
            var min = Math.min;
            var max = Math.max;
            var logE = Math.log;
            var fromCharCode = String.fromCharCode;
            var nextFontId = 1;
            function maxPower2(num) {
                var maxPower = 0;
                var val = num;
                while (val >= 2) {
                    val /= 2;
                    ++maxPower;
                }
                return pow(2, maxPower);
            }
            function toString16(val) {
                return fromCharCode(val >> 8 & 255, val & 255);
            }
            function toString32(val) {
                return toString16(val >> 16) + toString16(val);
            }
            /**
             * Heuristic to detect if DefineFont2 was scaled as Font3: scanning all
             * x and y coordinates of the glyphs and if their bounding box dimensions
             * greater than 5000 (that's more than enough for normal TrueType font),
             * then the font coordinates were scaled by 20.
             */
            function isScaledFont2(glyphs) {
                var xMin = 0, yMin = 0, xMax = 0, yMax = 0;
                for (var i = 0; i < glyphs.length; i++) {
                    var records = glyphs[i];
                    if (!records) {
                        continue;
                    }
                    var record;
                    var x = 0;
                    var y = 0;
                    for (var j = 0; j < records.length; j++) {
                        record = records[j];
                        if (record.type) {
                            if (record.flags & 32    /* IsStraight */) {
                                x += record.deltaX || 0;
                                y += -(record.deltaY || 0);
                            } else {
                                x += record.controlDeltaX;
                                y += -record.controlDeltaY;
                                x += record.anchorDeltaX;
                                y += -record.anchorDeltaY;
                            }
                        } else {
                            if (record.flags & 1    /* Move */) {
                                x = record.moveX;
                                y = -record.moveY;
                            }
                        }
                        if (xMin > x) {
                            xMin = x;
                        }
                        if (yMin > y) {
                            yMin = y;
                        }
                        if (xMax < x) {
                            xMax = x;
                        }
                        if (yMax < y) {
                            yMax = y;
                        }
                    }
                }
                var maxDimension = Math.max(xMax - xMin, yMax - yMin);
                return maxDimension > 5000;
            }
            function defineFont(tag) {
                var uniqueName = 'swf-font-' + tag.id;
                var fontName = tag.name || uniqueName;
                var font = {
                    type: 'font',
                    id: tag.id,
                    name: fontName,
                    bold: !!(tag.flags & 1    /* Bold */),
                    italic: !!(tag.flags & 2    /* Italic */),
                    codes: null,
                    metrics: null,
                    data: tag.data,
                    originalSize: false
                };
                var glyphs = tag.glyphs;
                var glyphCount = glyphs ? glyphs.length : 0;
                if (!glyphCount) {
                    return font;
                }
                var tables = {};
                var codes = [];
                var glyphIndex = {};
                var ranges = [];
                var originalCode;
                var generateAdvancement = !('advance' in tag);
                var correction = 0;
                var isFont2 = tag.code === 48    /* CODE_DEFINE_FONT2 */;
                var isFont3 = tag.code === 75    /* CODE_DEFINE_FONT3 */;
                if (generateAdvancement) {
                    tag.advance = [];
                }
                var maxCode = Math.max.apply(null, tag.codes) || 35;
                if (tag.codes) {
                    for (var i = 0; i < tag.codes.length; i++) {
                        var code = tag.codes[i];
                        if (code < 32 || code in glyphIndex) {
                            maxCode++;
                            if (maxCode == 8232) {
                                maxCode = 8240;
                            }
                            code = maxCode;
                        }
                        codes.push(code);
                        glyphIndex[code] = i;
                    }
                    originalCode = codes.concat();
                    codes.sort(function (a, b) {
                        return a - b;
                    });
                    var i = 0;
                    var code;
                    var indices;
                    while ((code = codes[i++]) !== undefined) {
                        var start = code;
                        var end = start;
                        indices = [i - 1];
                        while ((code = codes[i]) !== undefined && end + 1 === code) {
                            ++end;
                            indices.push(i);
                            ++i;
                        }
                        ranges.push([
                            start,
                            end,
                            indices
                        ]);
                    }
                } else {
                    indices = [];
                    var UAC_OFFSET = 57344;
                    for (var i = 0; i < glyphCount; i++) {
                        code = UAC_OFFSET + i;
                        codes.push(code);
                        glyphIndex[code] = i;
                        indices.push(i);
                    }
                    ranges.push([
                        UAC_OFFSET,
                        UAC_OFFSET + glyphCount - 1,
                        indices
                    ]);
                    originalCode = codes.concat();
                }
                var resolution = tag.resolution || 1;
                if (isFont2 && isScaledFont2(glyphs)) {
                    // some DefineFont2 without layout using DefineFont3 resolution, why?
                    resolution = 20;
                    font.originalSize = true;
                }
                var ascent = Math.ceil(tag.ascent / resolution) || 1024;
                var descent = -Math.ceil(tag.descent / resolution) || 0;
                var leading = tag.leading / resolution || 0;
                tables['OS/2'] = '';
                var startCount = '';
                var endCount = '';
                var idDelta = '';
                var idRangeOffset = '';
                var i = 0;
                var range;
                while (range = ranges[i++]) {
                    var start = range[0];
                    var end = range[1];
                    var code = range[2][0];
                    startCount += toString16(start);
                    endCount += toString16(end);
                    idDelta += toString16(code - start + 1 & 65535);
                    idRangeOffset += toString16(0);
                }
                endCount += '\xFF\xFF';
                startCount += '\xFF\xFF';
                idDelta += '\0\x01';
                idRangeOffset += '\0\0';
                var segCount = ranges.length + 1;
                var searchRange = maxPower2(segCount) * 2;
                var rangeShift = 2 * segCount - searchRange;
                var format314 = '\0\0' + toString16(segCount * 2) + toString16(searchRange) + toString16(logE(segCount) / logE(2)) + toString16(rangeShift) + endCount + '\0\0' + startCount + idDelta + idRangeOffset;
                tables['cmap'] = '\0\0' + '\0\x01' + '\0\x03' + '\0\x01' + '\0\0\0\f' + '\0\x04' + toString16(format314.length + 4) + format314;
                var glyf = '\0\x01\0\0\0\0\0\0\0\0\0\0\0\x001\0';
                var loca = '\0\0';
                var offset = 16;
                var maxPoints = 0;
                var xMins = [];
                var xMaxs = [];
                var yMins = [];
                var yMaxs = [];
                var maxContours = 0;
                var i = 0;
                var code;
                var rawData = {};
                while ((code = codes[i++]) !== undefined) {
                    var records = glyphs[glyphIndex[code]];
                    var x = 0;
                    var y = 0;
                    var myFlags = '';
                    var myEndpts = '';
                    var endPoint = 0;
                    var segments = [];
                    var segmentIndex = -1;
                    for (var j = 0; j < records.length; j++) {
                        record = records[j];
                        if (record.type) {
                            if (segmentIndex < 0) {
                                segmentIndex = 0;
                                segments[segmentIndex] = {
                                    data: [],
                                    commands: [],
                                    xMin: 0,
                                    xMax: 0,
                                    yMin: 0,
                                    yMax: 0
                                };
                            }
                            if (record.flags & 32    /* IsStraight */) {
                                segments[segmentIndex].commands.push(2);
                                var dx = (record.deltaX || 0) / resolution;
                                var dy = -(record.deltaY || 0) / resolution;
                                x += dx;
                                y += dy;
                                segments[segmentIndex].data.push(x, y);
                            } else {
                                segments[segmentIndex].commands.push(3);
                                var cx = record.controlDeltaX / resolution;
                                var cy = -record.controlDeltaY / resolution;
                                x += cx;
                                y += cy;
                                segments[segmentIndex].data.push(x, y);
                                var dx = record.anchorDeltaX / resolution;
                                var dy = -record.anchorDeltaY / resolution;
                                x += dx;
                                y += dy;
                                segments[segmentIndex].data.push(x, y);
                            }
                        } else {
                            if (record.flags & 1    /* Move */) {
                                segmentIndex++;
                                segments[segmentIndex] = {
                                    data: [],
                                    commands: [],
                                    xMin: 0,
                                    xMax: 0,
                                    yMin: 0,
                                    yMax: 0
                                };
                                segments[segmentIndex].commands.push(1);
                                var moveX = record.moveX / resolution;
                                var moveY = -record.moveY / resolution;
                                var dx = moveX - x;
                                var dy = moveY - y;
                                x = moveX;
                                y = moveY;
                                segments[segmentIndex].data.push(x, y);
                            }
                        }
                        if (segmentIndex > -1) {
                            if (segments[segmentIndex].xMin > x) {
                                segments[segmentIndex].xMin = x;
                            }
                            if (segments[segmentIndex].yMin > y) {
                                segments[segmentIndex].yMin = y;
                            }
                            if (segments[segmentIndex].xMax < x) {
                                segments[segmentIndex].xMax = x;
                            }
                            if (segments[segmentIndex].yMax < y) {
                                segments[segmentIndex].yMax = y;
                            }
                        }
                    }
                    if (!isFont3) {
                        segments.sort(function (a, b) {
                            return (b.xMax - b.xMin) * (b.yMax - b.yMin) - (a.xMax - a.xMin) * (a.yMax - a.yMin);
                        });
                    }
                    rawData[code] = segments;
                }
                i = 0;
                while ((code = codes[i++]) !== undefined) {
                    var records = glyphs[glyphIndex[code]];
                    segments = rawData[code];
                    var numberOfContours = 1;
                    var endPoint = 0;
                    var endPtsOfContours = '';
                    var flags = '';
                    var xCoordinates = '';
                    var yCoordinates = '';
                    var x = 0;
                    var y = 0;
                    var xMin = 0;
                    var xMax = -1024;
                    var yMin = 0;
                    var yMax = -1024;
                    var myFlags = '';
                    var myEndpts = '';
                    var endPoint = 0;
                    var segmentIndex = -1;
                    var data = [];
                    var commands = [];
                    for (j = 0; j < segments.length; j++) {
                        data = data.concat(segments[j].data);
                        commands = commands.concat(segments[j].commands);
                    }
                    x = 0;
                    y = 0;
                    var nx = 0;
                    var ny = 0;
                    var myXCoordinates = '';
                    var myYCoordinates = '';
                    var dataIndex = 0;
                    var endPoint = 0;
                    var numberOfContours = 1;
                    var myEndpts = '';
                    for (j = 0; j < commands.length; j++) {
                        var command = commands[j];
                        if (command === 1) {
                            if (endPoint) {
                                ++numberOfContours;
                                myEndpts += toString16(endPoint - 1);
                            }
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var dx = nx - x;
                            var dy = ny - y;
                            myFlags += '\x01';
                            myXCoordinates += toString16(dx);
                            myYCoordinates += toString16(dy);
                            x = nx;
                            y = ny;
                        } else if (command === 2) {
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var dx = nx - x;
                            var dy = ny - y;
                            myFlags += '\x01';
                            myXCoordinates += toString16(dx);
                            myYCoordinates += toString16(dy);
                            x = nx;
                            y = ny;
                        } else if (command === 3) {
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var cx = nx - x;
                            var cy = ny - y;
                            myFlags += '\0';
                            myXCoordinates += toString16(cx);
                            myYCoordinates += toString16(cy);
                            x = nx;
                            y = ny;
                            endPoint++;
                            nx = data[dataIndex++];
                            ny = data[dataIndex++];
                            var cx = nx - x;
                            var cy = ny - y;
                            myFlags += '\x01';
                            myXCoordinates += toString16(cx);
                            myYCoordinates += toString16(cy);
                            x = nx;
                            y = ny;
                        }
                        endPoint++;
                        if (endPoint > maxPoints) {
                            maxPoints = endPoint;
                        }
                        if (xMin > x) {
                            xMin = x;
                        }
                        if (yMin > y) {
                            yMin = y;
                        }
                        if (xMax < x) {
                            xMax = x;
                        }
                        if (yMax < y) {
                            yMax = y;
                        }
                    }
                    myEndpts += toString16((endPoint || 1) - 1);
                    endPtsOfContours = myEndpts;
                    xCoordinates = myXCoordinates;
                    yCoordinates = myYCoordinates;
                    flags = myFlags;
                    if (!j) {
                        xMin = xMax = yMin = yMax = 0;
                        flags += '1';
                    }
                    var entry = toString16(numberOfContours) + toString16(xMin) + toString16(yMin) + toString16(xMax) + toString16(yMax) + endPtsOfContours + '\0\0' + flags + xCoordinates + yCoordinates;
                    if (entry.length & 1) {
                        entry += '\0';
                    }
                    glyf += entry;
                    loca += toString16(offset / 2);
                    offset += entry.length;
                    xMins.push(xMin);
                    xMaxs.push(xMax);
                    yMins.push(yMin);
                    yMaxs.push(yMax);
                    if (numberOfContours > maxContours) {
                        maxContours = numberOfContours;
                    }
                    if (endPoint > maxPoints) {
                        maxPoints = endPoint;
                    }
                    if (generateAdvancement) {
                        tag.advance.push((xMax - xMin) * resolution * 1.3);
                    }
                }
                loca += toString16(offset / 2);
                tables['glyf'] = glyf;
                if (!isFont3) {
                    var minYmin = Math.min.apply(null, yMins);
                    if (minYmin < 0) {
                        descent = descent || minYmin;
                    }
                }
                tables['OS/2'] = '\0\x01' + '\0\0' + toString16(font.bold ? 700 : 400) + '\0\x05' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0\0\0\0\0\0\0\0\0' + '\0\0\0\0' + '\0\0\0\0' + '\0\0\0\0' + '\0\0\0\0' + 'ALF ' + toString16((font.italic ? 1 : 0) | (font.bold ? 32 : 0)) + toString16(codes[0]) + toString16(codes[codes.length - 1]) + toString16(ascent) + toString16(descent) + toString16(leading) + toString16(ascent) + toString16(-descent) + '\0\0\0\0' + '\0\0\0\0'    // ulCodePageRange2
;
                tables['head'] = '\0\x01\0\0' + '\0\x01\0\0' + '\0\0\0\0' + '_\x0F<\xF5' + '\0\x0B' + '\x04\0' + '\0\0\0\0' + toString32(Date.now()) + '\0\0\0\0' + toString32(Date.now()) + toString16(min.apply(null, xMins)) + toString16(min.apply(null, yMins)) + toString16(max.apply(null, xMaxs)) + toString16(max.apply(null, yMaxs)) + toString16((font.italic ? 2 : 0) | (font.bold ? 1 : 0)) + '\0\b' + '\0\x02' + '\0\0' + '\0\0'    // glyphDataFormat
;
                var advance = tag.advance;
                tables['hhea'] = '\0\x01\0\0' + toString16(ascent) + toString16(descent) + toString16(leading) + toString16(advance ? max.apply(null, advance) : 1024) + '\0\0' + '\0\0' + '\x03\xB8' + '\0\x01' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + toString16(glyphCount + 1)    // numberOfHMetrics
;
                var hmtx = '\0\0\0\0';
                for (var i = 0; i < glyphCount; ++i) {
                    hmtx += toString16(advance ? advance[i] / resolution : 1024) + '\0\0';
                }
                tables['hmtx'] = hmtx;
                if (tag.kerning && tag.kerning.length) {
                    var kerning = tag.kerning;
                    var nPairs = kerning.length;
                    var searchRange = maxPower2(nPairs) * 2;
                    var kern = '\0\0' + '\0\x01' + '\0\0' + toString16(14 + nPairs * 6) + '\0\x01' + toString16(nPairs) + toString16(searchRange) + toString16(logE(nPairs) / logE(2)) + toString16(2 * nPairs - searchRange);
                    var i = 0;
                    var record;
                    while (record = kerning[i++]) {
                        kern += toString16(glyphIndex[record.code1]) + toString16(glyphIndex[record.code2]) + toString16(record.adjustment)    // value
;
                    }
                    tables['kern'] = kern;
                }
                tables['loca'] = loca;
                tables['maxp'] = '\0\x01\0\0' + toString16(glyphCount + 1) + toString16(maxPoints) + toString16(maxContours) + '\0\0' + '\0\0' + '\0\x01' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0' + '\0\0'    // maxComponentDepth
;
                var psName = fontName.replace(/ /g, '');
                var strings = [
                    tag.copyright || 'Original licence',
                    fontName,
                    'Unknown',
                    uniqueName,
                    fontName,
                    '1.0',
                    psName,
                    'Unknown',
                    'Unknown',
                    'Unknown'    // 9. Designer
                ];
                var count = strings.length;
                var name = '\0\0' + toString16(count) + toString16(count * 12 + 6);
                // stringOffset
                var offset = 0;
                var i = 0;
                var str;
                while (str = strings[i++]) {
                    name += '\0\x01' + '\0\0' + '\0\0' + toString16(i - 1) + toString16(str.length) + toString16(offset);
                    offset += str.length;
                }
                tables['name'] = name + strings.join('');
                tables['post'] = '\0\x03\0\0' + '\0\0\0\0' + '\0\0' + '\0\0' + '\0\0\0\0' + '\0\0\0\0' + '\0\0\0\0' + '\0\0\0\0' + '\0\0\0\0'    // maxMemType1
;
                var names = Object.keys(tables);
                var numTables = names.length;
                var header = '\0\x01\0\0' + toString16(numTables) + '\0\x80' + '\0\x03' + '\0 ';
                var dataString = '';
                var offset = numTables * 16 + header.length;
                var i = 0;
                while (name = names[i++]) {
                    var table = tables[name];
                    var length = table.length;
                    header += name + '\0\0\0\0' + toString32(offset) + toString32(length);
                    while (length & 3) {
                        table += '\0';
                        ++length;
                    }
                    dataString += table;
                    while (offset & 3) {
                        ++offset;
                    }
                    offset += length;
                }
                var otf = header + dataString;
                var unitPerEm = 1024;
                var metrics = {
                    ascent: ascent / unitPerEm,
                    descent: -descent / unitPerEm,
                    leading: leading / unitPerEm
                };
                // TODO: use a buffer to generate font data
                var dataBuffer = new Uint8Array(otf.length);
                for (var i = 0; i < otf.length; i++) {
                    dataBuffer[i] = otf.charCodeAt(i) & 255;
                }
                font.codes = originalCode;
                font.metrics = metrics;
                font.data = dataBuffer;
                return font;
            }
            Parser.defineFont = defineFont;
            var Inflate = Shumway.ArrayUtilities.Inflate;
            /**
             * Reads the next two bytes at the specified position.
             */
            function readUint16(bytes, position) {
                return bytes[position] << 8 | bytes[position + 1];
            }
            /**
             * Reads the next four bytes at the specified position.
             */
            function readInt32(bytes, position) {
                return bytes[position] << 24 | bytes[position + 1] << 16 | bytes[position + 2] << 8 | bytes[position + 3];
            }
            /**
             * Parses JPEG chunks and reads image width and height information. JPEG data
             * in SWFs is encoded in chunks and not directly decodable by the JPEG parser.
             */
            function parseJpegChunks(bytes, chunks) {
                var i = 0;
                var n = bytes.length;
                // Finding first marker, and skipping the data before this marker.
                // (FF 00 - code is escaped FF; FF FF ... (FF xx) - fill bytes before marker).
                while (i < n && (bytes[i] !== 255 || i + 1 < n && (bytes[i + 1] === 0 || bytes[i + 1] === 255))) {
                    ++i;
                }
                if (i >= n) {
                    return;    // no valid data was found
                }
                do {
                    release || Shumway.Debug.assert(bytes[i] === 255);
                    var begin = i++;
                    var code = bytes[i++];
                    // Some tags have length field -- using it
                    if (code >= 192 && code <= 199 || code >= 201 && code <= 207 || code >= 218 && code <= 239 || code === 254) {
                        var length = readUint16(bytes, i);
                        i += length;
                    }
                    // Finding next marker.
                    while (i < n && (bytes[i] !== 255 || i + 1 < n && (bytes[i + 1] === 0 || bytes[i + 1] === 255))) {
                        ++i;
                    }
                    if (code === 216 || code === 217) {
                        // Removing SOI and EOI to avoid wrong EOI-SOI pairs in the middle.
                        continue;
                    }
                    chunks.push(bytes.subarray(begin, i));
                } while (i < n);
            }
            Parser.parseJpegChunks = parseJpegChunks;
            /**
             * Extracts PNG width and height information.
             */
            function parsePngHeaders(image, bytes) {
                var ihdrOffset = 12;
                if (bytes[ihdrOffset] !== 73 || bytes[ihdrOffset + 1] !== 72 || bytes[ihdrOffset + 2] !== 68 || bytes[ihdrOffset + 3] !== 82) {
                    return;
                }
                image.width = readInt32(bytes, ihdrOffset + 4);
                image.height = readInt32(bytes, ihdrOffset + 8);
                var type = bytes[ihdrOffset + 14];
                image.hasAlpha = type === 4 || type === 6;
            }
            Parser.parsePngHeaders = parsePngHeaders;
            /**
             * Joins all the chunks in a larger byte array.
             */
            function joinChunks(chunks) {
                var length = 0;
                for (var i = 0; i < chunks.length; i++) {
                    length += chunks[i].length;
                }
                var bytes = new Uint8Array(length);
                var offset = 0;
                for (var i = 0; i < chunks.length; i++) {
                    var chunk = chunks[i];
                    bytes.set(chunk, offset);
                    offset += chunk.length;
                }
                return bytes;
            }
            function injectJPEGTables(chunks, state) {
                if (!state.parsedChunks) {
                    var parsedChunks = [];
                    parseJpegChunks(state.data, parsedChunks);
                    state.parsedChunks = parsedChunks;
                }
                // Finding first SOF and inserting tables there
                var i = 0;
                while (i < chunks.length && !(chunks[i][1] >= 192 && chunks[i][1] <= 192)) {
                    i++;
                }
                Array.prototype.splice.apply(chunks, Array.prototype.concat.call([
                    i,
                    0
                ], state.parsedChunks));
            }
            var JPEG_SOI = new Uint8Array([
                255,
                216
            ]);
            var JPEG_EOI = new Uint8Array([
                255,
                217
            ]);
            function defineImage(tag) {
                SWF.enterTimeline('defineImage');
                var image = {
                    type: 'image',
                    id: tag.id,
                    mimeType: tag.mimeType
                };
                var imgData = tag.imgData;
                if (tag.mimeType === 'image/jpeg') {
                    // Parsing/repairing the SWF JPEG data.
                    var chunks = [];
                    chunks.push(JPEG_SOI);
                    parseJpegChunks(imgData, chunks);
                    if (tag.jpegTables) {
                        injectJPEGTables(chunks, tag.jpegTables);
                    }
                    chunks.push(JPEG_EOI);
                    // Finding SOF to extract image size.
                    chunks.forEach(function (chunk) {
                        var code = chunk[1];
                        if (code >= 192 && code <= 195) {
                            image.height = readUint16(chunk, 5);
                            image.width = readUint16(chunk, 7);
                        }
                    });
                    image.data = joinChunks(chunks);
                    image.dataType = Shumway.ImageType.JPEG;
                    var alphaData = tag.alphaData;
                    if (alphaData) {
                        var length = image.width * image.height;
                        try {
                            image.alphaData = Inflate.inflate(alphaData, length, true);
                        } catch (e) {
                            // Alpha layer is invalid, so hiding everything.
                            image.alphaData = new Uint8Array(length);
                        }
                    }
                } else {
                    parsePngHeaders(image, imgData);
                    image.data = imgData;
                    image.dataType = Shumway.ImageType.PNG;
                }
                SWF.leaveTimeline();
                return image;
            }
            Parser.defineImage = defineImage;
            function defineLabel(tag) {
                var label = {
                    type: 'label',
                    id: tag.id,
                    fillBounds: tag.bbox,
                    matrix: tag.matrix,
                    tag: {
                        hasText: true,
                        initialText: '',
                        html: true,
                        readonly: true
                    },
                    records: tag.records,
                    coords: null,
                    static: true,
                    require: null
                };
                return label;
            }
            Parser.defineLabel = defineLabel;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var ShapeData = Shumway.ShapeData;
            var clamp = Shumway.NumberUtilities.clamp;
            var assert = Shumway.Debug.assert;
            var assertUnreachable = Shumway.Debug.assertUnreachable;
            var push = Array.prototype.push;
            var FillType;
            (function (FillType) {
                FillType[FillType['Solid'] = 0] = 'Solid';
                FillType[FillType['LinearGradient'] = 16] = 'LinearGradient';
                FillType[FillType['RadialGradient'] = 18] = 'RadialGradient';
                FillType[FillType['FocalRadialGradient'] = 19] = 'FocalRadialGradient';
                FillType[FillType['RepeatingBitmap'] = 64] = 'RepeatingBitmap';
                FillType[FillType['ClippedBitmap'] = 65] = 'ClippedBitmap';
                FillType[FillType['NonsmoothedRepeatingBitmap'] = 66] = 'NonsmoothedRepeatingBitmap';
                FillType[FillType['NonsmoothedClippedBitmap'] = 67] = 'NonsmoothedClippedBitmap';
            }(FillType || (FillType = {})));
            /*
             * Applies the current segment to the paths of all styles specified in the last
             * style-change record.
             *
             * For fill0, we have to apply commands and their data in reverse order, to turn
             * left fills into right ones.
             *
             * If we have more than one style, we only recorded commands for the first one
             * and have to duplicate them for the other styles. The order is: fill1, line,
             * fill0. (That means we only ever recorded into fill0 if that's the only style.)
             */
            function applySegmentToStyles(segment, styles, linePaths, fillPaths) {
                if (!segment) {
                    return;
                }
                var path;
                if (styles.fill0) {
                    path = fillPaths[styles.fill0 - 1];
                    // If fill0 is the only style, we have pushed the segment to its stack. In
                    // that case, just mark it as reversed and move on.
                    if (!(styles.fill1 || styles.line)) {
                        segment.isReversed = true;
                        return;
                    } else {
                        path.addSegment(segment.toReversed());
                    }
                }
                if (styles.line && styles.fill1) {
                    path = linePaths[styles.line - 1];
                    path.addSegment(segment.clone());
                }
            }
            /*
             * Converts records from the space-optimized format they're stored in to a
             * format that's more amenable to fast rendering.
             *
             * See http://blogs.msdn.com/b/mswanson/archive/2006/02/27/539749.aspx and
             * http://wahlers.com.br/claus/blog/hacking-swf-1-shapes-in-flash/ for details.
             */
            function convertRecordsToShapeData(records, fillPaths, linePaths, dependencies, recordsMorph) {
                var isMorph = recordsMorph !== null;
                var styles = {
                    fill0: 0,
                    fill1: 0,
                    line: 0
                };
                var segment = null;
                // Fill- and line styles can be added by style change records in the middle of
                // a shape records list. This also causes the previous paths to be treated as
                // a group, so the lines don't get moved on top of any following fills.
                // To support this, we just append all current fill and line paths to a list
                // when new styles are introduced.
                var allPaths;
                // If no style is set for a segment of a path, a 1px transparent line is used.
                var defaultPath;
                var numRecords = records.length;
                var x = 0;
                var y = 0;
                var morphX = 0;
                var morphY = 0;
                var path;
                for (var i = 0, j = 0; i < numRecords; i++) {
                    var record = records[i];
                    var morphRecord;
                    if (isMorph) {
                        morphRecord = recordsMorph[j++];
                    }
                    // type 0 is a StyleChange record
                    if (record.type === 0) {
                        //TODO: make the `has*` fields bitflags
                        if (segment) {
                            applySegmentToStyles(segment, styles, linePaths, fillPaths);
                        }
                        if (record.flags & 16    /* HasNewStyles */) {
                            if (!allPaths) {
                                allPaths = [];
                            }
                            push.apply(allPaths, fillPaths);
                            fillPaths = createPathsList(record.fillStyles, false, isMorph, dependencies);
                            push.apply(allPaths, linePaths);
                            linePaths = createPathsList(record.lineStyles, true, isMorph, dependencies);
                            if (defaultPath) {
                                allPaths.push(defaultPath);
                                defaultPath = null;
                            }
                            styles = {
                                fill0: 0,
                                fill1: 0,
                                line: 0
                            };
                        }
                        if (record.flags & 2    /* HasFillStyle0 */) {
                            styles.fill0 = record.fillStyle0;
                        }
                        if (record.flags & 4    /* HasFillStyle1 */) {
                            styles.fill1 = record.fillStyle1;
                        }
                        if (record.flags & 8    /* HasLineStyle */) {
                            styles.line = record.lineStyle;
                        }
                        if (styles.fill1) {
                            path = fillPaths[styles.fill1 - 1];
                        } else if (styles.line) {
                            path = linePaths[styles.line - 1];
                        } else if (styles.fill0) {
                            path = fillPaths[styles.fill0 - 1];
                        }
                        if (record.flags & 1    /* Move */) {
                            x = record.moveX | 0;
                            y = record.moveY | 0;
                        }
                        // Very first record can be just fill/line-style definition record.
                        if (path) {
                            segment = PathSegment.FromDefaults(isMorph);
                            path.addSegment(segment);
                            // Move or not, we want this path segment to start where the last one
                            // left off. Even if the last one belonged to a different style.
                            // "Huh," you say? Yup.
                            if (!isMorph) {
                                segment.moveTo(x, y);
                            } else {
                                if (morphRecord.type === 0) {
                                    morphX = morphRecord.moveX | 0;
                                    morphY = morphRecord.moveY | 0;
                                } else {
                                    morphX = x;
                                    morphY = y;
                                    // Not all moveTos are reflected in morph data.
                                    // In that case, decrease morph data index.
                                    j--;
                                }
                                segment.morphMoveTo(x, y, morphX, morphY);
                            }
                        }
                    } else {
                        release || assert(record.type === 1);
                        if (!segment) {
                            if (!defaultPath) {
                                var style = {
                                    color: {
                                        red: 0,
                                        green: 0,
                                        blue: 0,
                                        alpha: 0
                                    },
                                    width: 20
                                };
                                defaultPath = new SegmentedPath(null, processStyle(style, true, isMorph, dependencies));
                            }
                            segment = PathSegment.FromDefaults(isMorph);
                            defaultPath.addSegment(segment);
                            if (!isMorph) {
                                segment.moveTo(x, y);
                            } else {
                                segment.morphMoveTo(x, y, morphX, morphY);
                            }
                        }
                        if (isMorph) {
                            // An invalid SWF might contain a move in the EndEdges list where the
                            // StartEdges list contains an edge. The Flash Player seems to skip it,
                            // so we do, too.
                            while (morphRecord && morphRecord.type === 0) {
                                morphRecord = recordsMorph[j++];
                            }
                            // The EndEdges list might be shorter than the StartEdges list. Reuse
                            // start edges as end edges in that case.
                            if (!morphRecord) {
                                morphRecord = record;
                            }
                        }
                        if (record.flags & 32    /* IsStraight */ && (!isMorph || morphRecord.flags & 32    /* IsStraight */)) {
                            x += record.deltaX | 0;
                            y += record.deltaY | 0;
                            if (!isMorph) {
                                segment.lineTo(x, y);
                            } else {
                                morphX += morphRecord.deltaX | 0;
                                morphY += morphRecord.deltaY | 0;
                                segment.morphLineTo(x, y, morphX, morphY);
                            }
                        } else {
                            var cx, cy;
                            var deltaX, deltaY;
                            if (!(record.flags & 32    /* IsStraight */)) {
                                cx = x + record.controlDeltaX | 0;
                                cy = y + record.controlDeltaY | 0;
                                x = cx + record.anchorDeltaX | 0;
                                y = cy + record.anchorDeltaY | 0;
                            } else {
                                deltaX = record.deltaX | 0;
                                deltaY = record.deltaY | 0;
                                cx = x + (deltaX >> 1);
                                cy = y + (deltaY >> 1);
                                x += deltaX;
                                y += deltaY;
                            }
                            if (!isMorph) {
                                segment.curveTo(cx, cy, x, y);
                            } else {
                                if (!(morphRecord.flags & 32    /* IsStraight */)) {
                                    var morphCX = morphX + morphRecord.controlDeltaX | 0;
                                    var morphCY = morphY + morphRecord.controlDeltaY | 0;
                                    morphX = morphCX + morphRecord.anchorDeltaX | 0;
                                    morphY = morphCY + morphRecord.anchorDeltaY | 0;
                                } else {
                                    deltaX = morphRecord.deltaX | 0;
                                    deltaY = morphRecord.deltaY | 0;
                                    var morphCX = morphX + (deltaX >> 1);
                                    var morphCY = morphY + (deltaY >> 1);
                                    morphX += deltaX;
                                    morphY += deltaY;
                                }
                                segment.morphCurveTo(cx, cy, x, y, morphCX, morphCY, morphX, morphY);
                            }
                        }
                    }
                }
                applySegmentToStyles(segment, styles, linePaths, fillPaths);
                // All current paths get appended to the allPaths list at the end. First fill,
                // then line paths.
                if (allPaths) {
                    push.apply(allPaths, fillPaths);
                } else {
                    allPaths = fillPaths;
                }
                push.apply(allPaths, linePaths);
                if (defaultPath) {
                    allPaths.push(defaultPath);
                }
                var shape = new ShapeData();
                if (isMorph) {
                    shape.morphCoordinates = new Int32Array(shape.coordinates.length);
                    shape.morphStyles = new DataBuffer(16);
                }
                for (i = 0; i < allPaths.length; i++) {
                    allPaths[i].serialize(shape);
                }
                return shape;
            }
            var IDENTITY_MATRIX = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            };
            function processStyle(style, isLineStyle, isMorph, dependencies) {
                var shapeStyle = style;
                if (isMorph) {
                    shapeStyle.morph = processMorphStyle(style, isLineStyle, dependencies);
                }
                if (isLineStyle) {
                    shapeStyle.miterLimit = (style.miterLimitFactor || 1.5) * 2;
                    if (!style.color && style.hasFill) {
                        var fillStyle = processStyle(style.fillStyle, false, false, dependencies);
                        shapeStyle.type = fillStyle.type;
                        shapeStyle.transform = fillStyle.transform;
                        shapeStyle.colors = fillStyle.colors;
                        shapeStyle.ratios = fillStyle.ratios;
                        shapeStyle.focalPoint = fillStyle.focalPoint;
                        shapeStyle.bitmapId = fillStyle.bitmapId;
                        shapeStyle.bitmapIndex = fillStyle.bitmapIndex;
                        shapeStyle.repeat = fillStyle.repeat;
                        style.fillStyle = null;
                        return shapeStyle;
                    } else {
                        shapeStyle.type = FillType.Solid;
                        return shapeStyle;
                    }
                }
                if (style.type === undefined || style.type === FillType.Solid) {
                    return shapeStyle;
                }
                var scale;
                switch (style.type) {
                case FillType.LinearGradient:
                case FillType.RadialGradient:
                case FillType.FocalRadialGradient:
                    var records = style.records;
                    var colors = shapeStyle.colors = [];
                    var ratios = shapeStyle.ratios = [];
                    for (var i = 0; i < records.length; i++) {
                        var record = records[i];
                        colors.push(record.color);
                        ratios.push(record.ratio);
                    }
                    scale = 819.2;
                    break;
                case FillType.RepeatingBitmap:
                case FillType.ClippedBitmap:
                case FillType.NonsmoothedRepeatingBitmap:
                case FillType.NonsmoothedClippedBitmap:
                    shapeStyle.smooth = style.type !== FillType.NonsmoothedRepeatingBitmap && style.type !== FillType.NonsmoothedClippedBitmap;
                    shapeStyle.repeat = style.type !== FillType.ClippedBitmap && style.type !== FillType.NonsmoothedClippedBitmap;
                    var index = dependencies.indexOf(style.bitmapId);
                    if (index === -1) {
                        index = dependencies.length;
                        dependencies.push(style.bitmapId);
                    }
                    shapeStyle.bitmapIndex = index;
                    scale = 0.05;
                    break;
                default:
                    Shumway.Debug.warning('shape parser encountered invalid fill style ' + style.type);
                }
                if (!style.matrix) {
                    shapeStyle.transform = IDENTITY_MATRIX;
                    return shapeStyle;
                }
                var matrix = style.matrix;
                shapeStyle.transform = {
                    a: matrix.a * scale,
                    b: matrix.b * scale,
                    c: matrix.c * scale,
                    d: matrix.d * scale,
                    tx: matrix.tx / 20,
                    ty: matrix.ty / 20
                };
                // null data that's unused from here on out
                style.matrix = null;
                return shapeStyle;
            }
            function processMorphStyle(style, isLineStyle, dependencies) {
                var morphStyle = Object.create(style);
                if (isLineStyle) {
                    morphStyle.width = style.widthMorph;
                    if (!style.color && style.hasFill) {
                        var fillStyle = processMorphStyle(style.fillStyle, false, dependencies);
                        morphStyle.transform = fillStyle.transform;
                        morphStyle.colors = fillStyle.colors;
                        morphStyle.ratios = fillStyle.ratios;
                        return morphStyle;
                    } else {
                        morphStyle.color = style.colorMorph;
                        return morphStyle;
                    }
                }
                if (style.type === undefined) {
                    return morphStyle;
                }
                if (style.type === FillType.Solid) {
                    morphStyle.color = style.colorMorph;
                    return morphStyle;
                }
                var scale;
                switch (style.type) {
                case FillType.LinearGradient:
                case FillType.RadialGradient:
                case FillType.FocalRadialGradient:
                    var records = style.records;
                    var colors = morphStyle.colors = [];
                    var ratios = morphStyle.ratios = [];
                    for (var i = 0; i < records.length; i++) {
                        var record = records[i];
                        colors.push(record.colorMorph);
                        ratios.push(record.ratioMorph);
                    }
                    scale = 819.2;
                    break;
                case FillType.RepeatingBitmap:
                case FillType.ClippedBitmap:
                case FillType.NonsmoothedRepeatingBitmap:
                case FillType.NonsmoothedClippedBitmap:
                    scale = 0.05;
                    break;
                default:
                    release || assertUnreachable('shape parser encountered invalid fill style');
                }
                if (!style.matrix) {
                    morphStyle.transform = IDENTITY_MATRIX;
                    return morphStyle;
                }
                var matrix = style.matrixMorph;
                morphStyle.transform = {
                    a: matrix.a * scale,
                    b: matrix.b * scale,
                    c: matrix.c * scale,
                    d: matrix.d * scale,
                    tx: matrix.tx / 20,
                    ty: matrix.ty / 20
                };
                return morphStyle;
            }
            /*
             * Paths are stored in 2-dimensional arrays. Each of the inner arrays contains
             * all the paths for a certain fill or line style.
             */
            function createPathsList(styles, isLineStyle, isMorph, dependencies) {
                var paths = [];
                for (var i = 0; i < styles.length; i++) {
                    var style = processStyle(styles[i], isLineStyle, isMorph, dependencies);
                    if (!isLineStyle) {
                        paths[i] = new SegmentedPath(style, null);
                    } else {
                        paths[i] = new SegmentedPath(null, style);
                    }
                }
                return paths;
            }
            function defineShape(tag) {
                var dependencies = [];
                var fillPaths = createPathsList(tag.fillStyles, false, !!tag.recordsMorph, dependencies);
                var linePaths = createPathsList(tag.lineStyles, true, !!tag.recordsMorph, dependencies);
                var shape = convertRecordsToShapeData(tag.records, fillPaths, linePaths, dependencies, tag.recordsMorph || null);
                return {
                    type: tag.flags & 8    /* IsMorph */ ? 'morphshape' : 'shape',
                    id: tag.id,
                    fillBounds: tag.fillBounds,
                    lineBounds: tag.lineBounds,
                    morphFillBounds: tag.fillBoundsMorph || null,
                    morphLineBounds: tag.lineBoundsMorph || null,
                    shape: shape.toPlainObject(),
                    transferables: shape.buffers,
                    require: dependencies.length ? dependencies : null
                };
            }
            Parser.defineShape = defineShape;
            var PathSegment = function () {
                function PathSegment(commands, data, morphData, prev, next, isReversed) {
                    this.commands = commands;
                    this.data = data;
                    this.morphData = morphData;
                    this.prev = prev;
                    this.next = next;
                    this.isReversed = isReversed;
                    this.id = PathSegment._counter++;
                }
                PathSegment.FromDefaults = function (isMorph) {
                    var commands = new DataBuffer();
                    var data = new DataBuffer();
                    commands.endian = data.endian = 'auto';
                    var morphData = null;
                    if (isMorph) {
                        morphData = new DataBuffer();
                        morphData.endian = 'auto';
                    }
                    return new PathSegment(commands, data, morphData, null, null, false);
                };
                PathSegment.prototype.moveTo = function (x, y) {
                    this.commands.writeUnsignedByte(9    /* MoveTo */);
                    this.data.write2Ints(x, y);
                };
                PathSegment.prototype.morphMoveTo = function (x, y, mx, my) {
                    this.moveTo(x, y);
                    this.morphData.write2Ints(mx, my);
                };
                PathSegment.prototype.lineTo = function (x, y) {
                    this.commands.writeUnsignedByte(10    /* LineTo */);
                    this.data.write2Ints(x, y);
                };
                PathSegment.prototype.morphLineTo = function (x, y, mx, my) {
                    this.lineTo(x, y);
                    this.morphData.write2Ints(mx, my);
                };
                PathSegment.prototype.curveTo = function (cpx, cpy, x, y) {
                    this.commands.writeUnsignedByte(11    /* CurveTo */);
                    this.data.write4Ints(cpx, cpy, x, y);
                };
                PathSegment.prototype.morphCurveTo = function (cpx, cpy, x, y, mcpx, mcpy, mx, my) {
                    this.curveTo(cpx, cpy, x, y);
                    this.morphData.write4Ints(mcpx, mcpy, mx, my);
                };
                /**
                 * Returns a shallow copy of the segment with the "isReversed" flag set.
                 * Reversed segments play themselves back in reverse when they're merged into the final
                 * non-segmented path.
                 * Note: Don't modify the original, or the reversed copy, after this operation!
                 */
                PathSegment.prototype.toReversed = function () {
                    release || assert(!this.isReversed);
                    return new PathSegment(this.commands, this.data, this.morphData, null, null, true);
                };
                PathSegment.prototype.clone = function () {
                    return new PathSegment(this.commands, this.data, this.morphData, null, null, this.isReversed);
                };
                PathSegment.prototype.storeStartAndEnd = function () {
                    var data = this.data.ints;
                    var endPoint1 = data[0] + ',' + data[1];
                    var endPoint2Offset = (this.data.length >> 2) - 2;
                    var endPoint2 = data[endPoint2Offset] + ',' + data[endPoint2Offset + 1];
                    if (!this.isReversed) {
                        this.startPoint = endPoint1;
                        this.endPoint = endPoint2;
                    } else {
                        this.startPoint = endPoint2;
                        this.endPoint = endPoint1;
                    }
                };
                PathSegment.prototype.connectsTo = function (other) {
                    release || assert(other !== this);
                    release || assert(this.endPoint);
                    release || assert(other.startPoint);
                    return this.endPoint === other.startPoint;
                };
                PathSegment.prototype.startConnectsTo = function (other) {
                    release || assert(other !== this);
                    return this.startPoint === other.startPoint;
                };
                PathSegment.prototype.flipDirection = function () {
                    var tempPoint = '';
                    tempPoint = this.startPoint;
                    this.startPoint = this.endPoint;
                    this.endPoint = tempPoint;
                    this.isReversed = !this.isReversed;
                };
                PathSegment.prototype.serialize = function (shape, lastPosition) {
                    if (this.isReversed) {
                        this._serializeReversed(shape, lastPosition);
                        return;
                    }
                    var commands = this.commands.bytes;
                    // Note: this *must* use `this.data.length`, because buffers will have padding.
                    var dataLength = this.data.length >> 2;
                    var morphData = this.morphData ? this.morphData.ints : null;
                    var data = this.data.ints;
                    release || assert(commands[0] === 9    /* MoveTo */);
                    // If the segment's first moveTo goes to the current coordinates, we have to skip it.
                    var offset = 0;
                    if (data[0] === lastPosition.x && data[1] === lastPosition.y) {
                        offset++;
                    }
                    var commandsCount = this.commands.length;
                    var dataPosition = offset * 2;
                    for (var i = offset; i < commandsCount; i++) {
                        dataPosition = this._writeCommand(commands[i], dataPosition, data, morphData, shape);
                    }
                    release || assert(dataPosition === dataLength);
                    lastPosition.x = data[dataLength - 2];
                    lastPosition.y = data[dataLength - 1];
                };
                PathSegment.prototype._serializeReversed = function (shape, lastPosition) {
                    // For reversing the fill0 segments, we rely on the fact that each segment
                    // starts with a moveTo. We first write a new moveTo with the final drawing command's
                    // target coordinates (if we don't skip it, see below). For each of the following
                    // commands, we take the coordinates of the command originally *preceding*
                    // it as the new target coordinates. The final coordinates we target will be
                    // the ones from the original first moveTo.
                    // Note: these *must* use `this.{data,commands}.length`, because buffers will have padding.
                    var commandsCount = this.commands.length;
                    var dataPosition = (this.data.length >> 2) - 2;
                    var commands = this.commands.bytes;
                    release || assert(commands[0] === 9    /* MoveTo */);
                    var data = this.data.ints;
                    var morphData = this.morphData ? this.morphData.ints : null;
                    // Only write the first moveTo if it doesn't go to the current coordinates.
                    if (data[dataPosition] !== lastPosition.x || data[dataPosition + 1] !== lastPosition.y) {
                        this._writeCommand(9    /* MoveTo */, dataPosition, data, morphData, shape);
                    }
                    if (commandsCount === 1) {
                        lastPosition.x = data[0];
                        lastPosition.y = data[1];
                        return;
                    }
                    for (var i = commandsCount; i-- > 1;) {
                        dataPosition -= 2;
                        var command = commands[i];
                        shape.writeCommandAndCoordinates(command, data[dataPosition], data[dataPosition + 1]);
                        if (morphData) {
                            shape.writeMorphCoordinates(morphData[dataPosition], morphData[dataPosition + 1]);
                        }
                        if (command === 11    /* CurveTo */) {
                            dataPosition -= 2;
                            shape.writeCoordinates(data[dataPosition], data[dataPosition + 1]);
                            if (morphData) {
                                shape.writeMorphCoordinates(morphData[dataPosition], morphData[dataPosition + 1]);
                            }
                        } else {
                        }
                    }
                    release || assert(dataPosition === 0);
                    lastPosition.x = data[0];
                    lastPosition.y = data[1];
                };
                PathSegment.prototype._writeCommand = function (command, position, data, morphData, shape) {
                    shape.writeCommandAndCoordinates(command, data[position++], data[position++]);
                    if (morphData) {
                        shape.writeMorphCoordinates(morphData[position - 2], morphData[position - 1]);
                    }
                    if (command === 11    /* CurveTo */) {
                        shape.writeCoordinates(data[position++], data[position++]);
                        if (morphData) {
                            shape.writeMorphCoordinates(morphData[position - 2], morphData[position - 1]);
                        }
                    }
                    return position;
                };
                PathSegment._counter = 0;
                return PathSegment;
            }();
            var SegmentedPath = function () {
                function SegmentedPath(fillStyle, lineStyle) {
                    this.fillStyle = fillStyle;
                    this.lineStyle = lineStyle;
                    this._head = null;
                }
                SegmentedPath.prototype.addSegment = function (segment) {
                    release || assert(segment);
                    release || assert(segment.next === null);
                    release || assert(segment.prev === null);
                    var currentHead = this._head;
                    if (currentHead) {
                        release || assert(segment !== currentHead);
                        currentHead.next = segment;
                        segment.prev = currentHead;
                    }
                    this._head = segment;
                };
                // Does *not* reset the segment's prev and next pointers!
                SegmentedPath.prototype.removeSegment = function (segment) {
                    if (segment.prev) {
                        segment.prev.next = segment.next;
                    }
                    if (segment.next) {
                        segment.next.prev = segment.prev;
                    }
                };
                SegmentedPath.prototype.insertSegment = function (segment, next) {
                    var prev = next.prev;
                    segment.prev = prev;
                    segment.next = next;
                    if (prev) {
                        prev.next = segment;
                    }
                    next.prev = segment;
                };
                SegmentedPath.prototype.head = function () {
                    return this._head;
                };
                SegmentedPath.prototype.serialize = function (shape) {
                    var segment = this.head();
                    if (!segment) {
                        // Path is empty.
                        return;
                    }
                    while (segment) {
                        segment.storeStartAndEnd();
                        segment = segment.prev;
                    }
                    var start = this.head();
                    var end = start;
                    var finalRoot = null;
                    var finalHead = null;
                    // Path segments for one style can appear in arbitrary order in the tag's list
                    // of edge records.
                    // Before we linearize them, we have to identify all pairs of segments where
                    // one ends at a coordinate the other starts at.
                    // The following loop does that, by creating ever-growing runs of matching
                    // segments. If no more segments are found that match the current run (either
                    // at the beginning, or at the end), the current run is complete, and a new
                    // one is started. Rinse, repeat, until no solitary segments remain.
                    var current = start.prev;
                    while (start) {
                        while (current) {
                            if (current.startConnectsTo(start)) {
                                current.flipDirection();
                            }
                            if (current.connectsTo(start)) {
                                if (current.next !== start) {
                                    this.removeSegment(current);
                                    this.insertSegment(current, start);
                                }
                                start = current;
                                current = start.prev;
                                continue;
                            }
                            if (current.startConnectsTo(end)) {
                                current.flipDirection();
                            }
                            if (end.connectsTo(current)) {
                                this.removeSegment(current);
                                end.next = current;
                                current = current.prev;
                                end.next.prev = end;
                                end.next.next = null;
                                end = end.next;
                                continue;
                            }
                            current = current.prev;
                        }
                        // This run of segments is finished. Store and forget it (for this loop).
                        current = start.prev;
                        if (!finalRoot) {
                            finalRoot = start;
                            finalHead = end;
                        } else {
                            finalHead.next = start;
                            start.prev = finalHead;
                            finalHead = end;
                            finalHead.next = null;
                        }
                        if (!current) {
                            break;
                        }
                        start = end = current;
                        current = start.prev;
                    }
                    if (this.fillStyle) {
                        var style = this.fillStyle;
                        var morph = style.morph;
                        switch (style.type) {
                        case FillType.Solid:
                            shape.beginFill(style.color);
                            if (morph) {
                                shape.writeMorphFill(morph.color);
                            }
                            break;
                        case FillType.LinearGradient:
                        case FillType.RadialGradient:
                        case FillType.FocalRadialGradient:
                            writeGradient(2    /* BeginGradientFill */, style, shape);
                            if (morph) {
                                writeMorphGradient(morph, shape);
                            }
                            break;
                        case FillType.ClippedBitmap:
                        case FillType.RepeatingBitmap:
                        case FillType.NonsmoothedClippedBitmap:
                        case FillType.NonsmoothedRepeatingBitmap:
                            writeBitmap(3    /* BeginBitmapFill */, style, shape);
                            if (morph) {
                                writeMorphBitmap(morph, shape);
                            }
                            break;
                        default:
                            release || assertUnreachable('Invalid fill style type: ' + style.type);
                        }
                    } else {
                        var style = this.lineStyle;
                        var morph = style.morph;
                        release || assert(style);
                        switch (style.type) {
                        case FillType.Solid:
                            writeLineStyle(style, shape);
                            if (morph) {
                                writeMorphLineStyle(morph, shape);
                            }
                            break;
                        case FillType.LinearGradient:
                        case FillType.RadialGradient:
                        case FillType.FocalRadialGradient:
                            writeLineStyle(style, shape);
                            writeGradient(6    /* LineStyleGradient */, style, shape);
                            if (morph) {
                                writeMorphLineStyle(morph, shape);
                                writeMorphGradient(morph, shape);
                            }
                            break;
                        case FillType.ClippedBitmap:
                        case FillType.RepeatingBitmap:
                        case FillType.NonsmoothedClippedBitmap:
                        case FillType.NonsmoothedRepeatingBitmap:
                            writeLineStyle(style, shape);
                            writeBitmap(7    /* LineStyleBitmap */, style, shape);
                            if (morph) {
                                writeMorphLineStyle(morph, shape);
                                writeMorphBitmap(morph, shape);
                            }
                            break;
                        default:
                        }
                    }
                    var lastPosition = {
                        x: 0,
                        y: 0
                    };
                    current = finalRoot;
                    while (current) {
                        current.serialize(shape, lastPosition);
                        current = current.next;
                    }
                    if (this.fillStyle) {
                        shape.endFill();
                    } else {
                        shape.endLine();
                    }
                    return shape;
                };
                return SegmentedPath;
            }();
            function writeLineStyle(style, shape) {
                // No scaling == 0, normal == 1, vertical only == 2, horizontal only == 3.
                var scaleMode = style.noHscale ? style.noVscale ? 0 : 2 : style.noVscale ? 3 : 1;
                // TODO: Figure out how to handle startCapsStyle
                var thickness = clamp(style.width, 0, 255 * 20) | 0;
                shape.lineStyle(thickness, style.color, style.pixelHinting, scaleMode, style.endCapsStyle, style.jointStyle, style.miterLimit);
            }
            function writeMorphLineStyle(style, shape) {
                // TODO: Figure out how to handle startCapsStyle
                var thickness = clamp(style.width, 0, 255 * 20) | 0;
                shape.writeMorphLineStyle(thickness, style.color);
            }
            function writeGradient(command, style, shape) {
                var gradientType = style.type === FillType.LinearGradient ? 16    /* Linear */ : 18    /* Radial */;
                shape.beginGradient(command, style.colors, style.ratios, gradientType, style.transform, style.spreadMethod, style.interpolationMode, style.focalPoint / 2 | 0);
            }
            function writeMorphGradient(style, shape) {
                shape.writeMorphGradient(style.colors, style.ratios, style.transform);
            }
            function writeBitmap(command, style, shape) {
                shape.beginBitmap(command, style.bitmapIndex, style.transform, style.repeat, style.smooth);
            }
            function writeMorphBitmap(style, shape) {
                shape.writeMorphBitmap(style.transform);
            }
            var SOUND_SIZE_8_BIT = 0;
            var SOUND_SIZE_16_BIT = 1;
            var SOUND_TYPE_MONO = 0;
            var SOUND_TYPE_STEREO = 1;
            var SOUND_FORMAT_PCM_BE = 0;
            var SOUND_FORMAT_ADPCM = 1;
            var SOUND_FORMAT_MP3 = 2;
            var SOUND_FORMAT_PCM_LE = 3;
            var SOUND_FORMAT_NELLYMOSER_16 = 4;
            var SOUND_FORMAT_NELLYMOSER_8 = 5;
            var SOUND_FORMAT_NELLYMOSER = 6;
            var SOUND_FORMAT_SPEEX = 11;
            var SOUND_RATES = [
                5512,
                11250,
                22500,
                44100
            ];
            var WaveHeader = new Uint8Array([
                82,
                73,
                70,
                70,
                0,
                0,
                0,
                0,
                87,
                65,
                86,
                69,
                102,
                109,
                116,
                32,
                16,
                0,
                0,
                0,
                1,
                0,
                2,
                0,
                68,
                172,
                0,
                0,
                16,
                177,
                2,
                0,
                4,
                0,
                16,
                0,
                100,
                97,
                116,
                97,
                0,
                0,
                0,
                0
            ]);
            function packageWave(data, sampleRate, channels, size, swapBytes) {
                var sizeInBytes = size >> 3;
                var sizePerSecond = channels * sampleRate * sizeInBytes;
                var sizePerSample = channels * sizeInBytes;
                var dataLength = data.length + (data.length & 1);
                var buffer = new ArrayBuffer(WaveHeader.length + dataLength);
                var bytes = new Uint8Array(buffer);
                bytes.set(WaveHeader);
                if (swapBytes) {
                    for (var i = 0, j = WaveHeader.length; i < data.length; i += 2, j += 2) {
                        bytes[j] = data[i + 1];
                        bytes[j + 1] = data[i];
                    }
                } else {
                    bytes.set(data, WaveHeader.length);
                }
                var view = new DataView(buffer);
                view.setUint32(4, dataLength + 36, true);
                view.setUint16(22, channels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sizePerSecond, true);
                view.setUint16(32, sizePerSample, true);
                view.setUint16(34, size, true);
                view.setUint32(40, dataLength, true);
                return {
                    data: bytes,
                    mimeType: 'audio/wav'
                };
            }
            function defineSound(tag) {
                var channels = tag.soundType == SOUND_TYPE_STEREO ? 2 : 1;
                var samplesCount = tag.samplesCount;
                var sampleRate = SOUND_RATES[tag.soundRate];
                var data = tag.soundData;
                var pcm, packaged;
                switch (tag.soundFormat) {
                case SOUND_FORMAT_PCM_BE:
                    pcm = new Float32Array(samplesCount * channels);
                    if (tag.soundSize == SOUND_SIZE_16_BIT) {
                        for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                            pcm[i] = (data[j] << 24 | data[j + 1] << 16) / 2147483648;
                        packaged = packageWave(data, sampleRate, channels, 16, true);
                    } else {
                        for (var i = 0; i < pcm.length; i++)
                            pcm[i] = (data[i] - 128) / 128;
                        packaged = packageWave(data, sampleRate, channels, 8, false);
                    }
                    break;
                case SOUND_FORMAT_PCM_LE:
                    pcm = new Float32Array(samplesCount * channels);
                    if (tag.soundSize == SOUND_SIZE_16_BIT) {
                        for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                            pcm[i] = (data[j + 1] << 24 | data[j] << 16) / 2147483648;
                        packaged = packageWave(data, sampleRate, channels, 16, false);
                    } else {
                        for (var i = 0; i < pcm.length; i++)
                            pcm[i] = (data[i] - 128) / 128;
                        packaged = packageWave(data, sampleRate, channels, 8, false);
                    }
                    break;
                case SOUND_FORMAT_MP3:
                    packaged = {
                        data: new Uint8Array(data.subarray(2)),
                        mimeType: 'audio/mpeg'
                    };
                    break;
                case SOUND_FORMAT_ADPCM:
                    var pcm16 = new Int16Array(samplesCount * channels);
                    decodeACPCMSoundData(data, pcm16, channels);
                    pcm = new Float32Array(samplesCount * channels);
                    for (var i = 0; i < pcm.length; i++)
                        pcm[i] = pcm16[i] / 32768;
                    packaged = packageWave(new Uint8Array(pcm16.buffer), sampleRate, channels, 16, !new Uint8Array(new Uint16Array([1]).buffer)[0]);
                    break;
                default:
                    Shumway.Debug.warning('Unsupported audio format: ' + tag.soundFormat);
                }
                var sound = {
                    type: 'sound',
                    id: tag.id,
                    sampleRate: sampleRate,
                    channels: channels,
                    pcm: pcm,
                    packaged: null
                };
                if (packaged) {
                    sound.packaged = packaged;
                }
                return sound;
            }
            Parser.defineSound = defineSound;
            var ACPCMIndexTables = [
                [
                    -1,
                    2
                ],
                [
                    -1,
                    -1,
                    2,
                    4
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    2,
                    4,
                    6,
                    8
                ],
                [
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    -1,
                    1,
                    2,
                    4,
                    6,
                    8,
                    10,
                    13,
                    16
                ]
            ];
            var ACPCMStepSizeTable = [
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                16,
                17,
                19,
                21,
                23,
                25,
                28,
                31,
                34,
                37,
                41,
                45,
                50,
                55,
                60,
                66,
                73,
                80,
                88,
                97,
                107,
                118,
                130,
                143,
                157,
                173,
                190,
                209,
                230,
                253,
                279,
                307,
                337,
                371,
                408,
                449,
                494,
                544,
                598,
                658,
                724,
                796,
                876,
                963,
                1060,
                1166,
                1282,
                1411,
                1552,
                1707,
                1878,
                2066,
                2272,
                2499,
                2749,
                3024,
                3327,
                3660,
                4026,
                4428,
                4871,
                5358,
                5894,
                6484,
                7132,
                7845,
                8630,
                9493,
                10442,
                11487,
                12635,
                13899,
                15289,
                16818,
                18500,
                20350,
                22385,
                24623,
                27086,
                29794,
                32767
            ];
            function decodeACPCMSoundData(data, pcm16, channels) {
                function readBits(n) {
                    while (dataBufferLength < n) {
                        dataBuffer = dataBuffer << 8 | data[dataPosition++];
                        dataBufferLength += 8;
                    }
                    dataBufferLength -= n;
                    return dataBuffer >>> dataBufferLength & (1 << n) - 1;
                }
                var dataPosition = 0;
                var dataBuffer = 0;
                var dataBufferLength = 0;
                var pcmPosition = 0;
                var codeSize = readBits(2);
                var indexTable = ACPCMIndexTables[codeSize];
                while (pcmPosition < pcm16.length) {
                    var x = pcm16[pcmPosition++] = readBits(16) << 16 >> 16, x2;
                    var stepIndex = readBits(6), stepIndex2;
                    if (channels > 1) {
                        x2 = pcm16[pcmPosition++] = readBits(16) << 16 >> 16;
                        stepIndex2 = readBits(6);
                    }
                    var signMask = 1 << codeSize + 1;
                    for (var i = 0; i < 4095; i++) {
                        var nibble = readBits(codeSize + 2);
                        var step = ACPCMStepSizeTable[stepIndex];
                        var sum = 0;
                        for (var currentBit = signMask >> 1; currentBit; currentBit >>= 1, step >>= 1) {
                            if (nibble & currentBit)
                                sum += step;
                        }
                        x += (nibble & signMask ? -1 : 1) * (sum + step);
                        pcm16[pcmPosition++] = x = x < -32768 ? -32768 : x > 32767 ? 32767 : x;
                        stepIndex += indexTable[nibble & ~signMask];
                        stepIndex = stepIndex < 0 ? 0 : stepIndex > 88 ? 88 : stepIndex;
                        if (channels > 1) {
                            nibble = readBits(codeSize + 2);
                            step = ACPCMStepSizeTable[stepIndex2];
                            sum = 0;
                            for (var currentBit = signMask >> 1; currentBit; currentBit >>= 1, step >>= 1) {
                                if (nibble & currentBit)
                                    sum += step;
                            }
                            x2 += (nibble & signMask ? -1 : 1) * (sum + step);
                            pcm16[pcmPosition++] = x2 = x2 < -32768 ? -32768 : x2 > 32767 ? 32767 : x2;
                            stepIndex2 += indexTable[nibble & ~signMask];
                            stepIndex2 = stepIndex2 < 0 ? 0 : stepIndex2 > 88 ? 88 : stepIndex2;
                        }
                    }
                }
            }
            var nextSoundStreamId = 0;
            var SoundStream = function () {
                function SoundStream(samplesCount, sampleRate, channels) {
                    this.streamId = nextSoundStreamId++;
                    this.samplesCount = samplesCount;
                    this.sampleRate = sampleRate;
                    this.channels = channels;
                    this.format = null;
                    this.currentSample = 0;
                }
                SoundStream.FromTag = function (tag) {
                    var channels = tag.streamType == SOUND_TYPE_STEREO ? 2 : 1;
                    var samplesCount = tag.samplesCount;
                    var sampleRate = SOUND_RATES[tag.streamRate];
                    var stream = new SoundStream(samplesCount, sampleRate, channels);
                    switch (tag.streamCompression) {
                    case SOUND_FORMAT_PCM_BE:
                    case SOUND_FORMAT_PCM_LE:
                        stream.format = 'wave';
                        if (tag.soundSize == SOUND_SIZE_16_BIT) {
                            stream.decode = tag.streamCompression === SOUND_FORMAT_PCM_BE ? SwfSoundStream_decode_PCM_be : SwfSoundStream_decode_PCM_le;
                        } else {
                            stream.decode = SwfSoundStream_decode_PCM;
                        }
                        break;
                    case SOUND_FORMAT_MP3:
                        stream.format = 'mp3';
                        stream.decode = SwfSoundStream_decode_MP3;
                        break;
                    default:
                        Shumway.Debug.warning('Unsupported audio stream format: ' + tag.streamCompression);
                        return null;
                    }
                    return stream;
                };
                return SoundStream;
            }();
            Parser.SoundStream = SoundStream;
            function SwfSoundStream_decode_PCM(data) {
                var pcm = new Float32Array(data.length);
                for (var i = 0; i < pcm.length; i++)
                    pcm[i] = (data[i] - 128) / 128;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }
            function SwfSoundStream_decode_PCM_be(data) {
                var pcm = new Float32Array(data.length / 2);
                for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                    pcm[i] = (data[j] << 24 | data[j + 1] << 16) / 2147483648;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }
            function SwfSoundStream_decode_PCM_le(data) {
                var pcm = new Float32Array(data.length / 2);
                for (var i = 0, j = 0; i < pcm.length; i++, j += 2)
                    pcm[i] = (data[j + 1] << 24 | data[j] << 16) / 2147483648;
                this.currentSample += pcm.length / this.channels;
                return {
                    streamId: this.streamId,
                    samplesCount: pcm.length / this.channels,
                    pcm: pcm
                };
            }
            function SwfSoundStream_decode_MP3(data) {
                var samplesCount = data[1] << 8 | data[0];
                var seek = data[3] << 8 | data[2];
                this.currentSample += samplesCount;
                return {
                    streamId: this.streamId,
                    samplesCount: samplesCount,
                    data: new Uint8Array(data.subarray(4)),
                    seek: seek
                };
            }
            function defineText(tag) {
                var bold = false;
                var italic = false;
                return {
                    type: 'text',
                    id: tag.id,
                    fillBounds: tag.bbox,
                    variableName: tag.variableName,
                    tag: tag,
                    bold: bold,
                    italic: italic
                };
            }
            Parser.defineText = defineText;
        }(Parser = SWF.Parser || (SWF.Parser = {})));
        SWF.timelineBuffer = Shumway.Tools ? new Shumway.Tools.Profiler.TimelineBuffer('Parser') : null;
        function enterTimeline(name, data) {
            profile && SWF.timelineBuffer && SWF.timelineBuffer.enter(name, data);
        }
        SWF.enterTimeline = enterTimeline;
        function leaveTimeline(data) {
            profile && SWF.timelineBuffer && SWF.timelineBuffer.leave(null, data);
        }
        SWF.leaveTimeline = leaveTimeline;
        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;
        var shumwayOptions = Shumway.Settings.shumwayOptions;
        SWF.parserOptions = shumwayOptions.register(new OptionSet('Parser Options'));
        SWF.traceLevel = SWF.parserOptions.register(new Option('parsertracelevel', 'Parser Trace Level', 'number', 0, 'Parser Trace Level'));
        SWF.StreamNoDataError = {};
        var masks = new Uint32Array(33);
        for (var i = 1, mask = 0; i <= 32; ++i) {
            masks[i] = mask = mask << 1 | 1;
        }
        var Stream = function () {
            function Stream(buffer, offset, length, maxLength) {
                if (offset === undefined)
                    offset = 0;
                if (buffer.buffer instanceof ArrayBuffer) {
                    offset += buffer.byteOffset;
                    buffer = buffer.buffer;
                }
                if (length === undefined)
                    length = buffer.byteLength - offset;
                if (maxLength === undefined)
                    maxLength = length;
                this.bytes = new Uint8Array(buffer, offset, maxLength);
                this.view = new DataView(buffer, offset, maxLength);
                this.pos = 0;
                this.end = length;
                this.bitBuffer = 0;
                this.bitLength = 0;
            }
            Stream.prototype.align = function () {
                this.bitBuffer = this.bitLength = 0;
            };
            Stream.prototype.ensure = function (size) {
                if (this.pos + size > this.end) {
                    throw SWF.StreamNoDataError;
                }
            };
            Stream.prototype.remaining = function () {
                return this.end - this.pos;
            };
            Stream.prototype.substream = function (begin, end) {
                var stream = new Stream(this.bytes);
                stream.pos = begin;
                stream.end = end;
                return stream;
            };
            Stream.prototype.push = function (data) {
                var bytes = this.bytes;
                var newBytesLength = this.end + data.length;
                if (newBytesLength > bytes.length) {
                    throw 'stream buffer overfow';
                }
                bytes.set(data, this.end);
                this.end = newBytesLength;
            };
            Stream.prototype.readSi8 = function () {
                return this.view.getInt8(this.pos++);
            };
            Stream.prototype.readSi16 = function () {
                var r = this.view.getInt16(this.pos, true);
                this.pos += 2;
                return r;
            };
            Stream.prototype.readSi32 = function () {
                var r = this.view.getInt32(this.pos, true);
                this.pos += 4;
                return r;
            };
            Stream.prototype.readUi8 = function () {
                return this.bytes[this.pos++];
            };
            Stream.prototype.readUi16 = function () {
                var r = this.view.getUint16(this.pos, true);
                this.pos += 2;
                return r;
            };
            Stream.prototype.readUi32 = function () {
                var r = this.view.getUint32(this.pos, true);
                this.pos += 4;
                return r;
            };
            Stream.prototype.readFixed = function () {
                var r = this.view.getInt32(this.pos, true) / 65536;
                this.pos += 4;
                return r;
            };
            Stream.prototype.readFixed8 = function () {
                var r = this.view.getInt16(this.pos, true) / 256;
                this.pos += 2;
                return r;
            };
            Stream.prototype.readFloat16 = function () {
                var ui16 = this.view.getUint16(this.pos, false);
                this.pos += 2;
                var sign = ui16 >> 15 ? -1 : 1;
                var exponent = (ui16 & 31744) >> 10;
                var fraction = ui16 & 1023;
                if (!exponent)
                    return sign * Math.pow(2, -14) * (fraction / 1024);
                if (exponent === 31)
                    return fraction ? NaN : sign * Infinity;
                return sign * Math.pow(2, exponent - 15) * (1 + fraction / 1024);
            };
            Stream.prototype.readFloat = function () {
                var r = this.view.getFloat32(this.pos, true);
                this.pos += 4;
                return r;
            };
            Stream.prototype.readDouble = function () {
                var r = this.view.getFloat64(this.pos, true);
                this.pos += 8;
                return r;
            };
            Stream.prototype.readEncodedU32 = function () {
                var bytes = this.bytes;
                var val = bytes[this.pos++];
                if (!(val & 128))
                    return val;
                val = val & 127 | bytes[this.pos++] << 7;
                if (!(val & 16384))
                    return val;
                val = val & 16383 | bytes[this.pos++] << 14;
                if (!(val & 2097152))
                    return val;
                val = val & 2097151 | bytes[this.pos++] << 21;
                if (!(val & 268435456))
                    return val;
                return val & 268435455 | bytes[this.pos++] << 28;
            };
            Stream.prototype.readBool = function () {
                return !!this.bytes[this.pos++];
            };
            Stream.prototype.readSb = function (size) {
                return this.readUb(size) << 32 - size >> 32 - size;
            };
            Stream.prototype.readUb = function (size) {
                var buffer = this.bitBuffer;
                var bitlen = this.bitLength;
                var val = 0;
                while (size > bitlen) {
                    if (bitlen > 24) {
                        // Avoid overflow. Save current buffer in val and add remaining bits later.
                        size -= bitlen;
                        val = buffer << size;
                        bitlen = 0;
                    }
                    buffer = buffer << 8 | this.bytes[this.pos++];
                    bitlen += 8;
                }
                bitlen -= size;
                val |= buffer >>> bitlen & masks[size];
                this.bitBuffer = buffer;
                this.bitLength = bitlen;
                return val;
            };
            Stream.prototype.readFb = function (size) {
                return this.readSb(size) / 65536;
            };
            Stream.prototype.readString = function (length) {
                var bytes = this.bytes;
                var codes;
                var pos = this.pos;
                if (length > -1) {
                    codes = bytes.subarray(pos, pos += length);
                } else {
                    length = 0;
                    for (var i = pos; bytes[i]; i++) {
                        length++;
                    }
                    codes = bytes.subarray(pos, pos += length);
                    pos++;
                }
                this.pos = pos;
                var str = Shumway.StringUtilities.utf8encode(codes);
                if (str.indexOf('\0') >= 0) {
                    str = str.split('\0').join('');
                }
                return str;
            };
            return Stream;
        }();
        SWF.Stream = Stream;
        SWF.MP3WORKER_PATH = '../../lib/mp3/mp3worker.js';
        var mp3Worker = null;
        function ensureMP3Worker() {
            if (!mp3Worker) {
                mp3Worker = new Worker(SWF.MP3WORKER_PATH);
                mp3Worker.addEventListener('message', function (e) {
                    if (e.data.action === 'console') {
                        console[e.data.method].call(console, e.data.message);
                    }
                });
            }
            return mp3Worker;
        }
        var nextSessionId = 0;
        var MP3DecoderSession = function () {
            function MP3DecoderSession() {
                this._sessionId = nextSessionId++;
                this._onworkermessageBound = this.onworkermessage.bind(this);
                this._worker = ensureMP3Worker();
                this._worker.addEventListener('message', this._onworkermessageBound, false);
                this._worker.postMessage({
                    sessionId: this._sessionId,
                    action: 'create'
                });
            }
            MP3DecoderSession.prototype.onworkermessage = function (e) {
                if (e.data.sessionId !== this._sessionId)
                    return;
                var action = e.data.action;
                switch (action) {
                case 'closed':
                    if (this.onclosed) {
                        this.onclosed();
                    }
                    this._worker.removeEventListener('message', this._onworkermessageBound, false);
                    this._worker = null;
                    break;
                case 'frame':
                    this.onframedata(e.data.frameData, e.data.channels, e.data.sampleRate, e.data.bitRate);
                    break;
                case 'id3':
                    if (this.onid3tag) {
                        this.onid3tag(e.data.id3Data);
                    }
                    break;
                case 'error':
                    if (this.onerror) {
                        this.onerror(e.data.message);
                    }
                    break;
                }
            };
            MP3DecoderSession.prototype.pushAsync = function (data) {
                this._worker.postMessage({
                    sessionId: this._sessionId,
                    action: 'decode',
                    data: data
                });
            };
            MP3DecoderSession.prototype.close = function () {
                this._worker.postMessage({
                    sessionId: this._sessionId,
                    action: 'close'
                });
            };
            MP3DecoderSession.processAll = function (data) {
                var currentBufferSize = 8000;
                var currentBuffer = new Float32Array(currentBufferSize);
                var bufferPosition = 0;
                var id3Tags = [];
                var sessionAborted = false;
                var promiseWrapper = new Shumway.PromiseWrapper();
                var session = new MP3DecoderSession();
                session.onframedata = function (frameData, channels, sampleRate, bitRate) {
                    var needed = frameData.length + bufferPosition;
                    if (needed > currentBufferSize) {
                        do {
                            currentBufferSize *= 2;
                        } while (needed > currentBufferSize);
                        var newBuffer = new Float32Array(currentBufferSize);
                        newBuffer.set(currentBuffer);
                        currentBuffer = newBuffer;
                    }
                    currentBuffer.set(frameData, bufferPosition);
                    bufferPosition += frameData.length;
                };
                session.onid3tag = function (tagData) {
                    id3Tags.push(tagData);
                };
                session.onclosed = function () {
                    if (sessionAborted)
                        return;
                    promiseWrapper.resolve({
                        data: currentBuffer.subarray(0, bufferPosition),
                        id3Tags: id3Tags
                    });
                };
                session.onerror = function (error) {
                    if (sessionAborted)
                        return;
                    sessionAborted = true;
                    promiseWrapper.reject(error);
                };
                session.pushAsync(data);
                session.close();
                return promiseWrapper.promise;
            };
            return MP3DecoderSession;
        }();
        SWF.MP3DecoderSession = MP3DecoderSession;
    }(SWF = Shumway.SWF || (Shumway.SWF = {})));
}(Shumway || (Shumway = {})));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    var SWF;
    (function (SWF) {
        var assert = Shumway.Debug.assert;
        var Parser = Shumway.SWF.Parser;
        var Stream = SWF.Stream;
        var Inflate = Shumway.ArrayUtilities.Inflate;
        var LzmaDecoder = Shumway.ArrayUtilities.LzmaDecoder;
        var DefinitionTags = Parser.DefinitionTags;
        var ImageDefinitionTags = Parser.ImageDefinitionTags;
        var FontDefinitionTags = Parser.FontDefinitionTags;
        var ControlTags = Parser.ControlTags;
        var getSwfTagCodeName = Parser.getSwfTagCodeName;
        var SWFFile = function () {
            function SWFFile(initialBytes, length, env) {
                // TODO: cleanly abort loading/parsing instead of just asserting here.
                release || assert(initialBytes[0] === 67 || initialBytes[0] === 70 || initialBytes[0] === 90, 'Unsupported compression format: ' + initialBytes[0]);
                release || assert(initialBytes[1] === 87);
                release || assert(initialBytes[2] === 83);
                release || assert(initialBytes.length >= 30, 'At least the header must be complete here.');
                if (!release && SWF.traceLevel.value > 0) {
                    console.log('Create SWFFile');
                }
                this.env = env;
                this.compression = 0    /* None */;
                this.swfVersion = 0;
                this.useAVM1 = true;
                this.backgroundColor = 4294967295;
                this.bounds = null;
                this.frameRate = 0;
                this.frameCount = 0;
                this.attributes = null;
                this.sceneAndFrameLabelData = null;
                this.bytesLoaded = 0;
                this.bytesTotal = length;
                this.pendingUpdateDelays = 0;
                this.framesLoaded = 0;
                this.frames = [];
                this.abcBlocks = [];
                this.dictionary = [];
                this.fonts = [];
                this.symbolClassesMap = [];
                this.symbolClassesList = [];
                this.eagerlyParsedSymbolsMap = [];
                this.eagerlyParsedSymbolsList = [];
                this._jpegTables = null;
                this._currentFrameLabel = null;
                this._currentSoundStreamHead = null;
                this._currentSoundStreamBlock = null;
                this._currentControlTags = null;
                this._currentActionBlocks = null;
                this._currentInitActionBlocks = null;
                this._currentExports = null;
                this._endTagEncountered = false;
                this.readHeaderAndInitialize(initialBytes);
            }
            SWFFile.prototype.appendLoadedData = function (bytes) {
                // TODO: only report decoded or sync-decodable bytes as loaded.
                this.bytesLoaded += bytes.length;
                release || assert(this.bytesLoaded <= this.bytesTotal);
                // Tags after the end tag are simply ignored, so we don't even have to scan them.
                if (this._endTagEncountered) {
                    return;
                }
                if (this.compression !== 0    /* None */) {
                    this._decompressor.push(bytes);
                } else {
                    this.processDecompressedData(bytes);
                }
                this.scanLoadedData();
            };
            SWFFile.prototype.finishLoading = function () {
                if (this.compression !== 0    /* None */) {
                    this._decompressor.close();
                    this._decompressor = null;
                    this.scanLoadedData();
                }
            };
            SWFFile.prototype.getSymbol = function (id) {
                if (this.eagerlyParsedSymbolsMap[id]) {
                    return this.eagerlyParsedSymbolsMap[id];
                }
                var unparsed = this.dictionary[id];
                if (!unparsed) {
                    return null;
                }
                var symbol;
                if (unparsed.tagCode === 39    /* CODE_DEFINE_SPRITE */) {
                    // TODO: replace this whole silly `type` business with tagCode checking.
                    symbol = this.parseSpriteTimeline(unparsed);
                } else {
                    symbol = this.getParsedTag(unparsed);
                }
                symbol.className = this.symbolClassesMap[id] || null;
                symbol.env = this.env;
                return symbol;
            };
            SWFFile.prototype.getParsedTag = function (unparsed) {
                SWF.enterTimeline('Parse tag ' + getSwfTagCodeName(unparsed.tagCode));
                this._dataStream.align();
                this._dataStream.pos = unparsed.byteOffset;
                var handler = Parser.LowLevel.tagHandlers[unparsed.tagCode];
                release || Shumway.Debug.assert(handler, 'handler shall exists here');
                var tagEnd = Math.min(unparsed.byteOffset + unparsed.byteLength, this._dataStream.end);
                var tag = handler(this._dataStream, this.swfVersion, unparsed.tagCode, tagEnd, this._jpegTables);
                var finalPos = this._dataStream.pos;
                if (finalPos !== tagEnd) {
                    this.emitTagSlopWarning(unparsed, tagEnd);
                }
                var symbol = defineSymbol(tag, this.dictionary);
                SWF.leaveTimeline();
                return symbol;
            };
            SWFFile.prototype.readHeaderAndInitialize = function (initialBytes) {
                SWF.enterTimeline('Initialize SWFFile');
                var isDeflateCompressed = initialBytes[0] === 67;
                var isLzmaCompressed = initialBytes[0] === 90;
                if (isDeflateCompressed) {
                    this.compression = 1    /* Deflate */;
                } else if (isLzmaCompressed) {
                    this.compression = 2    /* LZMA */;
                }
                this.swfVersion = initialBytes[3];
                this._loadStarted = Date.now();
                this._uncompressedLength = readSWFLength(initialBytes);
                this.bytesLoaded = initialBytes.length;
                // In some malformed SWFs, the parsed length in the header doesn't exactly match the actual size of the file. For
                // uncompressed files it seems to be safer to make the buffer large enough from the beginning to fit the entire
                // file than having to resize it later or risking an exception when reading out of bounds.
                this.data = new Uint8Array(this.compression === 0    /* None */ ? this.bytesTotal : this._uncompressedLength);
                this._dataStream = new Stream(this.data.buffer);
                this._dataStream.pos = 8;
                this._dataView = this._dataStream.view;
                if (isDeflateCompressed) {
                    this.data.set(initialBytes.subarray(0, 8));
                    this._uncompressedLoadedLength = 8;
                    this._decompressor = Inflate.create(true);
                    // Parts of the header are compressed. Get those out of the way before starting tag parsing.
                    this._decompressor.onData = this.processFirstBatchOfDecompressedData.bind(this);
                    this._decompressor.onError = function (error) {
                        // TODO: Let the loader handle this error.
                        throw new Error(error);
                    };
                    this._decompressor.push(initialBytes.subarray(8));
                } else if (isLzmaCompressed) {
                    this.data.set(initialBytes.subarray(0, 8));
                    this._uncompressedLoadedLength = 8;
                    this._decompressor = new LzmaDecoder(true);
                    this._decompressor.onData = this.processFirstBatchOfDecompressedData.bind(this);
                    this._decompressor.onError = function (error) {
                        // TODO: Let the loader handle this error.
                        Shumway.Debug.warning('Invalid LZMA stream: ' + error);
                    };
                    this._decompressor.push(initialBytes);
                } else {
                    this.data.set(initialBytes);
                    this._uncompressedLoadedLength = initialBytes.length;
                    this._decompressor = null;
                    this.parseHeaderContents();
                }
                SWF.leaveTimeline();
                this._lastScanPosition = this._dataStream.pos;
                this.scanLoadedData();
            };
            SWFFile.prototype.parseHeaderContents = function () {
                var obj = Parser.LowLevel.parseHeader(this._dataStream);
                this.bounds = obj.bounds;
                this.frameRate = obj.frameRate;
                this.frameCount = obj.frameCount;
            };
            SWFFile.prototype.processFirstBatchOfDecompressedData = function (data) {
                this.processDecompressedData(data);
                this.parseHeaderContents();
                this._decompressor.onData = this.processDecompressedData.bind(this);
            };
            SWFFile.prototype.processDecompressedData = function (data) {
                // Make sure we don't cause an exception here when trying to set out-of-bound data by clamping the number of bytes
                // to write to the remaining space in our buffer. If this is the case, we probably got a wrong file length from
                // the SWF header. The Flash Player ignores data that goes over that given length, so should we.
                var length = Math.min(data.length, this._uncompressedLength - this._uncompressedLoadedLength);
                Shumway.ArrayUtilities.memCopy(this.data, data, this._uncompressedLoadedLength, 0, length);
                this._uncompressedLoadedLength += length;
            };
            SWFFile.prototype.scanLoadedData = function () {
                SWF.enterTimeline('Scan loaded SWF file tags');
                this._dataStream.pos = this._lastScanPosition;
                this.scanTagsToOffset(this._uncompressedLoadedLength, true);
                this._lastScanPosition = this._dataStream.pos;
                SWF.leaveTimeline();
            };
            SWFFile.prototype.scanTagsToOffset = function (endOffset, rootTimelineMode) {
                // `parsePos` is always at the start of a tag at this point, because it only gets updated
                // when a tag has been fully parsed.
                var tempTag = new UnparsedTag(0, 0, 0);
                var pos;
                while ((pos = this._dataStream.pos) < endOffset - 1) {
                    if (!this.parseNextTagHeader(tempTag)) {
                        break;
                    }
                    if (tempTag.tagCode === 0    /* CODE_END */) {
                        if (rootTimelineMode) {
                            this._endTagEncountered = true;
                        }
                        return;
                    }
                    var tagEnd = tempTag.byteOffset + tempTag.byteLength;
                    if (tagEnd > endOffset) {
                        this._dataStream.pos = pos;
                        return;
                    }
                    this.scanTag(tempTag, rootTimelineMode);
                    if (this._dataStream.pos !== tagEnd) {
                        this.emitTagSlopWarning(tempTag, tagEnd);
                    }
                }
            };
            /**
             * Parses tag header information at the current seek offset and stores it in the given object.
             *
             * Public so it can be used by tools to parse through entire SWFs.
             */
            SWFFile.prototype.parseNextTagHeader = function (target) {
                var position = this._dataStream.pos;
                var tagCodeAndLength = this._dataView.getUint16(position, true);
                position += 2;
                target.tagCode = tagCodeAndLength >> 6;
                var tagLength = tagCodeAndLength & 63;
                var extendedLength = tagLength === 63;
                if (extendedLength) {
                    if (position + 4 > this._uncompressedLoadedLength) {
                        return false;
                    }
                    tagLength = this._dataView.getUint32(position, true);
                    position += 4;
                }
                this._dataStream.pos = position;
                target.byteOffset = position;
                target.byteLength = tagLength;
                return true;
            };
            SWFFile.prototype.scanTag = function (tag, rootTimelineMode) {
                var stream = this._dataStream;
                var byteOffset = stream.pos;
                release || assert(byteOffset === tag.byteOffset);
                var tagCode = tag.tagCode;
                var tagLength = tag.byteLength;
                if (!release && SWF.traceLevel.value > 1) {
                    console.info('Scanning tag ' + getSwfTagCodeName(tagCode) + ' (start: ' + byteOffset + ', end: ' + (byteOffset + tagLength) + ')');
                }
                if (tagCode === 39    /* CODE_DEFINE_SPRITE */) {
                    // According to Chapter 13 of the SWF format spec, no nested definition tags are
                    // allowed within DefineSprite. However, they're added to the symbol dictionary
                    // anyway, and some tools produce them. Notably swfmill.
                    // We essentially treat them as though they came before the current sprite. That
                    // should be ok because it doesn't make sense for them to rely on their parent being
                    // fully defined - so they don't have to come after it -, and any control tags within
                    // the parent will just pick them up the moment they're defined, just as always.
                    this.addLazySymbol(tagCode, byteOffset, tagLength);
                    var spriteTagEnd = byteOffset + tagLength;
                    stream.pos += 4;
                    // Jump over symbol ID and frameCount.
                    this.scanTagsToOffset(spriteTagEnd, false);
                    if (this._dataStream.pos !== spriteTagEnd) {
                        this.emitTagSlopWarning(tag, spriteTagEnd);
                    }
                    return;
                }
                if (ImageDefinitionTags[tagCode]) {
                    // Images are decoded asynchronously, so we have to deal with them ahead of time to
                    // ensure they're ready when used.
                    var unparsed = this.addLazySymbol(tagCode, byteOffset, tagLength);
                    this.decodeEmbeddedImage(unparsed);
                    return;
                }
                if (FontDefinitionTags[tagCode]) {
                    var unparsed = this.addLazySymbol(tagCode, byteOffset, tagLength);
                    this.registerEmbeddedFont(unparsed);
                    return;
                }
                if (DefinitionTags[tagCode]) {
                    this.addLazySymbol(tagCode, byteOffset, tagLength);
                    this.jumpToNextTag(tagLength);
                    return;
                }
                if (!rootTimelineMode && !(tagCode === 76    /* CODE_SYMBOL_CLASS */ || tagCode === 56    /* CODE_EXPORT_ASSETS */)) {
                    this.jumpToNextTag(tagLength);
                    return;
                }
                if (ControlTags[tagCode]) {
                    this.addControlTag(tagCode, byteOffset, tagLength);
                    return;
                }
                switch (tagCode) {
                case 69    /* CODE_FILE_ATTRIBUTES */:
                    this.setFileAttributes(tagLength);
                    break;
                case 86    /* CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA */:
                    this.setSceneAndFrameLabelData(tagLength);
                    break;
                case 9    /* CODE_SET_BACKGROUND_COLOR */:
                    this.backgroundColor = Parser.LowLevel.parseRgb(this._dataStream);
                    break;
                case 8    /* CODE_JPEG_TABLES */:
                    // Only use the first JpegTables tag, ignore any following.
                    // TODO test it, swfdec is using the last one
                    if (!this._jpegTables) {
                        this._jpegTables = tagLength === 0 ? new Uint8Array(0) : this.data.subarray(stream.pos, stream.pos + tagLength - 2);
                    }
                    this.jumpToNextTag(tagLength);
                    break;
                case 82    /* CODE_DO_ABC */:
                case 72    /* CODE_DO_ABC_DEFINE */:
                    if (!this.useAVM1) {
                        var tagEnd = byteOffset + tagLength;
                        var abcBlock = new ABCBlock();
                        if (tagCode === 82    /* CODE_DO_ABC */) {
                            abcBlock.flags = stream.readUi32();
                            abcBlock.name = stream.readString(-1);
                        } else {
                            abcBlock.flags = 0;
                            abcBlock.name = '';
                        }
                        abcBlock.data = this.data.subarray(stream.pos, tagEnd);
                        this.abcBlocks.push(abcBlock);
                        stream.pos = tagEnd;
                    } else {
                        this.jumpToNextTag(tagLength);
                    }
                    break;
                case 76    /* CODE_SYMBOL_CLASS */:
                    var tagEnd = byteOffset + tagLength;
                    var symbolCount = stream.readUi16();
                    // TODO: check if symbols can be reassociated after instances have been created.
                    while (symbolCount--) {
                        var symbolId = stream.readUi16();
                        var symbolClassName = stream.readString(-1);
                        if (!release && SWF.traceLevel.value > 0) {
                            console.log('Registering symbol class ' + symbolClassName + ' to symbol ' + symbolId);
                        }
                        this.symbolClassesMap[symbolId] = symbolClassName;
                        this.symbolClassesList.push({
                            id: symbolId,
                            className: symbolClassName
                        });
                    }
                    // Make sure we move to end of tag even if the content is invalid.
                    stream.pos = tagEnd;
                    break;
                case 59    /* CODE_DO_INIT_ACTION */:
                    if (this.useAVM1) {
                        var initActionBlocks = this._currentInitActionBlocks || (this._currentInitActionBlocks = []);
                        var spriteId = this._dataView.getUint16(stream.pos, true);
                        var actionsData = this.data.subarray(byteOffset + 2, byteOffset + tagLength);
                        initActionBlocks.push({
                            spriteId: spriteId,
                            actionsData: actionsData
                        });
                    }
                    this.jumpToNextTag(tagLength);
                    break;
                case 12    /* CODE_DO_ACTION */:
                    if (this.useAVM1) {
                        var actionBlocks = this._currentActionBlocks || (this._currentActionBlocks = []);
                        var actionsData = this.data.subarray(stream.pos, stream.pos + tagLength);
                        actionBlocks.push({
                            actionsData: actionsData,
                            precedence: stream.pos
                        });
                    }
                    this.jumpToNextTag(tagLength);
                    break;
                case 18    /* CODE_SOUND_STREAM_HEAD */:
                case 45    /* CODE_SOUND_STREAM_HEAD2 */:
                    var soundStreamTag = Parser.LowLevel.parseSoundStreamHeadTag(this._dataStream, byteOffset + tagLength);
                    this._currentSoundStreamHead = Parser.SoundStream.FromTag(soundStreamTag);
                    break;
                case 19    /* CODE_SOUND_STREAM_BLOCK */:
                    this._currentSoundStreamBlock = this.data.subarray(stream.pos, stream.pos += tagLength);
                    break;
                case 43    /* CODE_FRAME_LABEL */:
                    var tagEnd = stream.pos + tagLength;
                    this._currentFrameLabel = stream.readString(-1);
                    // TODO: support SWF6+ anchors.
                    stream.pos = tagEnd;
                    break;
                case 1    /* CODE_SHOW_FRAME */:
                    this.finishFrame();
                    break;
                case 0    /* CODE_END */:
                    return;
                case 56    /* CODE_EXPORT_ASSETS */:
                    var tagEnd = stream.pos + tagLength;
                    var exportsCount = stream.readUi16();
                    var exports = this._currentExports || (this._currentExports = []);
                    while (exportsCount--) {
                        var symbolId = stream.readUi16();
                        var className = stream.readString(-1);
                        if (stream.pos > tagEnd) {
                            stream.pos = tagEnd;
                            break;
                        }
                        exports.push(new SymbolExport(symbolId, className));
                    }
                    stream.pos = tagEnd;
                    break;
                case 23    /* CODE_DEFINE_BUTTON_CXFORM */:
                case 17    /* CODE_DEFINE_BUTTON_SOUND */:
                case 13    /* CODE_DEFINE_FONT_INFO */:
                case 62    /* CODE_DEFINE_FONT_INFO2 */:
                case 78    /* CODE_DEFINE_SCALING_GRID */:
                case 57    /* CODE_IMPORT_ASSETS */:
                case 71    /* CODE_IMPORT_ASSETS2 */:
                    Shumway.Debug.warning('Unsupported tag encountered ' + tagCode + ': ' + getSwfTagCodeName(tagCode));
                    this.jumpToNextTag(tagLength);
                    break;
                // These tags should be supported at some point, but for now, we ignore them.
                case 74    /* CODE_CSM_TEXT_SETTINGS */:
                case 73    /* CODE_DEFINE_FONT_ALIGN_ZONES */:
                case 65    /* CODE_SCRIPT_LIMITS */:
                case 66    /* CODE_SET_TAB_INDEX */:
                // These tags are used by the player, but not relevant to us.
                case 58    /* CODE_ENABLE_DEBUGGER */:
                case 64    /* CODE_ENABLE_DEBUGGER2 */:
                case 63    /* CODE_DEBUG_ID */:
                case 88    /* CODE_DEFINE_FONT_NAME */:
                case 40    /* CODE_NAME_CHARACTER */:
                case 41    /* CODE_PRODUCT_INFO */:
                case 77    /* CODE_METADATA */:
                case 24    /* CODE_PROTECT */:
                case 25    /* CODE_PATHS_ARE_POSTSCRIPT */:
                case 93    /* CODE_TELEMETRY */:
                // These are obsolete Generator-related tags.
                case 55    /* CODE_GEN_TAG_OBJECTS */:
                case 49    /* CODE_GEN_COMMAND */:
                    this.jumpToNextTag(tagLength);
                    break;
                // These tags aren't used in the player.
                case 51    /* CODE_CHARACTER_SET */:
                case 44    /* CODE_DEFINE_BEHAVIOUR */:
                case 50    /* CODE_DEFINE_COMMAND_OBJECT */:
                case 53    /* CODE_DEFINE_FUNCTION */:
                case 42    /* CODE_DEFINE_TEXT_FORMAT */:
                case 38    /* CODE_DEFINE_VIDEO */:
                case 52    /* CODE_EXTERNAL_FONT */:
                case 3    /* CODE_FREE_CHARACTER */:
                case 31    /* CODE_FREE_ALL */:
                case 47    /* CODE_GENERATE_FRAME */:
                case 16    /* CODE_STOP_SOUND */:
                case 29    /* CODE_SYNC_FRAME */:
                    console.info('Ignored tag (these shouldn\'t occur) ' + tagCode + ': ' + getSwfTagCodeName(tagCode));
                    this.jumpToNextTag(tagLength);
                    break;
                default:
                    if (tagCode > 100) {
                        Shumway.Debug.warning('Encountered undefined tag ' + tagCode + ', probably used for AVM1 ' + 'obfuscation. See http://ijs.mtasa.com/files/swfdecrypt.cpp.');
                    } else {
                        Shumway.Debug.warning('Tag not handled by the parser: ' + tagCode + ': ' + getSwfTagCodeName(tagCode));
                    }
                    this.jumpToNextTag(tagLength);
                }
            };
            SWFFile.prototype.parseSpriteTimeline = function (spriteTag) {
                SWF.enterTimeline('parseSpriteTimeline');
                var data = this.data;
                var stream = this._dataStream;
                var dataView = this._dataView;
                var timeline = {
                    id: spriteTag.id,
                    type: 'sprite',
                    frames: []
                };
                var spriteTagEnd = spriteTag.byteOffset + spriteTag.byteLength;
                var frames = timeline.frames;
                var label = null;
                var controlTags = [];
                var soundStreamHead = null;
                var soundStreamBlock = null;
                var actionBlocks = null;
                var initActionBlocks = null;
                // Skip ID.
                stream.pos = spriteTag.byteOffset + 2;
                // TODO: check if numFrames or the real number of ShowFrame tags wins. (Probably the former.)
                timeline.frameCount = dataView.getUint16(stream.pos, true);
                stream.pos += 2;
                var spriteContentTag = new UnparsedTag(0, 0, 0);
                while (stream.pos < spriteTagEnd) {
                    this.parseNextTagHeader(spriteContentTag);
                    var tagLength = spriteContentTag.byteLength;
                    var tagCode = spriteContentTag.tagCode;
                    if (stream.pos + tagLength > spriteTagEnd) {
                        Shumway.Debug.warning('DefineSprite child tags exceed DefineSprite tag length and are dropped');
                        break;
                    }
                    if (Parser.ControlTags[tagCode]) {
                        controlTags.push(new UnparsedTag(tagCode, stream.pos, tagLength));
                        stream.pos += tagLength;
                        continue;
                    }
                    switch (tagCode) {
                    case 12    /* CODE_DO_ACTION */:
                        if (this.useAVM1) {
                            if (!actionBlocks) {
                                actionBlocks = [];
                            }
                            var actionsData = data.subarray(stream.pos, stream.pos + tagLength);
                            actionBlocks.push({
                                actionsData: actionsData,
                                precedence: stream.pos
                            });
                        }
                        break;
                    case 59    /* CODE_DO_INIT_ACTION */:
                        if (this.useAVM1) {
                            if (!initActionBlocks) {
                                initActionBlocks = [];
                            }
                            var spriteId = dataView.getUint16(stream.pos, true);
                            stream.pos += 2;
                            var actionsData = data.subarray(stream.pos, stream.pos + tagLength);
                            initActionBlocks.push({
                                spriteId: spriteId,
                                actionsData: actionsData
                            });
                        }
                        break;
                    case 43    /* CODE_FRAME_LABEL */:
                        var tagEnd = stream.pos + tagLength;
                        label = stream.readString(-1);
                        // TODO: support SWF6+ anchors.
                        stream.pos = tagEnd;
                        tagLength = 0;
                        break;
                    case 1    /* CODE_SHOW_FRAME */:
                        frames.push(new SWFFrame(controlTags, label, soundStreamHead, soundStreamBlock, actionBlocks, initActionBlocks, null));
                        label = null;
                        controlTags = [];
                        soundStreamHead = null;
                        soundStreamBlock = null;
                        actionBlocks = null;
                        initActionBlocks = null;
                        break;
                    case 0    /* CODE_END */:
                        stream.pos = spriteTagEnd;
                        tagLength = 0;
                        break;
                    default:
                    }
                    stream.pos += tagLength;
                    release || assert(stream.pos <= spriteTagEnd);
                }
                SWF.leaveTimeline();
                return timeline;
            };
            SWFFile.prototype.jumpToNextTag = function (currentTagLength) {
                this._dataStream.pos += currentTagLength;
            };
            SWFFile.prototype.emitTagSlopWarning = function (tag, tagEnd) {
                var consumedBytes = this._dataStream.pos - tag.byteOffset;
                Shumway.Debug.warning('Scanning ' + getSwfTagCodeName(tag.tagCode) + ' at offset ' + tag.byteOffset + ' consumed ' + consumedBytes + ' of ' + tag.byteLength + ' bytes. (' + (tag.byteLength - consumedBytes) + ' left)');
                this._dataStream.pos = tagEnd;
            };
            SWFFile.prototype.finishFrame = function () {
                if (this.pendingUpdateDelays === 0) {
                    this.framesLoaded++;
                }
                this.frames.push(new SWFFrame(this._currentControlTags, this._currentFrameLabel, this._currentSoundStreamHead, this._currentSoundStreamBlock, this._currentActionBlocks, this._currentInitActionBlocks, this._currentExports));
                this._currentFrameLabel = null;
                this._currentControlTags = null;
                this._currentSoundStreamHead = null;
                this._currentSoundStreamBlock = null;
                this._currentActionBlocks = null;
                this._currentInitActionBlocks = null;
                this._currentExports = null;
            };
            SWFFile.prototype.setFileAttributes = function (tagLength) {
                // TODO: check what happens to attributes tags that aren't the first tag.
                if (this.attributes) {
                    this.jumpToNextTag(tagLength);
                }
                var bits = this.data[this._dataStream.pos];
                this._dataStream.pos += 4;
                this.attributes = {
                    network: bits & 1,
                    relativeUrls: bits & 2,
                    noCrossDomainCaching: bits & 4,
                    doAbc: bits & 8,
                    hasMetadata: bits & 16,
                    useGpu: bits & 32,
                    useDirectBlit: bits & 64
                };
                this.useAVM1 = !this.attributes.doAbc;
            };
            SWFFile.prototype.setSceneAndFrameLabelData = function (tagLength) {
                if (this.sceneAndFrameLabelData) {
                    this.jumpToNextTag(tagLength);
                    return;
                }
                this.sceneAndFrameLabelData = Parser.LowLevel.parseDefineSceneTag(this._dataStream, 86    /* CODE_DEFINE_SCENE_AND_FRAME_LABEL_DATA */);
            };
            SWFFile.prototype.addControlTag = function (tagCode, byteOffset, tagLength) {
                var controlTags = this._currentControlTags || (this._currentControlTags = []);
                controlTags.push(new UnparsedTag(tagCode, byteOffset, tagLength));
                this.jumpToNextTag(tagLength);
            };
            SWFFile.prototype.addLazySymbol = function (tagCode, byteOffset, tagLength) {
                var id = this._dataView.getUint16(this._dataStream.pos, true);
                var symbol = new DictionaryEntry(id, tagCode, byteOffset, tagLength);
                this.dictionary[id] = symbol;
                if (!release && SWF.traceLevel.value > 0) {
                    console.info('Registering symbol ' + id + ' of type ' + getSwfTagCodeName(tagCode));
                }
                return symbol;
            };
            SWFFile.prototype.decodeEmbeddedFont = function (unparsed) {
                var definition = this.getParsedTag(unparsed);
                var symbol = new EagerlyParsedDictionaryEntry(definition.id, unparsed, 'font', definition, this.env);
                if (!release && SWF.traceLevel.value > 0) {
                    var style = flagsToFontStyle(definition.bold, definition.italic);
                    console.info('Decoding embedded font ' + definition.id + ' with name \'' + definition.name + '\' and style ' + style, definition);
                }
                this.eagerlyParsedSymbolsMap[symbol.id] = symbol;
                this.eagerlyParsedSymbolsList.push(symbol);
                var style = flagsToFontStyle(definition.bold, definition.italic);
                this.fonts.push({
                    name: definition.name,
                    id: definition.id,
                    style: style
                });
            };
            SWFFile.prototype.registerEmbeddedFont = function (unparsed) {
                if (!inFirefox) {
                    this.decodeEmbeddedFont(unparsed);
                    return;
                }
                var stream = this._dataStream;
                var id = this._dataView.getUint16(stream.pos, true);
                var style;
                var name;
                // DefineFont only specifies a symbol ID, no font name or style.
                if (unparsed.tagCode === 10    /* CODE_DEFINE_FONT */) {
                    // Assigning some unique name to simplify font registration and look ups.
                    name = '__autofont__' + unparsed.byteOffset;
                    style = 'regular';
                } else {
                    var flags = this.data[stream.pos + 2];
                    style = flagsToFontStyle(!!(flags & 1), !!(flags & 2));
                    var nameLength = this.data[stream.pos + 4];
                    // Skip language code.
                    stream.pos += 5;
                    name = stream.readString(nameLength);
                }
                this.fonts.push({
                    name: name,
                    id: id,
                    style: style
                });
                if (!release && SWF.traceLevel.value > 0) {
                    console.info('Registering embedded font ' + id + ' with name \'' + name + '\' and style ' + style);
                }
                stream.pos = unparsed.byteOffset + unparsed.byteLength;
            };
            SWFFile.prototype.decodeEmbeddedImage = function (unparsed) {
                var definition = this.getParsedTag(unparsed);
                var symbol = new EagerlyParsedDictionaryEntry(definition.id, unparsed, 'image', definition, this.env);
                if (!release && SWF.traceLevel.value > 0) {
                    console.info('Decoding embedded image ' + definition.id + ' of type ' + getSwfTagCodeName(unparsed.tagCode) + ' (start: ' + unparsed.byteOffset + ', end: ' + (unparsed.byteOffset + unparsed.byteLength) + ')');
                }
                this.eagerlyParsedSymbolsMap[symbol.id] = symbol;
                this.eagerlyParsedSymbolsList.push(symbol);
            };
            return SWFFile;
        }();
        SWF.SWFFile = SWFFile;
        function flagsToFontStyle(bold, italic) {
            if (bold && italic) {
                return 'boldItalic';
            }
            if (bold) {
                return 'bold';
            }
            if (italic) {
                return 'italic';
            }
            return 'regular';
        }
        var SWFFrame = function () {
            function SWFFrame(controlTags, labelName, soundStreamHead, soundStreamBlock, actionBlocks, initActionBlocks, exports) {
                release || controlTags && Object.freeze(controlTags);
                this.controlTags = controlTags;
                this.labelName = labelName;
                release || actionBlocks && Object.freeze(actionBlocks);
                this.soundStreamHead = soundStreamHead;
                this.soundStreamBlock = soundStreamBlock;
                this.actionBlocks = actionBlocks;
                release || initActionBlocks && Object.freeze(initActionBlocks);
                this.initActionBlocks = initActionBlocks;
                release || exports && Object.freeze(exports);
                this.exports = exports;
            }
            return SWFFrame;
        }();
        SWF.SWFFrame = SWFFrame;
        var ABCBlock = function () {
            function ABCBlock() {
            }
            return ABCBlock;
        }();
        SWF.ABCBlock = ABCBlock;
        var ActionBlock = function () {
            function ActionBlock() {
            }
            return ActionBlock;
        }();
        SWF.ActionBlock = ActionBlock;
        var InitActionBlock = function () {
            function InitActionBlock() {
            }
            return InitActionBlock;
        }();
        SWF.InitActionBlock = InitActionBlock;
        var SymbolExport = function () {
            function SymbolExport(symbolId, className) {
                this.symbolId = symbolId;
                this.className = className;
            }
            return SymbolExport;
        }();
        SWF.SymbolExport = SymbolExport;
        var UnparsedTag = function () {
            function UnparsedTag(tagCode, byteOffset, byteLength) {
                this.tagCode = tagCode;
                this.byteOffset = byteOffset;
                this.byteLength = byteLength;
            }
            return UnparsedTag;
        }();
        SWF.UnparsedTag = UnparsedTag;
        var DictionaryEntry = function (_super) {
            __extends(DictionaryEntry, _super);
            function DictionaryEntry(id, tagCode, byteOffset, byteLength) {
                _super.call(this, tagCode, byteOffset, byteLength);
                this.id = id;
            }
            return DictionaryEntry;
        }(UnparsedTag);
        SWF.DictionaryEntry = DictionaryEntry;
        var EagerlyParsedDictionaryEntry = function (_super) {
            __extends(EagerlyParsedDictionaryEntry, _super);
            function EagerlyParsedDictionaryEntry(id, unparsed, type, definition, env) {
                _super.call(this, id, unparsed.tagCode, unparsed.byteOffset, unparsed.byteLength);
                this.type = type;
                this.definition = definition;
                this.env = env;
                this.ready = false;
            }
            return EagerlyParsedDictionaryEntry;
        }(DictionaryEntry);
        SWF.EagerlyParsedDictionaryEntry = EagerlyParsedDictionaryEntry;
        function readSWFLength(bytes) {
            // We read the length manually because creating a DataView just for that is silly.
            return (bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24) >>> 0;
        }
        function defineSymbol(swfTag, symbols) {
            switch (swfTag.code) {
            case 6    /* CODE_DEFINE_BITS */:
            case 21    /* CODE_DEFINE_BITS_JPEG2 */:
            case 35    /* CODE_DEFINE_BITS_JPEG3 */:
            case 90    /* CODE_DEFINE_BITS_JPEG4 */:
                return Shumway.SWF.Parser.defineImage(swfTag);
            case 20    /* CODE_DEFINE_BITS_LOSSLESS */:
            case 36    /* CODE_DEFINE_BITS_LOSSLESS2 */:
                return Shumway.SWF.Parser.defineBitmap(swfTag);
            case 7    /* CODE_DEFINE_BUTTON */:
            case 34    /* CODE_DEFINE_BUTTON2 */:
                return Shumway.SWF.Parser.defineButton(swfTag, symbols);
            case 37    /* CODE_DEFINE_EDIT_TEXT */:
                return Shumway.SWF.Parser.defineText(swfTag);
            case 10    /* CODE_DEFINE_FONT */:
            case 48    /* CODE_DEFINE_FONT2 */:
            case 75    /* CODE_DEFINE_FONT3 */:
            case 91    /* CODE_DEFINE_FONT4 */:
                return Shumway.SWF.Parser.defineFont(swfTag);
            case 46    /* CODE_DEFINE_MORPH_SHAPE */:
            case 84    /* CODE_DEFINE_MORPH_SHAPE2 */:
            case 2    /* CODE_DEFINE_SHAPE */:
            case 22    /* CODE_DEFINE_SHAPE2 */:
            case 32    /* CODE_DEFINE_SHAPE3 */:
            case 83    /* CODE_DEFINE_SHAPE4 */:
                return Shumway.SWF.Parser.defineShape(swfTag);
            case 14    /* CODE_DEFINE_SOUND */:
                return Shumway.SWF.Parser.defineSound(swfTag);
            case 60    /* CODE_DEFINE_VIDEO_STREAM */:
                return {
                    type: 'video',
                    id: swfTag.id,
                    width: swfTag.width,
                    height: swfTag.height,
                    deblocking: swfTag.deblocking,
                    smoothing: swfTag.smoothing,
                    codec: swfTag.codecId
                };
            case 39    /* CODE_DEFINE_SPRITE */:
                // Sprites are fully defined at this point.
                return swfTag;
            case 87    /* CODE_DEFINE_BINARY_DATA */:
                return {
                    type: 'binary',
                    id: swfTag.id,
                    data: swfTag.data
                };
            case 11    /* CODE_DEFINE_TEXT */:
            case 33    /* CODE_DEFINE_TEXT2 */:
                return Shumway.SWF.Parser.defineLabel(swfTag);
            default:
                return swfTag;
            }
        }
    }(SWF = Shumway.SWF || (Shumway.SWF = {})));
    var ImageTypeMagicHeaderBytes;
    (function (ImageTypeMagicHeaderBytes) {
        ImageTypeMagicHeaderBytes[ImageTypeMagicHeaderBytes['JPG'] = 16767231] = 'JPG';
        ImageTypeMagicHeaderBytes[ImageTypeMagicHeaderBytes['PNG'] = 8998990] = 'PNG';
        ImageTypeMagicHeaderBytes[ImageTypeMagicHeaderBytes['GIF'] = 4671814] = 'GIF';
    }(ImageTypeMagicHeaderBytes || (ImageTypeMagicHeaderBytes = {})));
    var mimetypesForHeaders = {};
    mimetypesForHeaders[ImageTypeMagicHeaderBytes.JPG] = 'image/jpeg';
    mimetypesForHeaders[ImageTypeMagicHeaderBytes.PNG] = 'image/png';
    mimetypesForHeaders[ImageTypeMagicHeaderBytes.GIF] = 'image/gif';
    var ImageFile = function () {
        function ImageFile(header, fileLength, env) {
            this.type = 4;
            this.env = env;
            this.bytesLoaded = header.length;
            if (header.length === fileLength) {
                this.data = header;
            } else {
                this.data = new Uint8Array(fileLength);
                this.data.set(header);
            }
            this.setMimetype();
        }
        Object.defineProperty(ImageFile.prototype, 'bytesTotal', {
            get: function () {
                return this.data.length;
            },
            enumerable: true,
            configurable: true
        });
        ImageFile.prototype.appendLoadedData = function (data) {
            this.data.set(data, this.bytesLoaded);
            this.bytesLoaded += data.length;
        };
        ImageFile.prototype.setMimetype = function () {
            var magic = this.data[0] << 16 | this.data[1] << 8 | this.data[2];
            this.mimeType = mimetypesForHeaders[magic];
        };
        return ImageFile;
    }();
    Shumway.ImageFile = ImageFile;
    var assert = Shumway.Debug.assert;
    var SWFFile = Shumway.SWF.SWFFile;
    // Minimal amount of data to load before starting to parse. Chosen fairly arbitrarily.
    var MIN_LOADED_BYTES = 8192;
    var LoadProgressUpdate = function () {
        function LoadProgressUpdate(bytesLoaded, framesLoaded) {
            this.bytesLoaded = bytesLoaded;
            this.framesLoaded = framesLoaded;
        }
        return LoadProgressUpdate;
    }();
    Shumway.LoadProgressUpdate = LoadProgressUpdate;
    var FileLoader = function () {
        function FileLoader(listener, env) {
            release || assert(listener);
            this._file = null;
            this._url = '';
            this._listener = listener;
            this._env = env;
            this._loadingServiceSession = null;
            this._delayedUpdatesPromise = null;
            this._bytesLoaded = 0;
        }
        // TODO: strongly type
        FileLoader.prototype.loadFile = function (request) {
            this._url = request.url;
            Shumway.SWF.enterTimeline('Load file', request.url);
            this._bytesLoaded = 0;
            var session = this._loadingServiceSession = Shumway.FileLoadingService.instance.createSession();
            session.onopen = this.processLoadOpen.bind(this);
            session.onprogress = this.processNewData.bind(this);
            session.onerror = this.processError.bind(this);
            session.onclose = this.processLoadClose.bind(this);
            session.open(request);
        };
        FileLoader.prototype.abortLoad = function () {
            if (this._loadingServiceSession) {
                this._loadingServiceSession.close();
                Shumway.SWF.leaveTimeline();
            }
            this._file = null;
        };
        FileLoader.prototype.loadBytes = function (bytes) {
            Shumway.SWF.enterTimeline('Load bytes');
            this.processLoadOpen();
            this.processNewData(bytes, {
                bytesLoaded: bytes.length,
                bytesTotal: bytes.length
            });
            this.processLoadClose();    // SWF.leaveTimeline happens in processLoadClose.
        };
        FileLoader.prototype.processLoadOpen = function () {
            release || assert(!this._file);
        };
        FileLoader.prototype.processNewData = function (data, progressInfo) {
            this._bytesLoaded += data.length;
            var isLoadingInProgress = progressInfo.bytesLoaded < progressInfo.bytesTotal;
            if (this._bytesLoaded < MIN_LOADED_BYTES && isLoadingInProgress) {
                if (!this._queuedInitialData) {
                    this._queuedInitialData = new Uint8Array(Math.min(MIN_LOADED_BYTES, progressInfo.bytesTotal));
                }
                this._queuedInitialData.set(data, this._bytesLoaded - data.length);
                return;
            } else if (this._queuedInitialData) {
                var allData = new Uint8Array(this._bytesLoaded);
                allData.set(this._queuedInitialData);
                allData.set(data, this._bytesLoaded - data.length);
                data = allData;
                this._queuedInitialData = null;
            }
            var file = this._file;
            var eagerlyParsedSymbolsCount = 0;
            var previousFramesLoaded = 0;
            if (!file) {
                file = this._file = createFileInstanceForHeader(data, progressInfo.bytesTotal, this._env);
                if (file) {
                    this._listener.onLoadOpen(file);
                }
            } else {
                if (file instanceof SWFFile) {
                    eagerlyParsedSymbolsCount = file.eagerlyParsedSymbolsList.length;
                    previousFramesLoaded = file.framesLoaded;
                }
                file.appendLoadedData(data);
            }
            if (file instanceof SWFFile) {
                this.processSWFFileUpdate(file, eagerlyParsedSymbolsCount, previousFramesLoaded);
            } else {
                release || assert(file instanceof Shumway.ImageFile);
                this._listener.onLoadProgress(new LoadProgressUpdate(progressInfo.bytesLoaded, -1));
                if (progressInfo.bytesLoaded === progressInfo.bytesTotal) {
                    this._listener.onImageBytesLoaded();
                }
            }
        };
        FileLoader.prototype.processError = function (error) {
            Shumway.Debug.warning('Loading error encountered:', error);
        };
        FileLoader.prototype.processLoadClose = function () {
            var file = this._file;
            if (!file) {
                this._listener.onLoadOpen(null);
                return;
            }
            if (file instanceof SWFFile) {
                var eagerlyParsedSymbolsCount = file.eagerlyParsedSymbolsList.length;
                var previousFramesLoaded = file.framesLoaded;
                file.finishLoading();
                this.processSWFFileUpdate(file, eagerlyParsedSymbolsCount, previousFramesLoaded);
            }
            if (file.bytesLoaded !== file.bytesTotal) {
                Shumway.Debug.warning('Shouldn\'t have reached this: aborting a load should prevent this from ' + 'being called.');
                Shumway.Debug.warning(new Error().stack);
            } else {
                Shumway.SWF.leaveTimeline();
            }
        };
        FileLoader.prototype.processSWFFileUpdate = function (file, previousEagerlyParsedSymbolsCount, previousFramesLoaded) {
            var promise;
            var eagerlyParsedSymbolsDelta = file.eagerlyParsedSymbolsList.length - previousEagerlyParsedSymbolsCount;
            if (!eagerlyParsedSymbolsDelta) {
                var update = this._lastDelayedUpdate;
                if (!update) {
                    release || assert(file.framesLoaded === file.frames.length);
                    this._listener.onLoadProgress(new LoadProgressUpdate(file.bytesLoaded, file.framesLoaded));
                } else {
                    release || assert(update.framesLoaded <= file.frames.length);
                    update.bytesLoaded = file.bytesLoaded;
                    update.framesLoaded = file.frames.length;
                }
                return;
            }
            promise = this._listener.onNewEagerlyParsedSymbols(file.eagerlyParsedSymbolsList, eagerlyParsedSymbolsDelta);
            if (this._delayedUpdatesPromise) {
                promise = Promise.all([
                    this._delayedUpdatesPromise,
                    promise
                ]);
            }
            this._delayedUpdatesPromise = promise;
            var update = new LoadProgressUpdate(file.bytesLoaded, file.frames.length);
            this._lastDelayedUpdate = update;
            file.pendingUpdateDelays++;
            var self = this;
            // Make sure the framesLoaded value from after this update isn't yet visible. Otherwise,
            // we might signal a higher value than allowed if this update is delayed sufficiently long
            // for another update to arrive in the meantime. That update sets the framesLoaded value too
            // high. Then, this update gets resolved, but signals a value for framesLoaded that's too
            // high.
            file.framesLoaded = previousFramesLoaded;
            promise.then(function () {
                if (!release && Shumway.SWF.traceLevel.value > 0) {
                    console.log('Reducing pending update delays from ' + file.pendingUpdateDelays + ' to ' + (file.pendingUpdateDelays - 1));
                }
                file.pendingUpdateDelays--;
                release || assert(file.pendingUpdateDelays >= 0);
                file.framesLoaded = update.framesLoaded;
                self._listener.onLoadProgress(update);
                if (self._delayedUpdatesPromise === promise) {
                    self._delayedUpdatesPromise = null;
                    self._lastDelayedUpdate = null;
                }
            });
        };
        return FileLoader;
    }();
    Shumway.FileLoader = FileLoader;
    function createFileInstanceForHeader(header, fileLength, env) {
        var magic = header[0] << 16 | header[1] << 8 | header[2];
        if ((magic & 65535) === FileTypeMagicHeaderBytes.SWF) {
            return new SWFFile(header, fileLength, env);
        }
        if (magic === FileTypeMagicHeaderBytes.JPG || magic === FileTypeMagicHeaderBytes.PNG || magic === FileTypeMagicHeaderBytes.GIF) {
            return new Shumway.ImageFile(header, fileLength, env);
        }
        // TODO: throw instead of returning null? Perhaps?
        return null;
    }
    var FileTypeMagicHeaderBytes;
    (function (FileTypeMagicHeaderBytes) {
        FileTypeMagicHeaderBytes[FileTypeMagicHeaderBytes['SWF'] = 22355] = 'SWF';
        FileTypeMagicHeaderBytes[FileTypeMagicHeaderBytes['JPG'] = 16767231] = 'JPG';
        FileTypeMagicHeaderBytes[FileTypeMagicHeaderBytes['PNG'] = 8998990] = 'PNG';
        FileTypeMagicHeaderBytes[FileTypeMagicHeaderBytes['GIF'] = 4671814] = 'GIF';
    }(FileTypeMagicHeaderBytes || (FileTypeMagicHeaderBytes = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='../../build/ts/tools.d.ts' />
///<reference path='parser/references.ts' />
///<reference path='module.ts'/>
///<reference path='settings.ts'/>
///<reference path='stream.ts' />
///<reference path='mp3decodersession.ts' />
///<reference path='SWFFile.ts' />
///<reference path='ImageFile.ts' />
///<reference path='FileLoader.ts' />
//# sourceMappingURL=swf.js.map
console.timeEnd('Load SWF Parser');
// !inline console.time("Load Compiled Code Cache");
// !inline console.timeEnd("Load Compiled Code Cache");
// Load Flash TS Dependencies
console.time('Load Flash TS Dependencies');
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    /*
     * HTML Parser By John Resig (ejohn.org)
     * Original code by Erik Arvidsson, Mozilla Public License
     * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
     *
     * // Use like so:
     * HTMLParser(htmlString, {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * });
     *
     */
    // Regular Expressions for parsing tags and attributes
    var startTag = /^<([-A-Za-z0-9_]+)((?:\s+[-A-Za-z0-9_]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/, endTag = /^<\/([-A-Za-z0-9_]+)[^>]*>/, attr = /([-A-Za-z0-9_]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;
    // Empty Elements - HTML 4.01
    var empty = makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed');
    // Block Elements - HTML 4.01
    var block = makeMap('address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul');
    // Inline Elements - HTML 4.01
    var inline = makeMap('a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var');
    // Elements that you can, intentionally, leave open
    // (and which close themselves)
    var closeSelf = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr');
    // Attributes that have their values filled in disabled="disabled"
    var fillAttrs = makeMap('checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected');
    // Special Elements (can contain anything)
    var special = makeMap('script,style');
    function HTMLParser(html, handler) {
        var index, chars, match, stack = [], last = html;
        function top() {
            return stack[stack.length - 1];
        }
        while (html) {
            chars = true;
            // Make sure we're not in a script or style element
            if (!top() || !special[top()]) {
                // Comment
                if (html.indexOf('<!--') == 0) {
                    index = html.indexOf('-->');
                    if (index >= 0) {
                        if (handler.comment)
                            handler.comment(html.substring(4, index));
                        html = html.substring(index + 3);
                        chars = false;
                    }
                } else if (html.indexOf('</') == 0) {
                    match = html.match(endTag);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(endTag, parseEndTag);
                        chars = false;
                    }
                } else if (html.indexOf('<') == 0) {
                    match = html.match(startTag);
                    if (match) {
                        html = html.substring(match[0].length);
                        match[0].replace(startTag, parseStartTag);
                        chars = false;
                    }
                }
                if (chars) {
                    index = html.indexOf('<');
                    var text = index < 0 ? html : html.substring(0, index);
                    html = index < 0 ? '' : html.substring(index);
                    if (handler.chars)
                        handler.chars(text);
                }
            } else {
                html = html.replace(new RegExp('(.*)</' + top() + '[^>]*>'), function (all, text) {
                    text = text.replace(/<!--(.*?)-->/g, '$1').replace(/<!\[CDATA\[(.*?)]]>/g, '$1');
                    if (handler.chars)
                        handler.chars(text);
                    return '';
                });
                parseEndTag('', top());
            }
            if (html == last)
                throw 'Parse Error: ' + html;
            last = html;
        }
        // Clean up any remaining tags
        parseEndTag();
        function parseStartTag(tag, tagName, rest, unary) {
            tagName = tagName.toLowerCase();
            if (block[tagName]) {
                while (top() && inline[top()]) {
                    parseEndTag('', top());
                }
            }
            if (closeSelf[tagName] && top() == tagName) {
                parseEndTag('', tagName);
            }
            unary = empty[tagName] || !!unary;
            if (!unary)
                stack.push(tagName);
            if (handler.start) {
                var attrs = Object.create(null);
                rest.replace(attr, function (match, name) {
                    name = name.toLowerCase();
                    var value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] : fillAttrs[name] ? name : '';
                    attrs[name] = value;
                    return match;
                });
                if (handler.start)
                    handler.start(tagName, attrs, !!unary);
            }
        }
        function parseEndTag(tag, tagName) {
            // If no tag name is provided, clean shop
            if (!tagName)
                var pos = 0;
            else
                for (var pos = stack.length - 1; pos >= 0; pos--)
                    if (stack[pos] == tagName)
                        break;
            if (pos >= 0) {
                // Close all the open elements, up the stack
                for (var i = stack.length - 1; i >= pos; i--)
                    if (handler.end)
                        handler.end(stack[i]);
                // Remove the open elements from the stack
                stack.length = pos;
            }
        }
    }
    Shumway.HTMLParser = HTMLParser;
    ;
    function makeMap(str) {
        var obj = {}, items = str.split(',');
        for (var i = 0; i < items.length; i++)
            obj[items[i]] = true;
        return obj;
    }
    var notImplemented = Shumway.Debug.notImplemented;
    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
    var Bounds = Shumway.Bounds;
    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
    var ColorUtilities = Shumway.ColorUtilities;
    var flash = Shumway.AVMX.AS.flash;
    var altTieBreakRound = Shumway.NumberUtilities.altTieBreakRound;
    var _decodeHTMLMap = {
        lt: '<',
        gt: '>',
        amp: '&',
        quot: '"',
        apos: '\'',
        nbsp: '\xA0'
    };
    /**
     * Decodes strings of the format:
     *
     * &#0000;
     * &#x0000;
     * &#x0000;
     * &amp;
     * &lthello
     *
     * This is complete enough to handle encoded HTML produced by the Flash IDE.
     */
    function decodeHTML(s) {
        var r = '';
        for (var i = 0; i < s.length; i++) {
            var c = s.charAt(i);
            if (c !== '&') {
                r += c;
            } else {
                // Look for the first '&' or ';', both of these can terminate
                // the current char code.
                var j = Shumway.StringUtilities.indexOfAny(s, [
                    '&',
                    ';'
                ], i + 1);
                if (j > 0) {
                    var v = s.substring(i + 1, j);
                    if (v.length > 1 && v.charAt(0) === '#') {
                        var n = 0;
                        if (v.length > 2 && v.charAt(1) === 'x') {
                            n = parseInt(v.substring(1));
                        } else {
                            n = parseInt(v.substring(2), 16);
                        }
                        r += String.fromCharCode(n);
                    } else {
                        if (_decodeHTMLMap[v] !== undefined) {
                            r += _decodeHTMLMap[v];
                        } else {
                            Shumway.Debug.unexpected(v);
                        }
                    }
                    i = j;
                } else {
                    // Flash sometimes generates entities that don't have terminators,
                    // like &bthello. Strong bad sometimes encodes this that way.
                    for (var k in _decodeHTMLMap) {
                        if (s.indexOf(k, i + 1) === i + 1) {
                            r += _decodeHTMLMap[k];
                            i += k.length;
                            break;
                        }
                    }
                }
            }
        }
        return r;
    }
    var TextContent = function () {
        function TextContent(sec, defaultTextFormat) {
            this.sec = sec;
            this._id = sec.flash.display.DisplayObject.axClass.getNextSyncID();
            this._bounds = new Bounds(0, 0, 0, 0);
            this._plainText = '';
            this._backgroundColor = 0;
            this._borderColor = 0;
            this._autoSize = 0;
            this._wordWrap = false;
            this._scrollV = 1;
            this._scrollH = 0;
            this.flags = 0    /* None */;
            this.defaultTextFormat = defaultTextFormat || new sec.flash.text.TextFormat();
            this.textRuns = [];
            this.textRunData = new DataBuffer();
            this.matrix = null;
            this.coords = null;
        }
        TextContent.prototype.parseHtml = function (htmlText, styleSheet, multiline) {
            var _this = this;
            var plainText = '';
            var textRuns = this.textRuns;
            textRuns.length = 0;
            var beginIndex = 0;
            var endIndex = 0;
            var textFormat = this.defaultTextFormat.clone();
            var prevTextRun = null;
            var stack = [];
            var handler;
            Shumway.HTMLParser(htmlText, handler = {
                chars: function (text) {
                    text = decodeHTML(text);
                    plainText += text;
                    endIndex += text.length;
                    if (endIndex - beginIndex) {
                        if (prevTextRun && prevTextRun.textFormat.equals(textFormat)) {
                            prevTextRun.endIndex = endIndex;
                        } else {
                            prevTextRun = new _this.sec.flash.text.TextRun(beginIndex, endIndex, textFormat);
                            textRuns.push(prevTextRun);
                        }
                        beginIndex = endIndex;
                    }
                },
                start: function (tagName, attributes) {
                    var hasStyle = false;
                    if (styleSheet) {
                        hasStyle = styleSheet.hasStyle(tagName);
                        if (hasStyle) {
                            stack.push(textFormat);
                            textFormat = textFormat.clone();
                            styleSheet.applyStyle(textFormat, tagName);
                        }
                    }
                    switch (tagName) {
                    case 'a':
                        stack.push(textFormat);
                        somewhatImplemented('<a/>');
                        var target = attributes.target || textFormat.target;
                        var url = attributes.url || textFormat.url;
                        if (target !== textFormat.target || url !== textFormat.url) {
                            if (!hasStyle) {
                                textFormat = textFormat.clone();
                            }
                            textFormat.target = target;
                            textFormat.url = url;
                        }
                        break;
                    case 'b':
                        stack.push(textFormat);
                        if (!textFormat.bold) {
                            if (!hasStyle) {
                                textFormat = textFormat.clone();
                            }
                            textFormat.bold = true;
                        }
                        break;
                    case 'font':
                        stack.push(textFormat);
                        var color = ColorUtilities.isValidHexColor(attributes.color) ? ColorUtilities.hexToRGB(attributes.color) : textFormat.color;
                        var font = attributes.face || textFormat.font;
                        var size = isNaN(attributes.size) ? textFormat.size : +attributes.size;
                        var letterSpacing = isNaN(attributes.letterspacing) ? textFormat.letterSpacing : +attributes.letterspacing;
                        var kerning = isNaN(attributes.kerning) ? textFormat.kerning : +attributes.kerning;
                        if (color !== textFormat.color || font !== textFormat.font || size !== textFormat.size || letterSpacing !== textFormat.letterSpacing || kerning !== textFormat.kerning) {
                            if (!hasStyle) {
                                textFormat = textFormat.clone();
                            }
                            textFormat.color = color;
                            textFormat.font = font;
                            textFormat.size = size;
                            textFormat.letterSpacing = letterSpacing;
                            textFormat.kerning = kerning;
                        }
                        break;
                    case 'img':
                        notImplemented('<img/>');
                        break;
                    case 'i':
                        stack.push(textFormat);
                        if (!textFormat.italic) {
                            if (!hasStyle) {
                                textFormat = textFormat.clone();
                            }
                            textFormat.italic = true;
                        }
                        break;
                    case 'li':
                        stack.push(textFormat);
                        if (!textFormat.bullet) {
                            if (!hasStyle) {
                                textFormat = textFormat.clone();
                            }
                            textFormat.bullet = true;
                        }
                        if (plainText[plainText.length - 1] === '\r') {
                            break;
                        }
                    case 'br':
                    case 'sbr':
                        if (multiline) {
                            handler.chars('\r');
                        }
                        break;
                    case 'span':
                    case 'p':
                        var hasClassStyle = false;
                        stack.push(textFormat);
                        if (styleSheet && attributes.class) {
                            var cssClass = '.' + attributes.class;
                            hasClassStyle = styleSheet.hasStyle(cssClass);
                            if (hasClassStyle) {
                                if (!hasStyle) {
                                    textFormat = textFormat.clone();
                                }
                                styleSheet.applyStyle(textFormat, cssClass);
                            }
                        }
                        if (tagName === 'span') {
                            break;
                        }
                        var align = attributes.align;
                        if (flash.text.TextFormatAlign.toNumber(align) > -1 && align !== textFormat.align) {
                            if (!(hasStyle || hasClassStyle)) {
                                textFormat = textFormat.clone();
                            }
                            textFormat.align = align;
                        }
                        break;
                    case 'textformat':
                        stack.push(textFormat);
                        var blockIndent = isNaN(attributes.blockindent) ? textFormat.blockIndent : +attributes.blockindent;
                        var indent = isNaN(attributes.indent) ? textFormat.indent : +attributes.indent;
                        var leading = isNaN(attributes.leading) ? textFormat.leading : +attributes.leading;
                        var leftMargin = isNaN(attributes.leftmargin) ? textFormat.leftMargin : +attributes.leftmargin;
                        var rightMargin = isNaN(attributes.rightmargin) ? textFormat.rightMargin : +attributes.rightmargin;
                        //var tabStops = attributes.tabstops || textFormat.tabStops;
                        if (blockIndent !== textFormat.blockIndent || indent !== textFormat.indent || leading !== textFormat.leading || leftMargin !== textFormat.leftMargin || rightMargin !== textFormat.rightMargin) {
                            if (!hasStyle) {
                                textFormat = textFormat.clone();
                            }
                            textFormat.blockIndent = blockIndent;
                            textFormat.indent = indent;
                            textFormat.leading = leading;
                            textFormat.leftMargin = leftMargin;
                            textFormat.rightMargin = rightMargin;
                        }
                        break;
                    case 'u':
                        stack.push(textFormat);
                        if (!textFormat.underline) {
                            if (!hasStyle) {
                                textFormat = textFormat.clone();
                            }
                            textFormat.underline = true;
                        }
                        break;
                    }
                },
                end: function (tagName) {
                    switch (tagName) {
                    case 'li':
                    case 'p':
                        if (multiline) {
                            handler.chars('\r');
                        }
                    case 'a':
                    case 'b':
                    case 'font':
                    case 'i':
                    case 'textformat':
                    case 'u':
                        textFormat = stack.pop();
                        if (styleSheet && styleSheet.hasStyle(tagName)) {
                            textFormat = stack.pop();
                        }
                    }
                }
            });
            this._plainText = plainText;
            this._serializeTextRuns();
        };
        Object.defineProperty(TextContent.prototype, 'plainText', {
            get: function () {
                return this._plainText;
            },
            set: function (value) {
                this._plainText = value.split('\n').join('\r');
                this.textRuns.length = 0;
                if (value) {
                    var textRun = new this.sec.flash.text.TextRun(0, value.length, this.defaultTextFormat);
                    this.textRuns[0] = textRun;
                }
                this._serializeTextRuns();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, 'bounds', {
            get: function () {
                return this._bounds;
            },
            set: function (bounds) {
                this._bounds.copyFrom(bounds);
                this.flags |= 1    /* DirtyBounds */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, 'autoSize', {
            get: function () {
                return this._autoSize;
            },
            set: function (value) {
                if (value === this._autoSize) {
                    return;
                }
                this._autoSize = value;
                if (this._plainText) {
                    this.flags |= 8    /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, 'wordWrap', {
            get: function () {
                return this._wordWrap;
            },
            set: function (value) {
                if (value === this._wordWrap) {
                    return;
                }
                this._wordWrap = value;
                if (this._plainText) {
                    this.flags |= 8    /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, 'scrollV', {
            get: function () {
                return this._scrollV;
            },
            set: function (value) {
                if (value === this._scrollV) {
                    return;
                }
                this._scrollV = value;
                if (this._plainText) {
                    this.flags |= 8    /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, 'scrollH', {
            get: function () {
                return this._scrollH;
            },
            set: function (value) {
                if (value === this._scrollH) {
                    return;
                }
                this._scrollH = value;
                if (this._plainText) {
                    this.flags |= 8    /* DirtyFlow */;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, 'backgroundColor', {
            get: function () {
                return this._backgroundColor;
            },
            set: function (value) {
                if (value === this._backgroundColor) {
                    return;
                }
                this._backgroundColor = value;
                this.flags |= 4    /* DirtyStyle */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextContent.prototype, 'borderColor', {
            get: function () {
                return this._borderColor;
            },
            set: function (value) {
                if (value === this._borderColor) {
                    return;
                }
                this._borderColor = value;
                this.flags |= 4    /* DirtyStyle */;
            },
            enumerable: true,
            configurable: true
        });
        TextContent.prototype._serializeTextRuns = function () {
            var textRuns = this.textRuns;
            this.textRunData.clear();
            for (var i = 0; i < textRuns.length; i++) {
                this._writeTextRun(textRuns[i]);
            }
            this.flags |= 2    /* DirtyContent */;
        };
        TextContent.prototype._writeTextRun = function (textRun) {
            var textRunData = this.textRunData;
            textRunData.writeInt(textRun.beginIndex);
            textRunData.writeInt(textRun.endIndex);
            var textFormat = textRun.textFormat;
            var size = +textFormat.size;
            textRunData.writeInt(size);
            var fontClass = this.sec.flash.text.Font.axClass;
            var font = fontClass.getByNameAndStyle(textFormat.font, textFormat.style) || fontClass.getDefaultFont();
            if (font.fontType === flash.text.FontType.EMBEDDED) {
                textRunData.writeUTF('swffont' + font._id);
            } else {
                textRunData.writeUTF(font._fontFamily);
            }
            textRunData.writeInt(altTieBreakRound(font.ascent * size, true));
            textRunData.writeInt(altTieBreakRound(font.descent * size, false));
            textRunData.writeInt(textFormat.leading === null ? font.leading * size : +textFormat.leading);
            // For embedded fonts, always set bold and italic to false. They're fully identified by name.
            var bold = false;
            var italic = false;
            if (font.fontType === flash.text.FontType.DEVICE) {
                if (textFormat.bold === null) {
                    bold = font.fontStyle === flash.text.FontStyle.BOLD || font.fontType === flash.text.FontStyle.BOLD_ITALIC;
                } else {
                    bold = !!textFormat.bold;
                }
                if (textFormat.italic === null) {
                    italic = font.fontStyle === flash.text.FontStyle.ITALIC || font.fontType === flash.text.FontStyle.BOLD_ITALIC;
                } else {
                    italic = !!textFormat.italic;
                }
            }
            textRunData.writeBoolean(bold);
            textRunData.writeBoolean(italic);
            textRunData.writeInt(+textFormat.color);
            textRunData.writeInt(flash.text.TextFormatAlign.toNumber(textFormat.align));
            textRunData.writeBoolean(!!textFormat.bullet);
            //textRunData.writeInt(textFormat.display);
            textRunData.writeInt(+textFormat.indent);
            //textRunData.writeInt(textFormat.blockIndent);
            textRunData.writeInt(+textFormat.kerning);
            textRunData.writeInt(+textFormat.leftMargin);
            textRunData.writeInt(+textFormat.letterSpacing);
            textRunData.writeInt(+textFormat.rightMargin);
            //textRunData.writeInt(textFormat.tabStops);
            textRunData.writeBoolean(!!textFormat.underline);
        };
        TextContent.prototype.appendText = function (newText, format) {
            if (!format) {
                format = this.defaultTextFormat;
            }
            var plainText = this._plainText;
            var newRun = new this.sec.flash.text.TextRun(plainText.length, plainText.length + newText.length, format);
            this._plainText = plainText + newText;
            this.textRuns.push(newRun);
            this._writeTextRun(newRun);
        };
        TextContent.prototype.prependText = function (newText, format) {
            if (!format) {
                format = this.defaultTextFormat;
            }
            var plainText = this._plainText;
            this._plainText = newText + plainText;
            var textRuns = this.textRuns;
            var shift = newText.length;
            for (var i = 0; i < textRuns.length; i++) {
                var run = textRuns[i];
                run.beginIndex += shift;
                run.endIndex += shift;
            }
            textRuns.unshift(new this.sec.flash.text.TextRun(0, shift, format));
            this._serializeTextRuns();
        };
        TextContent.prototype.replaceText = function (beginIndex, endIndex, newText, format) {
            if (endIndex < beginIndex || !newText) {
                return;
            }
            if (endIndex === 0) {
                // Insert text at the beginning.
                this.prependText(newText, format);
                return;
            }
            var plainText = this._plainText;
            // When inserting text to the end, we can simply add a new text run without changing any
            // existing ones.
            if (beginIndex >= plainText.length) {
                this.appendText(newText, format);
                return;
            }
            var defaultTextFormat = this.defaultTextFormat;
            // A text format used for new text runs will have unset properties merged in from the default
            // text format.
            var newFormat = defaultTextFormat;
            if (format) {
                newFormat = newFormat.clone();
                newFormat.merge(format);
            }
            // If replacing the whole text, just regenerate runs by setting plainText.
            if (beginIndex <= 0 && endIndex >= plainText.length) {
                if (format) {
                    // Temporarily set the passed text format as default.
                    this.defaultTextFormat = newFormat;
                    this.plainText = newText;
                    // Restore the original default when finished.
                    this.defaultTextFormat = defaultTextFormat;
                } else {
                    this.plainText = newText;
                }
                return;
            }
            var textRuns = this.textRuns;
            var newTextRuns = [];
            var newEndIndex = beginIndex + newText.length;
            var shift = newEndIndex - endIndex;
            for (var i = 0; i < textRuns.length; i++) {
                var run = textRuns[i];
                var isLast = i >= textRuns.length - 1;
                if (beginIndex < run.endIndex) {
                    // Skip all following steps (including adding the current run to the new list of runs) if
                    // the inserted text overlaps the current run, which is not the last one.
                    if (!isLast && beginIndex <= run.beginIndex && newEndIndex >= run.endIndex) {
                        continue;
                    }
                    var containsBeginIndex = run.containsIndex(beginIndex);
                    var containsEndIndex = run.containsIndex(endIndex) || isLast && endIndex >= run.endIndex;
                    if (containsBeginIndex && containsEndIndex) {
                        // The current run spans over the inserted text.
                        if (format) {
                            // Split up the current run.
                            var clone = run.clone();
                            clone.endIndex = beginIndex;
                            newTextRuns.push(clone);
                            i--;
                            run.beginIndex = beginIndex + 1;
                            continue;
                        }
                    } else if (containsBeginIndex) {
                        // Run is intersecting on the left. Adjust its length.
                        run.endIndex = beginIndex;
                    } else if (containsEndIndex) {
                        // If a a text format was passed, a new run needs to be inserted.
                        if (format) {
                            newTextRuns.push(new this.sec.flash.text.TextRun(beginIndex, newEndIndex, newFormat));
                            run.beginIndex = newEndIndex;
                        } else {
                            // Otherwise make the current run span over the inserted text.
                            run.beginIndex = beginIndex;
                            run.endIndex += shift;
                        }
                    } else {
                        // No intersection, shift entire run to the right.
                        run.beginIndex += shift;
                        run.endIndex += shift;
                    }
                }
                // Ignore empty runs.
                if (run.endIndex > run.beginIndex) {
                    newTextRuns.push(run);
                }
            }
            this._plainText = plainText.substring(0, beginIndex) + newText + plainText.substring(endIndex);
            this.textRuns = newTextRuns;
            this._serializeTextRuns();
        };
        return TextContent;
    }();
    Shumway.TextContent = TextContent;
    var AVMX;
    (function (AVMX) {
        var AS;
        (function (AS) {
            var OptionSet = Shumway.Options.OptionSet;
            var shumwayOptions = Shumway.Settings.shumwayOptions;
            AS.flashOptions = shumwayOptions.register(new OptionSet('Flash Options'));
            AS.traceEventsOption = AS.flashOptions.register(new Shumway.Options.Option('te', 'Trace Events', 'boolean', false, 'Trace dispatching of events.'));
            AS.traceLoaderOption = AS.flashOptions.register(new Shumway.Options.Option('tp', 'Trace Loader', 'boolean', false, 'Trace loader execution.'));
            AS.disableAudioOption = AS.flashOptions.register(new Shumway.Options.Option('da', 'Disable Audio', 'boolean', false, 'Disables audio.'));
            AS.webAudioOption = AS.flashOptions.register(new Shumway.Options.Option(null, 'Use WebAudio for Sound', 'boolean', false, 'Enables WebAudio API for MovieClip sound stream. (MP3 format is an exception)'));
            AS.webAudioMP3Option = AS.flashOptions.register(new Shumway.Options.Option(null, 'Use MP3 decoding to WebAudio', 'boolean', false, 'Enables WebAudio API and software MP3 decoding and disables any AUDIO tag usage for MP3 format'));
            AS.mediaSourceOption = AS.flashOptions.register(new Shumway.Options.Option(null, 'Use Media Source for Video', 'boolean', false, 'Enables Media Source Extension API for NetStream.'));
            AS.mediaSourceMP3Option = AS.flashOptions.register(new Shumway.Options.Option(null, 'Use Media Source for MP3', 'boolean', true, 'Enables Media Source Extension API for MP3 streams.'));
            AS.flvOption = AS.flashOptions.register(new Shumway.Options.Option(null, 'FLV support.', 'string', 'unsupported', 'Defines how to deal with FLV streams.'));
        }(AS = AVMX.AS || (AVMX.AS = {})));
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
}(Shumway || (Shumway = {})));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    var Timeline;
    (function (Timeline) {
        var isInteger = Shumway.isInteger;
        var assert = Shumway.Debug.assert;
        var warning = Shumway.Debug.warning;
        var Bounds = Shumway.Bounds;
        /**
         * TODO document
         */
        var Symbol = function () {
            function Symbol(data, symbolDefaultClass) {
                release || assert(isInteger(data.id));
                this.data = data;
                if (data.className) {
                    var app = data.env.app;
                    try {
                        var symbolClass = app.getClass(Shumway.AVMX.Multiname.FromFQNString(data.className, 0    /* Public */));
                        this.symbolClass = symbolClass;
                        // The symbolClass should have received a lazy symbol resolver in Loader#_applyLoadUpdate.
                        release || assert(symbolClass.tPrototype.hasOwnProperty('_symbol'));
                        // Replace it by this symbol without triggering the resolver and causing an infinite
                        // recursion.
                        Object.defineProperty(symbolClass.tPrototype, '_symbol', { value: this });
                    } catch (e) {
                        warning('Symbol ' + data.id + ' bound to non-existing class ' + data.className);
                        this.symbolClass = symbolDefaultClass;
                    }
                } else {
                    this.symbolClass = symbolDefaultClass;
                }
                this.isAVM1Object = false;
            }
            Object.defineProperty(Symbol.prototype, 'id', {
                get: function () {
                    return this.data.id;
                },
                enumerable: true,
                configurable: true
            });
            return Symbol;
        }();
        Timeline.Symbol = Symbol;
        var DisplaySymbol = function (_super) {
            __extends(DisplaySymbol, _super);
            function DisplaySymbol(data, symbolClass, dynamic) {
                _super.call(this, data, symbolClass);
                this.dynamic = dynamic;
            }
            DisplaySymbol.prototype._setBoundsFromData = function (data) {
                this.fillBounds = data.fillBounds ? Bounds.FromUntyped(data.fillBounds) : null;
                this.lineBounds = data.lineBounds ? Bounds.FromUntyped(data.lineBounds) : null;
                if (!this.lineBounds && this.fillBounds) {
                    this.lineBounds = this.fillBounds.clone();
                }
            };
            return DisplaySymbol;
        }(Symbol);
        Timeline.DisplaySymbol = DisplaySymbol;
        var BinarySymbol = function (_super) {
            __extends(BinarySymbol, _super);
            function BinarySymbol(data, sec) {
                _super.call(this, data, sec.flash.utils.ByteArray.axClass);
            }
            BinarySymbol.FromData = function (data, loaderInfo) {
                var symbol = new BinarySymbol(data, loaderInfo.app.sec);
                symbol.buffer = data.data;
                symbol.byteLength = data.data.byteLength;
                return symbol;
            };
            return BinarySymbol;
        }(Symbol);
        Timeline.BinarySymbol = BinarySymbol;
        var SoundStart = function () {
            function SoundStart(soundId, soundInfo) {
                this.soundId = soundId;
                this.soundInfo = soundInfo;
            }
            return SoundStart;
        }();
        Timeline.SoundStart = SoundStart;
    }(Timeline = Shumway.Timeline || (Shumway.Timeline = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RtmpJs;
(function (RtmpJs) {
    var Browser;
    (function (Browser) {
        var ShumwayComRtmpSocket = function () {
            function ShumwayComRtmpSocket(host, port, params) {
                this._socket = ShumwayCom.createRtmpSocket({
                    host: host,
                    port: port,
                    ssl: params.useSecureTransport
                });
            }
            Object.defineProperty(ShumwayComRtmpSocket, 'isAvailable', {
                get: function () {
                    return !!(typeof ShumwayCom !== 'undefined' && ShumwayCom.createRtmpSocket);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, 'onopen', {
                get: function () {
                    return this._onopen;
                },
                set: function (callback) {
                    this._socket.setOpenCallback(this._onopen = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, 'ondata', {
                get: function () {
                    return this._ondata;
                },
                set: function (callback) {
                    this._socket.setDataCallback(this._ondata = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, 'ondrain', {
                get: function () {
                    return this._ondrain;
                },
                set: function (callback) {
                    this._socket.setDrainCallback(this._ondrain = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, 'onerror', {
                get: function () {
                    return this._onerror;
                },
                set: function (callback) {
                    this._socket.setErrorCallback(this._onerror = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpSocket.prototype, 'onclose', {
                get: function () {
                    return this._onclose;
                },
                set: function (callback) {
                    this._socket.setCloseCallback(this._onclose = callback);
                },
                enumerable: true,
                configurable: true
            });
            ShumwayComRtmpSocket.prototype.send = function (buffer, offset, count) {
                return this._socket.send(buffer, offset, count);
            };
            ShumwayComRtmpSocket.prototype.close = function () {
                this._socket.close();
            };
            return ShumwayComRtmpSocket;
        }();
        Browser.ShumwayComRtmpSocket = ShumwayComRtmpSocket;
        var ShumwayComRtmpXHR = function () {
            function ShumwayComRtmpXHR() {
                this._xhr = ShumwayCom.createRtmpXHR();
            }
            Object.defineProperty(ShumwayComRtmpXHR, 'isAvailable', {
                get: function () {
                    return !!(typeof ShumwayCom !== 'undefined' && ShumwayCom.createRtmpXHR);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, 'status', {
                get: function () {
                    return this._xhr.status;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, 'response', {
                get: function () {
                    return this._xhr.response;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, 'responseType', {
                get: function () {
                    return this._xhr.responseType;
                },
                set: function (type) {
                    this._xhr.responseType = type;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, 'onload', {
                get: function () {
                    return this._onload;
                },
                set: function (callback) {
                    this._xhr.setLoadCallback(this._onload = callback);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ShumwayComRtmpXHR.prototype, 'onerror', {
                get: function () {
                    return this._onload;
                },
                set: function (callback) {
                    this._xhr.setErrorCallback(this._onerror = callback);
                },
                enumerable: true,
                configurable: true
            });
            ShumwayComRtmpXHR.prototype.open = function (method, path, async) {
                if (async === void 0) {
                    async = true;
                }
                this._xhr.open(method, path, async);
            };
            ShumwayComRtmpXHR.prototype.setRequestHeader = function (header, value) {
                this._xhr.setRequestHeader(header, value);
            };
            ShumwayComRtmpXHR.prototype.send = function (data) {
                this._xhr.send(data);
            };
            return ShumwayComRtmpXHR;
        }();
        Browser.ShumwayComRtmpXHR = ShumwayComRtmpXHR;
    }(Browser = RtmpJs.Browser || (RtmpJs.Browser = {})));
    var MAX_CHUNKED_CHANNEL_BUFFER = 524288;
    var RANDOM_DATA_SIZE = 1536;
    var PROTOCOL_VERSION = 3;
    var SET_CHUNK_SIZE_CONTROL_MESSAGE_ID = 1;
    var ABORT_MESSAGE_CONTROL_MESSAGE_ID = 2;
    var ACK_MESSAGE_ID = 3;
    var USER_CONTROL_MESSAGE_ID = 4;
    var ACK_WINDOW_SIZE_MESSAGE_ID = 5;
    var SET_PEER_BANDWIDTH_MESSAGE_ID = 6;
    var CONTROL_CHUNK_STREAM_ID = 2;
    var MIN_CHUNK_STREAM_ID = 3;
    var MAX_CHUNK_STREAM_ID = 65599;
    var MAX_CHUNK_HEADER_SIZE = 18;
    var ChunkedStream = function () {
        function ChunkedStream(id) {
            this.onmessage = null;
            this.id = id;
            this.buffer = null;
            this.bufferLength = 0;
            this.lastStreamId = -1;
            this.lastTimestamp = 0;
            this.lastLength = 0;
            this.lastTypeId = 0;
            this.lastMessageComplete = false;
            this.waitingForBytes = 0;
            this.sentStreamId = -1;
            this.sentTimestamp = 0;
            this.sentLength = 0;
            this.sentTypeId = 0;
        }
        ChunkedStream.prototype.setBuffer = function (enabled) {
            if (enabled && !this.buffer) {
                this.buffer = new Uint8Array(128);
                this.bufferLength = 0;
            }
            if (!enabled && this.buffer) {
                this.buffer = null;
                this.bufferLength = 0;
            }
        };
        ChunkedStream.prototype.abort = function () {
            if (this.buffer) {
                this.bufferLength = 0;
            } else if (!this.lastMessageComplete) {
                this.lastMessageComplete = true;
                this.onmessage({
                    timestamp: this.lastTimestamp,
                    streamId: this.lastStreamId,
                    chunkedStreamId: this.id,
                    typeId: this.lastTypeId,
                    data: null,
                    firstChunk: false,
                    lastChunk: true
                });
            }
        };
        ChunkedStream.prototype._push = function (data, firstChunk, lastChunk) {
            if (!this.onmessage) {
                return;
            }
            if (firstChunk && lastChunk || !this.buffer) {
                this.onmessage({
                    timestamp: this.lastTimestamp,
                    streamId: this.lastStreamId,
                    chunkedStreamId: this.id,
                    typeId: this.lastTypeId,
                    data: data,
                    firstChunk: firstChunk,
                    lastChunk: lastChunk
                });
                return;
            }
            if (firstChunk) {
                this.bufferLength = 0;
                if (this.lastLength > this.buffer.length) {
                    this.buffer = new Uint8Array(this.lastLength);
                }
            }
            this.buffer.set(data, this.bufferLength);
            this.bufferLength += data.length;
            if (lastChunk) {
                this.onmessage({
                    timestamp: this.lastTimestamp,
                    streamId: this.lastStreamId,
                    chunkedStreamId: this.id,
                    typeId: this.lastTypeId,
                    data: this.buffer.subarray(0, this.bufferLength),
                    firstChunk: true,
                    lastChunk: true
                });
            }
        };
        return ChunkedStream;
    }();
    RtmpJs.ChunkedStream = ChunkedStream;
    var ChunkedChannel = function () {
        function ChunkedChannel() {
            this.onusercontrolmessage = null;
            this.onack = null;
            this.ondata = function (data) {
            };
            this.onclose = function () {
            };
            this.oncreated = null;
            this.state = 'uninitialized';
            this.buffer = new Uint8Array(4092);
            this.bufferLength = 0;
            this.chunkSize = 128;
            this.chunkStreams = [];
            this.peerChunkSize = 128;
            this.peerAckWindowSize = 0;
            this.bandwidthLimitType = 0;
            this.windowAckSize = 0;
            this.bytesReceived = 0;
            this.lastAckSent = 0;
        }
        ChunkedChannel.prototype.push = function (data) {
            var newDataLength = data.length + this.bufferLength;
            if (newDataLength > this.buffer.length) {
                var newBufferLength = this.buffer.length * 2;
                while (newDataLength > newBufferLength) {
                    newBufferLength *= 2;
                }
                if (newBufferLength > MAX_CHUNKED_CHANNEL_BUFFER) {
                    this._fail('Buffer overflow');
                }
                var newBuffer = new Uint8Array(newBufferLength);
                newBuffer.set(this.buffer);
                this.buffer = newBuffer;
            }
            for (var i = 0, j = this.bufferLength; i < data.length; i++, j++) {
                this.buffer[j] = data[i];
            }
            this.bufferLength = newDataLength;
            this.bytesReceived += data.length;
            if (this.peerAckWindowSize && this.bytesReceived - this.lastAckSent >= this.peerAckWindowSize) {
                this._sendAck();
            }
            while (this.bufferLength > 0) {
                // release || console.log('current bufferLength: ' + this.bufferLength + ' state:' + this.state);
                var shiftBy = 0;
                switch (this.state) {
                case 'uninitialized':
                    if (this.bufferLength < 1) {
                        return;
                    }
                    this.serverVersion = this.buffer[0];
                    shiftBy = 1;
                    if (this.serverVersion !== PROTOCOL_VERSION) {
                        this._fail('Unsupported protocol version: ' + this.serverVersion);
                    }
                    this.state = 'version_received';
                    break;
                case 'version_received':
                    if (this.bufferLength < RANDOM_DATA_SIZE) {
                        return;
                    }
                    shiftBy = RANDOM_DATA_SIZE;
                    var timestamp = Date.now() - this.epochStart | 0;
                    this.buffer[4] = timestamp >>> 24 & 255;
                    this.buffer[5] = timestamp >>> 16 & 255;
                    this.buffer[6] = timestamp >>> 8 & 255;
                    this.buffer[7] = timestamp & 255;
                    this.ondata(this.buffer.subarray(0, RANDOM_DATA_SIZE));
                    this.state = 'ack_sent';
                    break;
                case 'ack_sent':
                    if (this.bufferLength < RANDOM_DATA_SIZE) {
                        return;
                    }
                    shiftBy = RANDOM_DATA_SIZE;
                    for (var i = 8; i < RANDOM_DATA_SIZE; i++) {
                        if (this.buffer[i] !== this.randomData[i]) {
                            this._fail('Random data do not match @' + i);
                        }
                    }
                    this.state = 'handshake_done';
                    this.lastAckSent = this.bytesReceived;
                    this._initialize();
                    break;
                case 'handshake_done':
                    shiftBy = this._parseChunkedData();
                    if (!shiftBy) {
                        return;
                    }
                    break;
                default:
                    return;
                }
                this.buffer.set(this.buffer.subarray(shiftBy, this.bufferLength), 0);
                this.bufferLength -= shiftBy;
            }
        };
        ChunkedChannel.prototype._initialize = function () {
            var controlStream = this._getChunkStream(CONTROL_CHUNK_STREAM_ID);
            controlStream.setBuffer(true);
            controlStream.onmessage = function (e) {
                if (e.streamId !== 0) {
                    return;
                }
                release || console.log('Control message: ' + e.typeId);
                switch (e.typeId) {
                case SET_CHUNK_SIZE_CONTROL_MESSAGE_ID:
                    var newChunkSize = e.data[0] << 24 | e.data[1] << 16 | e.data[2] << 8 | e.data[3];
                    if (newChunkSize >= 1 && newChunkSize <= 2147483647) {
                        this.peerChunkSize = newChunkSize;
                    }
                    break;
                case ABORT_MESSAGE_CONTROL_MESSAGE_ID:
                    var chunkStreamId = e.data[0] << 24 | e.data[1] << 16 | e.data[2] << 8 | e.data[3];
                    if (MIN_CHUNK_STREAM_ID <= chunkStreamId && chunkStreamId <= MAX_CHUNK_STREAM_ID) {
                        var chunkStream = this._getChunkStream(chunkStreamId);
                        chunkStream.abort();
                    }
                    break;
                case ACK_MESSAGE_ID:
                    if (this.onack) {
                        this.onack();
                    }
                    break;
                case USER_CONTROL_MESSAGE_ID:
                    if (this.onusercontrolmessage) {
                        this.onusercontrolmessage({
                            type: e.data[0] << 8 | e.data[1],
                            data: e.data.subarray(2)
                        });
                    }
                    break;
                case ACK_WINDOW_SIZE_MESSAGE_ID:
                    var ackWindowSize = e.data[0] << 24 | e.data[1] << 16 | e.data[2] << 8 | e.data[3];
                    if (ackWindowSize < 0) {
                        break;
                    }
                    this.peerAckWindowSize = ackWindowSize;
                    break;
                case SET_PEER_BANDWIDTH_MESSAGE_ID:
                    var ackWindowSize = e.data[0] << 24 | e.data[1] << 16 | e.data[2] << 8 | e.data[3];
                    var limitType = e.data[4];
                    if (ackWindowSize < 0 || limitType > 2) {
                        break;
                    }
                    if (limitType === 1 || limitType === 2 && this.bandwidthLimitType === 1) {
                        ackWindowSize = Math.min(this.windowAckSize, ackWindowSize);
                    }
                    if (ackWindowSize !== this.ackWindowSize) {
                        this.ackWindowSize = ackWindowSize;
                        var ackData = new Uint8Array([
                            ackWindowSize >>> 24 & 255,
                            ackWindowSize >>> 16 & 255,
                            ackWindowSize >>> 8 & 255,
                            ackWindowSize & 255
                        ]);
                        this._sendMessage(CONTROL_CHUNK_STREAM_ID, {
                            typeId: ACK_WINDOW_SIZE_MESSAGE_ID,
                            streamId: 0,
                            data: ackData
                        });
                        if (limitType !== 2) {
                            this.bandwidthLimitType = limitType;
                        }
                    }
                    break;
                }
            }.bind(this);
            if (this.oncreated) {
                this.oncreated();
            }
        };
        ChunkedChannel.prototype.setChunkSize = function (chunkSize) {
            if (chunkSize < 1 || chunkSize > 2147483647) {
                throw new Error('Invalid chunk size');
            }
            this._sendMessage(CONTROL_CHUNK_STREAM_ID, {
                streamId: 0,
                typeId: SET_CHUNK_SIZE_CONTROL_MESSAGE_ID,
                data: new Uint8Array([
                    chunkSize >>> 24 & 255,
                    chunkSize >>> 16 & 255,
                    chunkSize >>> 8 & 255,
                    chunkSize & 255
                ])
            });
            this.chunkSize = chunkSize;
        };
        ChunkedChannel.prototype.send = function (chunkStreamId, message) {
            if (chunkStreamId < MIN_CHUNK_STREAM_ID || chunkStreamId > MAX_CHUNK_STREAM_ID) {
                throw new Error('Invalid chunkStreamId');
            }
            return this._sendMessage(chunkStreamId, message);
        };
        ChunkedChannel.prototype.sendUserControlMessage = function (type, data) {
            var eventData = new Uint8Array(2 + data.length);
            eventData[0] = type >> 8 & 255;
            eventData[1] = type & 255;
            eventData.set(data, 2);
            this._sendMessage(CONTROL_CHUNK_STREAM_ID, {
                typeId: USER_CONTROL_MESSAGE_ID,
                streamId: 0,
                data: eventData
            });
        };
        ChunkedChannel.prototype._sendAck = function () {
            var ackData = new Uint8Array([
                this.bytesReceived >>> 24 & 255,
                this.bytesReceived >>> 16 & 255,
                this.bytesReceived >>> 8 & 255,
                this.bytesReceived & 255
            ]);
            this._sendMessage(CONTROL_CHUNK_STREAM_ID, {
                typeId: ACK_MESSAGE_ID,
                streamId: 0,
                data: ackData
            });
        };
        ChunkedChannel.prototype._sendMessage = function (chunkStreamId, message) {
            var data = message.data;
            var messageLength = data.length;
            var chunkStream = this._getChunkStream(chunkStreamId);
            var timestamp = ('timestamp' in message ? message.timestamp : Date.now() - this.epochStart) | 0;
            var timestampDelta = timestamp - chunkStream.sentTimestamp | 0;
            var buffer = new Uint8Array(this.chunkSize + MAX_CHUNK_HEADER_SIZE);
            var chunkStreamIdSize;
            if (chunkStreamId < 64) {
                chunkStreamIdSize = 1;
                buffer[0] = chunkStreamId;
            } else if (chunkStreamId < 320) {
                chunkStreamIdSize = 2;
                buffer[0] = 0;
                buffer[1] = chunkStreamId - 64;
            } else {
                chunkStreamIdSize = 3;
                buffer[0] = 1;
                buffer[1] = chunkStreamId - 64 >> 8 & 255;
                buffer[2] = chunkStreamId - 64 & 255;
            }
            var position = chunkStreamIdSize;
            var extendTimestamp = 0;
            if (message.streamId !== chunkStream.sentStreamId || timestampDelta < 0) {
                // chunk type 0
                if ((timestamp & 4278190080) !== 0) {
                    extendTimestamp = timestamp;
                    buffer[position] = buffer[position + 1] = buffer[position + 2] = 255;
                } else {
                    buffer[position] = timestamp >> 16 & 255;
                    buffer[position + 1] = timestamp >> 8 & 255;
                    buffer[position + 2] = timestamp & 255;
                }
                position += 3;
                buffer[position++] = messageLength >> 16 & 255;
                buffer[position++] = messageLength >> 8 & 255;
                buffer[position++] = messageLength & 255;
                buffer[position++] = message.typeId;
                buffer[position++] = message.streamId & 255;
                // little-endian
                buffer[position++] = message.streamId >> 8 & 255;
                buffer[position++] = message.streamId >> 16 & 255;
                buffer[position++] = message.streamId >> 24 & 255;
            } else if (messageLength !== chunkStream.sentLength || message.typeId !== chunkStream.sentTypeId) {
                // chunk type 1
                buffer[0] |= 64;
                if ((timestampDelta & 4278190080) !== 0) {
                    extendTimestamp = timestampDelta;
                    buffer[position] = buffer[position + 1] = buffer[position + 2] = 255;
                } else {
                    buffer[position] = timestampDelta >> 16 & 255;
                    buffer[position + 1] = timestampDelta >> 8 & 255;
                    buffer[position + 2] = timestampDelta & 255;
                }
                position += 3;
                buffer[position++] = messageLength >> 16 & 255;
                buffer[position++] = messageLength >> 8 & 255;
                buffer[position++] = messageLength & 255;
                buffer[position++] = message.typeId;
            } else if (timestampDelta !== 0) {
                // chunk type 2
                buffer[0] |= 128;
                if ((timestampDelta & 4278190080) !== 0) {
                    extendTimestamp = timestampDelta;
                    buffer[position] = buffer[position + 1] = buffer[position + 2] = 255;
                } else {
                    buffer[position] = timestampDelta >> 16 & 255;
                    buffer[position + 1] = timestampDelta >> 8 & 255;
                    buffer[position + 2] = timestampDelta & 255;
                }
                position += 3;
            } else {
                // chunk type 3
                buffer[0] |= 192;
            }
            if (extendTimestamp) {
                buffer[position++] = extendTimestamp >>> 24 & 255;
                buffer[position++] = extendTimestamp >>> 16 & 255;
                buffer[position++] = extendTimestamp >>> 8 & 255;
                buffer[position++] = extendTimestamp & 255;
            }
            chunkStream.sentTimestamp = timestamp;
            chunkStream.sentStreamId = message.streamId;
            chunkStream.sentTypeId = message.typeId;
            chunkStream.sentLength = messageLength;
            var sent = 0;
            while (sent < messageLength) {
                var currentChunkLength = Math.min(messageLength - sent, this.chunkSize);
                buffer.set(data.subarray(sent, sent + currentChunkLength), position);
                sent += currentChunkLength;
                this.ondata(buffer.subarray(0, position + currentChunkLength));
                // reset position and chunk type
                buffer[0] |= 192;
                position = chunkStreamIdSize;
            }
            return timestamp;
        };
        ChunkedChannel.prototype._getChunkStream = function (id) {
            var chunkStream = this.chunkStreams[id];
            if (!chunkStream) {
                this.chunkStreams[id] = chunkStream = new ChunkedStream(id);
                chunkStream.setBuffer(true);
                chunkStream.onmessage = function (message) {
                    if (this.onmessage) {
                        this.onmessage(message);
                    }
                }.bind(this);
            }
            return chunkStream;
        };
        ChunkedChannel.prototype._parseChunkedData = function () {
            if (this.bufferLength < 1) {
                return;
            }
            var chunkType = this.buffer[0] >> 6 & 3;
            var chunkHeaderPosition = 1;
            var chunkStreamId = this.buffer[0] & 63;
            if (chunkStreamId === 0) {
                if (this.bufferLength < 2) {
                    return;
                }
                chunkStreamId = this.buffer[1] + 64;
                chunkHeaderPosition = 2;
            } else if (chunkStreamId === 1) {
                if (this.bufferLength < 2) {
                    return;
                }
                chunkStreamId = (this.buffer[1] << 8) + this.buffer[2] + 64;
                chunkHeaderPosition = 3;
            }
            var chunkHeaderSize = chunkType === 0 ? 11 : chunkType === 1 ? 7 : chunkType === 2 ? 3 : 0;
            if (this.bufferLength < chunkHeaderPosition + chunkHeaderSize) {
                return;
            }
            var extendTimestampSize = chunkType !== 3 && this.buffer[chunkHeaderPosition] === 255 && this.buffer[chunkHeaderPosition + 1] === 255 && this.buffer[chunkHeaderPosition + 2] === 255 ? 4 : 0;
            var totalChunkHeaderSize = chunkHeaderPosition + chunkHeaderSize + extendTimestampSize;
            if (this.bufferLength < totalChunkHeaderSize) {
                return;
            }
            var chunkStream = this._getChunkStream(chunkStreamId);
            var chunkTimestamp;
            if (chunkType === 3) {
                chunkTimestamp = chunkStream.lastTimestamp;
            } else {
                chunkTimestamp = this.buffer[chunkHeaderPosition] << 16 | this.buffer[chunkHeaderPosition + 1] << 8 | this.buffer[chunkHeaderPosition + 2];
            }
            if (extendTimestampSize) {
                var chunkTimestampPosition = chunkHeaderPosition + chunkHeaderSize;
                chunkTimestamp = this.buffer[chunkTimestampPosition] << 24 | this.buffer[chunkTimestampPosition + 1] << 16 | this.buffer[chunkTimestampPosition + 2] << 8 | this.buffer[chunkTimestampPosition + 3];
            }
            if (chunkType === 1 || chunkType === 2) {
                chunkTimestamp = chunkStream.lastTimestamp + chunkTimestamp | 0;
            }
            var messageLength = chunkStream.lastLength;
            var messageTypeId = chunkStream.lastTypeId;
            var messageStreamId = chunkStream.lastStreamId;
            if (chunkType === 0 || chunkType === 1) {
                messageLength = this.buffer[chunkHeaderPosition + 3] << 16 | this.buffer[chunkHeaderPosition + 4] << 8 | this.buffer[chunkHeaderPosition + 5];
                messageTypeId = this.buffer[chunkHeaderPosition + 6];
            }
            if (chunkType === 0) {
                // little-endian
                messageStreamId = this.buffer[chunkHeaderPosition + 10] << 24 | this.buffer[chunkHeaderPosition + 9] << 16 | this.buffer[chunkHeaderPosition + 8] << 8 | this.buffer[chunkHeaderPosition + 7];
            }
            var read, tailLength, firstChunk;
            if (chunkType === 3 && chunkStream.waitingForBytes) {
                firstChunk = false;
                read = Math.min(chunkStream.waitingForBytes, this.peerChunkSize);
                tailLength = chunkStream.waitingForBytes - read;
            } else {
                firstChunk = true;
                read = Math.min(messageLength, this.peerChunkSize);
                tailLength = messageLength - read;
            }
            if (this.bufferLength < totalChunkHeaderSize + read) {
                return;
            }
            release || !firstChunk && tailLength || console.log('Chunk received: cs:' + chunkStreamId + '; ' + 'f/l:' + firstChunk + '/' + !tailLength + ';  len:' + messageLength);
            chunkStream.lastTimestamp = chunkTimestamp;
            chunkStream.lastLength = messageLength;
            chunkStream.lastTypeId = messageTypeId;
            chunkStream.lastStreamId = messageStreamId;
            chunkStream.lastMessageComplete = !tailLength;
            chunkStream.waitingForBytes = tailLength;
            chunkStream._push(this.buffer.subarray(totalChunkHeaderSize, totalChunkHeaderSize + read), firstChunk, !tailLength);
            return totalChunkHeaderSize + read;
        };
        ChunkedChannel.prototype.start = function () {
            this.epochStart = Date.now();
            this.ondata(new Uint8Array([PROTOCOL_VERSION]));
            // c0
            this.randomData = new Uint8Array(RANDOM_DATA_SIZE);
            this.randomData[0] = 0;
            this.randomData[1] = 0;
            this.randomData[2] = 0;
            this.randomData[3] = 0;
            for (var i = 8; i < RANDOM_DATA_SIZE; i++) {
                this.randomData[i] = Math.random() * 256 | 0;
            }
            this.ondata(this.randomData);
            // c1
            console.log('## connected');
        };
        ChunkedChannel.prototype.stop = function (error) {
            if (error) {
                console.error('socket error!!!');
            }
            console.log('## closed');
        };
        ChunkedChannel.prototype._fail = function (message) {
            console.error('failed: ' + message);
            this.state = 'failed';
            this.onclose();
            throw new Error(message);
        };
        return ChunkedChannel;
    }();
    RtmpJs.ChunkedChannel = ChunkedChannel;
    var flash = Shumway.AVMX.AS.flash;
    var TRANSPORT_ENCODING = 0;
    var MAIN_CHUNKED_STREAM_ID = 3;
    var CONNECT_TRANSACTION_ID = 1;
    var DEFAULT_STREAM_ID = 0;
    var COMMAND_MESSAGE_AMF0_ID = 20;
    var COMMAND_MESSAGE_AMF3_ID = 17;
    var SET_BUFFER_CONTROL_MESSAGE_ID = 3;
    var PING_REQUEST_CONTROL_MESSAGE_ID = 6;
    var PING_RESPONSE_CONTROL_MESSAGE_ID = 7;
    var BaseTransport = function () {
        function BaseTransport() {
            this._streams = [];
        }
        BaseTransport.prototype.connect = function (properties, args) {
            throw new Error('Abstract BaseTransport.connect method');
        };
        BaseTransport.prototype._initChannel = function (properties, args) {
            var channel = new RtmpJs.ChunkedChannel();
            var transport = this;
            channel.oncreated = function () {
                var ba = new flash.utils.ByteArray();
                ba.objectEncoding = TRANSPORT_ENCODING;
                ba.writeObject('connect');
                ba.writeObject(CONNECT_TRANSACTION_ID);
                ba.writeObject(properties);
                ba.writeObject(args || null);
                release || console.log('.. Connect sent');
                channel.send(MAIN_CHUNKED_STREAM_ID, {
                    streamId: DEFAULT_STREAM_ID,
                    typeId: TRANSPORT_ENCODING ? COMMAND_MESSAGE_AMF3_ID : COMMAND_MESSAGE_AMF0_ID,
                    data: new Uint8Array(ba._buffer, 0, ba.length)
                });
            };
            channel.onmessage = function (message) {
                release || console.log('.. Data received: typeId:' + message.typeId + ', streamId:' + message.streamId + ', cs: ' + message.chunkedStreamId);
                if (message.streamId !== 0) {
                    transport._streams[message.streamId]._push(message);
                    return;
                }
                if (message.typeId === COMMAND_MESSAGE_AMF0_ID || message.typeId === COMMAND_MESSAGE_AMF3_ID) {
                    var ba = new flash.utils.ByteArray();
                    ba.writeRawBytes(message.data);
                    ba.position = 0;
                    ba.objectEncoding = message.typeId === COMMAND_MESSAGE_AMF0_ID ? 0 : 3;
                    var commandName = ba.readObject();
                    if (commandName === undefined) {
                        ba.objectEncoding = 0;
                        commandName = ba.readObject();
                    }
                    var transactionId = ba.readObject();
                    if (commandName === '_result' || commandName === '_error') {
                        var isError = commandName === '_error';
                        if (transactionId === CONNECT_TRANSACTION_ID) {
                            var properties = ba.readObject();
                            var information = ba.readObject();
                            if (transport.onconnected) {
                                transport.onconnected({
                                    properties: properties,
                                    information: information,
                                    isError: isError
                                });
                            }
                        } else {
                            var commandObject = ba.readObject();
                            var streamId = ba.readObject();
                            if (transport.onstreamcreated) {
                                var stream = new NetStream(transport, streamId);
                                transport._streams[streamId] = stream;
                                transport.onstreamcreated({
                                    transactionId: transactionId,
                                    commandObject: commandObject,
                                    streamId: streamId,
                                    stream: stream,
                                    isError: isError
                                });
                            }
                        }
                    } else if (commandName === 'onBWCheck' || commandName === 'onBWDone') {
                        // TODO skipping those for now
                        transport.sendCommandOrResponse('_error', transactionId, null, {
                            code: 'NetConnection.Call.Failed',
                            level: 'error'
                        });
                    } else {
                        var commandObject = ba.readObject();
                        var response = ba.position < ba.length ? ba.readObject() : undefined;
                        if (transport.onresponse) {
                            transport.onresponse({
                                commandName: commandName,
                                transactionId: transactionId,
                                commandObject: commandObject,
                                response: response
                            });
                        }
                    }
                    return;
                }    // TODO misc messages
            };
            channel.onusercontrolmessage = function (e) {
                release || console.log('.. Event ' + e.type + ' +' + e.data.length + ' bytes');
                if (e.type === PING_REQUEST_CONTROL_MESSAGE_ID) {
                    channel.sendUserControlMessage(PING_RESPONSE_CONTROL_MESSAGE_ID, e.data);
                }
                if (transport.onevent) {
                    transport.onevent({
                        type: e.type,
                        data: e.data
                    });
                }
            };
            return this.channel = channel;
        };
        BaseTransport.prototype.call = function (procedureName, transactionId, commandObject, args) {
            var channel = this.channel;
            var ba = new flash.utils.ByteArray();
            ba.objectEncoding = TRANSPORT_ENCODING;
            ba.writeObject(procedureName);
            ba.writeObject(transactionId);
            ba.writeObject(commandObject);
            ba.writeObject(args);
            channel.send(MAIN_CHUNKED_STREAM_ID, {
                streamId: DEFAULT_STREAM_ID,
                typeId: TRANSPORT_ENCODING ? COMMAND_MESSAGE_AMF3_ID : COMMAND_MESSAGE_AMF0_ID,
                data: new Uint8Array(ba._buffer, 0, ba.length)
            });
        };
        BaseTransport.prototype.createStream = function (transactionId, commandObject) {
            this.sendCommandOrResponse('createStream', transactionId, commandObject);
        };
        BaseTransport.prototype.sendCommandOrResponse = function (commandName, transactionId, commandObject, response) {
            var channel = this.channel;
            var ba = new flash.utils.ByteArray();
            ba.writeByte(0);
            // ???
            ba.objectEncoding = 0;
            // TRANSPORT_ENCODING;
            ba.writeObject(commandName);
            ba.writeObject(transactionId);
            ba.writeObject(commandObject || null);
            if (arguments.length > 3) {
                ba.writeObject(response);
            }
            channel.send(MAIN_CHUNKED_STREAM_ID, {
                streamId: DEFAULT_STREAM_ID,
                typeId: COMMAND_MESSAGE_AMF3_ID,
                data: new Uint8Array(ba._buffer, 0, ba.length)
            });    /*     // really weird that this does not work
             var ba = new flash.utils.ByteArray();
             ba.objectEncoding = TRANSPORT_ENCODING;
             ba.writeObject('createStream');
             ba.writeObject(transactionId);
             ba.writeObject(commandObject || null);
             channel.send(MAIN_CHUNKED_STREAM_ID, {
             streamId: DEFAULT_STREAM_ID,
             typeId: TRANSPORT_ENCODING ? COMMAND_MESSAGE_AMF3_ID : COMMAND_MESSAGE_AMF0_ID,
             data: new Uint8Array((<any> ba)._buffer, 0, (<any> ba).length)
             });
             */
        };
        BaseTransport.prototype._setBuffer = function (streamId, ms) {
            this.channel.sendUserControlMessage(SET_BUFFER_CONTROL_MESSAGE_ID, new Uint8Array([
                streamId >> 24 & 255,
                streamId >> 16 & 255,
                streamId >> 8 & 255,
                streamId & 255,
                ms >> 24 & 255,
                ms >> 16 & 255,
                ms >> 8 & 255,
                ms & 255
            ]));
        };
        BaseTransport.prototype._sendCommand = function (streamId, data) {
            this.channel.send(8, {
                streamId: streamId,
                typeId: TRANSPORT_ENCODING ? COMMAND_MESSAGE_AMF3_ID : COMMAND_MESSAGE_AMF0_ID,
                data: data
            });
        };
        return BaseTransport;
    }();
    RtmpJs.BaseTransport = BaseTransport;
    var DEFAULT_BUFFER_LENGTH = 100;
    // ms
    var NetStream = function () {
        function NetStream(transport, streamId) {
            this.transport = transport;
            this.streamId = streamId;
        }
        NetStream.prototype.play = function (name, start, duration, reset) {
            var ba = new flash.utils.ByteArray();
            ba.objectEncoding = TRANSPORT_ENCODING;
            ba.writeObject('play');
            ba.writeObject(0);
            ba.writeObject(null);
            ba.writeObject(name);
            if (arguments.length > 1) {
                ba.writeObject(start);
            }
            if (arguments.length > 2) {
                ba.writeObject(duration);
            }
            if (arguments.length > 3) {
                ba.writeObject(reset);
            }
            this.transport._sendCommand(this.streamId, new Uint8Array(ba._buffer, 0, ba.length));
            // set the buffer, otherwise it will stop in ~15 sec
            this.transport._setBuffer(this.streamId, DEFAULT_BUFFER_LENGTH);
        };
        NetStream.prototype._push = function (message) {
            switch (message.typeId) {
            case 8:
            case 9:
                if (this.ondata) {
                    this.ondata(message);
                }
                break;
            case 18:
            case 20:
                var args = [];
                var ba = new flash.utils.ByteArray();
                ba.writeRawBytes(message.data);
                ba.position = 0;
                ba.objectEncoding = 0;
                while (ba.position < ba.length) {
                    args.push(ba.readObject());
                }
                if (message.typeId === 18 && this.onscriptdata) {
                    this.onscriptdata.apply(this, args);
                }
                if (message.typeId === 20 && this.oncallback) {
                    this.oncallback.apply(this, args);
                }
                break;
            }
        };
        return NetStream;
    }();
    function parseConnectionString(s) {
        // The s has to have the following format:
        //   protocol:[//host][:port]/appname[/instanceName]
        var protocolSeparatorIndex = s.indexOf(':');
        if (protocolSeparatorIndex < 0) {
            return null;    // no protocol
        }
        if (s[protocolSeparatorIndex + 1] !== '/') {
            return null;    // shall have '/' after protocol
        }
        var protocol = s.substring(0, protocolSeparatorIndex).toLocaleLowerCase();
        if (protocol !== 'rtmp' && protocol !== 'rtmpt' && protocol !== 'rtmps' && protocol !== 'rtmpe' && protocol !== 'rtmpte' && protocol !== 'rtmfp') {
            return null;
        }
        var host, port;
        var appnameSeparator = protocolSeparatorIndex + 1;
        if (s[protocolSeparatorIndex + 2] === '/') {
            // has host
            appnameSeparator = s.indexOf('/', protocolSeparatorIndex + 3);
            if (appnameSeparator < 0) {
                return undefined;    // has host but no appname
            }
            var portSeparator = s.indexOf(':', protocolSeparatorIndex + 1);
            if (portSeparator >= 0 && portSeparator < appnameSeparator) {
                host = s.substring(protocolSeparatorIndex + 3, portSeparator);
                port = +s.substring(portSeparator + 1, appnameSeparator);
            } else {
                host = s.substring(protocolSeparatorIndex + 3, appnameSeparator);
            }
        }
        var app = s.substring(appnameSeparator + 1);
        return {
            protocol: protocol,
            host: host,
            port: port,
            app: app
        };
    }
    RtmpJs.parseConnectionString = parseConnectionString;
    var Browser;
    (function (Browser) {
        var DEFAULT_RTMP_PORT = 1935;
        var COMBINE_RTMPT_DATA = true;
        var RtmpTransport = function (_super) {
            __extends(RtmpTransport, _super);
            function RtmpTransport(connectionSettings) {
                _super.call(this);
                if (typeof connectionSettings === 'string') {
                    connectionSettings = { host: connectionSettings };
                }
                this.host = connectionSettings.host || 'localhost';
                this.port = connectionSettings.port || DEFAULT_RTMP_PORT;
                this.ssl = !!connectionSettings.ssl || false;
            }
            RtmpTransport.prototype.connect = function (properties, args) {
                var TCPSocket = typeof navigator !== 'undefined' && navigator.mozTCPSocket;
                if (!TCPSocket) {
                    throw new Error('Your browser does not support socket communication.\n' + 'Currenly only Firefox with enabled mozTCPSocket is allowed (see README.md).');
                }
                var channel = this._initChannel(properties, args);
                var writeQueue = [], socketError = false;
                var socket = typeof Browser.ShumwayComRtmpSocket !== 'undefined' && Browser.ShumwayComRtmpSocket.isAvailable ? new Browser.ShumwayComRtmpSocket(this.host, this.port, {
                    useSecureTransport: this.ssl,
                    binaryType: 'arraybuffer'
                }) : TCPSocket.open(this.host, this.port, {
                    useSecureTransport: this.ssl,
                    binaryType: 'arraybuffer'
                });
                var sendData = function (data) {
                    return socket.send(data.buffer, data.byteOffset, data.byteLength);
                };
                socket.onopen = function (e) {
                    channel.ondata = function (data) {
                        var buf = new Uint8Array(data);
                        writeQueue.push(buf);
                        if (writeQueue.length > 1) {
                            return;
                        }
                        release || console.log('Bytes written: ' + buf.length);
                        if (sendData(buf)) {
                            writeQueue.shift();
                        }
                    };
                    channel.onclose = function () {
                        socket.close();
                    };
                    channel.start();
                };
                socket.ondrain = function (e) {
                    writeQueue.shift();
                    release || console.log('Write completed');
                    while (writeQueue.length > 0) {
                        release || console.log('Bytes written: ' + writeQueue[0].length);
                        if (!sendData(writeQueue[0])) {
                            break;
                        }
                        writeQueue.shift();
                    }
                };
                socket.onclose = function (e) {
                    channel.stop(socketError);
                };
                socket.onerror = function (e) {
                    socketError = true;
                    console.error('socket error: ' + e.data);
                };
                socket.ondata = function (e) {
                    release || console.log('Bytes read: ' + e.data.byteLength);
                    channel.push(new Uint8Array(e.data));
                };
            };
            return RtmpTransport;
        }(RtmpJs.BaseTransport);
        Browser.RtmpTransport = RtmpTransport;
        /*
         * RtmptTransport uses systemXHR to send HTTP requests.
         * See https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#XMLHttpRequest%28%29 and
         * https://github.com/mozilla-b2g/gaia/blob/master/apps/email/README.md#running-in-firefox
         *
         * Spec at http://red5.electroteque.org/dev/doc/html/rtmpt.html
         */
        var RtmptTransport = function (_super) {
            __extends(RtmptTransport, _super);
            function RtmptTransport(connectionSettings) {
                _super.call(this);
                var host = connectionSettings.host || 'localhost';
                var url = (connectionSettings.ssl ? 'https' : 'http') + '://' + host;
                if (connectionSettings.port) {
                    url += ':' + connectionSettings.port;
                }
                this.baseUrl = url;
                this.stopped = false;
                this.sessionId = null;
                this.requestId = 0;
                this.data = [];
            }
            RtmptTransport.prototype.connect = function (properties, args) {
                var channel = this._initChannel(properties, args);
                channel.ondata = function (data) {
                    release || console.log('Bytes written: ' + data.length);
                    this.data.push(new Uint8Array(data));
                }.bind(this);
                channel.onclose = function () {
                    this.stopped = true;
                }.bind(this);
                post(this.baseUrl + '/fcs/ident2', null, function (data, status) {
                    if (status !== 404) {
                        throw new Error('Unexpected response: ' + status);
                    }
                    post(this.baseUrl + '/open/1', null, function (data, status) {
                        this.sessionId = String.fromCharCode.apply(null, data).slice(0, -1);
                        // - '\n'
                        console.log('session id: ' + this.sessionId);
                        this.tick();
                        channel.start();
                    }.bind(this));
                }.bind(this));
            };
            RtmptTransport.prototype.tick = function () {
                var continueSend = function (data, status) {
                    if (status !== 200) {
                        throw new Error('Invalid HTTP status');
                    }
                    var idle = data[0];
                    if (data.length > 1) {
                        this.channel.push(data.subarray(1));
                    }
                    setTimeout(this.tick.bind(this), idle * 16);
                }.bind(this);
                if (this.stopped) {
                    post(this.baseUrl + '/close/2', null, function () {
                    });
                    return;
                }
                if (this.data.length > 0) {
                    var data;
                    if (COMBINE_RTMPT_DATA) {
                        var length = 0;
                        this.data.forEach(function (i) {
                            length += i.length;
                        });
                        var pos = 0;
                        data = new Uint8Array(length);
                        this.data.forEach(function (i) {
                            data.set(i, pos);
                            pos += i.length;
                        });
                        this.data.length = 0;
                    } else {
                        data = this.data.shift();
                    }
                    post(this.baseUrl + '/send/' + this.sessionId + '/' + this.requestId++, data, continueSend);
                } else {
                    post(this.baseUrl + '/idle/' + this.sessionId + '/' + this.requestId++, null, continueSend);
                }
            };
            return RtmptTransport;
        }(RtmpJs.BaseTransport);
        Browser.RtmptTransport = RtmptTransport;
        var emptyPostData = new Uint8Array([0]);
        function post(path, data, onload) {
            data || (data = emptyPostData);
            var xhr = typeof Browser.ShumwayComRtmpXHR !== 'undefined' && Browser.ShumwayComRtmpXHR.isAvailable ? new Browser.ShumwayComRtmpXHR() : new XMLHttpRequest({ mozSystem: true });
            xhr.open('POST', path, true);
            xhr.responseType = 'arraybuffer';
            xhr.setRequestHeader('Content-Type', 'application/x-fcs');
            xhr.onload = function (e) {
                onload(new Uint8Array(xhr.response), xhr.status);
            };
            xhr.onerror = function (e) {
                console.log('error');
                throw new Error('HTTP error');
            };
            xhr.send(data);
        }
    }(Browser = RtmpJs.Browser || (RtmpJs.Browser = {})));
    var MP4;
    (function (MP4) {
        var Iso;
        (function (Iso) {
            var utf8decode = Shumway.StringUtilities.utf8decode;
            var START_DATE = -2082844800000;
            /* midnight after Jan. 1, 1904 */
            var DEFAULT_MOVIE_MATRIX = [
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1
            ];
            var DEFAULT_OP_COLOR = [
                0,
                0,
                0
            ];
            function concatArrays(arg0) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                return Array.prototype.concat.apply(arg0, args);
            }
            function writeInt32(data, offset, value) {
                data[offset] = value >> 24 & 255;
                data[offset + 1] = value >> 16 & 255;
                data[offset + 2] = value >> 8 & 255;
                data[offset + 3] = value & 255;
            }
            function decodeInt32(s) {
                return s.charCodeAt(0) << 24 | s.charCodeAt(1) << 16 | s.charCodeAt(2) << 8 | s.charCodeAt(3);
            }
            function encodeDate(d) {
                return (d - START_DATE) / 1000 | 0;
            }
            function encodeFloat_16_16(f) {
                return f * 65536 | 0;
            }
            function encodeFloat_2_30(f) {
                return f * 1073741824 | 0;
            }
            function encodeFloat_8_8(f) {
                return f * 256 | 0;
            }
            function encodeLang(s) {
                return (s.charCodeAt(0) & 31) << 10 | (s.charCodeAt(1) & 31) << 5 | s.charCodeAt(2) & 31;
            }
            var Box = function () {
                function Box(boxtype, extendedType) {
                    this.boxtype = boxtype;
                    if (boxtype === 'uuid') {
                        this.userType = extendedType;
                    }
                }
                /**
                 * @param offset Position where writing will start in the output array
                 * @returns {number} Size of the written data
                 */
                Box.prototype.layout = function (offset) {
                    this.offset = offset;
                    var size = 8;
                    if (this.userType) {
                        size += 16;
                    }
                    this.size = size;
                    return size;
                };
                /**
                 * @param data Output array
                 * @returns {number} Amount of written bytes by this Box and its children only.
                 */
                Box.prototype.write = function (data) {
                    writeInt32(data, this.offset, this.size);
                    writeInt32(data, this.offset + 4, decodeInt32(this.boxtype));
                    if (!this.userType) {
                        return 8;
                    }
                    data.set(this.userType, this.offset + 8);
                    return 24;
                };
                Box.prototype.toUint8Array = function () {
                    var size = this.layout(0);
                    var data = new Uint8Array(size);
                    this.write(data);
                    return data;
                };
                return Box;
            }();
            Iso.Box = Box;
            var FullBox = function (_super) {
                __extends(FullBox, _super);
                function FullBox(boxtype, version, flags) {
                    if (version === void 0) {
                        version = 0;
                    }
                    if (flags === void 0) {
                        flags = 0;
                    }
                    _super.call(this, boxtype);
                    this.version = version;
                    this.flags = flags;
                }
                FullBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4;
                    return this.size;
                };
                FullBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.version << 24 | this.flags);
                    return offset + 4;
                };
                return FullBox;
            }(Box);
            Iso.FullBox = FullBox;
            var FileTypeBox = function (_super) {
                __extends(FileTypeBox, _super);
                function FileTypeBox(majorBrand, minorVersion, compatibleBrands) {
                    _super.call(this, 'ftype');
                    this.majorBrand = majorBrand;
                    this.minorVersion = minorVersion;
                    this.compatibleBrands = compatibleBrands;
                }
                FileTypeBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4 * (2 + this.compatibleBrands.length);
                    return this.size;
                };
                FileTypeBox.prototype.write = function (data) {
                    var _this = this;
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, decodeInt32(this.majorBrand));
                    writeInt32(data, this.offset + offset + 4, this.minorVersion);
                    offset += 8;
                    this.compatibleBrands.forEach(function (brand) {
                        writeInt32(data, _this.offset + offset, decodeInt32(brand));
                        offset += 4;
                    }, this);
                    return offset;
                };
                return FileTypeBox;
            }(Box);
            Iso.FileTypeBox = FileTypeBox;
            var BoxContainerBox = function (_super) {
                __extends(BoxContainerBox, _super);
                function BoxContainerBox(type, children) {
                    _super.call(this, type);
                    this.children = children;
                }
                BoxContainerBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    this.children.forEach(function (child) {
                        if (!child) {
                            return;    // skipping undefined
                        }
                        size += child.layout(offset + size);
                    });
                    return this.size = size;
                };
                BoxContainerBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    this.children.forEach(function (child) {
                        if (!child) {
                            return;    // skipping undefined
                        }
                        offset += child.write(data);
                    });
                    return offset;
                };
                return BoxContainerBox;
            }(Box);
            Iso.BoxContainerBox = BoxContainerBox;
            var MovieBox = function (_super) {
                __extends(MovieBox, _super);
                function MovieBox(header, tracks, extendsBox, userData) {
                    _super.call(this, 'moov', concatArrays([header], tracks, [
                        extendsBox,
                        userData
                    ]));
                    this.header = header;
                    this.tracks = tracks;
                    this.extendsBox = extendsBox;
                    this.userData = userData;
                }
                return MovieBox;
            }(BoxContainerBox);
            Iso.MovieBox = MovieBox;
            var MovieHeaderBox = function (_super) {
                __extends(MovieHeaderBox, _super);
                function MovieHeaderBox(timescale, duration, nextTrackId, rate, volume, matrix, creationTime, modificationTime) {
                    if (rate === void 0) {
                        rate = 1;
                    }
                    if (volume === void 0) {
                        volume = 1;
                    }
                    if (matrix === void 0) {
                        matrix = DEFAULT_MOVIE_MATRIX;
                    }
                    if (creationTime === void 0) {
                        creationTime = START_DATE;
                    }
                    if (modificationTime === void 0) {
                        modificationTime = START_DATE;
                    }
                    _super.call(this, 'mvhd', 0, 0);
                    this.timescale = timescale;
                    this.duration = duration;
                    this.nextTrackId = nextTrackId;
                    this.rate = rate;
                    this.volume = volume;
                    this.matrix = matrix;
                    this.creationTime = creationTime;
                    this.modificationTime = modificationTime;
                }
                MovieHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 16 + 4 + 2 + 2 + 8 + 36 + 24 + 4;
                    return this.size;
                };
                MovieHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    // Only version 0
                    writeInt32(data, this.offset + offset, encodeDate(this.creationTime));
                    writeInt32(data, this.offset + offset + 4, encodeDate(this.modificationTime));
                    writeInt32(data, this.offset + offset + 8, this.timescale);
                    writeInt32(data, this.offset + offset + 12, this.duration);
                    offset += 16;
                    writeInt32(data, this.offset + offset, encodeFloat_16_16(this.rate));
                    writeInt32(data, this.offset + offset + 4, encodeFloat_8_8(this.volume) << 16);
                    writeInt32(data, this.offset + offset + 8, 0);
                    writeInt32(data, this.offset + offset + 12, 0);
                    offset += 16;
                    writeInt32(data, this.offset + offset, encodeFloat_16_16(this.matrix[0]));
                    writeInt32(data, this.offset + offset + 4, encodeFloat_16_16(this.matrix[1]));
                    writeInt32(data, this.offset + offset + 8, encodeFloat_16_16(this.matrix[2]));
                    writeInt32(data, this.offset + offset + 12, encodeFloat_16_16(this.matrix[3]));
                    writeInt32(data, this.offset + offset + 16, encodeFloat_16_16(this.matrix[4]));
                    writeInt32(data, this.offset + offset + 20, encodeFloat_16_16(this.matrix[5]));
                    writeInt32(data, this.offset + offset + 24, encodeFloat_2_30(this.matrix[6]));
                    writeInt32(data, this.offset + offset + 28, encodeFloat_2_30(this.matrix[7]));
                    writeInt32(data, this.offset + offset + 32, encodeFloat_2_30(this.matrix[8]));
                    offset += 36;
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, 0);
                    writeInt32(data, this.offset + offset + 8, 0);
                    writeInt32(data, this.offset + offset + 12, 0);
                    writeInt32(data, this.offset + offset + 16, 0);
                    writeInt32(data, this.offset + offset + 20, 0);
                    offset += 24;
                    writeInt32(data, this.offset + offset, this.nextTrackId);
                    offset += 4;
                    return offset;
                };
                return MovieHeaderBox;
            }(FullBox);
            Iso.MovieHeaderBox = MovieHeaderBox;
            var TrackHeaderBox = function (_super) {
                __extends(TrackHeaderBox, _super);
                function TrackHeaderBox(flags, trackId, duration, width, height, volume, alternateGroup, layer, matrix, creationTime, modificationTime) {
                    if (alternateGroup === void 0) {
                        alternateGroup = 0;
                    }
                    if (layer === void 0) {
                        layer = 0;
                    }
                    if (matrix === void 0) {
                        matrix = DEFAULT_MOVIE_MATRIX;
                    }
                    if (creationTime === void 0) {
                        creationTime = START_DATE;
                    }
                    if (modificationTime === void 0) {
                        modificationTime = START_DATE;
                    }
                    _super.call(this, 'tkhd', 0, flags);
                    this.trackId = trackId;
                    this.duration = duration;
                    this.width = width;
                    this.height = height;
                    this.volume = volume;
                    this.alternateGroup = alternateGroup;
                    this.layer = layer;
                    this.matrix = matrix;
                    this.creationTime = creationTime;
                    this.modificationTime = modificationTime;
                }
                TrackHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 20 + 8 + 6 + 2 + 36 + 8;
                    return this.size;
                };
                TrackHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    // Only version 0
                    writeInt32(data, this.offset + offset, encodeDate(this.creationTime));
                    writeInt32(data, this.offset + offset + 4, encodeDate(this.modificationTime));
                    writeInt32(data, this.offset + offset + 8, this.trackId);
                    writeInt32(data, this.offset + offset + 12, 0);
                    writeInt32(data, this.offset + offset + 16, this.duration);
                    offset += 20;
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, 0);
                    writeInt32(data, this.offset + offset + 8, this.layer << 16 | this.alternateGroup);
                    writeInt32(data, this.offset + offset + 12, encodeFloat_8_8(this.volume) << 16);
                    offset += 16;
                    writeInt32(data, this.offset + offset, encodeFloat_16_16(this.matrix[0]));
                    writeInt32(data, this.offset + offset + 4, encodeFloat_16_16(this.matrix[1]));
                    writeInt32(data, this.offset + offset + 8, encodeFloat_16_16(this.matrix[2]));
                    writeInt32(data, this.offset + offset + 12, encodeFloat_16_16(this.matrix[3]));
                    writeInt32(data, this.offset + offset + 16, encodeFloat_16_16(this.matrix[4]));
                    writeInt32(data, this.offset + offset + 20, encodeFloat_16_16(this.matrix[5]));
                    writeInt32(data, this.offset + offset + 24, encodeFloat_2_30(this.matrix[6]));
                    writeInt32(data, this.offset + offset + 28, encodeFloat_2_30(this.matrix[7]));
                    writeInt32(data, this.offset + offset + 32, encodeFloat_2_30(this.matrix[8]));
                    offset += 36;
                    writeInt32(data, this.offset + offset, encodeFloat_16_16(this.width));
                    writeInt32(data, this.offset + offset + 4, encodeFloat_16_16(this.height));
                    offset += 8;
                    return offset;
                };
                return TrackHeaderBox;
            }(FullBox);
            Iso.TrackHeaderBox = TrackHeaderBox;
            var MediaHeaderBox = function (_super) {
                __extends(MediaHeaderBox, _super);
                function MediaHeaderBox(timescale, duration, language, creationTime, modificationTime) {
                    if (language === void 0) {
                        language = 'unk';
                    }
                    if (creationTime === void 0) {
                        creationTime = START_DATE;
                    }
                    if (modificationTime === void 0) {
                        modificationTime = START_DATE;
                    }
                    _super.call(this, 'mdhd', 0, 0);
                    this.timescale = timescale;
                    this.duration = duration;
                    this.language = language;
                    this.creationTime = creationTime;
                    this.modificationTime = modificationTime;
                }
                MediaHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 16 + 4;
                    return this.size;
                };
                MediaHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    // Only version 0
                    writeInt32(data, this.offset + offset, encodeDate(this.creationTime));
                    writeInt32(data, this.offset + offset + 4, encodeDate(this.modificationTime));
                    writeInt32(data, this.offset + offset + 8, this.timescale);
                    writeInt32(data, this.offset + offset + 12, this.duration);
                    writeInt32(data, this.offset + offset + 16, encodeLang(this.language) << 16);
                    return offset + 20;
                };
                return MediaHeaderBox;
            }(FullBox);
            Iso.MediaHeaderBox = MediaHeaderBox;
            var HandlerBox = function (_super) {
                __extends(HandlerBox, _super);
                function HandlerBox(handlerType, name) {
                    _super.call(this, 'hdlr', 0, 0);
                    this.handlerType = handlerType;
                    this.name = name;
                    this._encodedName = utf8decode(this.name);
                }
                HandlerBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 8 + 12 + (this._encodedName.length + 1);
                    return this.size;
                };
                HandlerBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, decodeInt32(this.handlerType));
                    writeInt32(data, this.offset + offset + 8, 0);
                    writeInt32(data, this.offset + offset + 12, 0);
                    writeInt32(data, this.offset + offset + 16, 0);
                    offset += 20;
                    data.set(this._encodedName, this.offset + offset);
                    data[this.offset + offset + this._encodedName.length] = 0;
                    offset += this._encodedName.length + 1;
                    return offset;
                };
                return HandlerBox;
            }(FullBox);
            Iso.HandlerBox = HandlerBox;
            var SoundMediaHeaderBox = function (_super) {
                __extends(SoundMediaHeaderBox, _super);
                function SoundMediaHeaderBox(balance) {
                    if (balance === void 0) {
                        balance = 0;
                    }
                    _super.call(this, 'smhd', 0, 0);
                    this.balance = balance;
                }
                SoundMediaHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4;
                    return this.size;
                };
                SoundMediaHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, encodeFloat_8_8(this.balance) << 16);
                    return offset + 4;
                };
                return SoundMediaHeaderBox;
            }(FullBox);
            Iso.SoundMediaHeaderBox = SoundMediaHeaderBox;
            var VideoMediaHeaderBox = function (_super) {
                __extends(VideoMediaHeaderBox, _super);
                function VideoMediaHeaderBox(graphicsMode, opColor) {
                    if (graphicsMode === void 0) {
                        graphicsMode = 0;
                    }
                    if (opColor === void 0) {
                        opColor = DEFAULT_OP_COLOR;
                    }
                    _super.call(this, 'vmhd', 0, 0);
                    this.graphicsMode = graphicsMode;
                    this.opColor = opColor;
                }
                VideoMediaHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 8;
                    return this.size;
                };
                VideoMediaHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.graphicsMode << 16 | this.opColor[0]);
                    writeInt32(data, this.offset + offset + 4, this.opColor[1] << 16 | this.opColor[2]);
                    return offset + 8;
                };
                return VideoMediaHeaderBox;
            }(FullBox);
            Iso.VideoMediaHeaderBox = VideoMediaHeaderBox;
            Iso.SELF_CONTAINED_DATA_REFERENCE_FLAG = 1;
            var DataEntryUrlBox = function (_super) {
                __extends(DataEntryUrlBox, _super);
                function DataEntryUrlBox(flags, location) {
                    if (location === void 0) {
                        location = null;
                    }
                    _super.call(this, 'url ', 0, flags);
                    this.location = location;
                    if (!(flags & Iso.SELF_CONTAINED_DATA_REFERENCE_FLAG)) {
                        this._encodedLocation = utf8decode(location);
                    }
                }
                DataEntryUrlBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    if (this._encodedLocation) {
                        size += this._encodedLocation.length + 1;
                    }
                    return this.size = size;
                };
                DataEntryUrlBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    if (this._encodedLocation) {
                        data.set(this._encodedLocation, this.offset + offset);
                        data[this.offset + offset + this._encodedLocation.length] = 0;
                        offset += this._encodedLocation.length;
                    }
                    return offset;
                };
                return DataEntryUrlBox;
            }(FullBox);
            Iso.DataEntryUrlBox = DataEntryUrlBox;
            var DataReferenceBox = function (_super) {
                __extends(DataReferenceBox, _super);
                function DataReferenceBox(entries) {
                    _super.call(this, 'dref', 0, 0);
                    this.entries = entries;
                }
                DataReferenceBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 4;
                    this.entries.forEach(function (entry) {
                        size += entry.layout(offset + size);
                    });
                    return this.size = size;
                };
                DataReferenceBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.entries.length);
                    this.entries.forEach(function (entry) {
                        offset += entry.write(data);
                    });
                    return offset;
                };
                return DataReferenceBox;
            }(FullBox);
            Iso.DataReferenceBox = DataReferenceBox;
            var DataInformationBox = function (_super) {
                __extends(DataInformationBox, _super);
                function DataInformationBox(dataReference) {
                    _super.call(this, 'dinf', [dataReference]);
                    this.dataReference = dataReference;
                }
                return DataInformationBox;
            }(BoxContainerBox);
            Iso.DataInformationBox = DataInformationBox;
            var SampleDescriptionBox = function (_super) {
                __extends(SampleDescriptionBox, _super);
                function SampleDescriptionBox(entries) {
                    _super.call(this, 'stsd', 0, 0);
                    this.entries = entries;
                }
                SampleDescriptionBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    size += 4;
                    this.entries.forEach(function (entry) {
                        size += entry.layout(offset + size);
                    });
                    return this.size = size;
                };
                SampleDescriptionBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.entries.length);
                    offset += 4;
                    this.entries.forEach(function (entry) {
                        offset += entry.write(data);
                    });
                    return offset;
                };
                return SampleDescriptionBox;
            }(FullBox);
            Iso.SampleDescriptionBox = SampleDescriptionBox;
            var SampleTableBox = function (_super) {
                __extends(SampleTableBox, _super);
                function SampleTableBox(sampleDescriptions, timeToSample, sampleToChunk, sampleSizes, chunkOffset) {
                    _super.call(this, 'stbl', [
                        sampleDescriptions,
                        timeToSample,
                        sampleToChunk,
                        sampleSizes,
                        chunkOffset
                    ]);
                    this.sampleDescriptions = sampleDescriptions;
                    this.timeToSample = timeToSample;
                    this.sampleToChunk = sampleToChunk;
                    this.sampleSizes = sampleSizes;
                    this.chunkOffset = chunkOffset;
                }
                return SampleTableBox;
            }(BoxContainerBox);
            Iso.SampleTableBox = SampleTableBox;
            var MediaInformationBox = function (_super) {
                __extends(MediaInformationBox, _super);
                function MediaInformationBox(header, info, sampleTable) {
                    _super.call(this, 'minf', [
                        header,
                        info,
                        sampleTable
                    ]);
                    this.header = header;
                    this.info = info;
                    this.sampleTable = sampleTable;
                }
                return MediaInformationBox;
            }(BoxContainerBox);
            Iso.MediaInformationBox = MediaInformationBox;
            var MediaBox = function (_super) {
                __extends(MediaBox, _super);
                function MediaBox(header, handler, info) {
                    _super.call(this, 'mdia', [
                        header,
                        handler,
                        info
                    ]);
                    this.header = header;
                    this.handler = handler;
                    this.info = info;
                }
                return MediaBox;
            }(BoxContainerBox);
            Iso.MediaBox = MediaBox;
            var TrackBox = function (_super) {
                __extends(TrackBox, _super);
                function TrackBox(header, media) {
                    _super.call(this, 'trak', [
                        header,
                        media
                    ]);
                    this.header = header;
                    this.media = media;
                }
                return TrackBox;
            }(BoxContainerBox);
            Iso.TrackBox = TrackBox;
            var TrackExtendsBox = function (_super) {
                __extends(TrackExtendsBox, _super);
                function TrackExtendsBox(trackId, defaultSampleDescriptionIndex, defaultSampleDuration, defaultSampleSize, defaultSampleFlags) {
                    _super.call(this, 'trex', 0, 0);
                    this.trackId = trackId;
                    this.defaultSampleDescriptionIndex = defaultSampleDescriptionIndex;
                    this.defaultSampleDuration = defaultSampleDuration;
                    this.defaultSampleSize = defaultSampleSize;
                    this.defaultSampleFlags = defaultSampleFlags;
                }
                TrackExtendsBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 20;
                    return this.size;
                };
                TrackExtendsBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.trackId);
                    writeInt32(data, this.offset + offset + 4, this.defaultSampleDescriptionIndex);
                    writeInt32(data, this.offset + offset + 8, this.defaultSampleDuration);
                    writeInt32(data, this.offset + offset + 12, this.defaultSampleSize);
                    writeInt32(data, this.offset + offset + 16, this.defaultSampleFlags);
                    return offset + 20;
                };
                return TrackExtendsBox;
            }(FullBox);
            Iso.TrackExtendsBox = TrackExtendsBox;
            var MovieExtendsBox = function (_super) {
                __extends(MovieExtendsBox, _super);
                function MovieExtendsBox(header, tracDefaults, levels) {
                    _super.call(this, 'mvex', concatArrays([header], tracDefaults, [levels]));
                    this.header = header;
                    this.tracDefaults = tracDefaults;
                    this.levels = levels;
                }
                return MovieExtendsBox;
            }(BoxContainerBox);
            Iso.MovieExtendsBox = MovieExtendsBox;
            var MetaBox = function (_super) {
                __extends(MetaBox, _super);
                function MetaBox(handler, otherBoxes) {
                    _super.call(this, 'meta', 0, 0);
                    this.handler = handler;
                    this.otherBoxes = otherBoxes;
                }
                MetaBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    size += this.handler.layout(offset + size);
                    this.otherBoxes.forEach(function (box) {
                        size += box.layout(offset + size);
                    });
                    return this.size = size;
                };
                MetaBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    offset += this.handler.write(data);
                    this.otherBoxes.forEach(function (box) {
                        offset += box.write(data);
                    });
                    return offset;
                };
                return MetaBox;
            }(FullBox);
            Iso.MetaBox = MetaBox;
            var MovieFragmentHeaderBox = function (_super) {
                __extends(MovieFragmentHeaderBox, _super);
                function MovieFragmentHeaderBox(sequenceNumber) {
                    _super.call(this, 'mfhd', 0, 0);
                    this.sequenceNumber = sequenceNumber;
                }
                MovieFragmentHeaderBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4;
                    return this.size;
                };
                MovieFragmentHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.sequenceNumber);
                    return offset + 4;
                };
                return MovieFragmentHeaderBox;
            }(FullBox);
            Iso.MovieFragmentHeaderBox = MovieFragmentHeaderBox;
            var TrackFragmentHeaderBox = function (_super) {
                __extends(TrackFragmentHeaderBox, _super);
                function TrackFragmentHeaderBox(flags, trackId, baseDataOffset, sampleDescriptionIndex, defaultSampleDuration, defaultSampleSize, defaultSampleFlags) {
                    _super.call(this, 'tfhd', 0, flags);
                    this.trackId = trackId;
                    this.baseDataOffset = baseDataOffset;
                    this.sampleDescriptionIndex = sampleDescriptionIndex;
                    this.defaultSampleDuration = defaultSampleDuration;
                    this.defaultSampleSize = defaultSampleSize;
                    this.defaultSampleFlags = defaultSampleFlags;
                }
                TrackFragmentHeaderBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 4;
                    var flags = this.flags;
                    if (!!(flags & 1    /* BASE_DATA_OFFSET_PRESENT */)) {
                        size += 8;
                    }
                    if (!!(flags & 2    /* SAMPLE_DESCRIPTION_INDEX_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 8    /* DEFAULT_SAMPLE_DURATION_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 16    /* DEFAULT_SAMPLE_SIZE_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 32    /* DEFAULT_SAMPLE_FLAGS_PRESENT */)) {
                        size += 4;
                    }
                    return this.size = size;
                };
                TrackFragmentHeaderBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    var flags = this.flags;
                    writeInt32(data, this.offset + offset, this.trackId);
                    offset += 4;
                    if (!!(flags & 1    /* BASE_DATA_OFFSET_PRESENT */)) {
                        writeInt32(data, this.offset + offset, 0);
                        writeInt32(data, this.offset + offset + 4, this.baseDataOffset);
                        offset += 8;
                    }
                    if (!!(flags & 2    /* SAMPLE_DESCRIPTION_INDEX_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.sampleDescriptionIndex);
                        offset += 4;
                    }
                    if (!!(flags & 8    /* DEFAULT_SAMPLE_DURATION_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.defaultSampleDuration);
                        offset += 4;
                    }
                    if (!!(flags & 16    /* DEFAULT_SAMPLE_SIZE_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.defaultSampleSize);
                        offset += 4;
                    }
                    if (!!(flags & 32    /* DEFAULT_SAMPLE_FLAGS_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.defaultSampleFlags);
                        offset += 4;
                    }
                    return offset;
                };
                return TrackFragmentHeaderBox;
            }(FullBox);
            Iso.TrackFragmentHeaderBox = TrackFragmentHeaderBox;
            var TrackFragmentBaseMediaDecodeTimeBox = function (_super) {
                __extends(TrackFragmentBaseMediaDecodeTimeBox, _super);
                function TrackFragmentBaseMediaDecodeTimeBox(baseMediaDecodeTime) {
                    _super.call(this, 'tfdt', 0, 0);
                    this.baseMediaDecodeTime = baseMediaDecodeTime;
                }
                TrackFragmentBaseMediaDecodeTimeBox.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 4;
                    return this.size;
                };
                TrackFragmentBaseMediaDecodeTimeBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, this.baseMediaDecodeTime);
                    return offset + 4;
                };
                return TrackFragmentBaseMediaDecodeTimeBox;
            }(FullBox);
            Iso.TrackFragmentBaseMediaDecodeTimeBox = TrackFragmentBaseMediaDecodeTimeBox;
            var TrackFragmentBox = function (_super) {
                __extends(TrackFragmentBox, _super);
                function TrackFragmentBox(header, decodeTime, run) {
                    _super.call(this, 'traf', [
                        header,
                        decodeTime,
                        run
                    ]);
                    this.header = header;
                    this.decodeTime = decodeTime;
                    this.run = run;
                }
                return TrackFragmentBox;
            }(BoxContainerBox);
            Iso.TrackFragmentBox = TrackFragmentBox;
            var TrackRunBox = function (_super) {
                __extends(TrackRunBox, _super);
                function TrackRunBox(flags, samples, dataOffset, firstSampleFlags) {
                    _super.call(this, 'trun', 1, flags);
                    this.samples = samples;
                    this.dataOffset = dataOffset;
                    this.firstSampleFlags = firstSampleFlags;
                }
                TrackRunBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 4;
                    var samplesCount = this.samples.length;
                    var flags = this.flags;
                    if (!!(flags & 1    /* DATA_OFFSET_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 4    /* FIRST_SAMPLE_FLAGS_PRESENT */)) {
                        size += 4;
                    }
                    if (!!(flags & 256    /* SAMPLE_DURATION_PRESENT */)) {
                        size += 4 * samplesCount;
                    }
                    if (!!(flags & 512    /* SAMPLE_SIZE_PRESENT */)) {
                        size += 4 * samplesCount;
                    }
                    if (!!(flags & 1024    /* SAMPLE_FLAGS_PRESENT */)) {
                        size += 4 * samplesCount;
                    }
                    if (!!(flags & 2048    /* SAMPLE_COMPOSITION_TIME_OFFSET */)) {
                        size += 4 * samplesCount;
                    }
                    return this.size = size;
                };
                TrackRunBox.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    var samplesCount = this.samples.length;
                    var flags = this.flags;
                    writeInt32(data, this.offset + offset, samplesCount);
                    offset += 4;
                    if (!!(flags & 1    /* DATA_OFFSET_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.dataOffset);
                        offset += 4;
                    }
                    if (!!(flags & 4    /* FIRST_SAMPLE_FLAGS_PRESENT */)) {
                        writeInt32(data, this.offset + offset, this.firstSampleFlags);
                        offset += 4;
                    }
                    for (var i = 0; i < samplesCount; i++) {
                        var sample = this.samples[i];
                        if (!!(flags & 256    /* SAMPLE_DURATION_PRESENT */)) {
                            writeInt32(data, this.offset + offset, sample.duration);
                            offset += 4;
                        }
                        if (!!(flags & 512    /* SAMPLE_SIZE_PRESENT */)) {
                            writeInt32(data, this.offset + offset, sample.size);
                            offset += 4;
                        }
                        if (!!(flags & 1024    /* SAMPLE_FLAGS_PRESENT */)) {
                            writeInt32(data, this.offset + offset, sample.flags);
                            offset += 4;
                        }
                        if (!!(flags & 2048    /* SAMPLE_COMPOSITION_TIME_OFFSET */)) {
                            writeInt32(data, this.offset + offset, sample.compositionTimeOffset);
                            offset += 4;
                        }
                    }
                    return offset;
                };
                return TrackRunBox;
            }(FullBox);
            Iso.TrackRunBox = TrackRunBox;
            var MovieFragmentBox = function (_super) {
                __extends(MovieFragmentBox, _super);
                function MovieFragmentBox(header, trafs) {
                    _super.call(this, 'moof', concatArrays([header], trafs));
                    this.header = header;
                    this.trafs = trafs;
                }
                return MovieFragmentBox;
            }(BoxContainerBox);
            Iso.MovieFragmentBox = MovieFragmentBox;
            var MediaDataBox = function (_super) {
                __extends(MediaDataBox, _super);
                function MediaDataBox(chunks) {
                    _super.call(this, 'mdat');
                    this.chunks = chunks;
                }
                MediaDataBox.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset);
                    this.chunks.forEach(function (chunk) {
                        size += chunk.length;
                    });
                    return this.size = size;
                };
                MediaDataBox.prototype.write = function (data) {
                    var _this = this;
                    var offset = _super.prototype.write.call(this, data);
                    this.chunks.forEach(function (chunk) {
                        data.set(chunk, _this.offset + offset);
                        offset += chunk.length;
                    }, this);
                    return offset;
                };
                return MediaDataBox;
            }(Box);
            Iso.MediaDataBox = MediaDataBox;
            var SampleEntry = function (_super) {
                __extends(SampleEntry, _super);
                function SampleEntry(format, dataReferenceIndex) {
                    _super.call(this, format);
                    this.dataReferenceIndex = dataReferenceIndex;
                }
                SampleEntry.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + 8;
                    return this.size;
                };
                SampleEntry.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, this.dataReferenceIndex);
                    return offset + 8;
                };
                return SampleEntry;
            }(Box);
            Iso.SampleEntry = SampleEntry;
            var AudioSampleEntry = function (_super) {
                __extends(AudioSampleEntry, _super);
                function AudioSampleEntry(codingName, dataReferenceIndex, channelCount, sampleSize, sampleRate, otherBoxes) {
                    if (channelCount === void 0) {
                        channelCount = 2;
                    }
                    if (sampleSize === void 0) {
                        sampleSize = 16;
                    }
                    if (sampleRate === void 0) {
                        sampleRate = 44100;
                    }
                    if (otherBoxes === void 0) {
                        otherBoxes = null;
                    }
                    _super.call(this, codingName, dataReferenceIndex);
                    this.channelCount = channelCount;
                    this.sampleSize = sampleSize;
                    this.sampleRate = sampleRate;
                    this.otherBoxes = otherBoxes;
                }
                AudioSampleEntry.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 20;
                    this.otherBoxes && this.otherBoxes.forEach(function (box) {
                        size += box.layout(offset + size);
                    });
                    return this.size = size;
                };
                AudioSampleEntry.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, 0);
                    writeInt32(data, this.offset + offset + 8, this.channelCount << 16 | this.sampleSize);
                    writeInt32(data, this.offset + offset + 12, 0);
                    writeInt32(data, this.offset + offset + 16, this.sampleRate << 16);
                    offset += 20;
                    this.otherBoxes && this.otherBoxes.forEach(function (box) {
                        offset += box.write(data);
                    });
                    return offset;
                };
                return AudioSampleEntry;
            }(SampleEntry);
            Iso.AudioSampleEntry = AudioSampleEntry;
            Iso.COLOR_NO_ALPHA_VIDEO_SAMPLE_DEPTH = 24;
            var VideoSampleEntry = function (_super) {
                __extends(VideoSampleEntry, _super);
                function VideoSampleEntry(codingName, dataReferenceIndex, width, height, compressorName, horizResolution, vertResolution, frameCount, depth, otherBoxes) {
                    if (compressorName === void 0) {
                        compressorName = '';
                    }
                    if (horizResolution === void 0) {
                        horizResolution = 72;
                    }
                    if (vertResolution === void 0) {
                        vertResolution = 72;
                    }
                    if (frameCount === void 0) {
                        frameCount = 1;
                    }
                    if (depth === void 0) {
                        depth = Iso.COLOR_NO_ALPHA_VIDEO_SAMPLE_DEPTH;
                    }
                    if (otherBoxes === void 0) {
                        otherBoxes = null;
                    }
                    _super.call(this, codingName, dataReferenceIndex);
                    this.width = width;
                    this.height = height;
                    this.compressorName = compressorName;
                    this.horizResolution = horizResolution;
                    this.vertResolution = vertResolution;
                    this.frameCount = frameCount;
                    this.depth = depth;
                    this.otherBoxes = otherBoxes;
                    if (compressorName.length > 31) {
                        throw new Error('invalid compressor name');
                    }
                }
                VideoSampleEntry.prototype.layout = function (offset) {
                    var size = _super.prototype.layout.call(this, offset) + 16 + 12 + 4 + 2 + 32 + 2 + 2;
                    this.otherBoxes && this.otherBoxes.forEach(function (box) {
                        size += box.layout(offset + size);
                    });
                    return this.size = size;
                };
                VideoSampleEntry.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, 0);
                    writeInt32(data, this.offset + offset + 8, 0);
                    writeInt32(data, this.offset + offset + 12, 0);
                    offset += 16;
                    writeInt32(data, this.offset + offset, this.width << 16 | this.height);
                    writeInt32(data, this.offset + offset + 4, encodeFloat_16_16(this.horizResolution));
                    writeInt32(data, this.offset + offset + 8, encodeFloat_16_16(this.vertResolution));
                    offset += 12;
                    writeInt32(data, this.offset + offset, 0);
                    writeInt32(data, this.offset + offset + 4, this.frameCount << 16);
                    offset += 6;
                    // weird offset
                    data[this.offset + offset] = this.compressorName.length;
                    for (var i = 0; i < 31; i++) {
                        data[this.offset + offset + i + 1] = i < this.compressorName.length ? this.compressorName.charCodeAt(i) & 127 : 0;
                    }
                    offset += 32;
                    writeInt32(data, this.offset + offset, this.depth << 16 | 65535);
                    offset += 4;
                    this.otherBoxes && this.otherBoxes.forEach(function (box) {
                        offset += box.write(data);
                    });
                    return offset;
                };
                return VideoSampleEntry;
            }(SampleEntry);
            Iso.VideoSampleEntry = VideoSampleEntry;
            var RawTag = function (_super) {
                __extends(RawTag, _super);
                function RawTag(type, data) {
                    _super.call(this, type);
                    this.data = data;
                }
                RawTag.prototype.layout = function (offset) {
                    this.size = _super.prototype.layout.call(this, offset) + this.data.length;
                    return this.size;
                };
                RawTag.prototype.write = function (data) {
                    var offset = _super.prototype.write.call(this, data);
                    data.set(this.data, this.offset + offset);
                    return offset + this.data.length;
                };
                return RawTag;
            }(Box);
            Iso.RawTag = RawTag;
        }(Iso = MP4.Iso || (MP4.Iso = {})));
        function hex(s) {
            var len = s.length >> 1;
            var arr = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                arr[i] = parseInt(s.substr(i * 2, 2), 16);
            }
            return arr;
        }
        var SOUNDRATES = [
            5500,
            11025,
            22050,
            44100
        ];
        var SOUNDFORMATS = [
            'PCM',
            'ADPCM',
            'MP3',
            'PCM le',
            'Nellymouser16',
            'Nellymouser8',
            'Nellymouser',
            'G.711 A-law',
            'G.711 mu-law',
            null,
            'AAC',
            'Speex',
            'MP3 8khz'
        ];
        var MP3_SOUND_CODEC_ID = 2;
        var AAC_SOUND_CODEC_ID = 10;
        var AudioPacketType;
        (function (AudioPacketType) {
            AudioPacketType[AudioPacketType['HEADER'] = 0] = 'HEADER';
            AudioPacketType[AudioPacketType['RAW'] = 1] = 'RAW';
        }(AudioPacketType || (AudioPacketType = {})));
        function parseAudiodata(data) {
            var i = 0;
            var packetType = AudioPacketType.RAW;
            var flags = data[i];
            var codecId = flags >> 4;
            var soundRateId = flags >> 2 & 3;
            var sampleSize = flags & 2 ? 16 : 8;
            var channels = flags & 1 ? 2 : 1;
            var samples;
            i++;
            switch (codecId) {
            case AAC_SOUND_CODEC_ID:
                var type = data[i++];
                packetType = type;
                samples = 1024;
                // AAC implementations typically represent 1024 PCM audio samples
                break;
            case MP3_SOUND_CODEC_ID:
                var version = data[i + 1] >> 3 & 3;
                // 3 - MPEG 1
                var layer = data[i + 1] >> 1 & 3;
                // 3 - Layer I, 2 - II, 1 - III
                samples = layer === 1 ? version === 3 ? 1152 : 576 : layer === 3 ? 384 : 1152;
                break;
            }
            return {
                codecDescription: SOUNDFORMATS[codecId],
                codecId: codecId,
                data: data.subarray(i),
                rate: SOUNDRATES[soundRateId],
                size: sampleSize,
                channels: channels,
                samples: samples,
                packetType: packetType
            };
        }
        var VIDEOCODECS = [
            null,
            'JPEG',
            'Sorenson',
            'Screen',
            'VP6',
            'VP6 alpha',
            'Screen2',
            'AVC'
        ];
        var VP6_VIDEO_CODEC_ID = 4;
        var AVC_VIDEO_CODEC_ID = 7;
        var VideoFrameType;
        (function (VideoFrameType) {
            VideoFrameType[VideoFrameType['KEY'] = 1] = 'KEY';
            VideoFrameType[VideoFrameType['INNER'] = 2] = 'INNER';
            VideoFrameType[VideoFrameType['DISPOSABLE'] = 3] = 'DISPOSABLE';
            VideoFrameType[VideoFrameType['GENERATED'] = 4] = 'GENERATED';
            VideoFrameType[VideoFrameType['INFO'] = 5] = 'INFO';
        }(VideoFrameType || (VideoFrameType = {})));
        var VideoPacketType;
        (function (VideoPacketType) {
            VideoPacketType[VideoPacketType['HEADER'] = 0] = 'HEADER';
            VideoPacketType[VideoPacketType['NALU'] = 1] = 'NALU';
            VideoPacketType[VideoPacketType['END'] = 2] = 'END';
        }(VideoPacketType || (VideoPacketType = {})));
        function parseVideodata(data) {
            var i = 0;
            var frameType = data[i] >> 4;
            var codecId = data[i] & 15;
            i++;
            var result = {
                frameType: frameType,
                codecId: codecId,
                codecDescription: VIDEOCODECS[codecId]
            };
            switch (codecId) {
            case AVC_VIDEO_CODEC_ID:
                var type = data[i++];
                result.packetType = type;
                result.compositionTime = (data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8) >> 8;
                i += 3;
                break;
            case VP6_VIDEO_CODEC_ID:
                result.packetType = VideoPacketType.NALU;
                result.horizontalOffset = data[i] >> 4 & 15;
                result.verticalOffset = data[i] & 15;
                result.compositionTime = 0;
                i++;
                break;
            }
            result.data = data.subarray(i);
            return result;
        }
        var AUDIO_PACKET = 8;
        var VIDEO_PACKET = 9;
        var MAX_PACKETS_IN_CHUNK = 200;
        var SPLIT_AT_KEYFRAMES = false;
        var MP4MuxState;
        (function (MP4MuxState) {
            MP4MuxState[MP4MuxState['CAN_GENERATE_HEADER'] = 0] = 'CAN_GENERATE_HEADER';
            MP4MuxState[MP4MuxState['NEED_HEADER_DATA'] = 1] = 'NEED_HEADER_DATA';
            MP4MuxState[MP4MuxState['MAIN_PACKETS'] = 2] = 'MAIN_PACKETS';
        }(MP4MuxState || (MP4MuxState = {})));
        var MP4Mux = function () {
            function MP4Mux(metadata) {
                var _this = this;
                this.oncodecinfo = function (codecs) {
                };
                this.ondata = function (data) {
                    throw new Error('MP4Mux.ondata is not set');
                };
                this.metadata = metadata;
                this.trackStates = this.metadata.tracks.map(function (t, index) {
                    var state = {
                        trackId: index + 1,
                        trackInfo: t,
                        cachedDuration: 0,
                        samplesProcessed: 0,
                        initializationData: []
                    };
                    if (_this.metadata.audioTrackId === index) {
                        _this.audioTrackState = state;
                    }
                    if (_this.metadata.videoTrackId === index) {
                        _this.videoTrackState = state;
                    }
                    return state;
                }, this);
                this._checkIfNeedHeaderData();
                this.filePos = 0;
                this.cachedPackets = [];
                this.chunkIndex = 0;
            }
            MP4Mux.prototype.pushPacket = function (type, data, timestamp) {
                if (this.state === MP4MuxState.CAN_GENERATE_HEADER) {
                    this._tryGenerateHeader();
                }
                switch (type) {
                case AUDIO_PACKET:
                    var audioTrack = this.audioTrackState;
                    var audioPacket = parseAudiodata(data);
                    if (!audioTrack || audioTrack.trackInfo.codecId !== audioPacket.codecId) {
                        throw new Error('Unexpected audio packet codec: ' + audioPacket.codecDescription);
                    }
                    switch (audioPacket.codecId) {
                    default:
                        throw new Error('Unsupported audio codec: ' + audioPacket.codecDescription);
                    case MP3_SOUND_CODEC_ID:
                        break;
                    // supported codec
                    case AAC_SOUND_CODEC_ID:
                        if (audioPacket.packetType === AudioPacketType.HEADER) {
                            audioTrack.initializationData.push(audioPacket.data);
                            return;
                        }
                        break;
                    }
                    this.cachedPackets.push({
                        packet: audioPacket,
                        timestamp: timestamp,
                        trackId: audioTrack.trackId
                    });
                    break;
                case VIDEO_PACKET:
                    var videoTrack = this.videoTrackState;
                    var videoPacket = parseVideodata(data);
                    if (!videoTrack || videoTrack.trackInfo.codecId !== videoPacket.codecId) {
                        throw new Error('Unexpected video packet codec: ' + videoPacket.codecDescription);
                    }
                    switch (videoPacket.codecId) {
                    default:
                        throw new Error('unsupported video codec: ' + videoPacket.codecDescription);
                    case VP6_VIDEO_CODEC_ID:
                        break;
                    // supported
                    case AVC_VIDEO_CODEC_ID:
                        if (videoPacket.packetType === VideoPacketType.HEADER) {
                            videoTrack.initializationData.push(videoPacket.data);
                            return;
                        }
                        break;
                    }
                    this.cachedPackets.push({
                        packet: videoPacket,
                        timestamp: timestamp,
                        trackId: videoTrack.trackId
                    });
                    break;
                default:
                    throw new Error('unknown packet type: ' + type);
                }
                if (this.state === MP4MuxState.NEED_HEADER_DATA) {
                    this._tryGenerateHeader();
                }
                if (this.cachedPackets.length >= MAX_PACKETS_IN_CHUNK && this.state === MP4MuxState.MAIN_PACKETS) {
                    this._chunk();
                }
            };
            MP4Mux.prototype.flush = function () {
                if (this.cachedPackets.length > 0) {
                    this._chunk();
                }
            };
            MP4Mux.prototype._checkIfNeedHeaderData = function () {
                if (this.trackStates.some(function (ts) {
                        return ts.trackInfo.codecId === AAC_SOUND_CODEC_ID || ts.trackInfo.codecId === AVC_VIDEO_CODEC_ID;
                    })) {
                    this.state = MP4MuxState.NEED_HEADER_DATA;
                } else {
                    this.state = MP4MuxState.CAN_GENERATE_HEADER;
                }
            };
            MP4Mux.prototype._tryGenerateHeader = function () {
                var allInitializationDataExists = this.trackStates.every(function (ts) {
                    switch (ts.trackInfo.codecId) {
                    case AAC_SOUND_CODEC_ID:
                    case AVC_VIDEO_CODEC_ID:
                        return ts.initializationData.length > 0;
                    default:
                        return true;
                    }
                });
                if (!allInitializationDataExists) {
                    return;    // not enough data, waiting more
                }
                var brands = ['isom'];
                var audioDataReferenceIndex = 1, videoDataReferenceIndex = 1;
                var traks = [];
                for (var i = 0; i < this.trackStates.length; i++) {
                    var trackState = this.trackStates[i];
                    var trackInfo = trackState.trackInfo;
                    var sampleEntry;
                    switch (trackInfo.codecId) {
                    case AAC_SOUND_CODEC_ID:
                        var audioSpecificConfig = trackState.initializationData[0];
                        sampleEntry = new MP4.Iso.AudioSampleEntry('mp4a', audioDataReferenceIndex, trackInfo.channels, trackInfo.samplesize, trackInfo.samplerate);
                        var esdsData = new Uint8Array(41 + audioSpecificConfig.length);
                        esdsData.set(hex('0000000003808080'), 0);
                        esdsData[8] = 32 + audioSpecificConfig.length;
                        esdsData.set(hex('00020004808080'), 9);
                        esdsData[16] = 18 + audioSpecificConfig.length;
                        esdsData.set(hex('40150000000000FA000000000005808080'), 17);
                        esdsData[34] = audioSpecificConfig.length;
                        esdsData.set(audioSpecificConfig, 35);
                        esdsData.set(hex('068080800102'), 35 + audioSpecificConfig.length);
                        sampleEntry.otherBoxes = [new MP4.Iso.RawTag('esds', esdsData)];
                        var objectType = audioSpecificConfig[0] >> 3;
                        // TODO 31
                        // mp4a.40.objectType
                        trackState.mimeTypeCodec = 'mp4a.40.' + objectType;
                        break;
                    case MP3_SOUND_CODEC_ID:
                        sampleEntry = new MP4.Iso.AudioSampleEntry('.mp3', audioDataReferenceIndex, trackInfo.channels, trackInfo.samplesize, trackInfo.samplerate);
                        trackState.mimeTypeCodec = 'mp3';
                        break;
                    case AVC_VIDEO_CODEC_ID:
                        var avcC = trackState.initializationData[0];
                        sampleEntry = new MP4.Iso.VideoSampleEntry('avc1', videoDataReferenceIndex, trackInfo.width, trackInfo.height);
                        sampleEntry.otherBoxes = [new MP4.Iso.RawTag('avcC', avcC)];
                        var codecProfile = avcC[1] << 16 | avcC[2] << 8 | avcC[3];
                        // avc1.XXYYZZ -- XX - profile + YY - constraints + ZZ - level
                        trackState.mimeTypeCodec = 'avc1.' + (16777216 | codecProfile).toString(16).substr(1);
                        brands.push('iso2', 'avc1', 'mp41');
                        break;
                    case VP6_VIDEO_CODEC_ID:
                        sampleEntry = new MP4.Iso.VideoSampleEntry('VP6F', videoDataReferenceIndex, trackInfo.width, trackInfo.height);
                        sampleEntry.otherBoxes = [new MP4.Iso.RawTag('glbl', hex('00'))];
                        // TODO to lie about codec to get it playing in MSE?
                        trackState.mimeTypeCodec = 'avc1.42001E';
                        break;
                    default:
                        throw new Error('not supported track type');
                    }
                    var trak;
                    var trakFlags = 1    /* TRACK_ENABLED */ | 2    /* TRACK_IN_MOVIE */;
                    if (trackState === this.audioTrackState) {
                        trak = new MP4.Iso.TrackBox(new MP4.Iso.TrackHeaderBox(trakFlags, trackState.trackId, -1, 0    /*width*/, 0    /*height*/, 1, i), new MP4.Iso.MediaBox(new MP4.Iso.MediaHeaderBox(trackInfo.timescale, -1, trackInfo.language), new MP4.Iso.HandlerBox('soun', 'SoundHandler'), new MP4.Iso.MediaInformationBox(new MP4.Iso.SoundMediaHeaderBox(), new MP4.Iso.DataInformationBox(new MP4.Iso.DataReferenceBox([new MP4.Iso.DataEntryUrlBox(MP4.Iso.SELF_CONTAINED_DATA_REFERENCE_FLAG)])), new MP4.Iso.SampleTableBox(new MP4.Iso.SampleDescriptionBox([sampleEntry]), new MP4.Iso.RawTag('stts', hex('0000000000000000')), new MP4.Iso.RawTag('stsc', hex('0000000000000000')), new MP4.Iso.RawTag('stsz', hex('000000000000000000000000')), new MP4.Iso.RawTag('stco', hex('0000000000000000'))))));
                    } else if (trackState === this.videoTrackState) {
                        trak = new MP4.Iso.TrackBox(new MP4.Iso.TrackHeaderBox(trakFlags, trackState.trackId, -1, trackInfo.width, trackInfo.height, 0    /* volume */, i), new MP4.Iso.MediaBox(new MP4.Iso.MediaHeaderBox(trackInfo.timescale, -1, trackInfo.language), new MP4.Iso.HandlerBox('vide', 'VideoHandler'), new MP4.Iso.MediaInformationBox(new MP4.Iso.VideoMediaHeaderBox(), new MP4.Iso.DataInformationBox(new MP4.Iso.DataReferenceBox([new MP4.Iso.DataEntryUrlBox(MP4.Iso.SELF_CONTAINED_DATA_REFERENCE_FLAG)])), new MP4.Iso.SampleTableBox(new MP4.Iso.SampleDescriptionBox([sampleEntry]), new MP4.Iso.RawTag('stts', hex('0000000000000000')), new MP4.Iso.RawTag('stsc', hex('0000000000000000')), new MP4.Iso.RawTag('stsz', hex('000000000000000000000000')), new MP4.Iso.RawTag('stco', hex('0000000000000000'))))));
                    }
                    traks.push(trak);
                }
                var mvex = new MP4.Iso.MovieExtendsBox(null, [
                    new MP4.Iso.TrackExtendsBox(1, 1, 0, 0, 0),
                    new MP4.Iso.TrackExtendsBox(2, 1, 0, 0, 0)
                ], null);
                var udat = new MP4.Iso.BoxContainerBox('udat', [new MP4.Iso.MetaBox(new MP4.Iso.RawTag('hdlr', hex('00000000000000006D6469726170706C000000000000000000')), [new MP4.Iso.RawTag('ilst', hex('00000025A9746F6F0000001D6461746100000001000000004C61766635342E36332E313034'))])]);
                var mvhd = new MP4.Iso.MovieHeaderBox(1000, 0    /* unknown duration */, this.trackStates.length + 1);
                var moov = new MP4.Iso.MovieBox(mvhd, traks, mvex, udat);
                var ftype = new MP4.Iso.FileTypeBox('isom', 512, brands);
                var ftypeSize = ftype.layout(0);
                var moovSize = moov.layout(ftypeSize);
                var header = new Uint8Array(ftypeSize + moovSize);
                ftype.write(header);
                moov.write(header);
                this.oncodecinfo(this.trackStates.map(function (ts) {
                    return ts.mimeTypeCodec;
                }));
                this.ondata(header);
                this.filePos += header.length;
                this.state = MP4MuxState.MAIN_PACKETS;
            };
            MP4Mux.prototype._chunk = function () {
                var cachedPackets = this.cachedPackets;
                if (SPLIT_AT_KEYFRAMES) {
                    var j = cachedPackets.length - 1;
                    var videoTrackId = this.videoTrackState.trackId;
                    // Finding last video keyframe.
                    while (j > 0 && (cachedPackets[j].trackId !== videoTrackId || cachedPackets[j].packet.frameType !== VideoFrameType.KEY)) {
                        j--;
                    }
                    if (j > 0) {
                        // We have keyframes and not only the first frame is a keyframe...
                        cachedPackets = cachedPackets.slice(0, j);
                    }
                }
                if (cachedPackets.length === 0) {
                    return;    // No data to produce.
                }
                var tdatParts = [];
                var tdatPosition = 0;
                var trafs = [];
                var trafDataStarts = [];
                for (var i = 0; i < this.trackStates.length; i++) {
                    var trackState = this.trackStates[i];
                    var trackInfo = trackState.trackInfo;
                    var trackId = trackState.trackId;
                    // Finding all packets for this track.
                    var trackPackets = cachedPackets.filter(function (cp) {
                        return cp.trackId === trackId;
                    });
                    if (trackPackets.length === 0) {
                        continue;
                    }
                    //var currentTimestamp = (trackPackets[0].timestamp * trackInfo.timescale / 1000) | 0;
                    var tfdt = new MP4.Iso.TrackFragmentBaseMediaDecodeTimeBox(trackState.cachedDuration);
                    var tfhd;
                    var trun;
                    var trunSamples;
                    trafDataStarts.push(tdatPosition);
                    switch (trackInfo.codecId) {
                    case AAC_SOUND_CODEC_ID:
                    case MP3_SOUND_CODEC_ID:
                        trunSamples = [];
                        for (var j = 0; j < trackPackets.length; j++) {
                            var audioPacket = trackPackets[j].packet;
                            var audioFrameDuration = Math.round(audioPacket.samples * trackInfo.timescale / trackInfo.samplerate);
                            tdatParts.push(audioPacket.data);
                            tdatPosition += audioPacket.data.length;
                            trunSamples.push({
                                duration: audioFrameDuration,
                                size: audioPacket.data.length
                            });
                            trackState.samplesProcessed += audioPacket.samples;
                        }
                        var tfhdFlags = 32    /* DEFAULT_SAMPLE_FLAGS_PRESENT */;
                        tfhd = new MP4.Iso.TrackFragmentHeaderBox(tfhdFlags, trackId, 0    /* offset */, 0    /* index */, 0    /* duration */, 0    /* size */, 33554432    /* SAMPLE_DEPENDS_ON_NO_OTHERS */);
                        var trunFlags = 1    /* DATA_OFFSET_PRESENT */ | 256    /* SAMPLE_DURATION_PRESENT */ | 512    /* SAMPLE_SIZE_PRESENT */;
                        trun = new MP4.Iso.TrackRunBox(trunFlags, trunSamples, 0    /* data offset */, 0    /* first flags */);
                        trackState.cachedDuration = Math.round(trackState.samplesProcessed * trackInfo.timescale / trackInfo.samplerate);
                        break;
                    case AVC_VIDEO_CODEC_ID:
                    case VP6_VIDEO_CODEC_ID:
                        trunSamples = [];
                        var samplesProcessed = trackState.samplesProcessed;
                        var decodeTime = samplesProcessed * trackInfo.timescale / trackInfo.framerate;
                        var lastTime = Math.round(decodeTime);
                        for (var j = 0; j < trackPackets.length; j++) {
                            var videoPacket = trackPackets[j].packet;
                            samplesProcessed++;
                            var nextTime = Math.round(samplesProcessed * trackInfo.timescale / trackInfo.framerate);
                            var videoFrameDuration = nextTime - lastTime;
                            lastTime = nextTime;
                            var compositionTime = Math.round(samplesProcessed * trackInfo.timescale / trackInfo.framerate + videoPacket.compositionTime * trackInfo.timescale / 1000);
                            tdatParts.push(videoPacket.data);
                            tdatPosition += videoPacket.data.length;
                            var frameFlags = videoPacket.frameType === VideoFrameType.KEY ? 33554432    /* SAMPLE_DEPENDS_ON_NO_OTHERS */ : 16777216    /* SAMPLE_DEPENDS_ON_OTHER */ | 65536    /* SAMPLE_IS_NOT_SYNC */;
                            trunSamples.push({
                                duration: videoFrameDuration,
                                size: videoPacket.data.length,
                                flags: frameFlags,
                                compositionTimeOffset: compositionTime - nextTime
                            });
                        }
                        var tfhdFlags = 32    /* DEFAULT_SAMPLE_FLAGS_PRESENT */;
                        tfhd = new MP4.Iso.TrackFragmentHeaderBox(tfhdFlags, trackId, 0    /* offset */, 0    /* index */, 0    /* duration */, 0    /* size */, 33554432    /* SAMPLE_DEPENDS_ON_NO_OTHERS */);
                        var trunFlags = 1    /* DATA_OFFSET_PRESENT */ | 256    /* SAMPLE_DURATION_PRESENT */ | 512    /* SAMPLE_SIZE_PRESENT */ | 1024    /* SAMPLE_FLAGS_PRESENT */ | 2048    /* SAMPLE_COMPOSITION_TIME_OFFSET */;
                        trun = new MP4.Iso.TrackRunBox(trunFlags, trunSamples, 0    /* data offset */, 0    /* first flag */);
                        trackState.cachedDuration = lastTime;
                        trackState.samplesProcessed = samplesProcessed;
                        break;
                    default:
                        throw new Error('Un codec');
                    }
                    var traf = new MP4.Iso.TrackFragmentBox(tfhd, tfdt, trun);
                    trafs.push(traf);
                }
                this.cachedPackets.splice(0, cachedPackets.length);
                var moofHeader = new MP4.Iso.MovieFragmentHeaderBox(++this.chunkIndex);
                var moof = new MP4.Iso.MovieFragmentBox(moofHeader, trafs);
                var moofSize = moof.layout(0);
                var mdat = new MP4.Iso.MediaDataBox(tdatParts);
                var mdatSize = mdat.layout(moofSize);
                var tdatOffset = moofSize + 8;
                for (var i = 0; i < trafs.length; i++) {
                    trafs[i].run.dataOffset = tdatOffset + trafDataStarts[i];
                }
                var chunk = new Uint8Array(moofSize + mdatSize);
                moof.write(chunk);
                mdat.write(chunk);
                this.ondata(chunk);
                this.filePos += chunk.length;
            };
            return MP4Mux;
        }();
        MP4.MP4Mux = MP4Mux;
        function parseFLVMetadata(metadata) {
            var tracks = [];
            var audioTrackId = -1;
            var videoTrackId = -1;
            var duration = +metadata.axGetPublicProperty('duration');
            var audioCodec, audioCodecId;
            var audioCodecCode = metadata.axGetPublicProperty('audiocodecid');
            switch (audioCodecCode) {
            case MP3_SOUND_CODEC_ID:
            case 'mp3':
                audioCodec = 'mp3';
                audioCodecId = MP3_SOUND_CODEC_ID;
                break;
            case AAC_SOUND_CODEC_ID:
            case 'mp4a':
                audioCodec = 'mp4a';
                audioCodecId = AAC_SOUND_CODEC_ID;
                break;
            default:
                if (!isNaN(audioCodecCode)) {
                    throw new Error('Unsupported audio codec: ' + audioCodecCode);
                }
                audioCodec = null;
                audioCodecId = -1;
                break;
            }
            var videoCodec, videoCodecId;
            var videoCodecCode = metadata.axGetPublicProperty('videocodecid');
            switch (videoCodecCode) {
            case VP6_VIDEO_CODEC_ID:
            case 'vp6f':
                videoCodec = 'vp6f';
                videoCodecId = VP6_VIDEO_CODEC_ID;
                break;
            case AVC_VIDEO_CODEC_ID:
            case 'avc1':
                videoCodec = 'avc1';
                videoCodecId = AVC_VIDEO_CODEC_ID;
                break;
            default:
                if (!isNaN(videoCodecCode)) {
                    throw new Error('Unsupported video codec: ' + videoCodecCode);
                }
                videoCodec = null;
                videoCodecId = -1;
                break;
            }
            var audioTrack = audioCodec === null ? null : {
                codecDescription: audioCodec,
                codecId: audioCodecId,
                language: 'und',
                timescale: +metadata.axGetPublicProperty('audiosamplerate') || 44100,
                samplerate: +metadata.axGetPublicProperty('audiosamplerate') || 44100,
                channels: +metadata.axGetPublicProperty('audiochannels') || 2,
                samplesize: 16
            };
            var videoTrack = videoCodec === null ? null : {
                codecDescription: videoCodec,
                codecId: videoCodecId,
                language: 'und',
                timescale: 60000,
                framerate: +metadata.axGetPublicProperty('videoframerate') || +metadata.axGetPublicProperty('framerate'),
                width: +metadata.axGetPublicProperty('width'),
                height: +metadata.axGetPublicProperty('height')
            };
            var trackInfos = metadata.axGetPublicProperty('trackinfo');
            if (trackInfos) {
                // Not in the Adobe's references, red5 specific?
                for (var i = 0; i < trackInfos.length; i++) {
                    var info = trackInfos[i];
                    var sampleDescription = info.axGetPublicProperty('sampledescription')[0];
                    if (sampleDescription.axGetPublicProperty('sampletype') === audioCodecCode) {
                        audioTrack.language = info.axGetPublicProperty('language');
                        audioTrack.timescale = +info.axGetPublicProperty('timescale');
                    } else if (sampleDescription.axGetPublicProperty('sampletype') === videoCodecCode) {
                        videoTrack.language = info.axGetPublicProperty('language');
                        videoTrack.timescale = +info.axGetPublicProperty('timescale');
                    }
                }
            }
            if (videoTrack) {
                videoTrackId = tracks.length;
                tracks.push(videoTrack);
            }
            if (audioTrack) {
                audioTrackId = tracks.length;
                tracks.push(audioTrack);
            }
            return {
                tracks: tracks,
                duration: duration,
                audioTrackId: audioTrackId,
                videoTrackId: videoTrackId
            };
        }
        MP4.parseFLVMetadata = parseFLVMetadata;
    }(MP4 = RtmpJs.MP4 || (RtmpJs.MP4 = {})));
    var FLV;
    (function (FLV) {
        var FLVParser = function () {
            function FLVParser() {
                this.state = 0;
                this.state = 0;
                this.buffer = new ArrayBuffer(1024);
                this.bufferSize = 0;
                this.previousTagSize = 0;
                this.onError = null;
                this.onHeader = null;
                this.onTag = null;
                this.onClose = null;
            }
            FLVParser.prototype.push = function (data) {
                var parseBuffer;
                if (this.bufferSize > 0) {
                    var needLength = this.bufferSize + data.length;
                    if (this.buffer.byteLength < needLength) {
                        var tmp = new Uint8Array(this.buffer, 0, this.bufferSize);
                        this.buffer = new ArrayBuffer(needLength);
                        parseBuffer = new Uint8Array(this.buffer);
                        parseBuffer.set(tmp);
                    } else {
                        parseBuffer = new Uint8Array(this.buffer, 0, needLength);
                    }
                    parseBuffer.set(data, this.bufferSize);
                } else {
                    parseBuffer = data;
                }
                var parsed = 0, end = parseBuffer.length;
                while (parsed < end) {
                    var chunkParsed = 0;
                    switch (this.state) {
                    case 0:
                        if (parsed + 9 > end) {
                            break;
                        }
                        var headerLength = parseBuffer[parsed + 5] << 24 | parseBuffer[parsed + 6] << 16 | parseBuffer[parsed + 7] << 8 | parseBuffer[parsed + 8];
                        if (headerLength < 9) {
                            this._error('Invalid header length');
                            break;
                        }
                        if (parsed + headerLength > end) {
                            break;
                        }
                        if (parseBuffer[parsed] !== 70    /* F */ || parseBuffer[parsed + 1] !== 76    /* L */ || parseBuffer[parsed + 2] !== 86    /* V */ || parseBuffer[parsed + 3] !== 1    /* version 1 */ || (parseBuffer[parsed + 4] & 250) !== 0) {
                            this._error('Invalid FLV header');
                            break;
                        }
                        var flags = parseBuffer[parsed + 4];
                        var extra = headerLength > 9 ? parseBuffer.subarray(parsed + 9, parsed + headerLength) : null;
                        this.onHeader && this.onHeader({
                            hasAudio: !!(flags & 4),
                            hasVideo: !!(flags & 1),
                            extra: extra
                        });
                        this.state = 2;
                        chunkParsed = headerLength;
                        break;
                    case 2:
                        if (parsed + 4 + 11 > end) {
                            break;
                        }
                        var previousTagSize = parseBuffer[parsed + 0] << 24 | parseBuffer[parsed + 1] << 16 | parseBuffer[parsed + 2] << 8 | parseBuffer[parsed + 3];
                        if (previousTagSize !== this.previousTagSize) {
                            this._error('Invalid PreviousTagSize');
                            break;
                        }
                        var dataSize = parseBuffer[parsed + 5] << 16 | parseBuffer[parsed + 6] << 8 | parseBuffer[parsed + 7];
                        var dataOffset = parsed + 4 + 11;
                        if (dataOffset + dataSize > end) {
                            break;
                        }
                        var flags = parseBuffer[parsed + 4];
                        var streamID = parseBuffer[parsed + 12] << 16 | parseBuffer[parsed + 13] << 8 | parseBuffer[parsed + 14];
                        if (streamID !== 0 || (flags & 192) !== 0) {
                            this._error('Invalid FLV tag');
                            break;
                        }
                        var dataType = flags & 31;
                        if (dataType !== 8 && dataType !== 9 && dataType !== 18) {
                            this._error('Invalid FLV tag type');
                            break;
                        }
                        var needPreprocessing = !!(flags & 32);
                        var timestamp = parseBuffer[parsed + 8] << 16 | parseBuffer[parsed + 9] << 8 | parseBuffer[parsed + 10] | parseBuffer[parseBuffer + 11] << 24;
                        this.onTag && this.onTag({
                            type: dataType,
                            needPreprocessing: needPreprocessing,
                            timestamp: timestamp,
                            data: parseBuffer.subarray(dataOffset, dataOffset + dataSize)
                        });
                        chunkParsed += 4 + 11 + dataSize;
                        this.previousTagSize = dataSize + 11;
                        this.state = 2;
                        break;
                    default:
                        throw new Error('invalid state');
                    }
                    if (chunkParsed === 0) {
                        break;    // not enough data
                    }
                    parsed += chunkParsed;
                }
                if (parsed < parseBuffer.length) {
                    this.bufferSize = parseBuffer.length - parsed;
                    if (this.buffer.byteLength < this.bufferSize) {
                        this.buffer = new ArrayBuffer(this.bufferSize);
                    }
                    new Uint8Array(this.buffer).set(parseBuffer.subarray(parsed));
                } else {
                    this.bufferSize = 0;
                }
            };
            FLVParser.prototype._error = function (message) {
                this.state = -1;
                this.onError && this.onError(message);
            };
            FLVParser.prototype.close = function () {
                this.onClose && this.onClose();
            };
            return FLVParser;
        }();
        FLV.FLVParser = FLVParser;
    }(FLV = RtmpJs.FLV || (RtmpJs.FLV = {})));
}(RtmpJs || (RtmpJs = {})));
/// <reference path='../../build/ts/avm2.d.ts' />
///<reference path='external.ts' />
///<reference path='rtmp.ts' />
///<reference path='transport.ts' />
///<reference path='transport-browser.ts' />
///<reference path='mp4iso.ts' />
///<reference path='mp4mux.ts' />
///<reference path='flvparser.ts' />
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Class: Matrix
var Shumway;
(function (Shumway) {
    var AVMX;
    (function (AVMX) {
        var AS;
        (function (AS) {
            var flash;
            (function (flash) {
                var geom;
                (function (geom) {
                    var PI = Math.PI;
                    var HalfPI = PI / 2;
                    var PacPI = PI + HalfPI;
                    var TwoPI = PI * 2;
                    function cos(angle) {
                        switch (angle) {
                        case HalfPI:
                        case -PacPI:
                            return 0;
                        case PI:
                        case -PI:
                            return -1;
                        case PacPI:
                        case -HalfPI:
                            return 0;
                        default:
                            return Math.cos(angle);
                        }
                    }
                    function sin(angle) {
                        switch (angle) {
                        case HalfPI:
                        case -PacPI:
                            return 1;
                        case PI:
                        case -PI:
                            return 0;
                        case PacPI:
                        case -HalfPI:
                            return -1;
                        default:
                            return Math.sin(angle);
                        }
                    }
                    var Matrix = function (_super) {
                        __extends(Matrix, _super);
                        // "invert", "identity", "createBox",
                        // "createGradientBox", "rotate", "translate",
                        // "scale", "deltaTransformPoint", "transformPoint",
                        // "copyFrom", "setTo", "copyRowTo", "copyColumnTo",
                        // "copyRowFrom", "copyColumnFrom", "clone",
                        // "toString"];
                        function Matrix(a, b, c, d, tx, ty) {
                            if (a === void 0) {
                                a = 1;
                            }
                            if (b === void 0) {
                                b = 0;
                            }
                            if (c === void 0) {
                                c = 0;
                            }
                            if (d === void 0) {
                                d = 1;
                            }
                            if (tx === void 0) {
                                tx = 0;
                            }
                            if (ty === void 0) {
                                ty = 0;
                            }
                            _super.call(this);
                            var m = this._data = new Float64Array(6);
                            m[0] = a;
                            m[1] = b;
                            m[2] = c;
                            m[3] = d;
                            m[4] = tx;
                            m[5] = ty;
                        }
                        Matrix.classInitializer = function () {
                            this.FROZEN_IDENTITY_MATRIX = Object.freeze(this.axConstruct([]));
                            this.TEMP_MATRIX = this.axConstruct([]);
                        };
                        Matrix.FromUntyped = function (object) {
                            return new this.sec.flash.geom.Matrix(object.a, object.b, object.c, object.d, object.tx, object.ty);
                        };
                        // Keep in sync with writeExternal below!
                        Matrix.FromDataBuffer = function (input) {
                            return new this.sec.flash.geom.Matrix(input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());
                        };
                        Object.defineProperty(Matrix.prototype, 'a', {
                            get: function () {
                                return this._data[0];
                            },
                            set: function (a) {
                                this._data[0] = a;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix.prototype, 'b', {
                            get: function () {
                                return this._data[1];
                            },
                            set: function (b) {
                                this._data[1] = b;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix.prototype, 'c', {
                            get: function () {
                                return this._data[2];
                            },
                            set: function (c) {
                                this._data[2] = c;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix.prototype, 'd', {
                            get: function () {
                                return this._data[3];
                            },
                            set: function (d) {
                                this._data[3] = d;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix.prototype, 'tx', {
                            get: function () {
                                return this._data[4];
                            },
                            set: function (tx) {
                                this._data[4] = tx;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix.prototype, 'ty', {
                            get: function () {
                                return this._data[5];
                            },
                            set: function (ty) {
                                this._data[5] = ty;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * this = this * other
                         */
                        Matrix.prototype.concat = function (other) {
                            var m = this._data, n = other._data;
                            var a = m[0] * n[0];
                            var b = 0;
                            var c = 0;
                            var d = m[3] * n[3];
                            var tx = m[4] * n[0] + n[4];
                            var ty = m[5] * n[3] + n[5];
                            if (m[1] !== 0 || m[2] !== 0 || n[1] !== 0 || n[2] !== 0) {
                                a += m[1] * n[2];
                                d += m[2] * n[1];
                                b += m[0] * n[1] + m[1] * n[3];
                                c += m[2] * n[0] + m[3] * n[2];
                                tx += m[5] * n[2];
                                ty += m[4] * n[1];
                            }
                            m[0] = a;
                            m[1] = b;
                            m[2] = c;
                            m[3] = d;
                            m[4] = tx;
                            m[5] = ty;
                        };
                        /**
                         * this = other * this
                         */
                        Matrix.prototype.preMultiply = function (other) {
                            this.preMultiplyInto(other, this);
                        };
                        /**
                         * target = other * this
                         */
                        Matrix.prototype.preMultiplyInto = function (other, target) {
                            var m = this._data, n = other._data, t = target._data;
                            var a = n[0] * m[0];
                            var b = 0;
                            var c = 0;
                            var d = n[3] * m[3];
                            var tx = n[4] * m[0] + m[4];
                            var ty = n[5] * m[3] + m[5];
                            if (n[1] !== 0 || n[2] !== 0 || m[1] !== 0 || m[2] !== 0) {
                                a += n[1] * m[2];
                                d += n[2] * m[1];
                                b += n[0] * m[1] + n[1] * m[3];
                                c += n[2] * m[0] + n[3] * m[2];
                                tx += n[5] * m[2];
                                ty += n[4] * m[1];
                            }
                            t[0] = a;
                            t[1] = b;
                            t[2] = c;
                            t[3] = d;
                            t[4] = tx;
                            t[5] = ty;
                        };
                        Matrix.prototype.invert = function () {
                            this.invertInto(this);
                        };
                        Matrix.prototype.invertInto = function (target) {
                            var m = this._data, t = target._data;
                            var b = m[1];
                            var c = m[2];
                            var tx = m[4];
                            var ty = m[5];
                            if (b === 0 && c === 0) {
                                var a = t[0] = 1 / m[0];
                                var d = t[3] = 1 / m[3];
                                t[1] = t[2] = 0;
                                t[4] = -a * tx;
                                t[5] = -d * ty;
                                return;
                            }
                            var a = m[0];
                            var d = m[3];
                            var determinant = a * d - b * c;
                            if (determinant === 0) {
                                target.identity();
                                return;
                            }
                            /**
                             * Multiplying by reciprocal of the |determinant| is only accurate if the reciprocal is
                             * representable without loss of precision. This is usually only the case for powers of
                             * two: 1/2, 1/4 ...
                             */
                            determinant = 1 / determinant;
                            var k = 0;
                            k = t[0] = d * determinant;
                            b = t[1] = -b * determinant;
                            c = t[2] = -c * determinant;
                            d = t[3] = a * determinant;
                            t[4] = -(k * tx + c * ty);
                            t[5] = -(b * tx + d * ty);
                        };
                        Matrix.prototype.identity = function () {
                            var m = this._data;
                            m[0] = m[3] = 1;
                            m[1] = m[2] = m[4] = m[5] = 0;
                        };
                        Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
                            if (rotation === void 0) {
                                rotation = 0;
                            }
                            if (tx === void 0) {
                                tx = 0;
                            }
                            if (ty === void 0) {
                                ty = 0;
                            }
                            var m = this._data;
                            if (rotation !== 0) {
                                var u = cos(rotation);
                                var v = sin(rotation);
                                m[0] = u * scaleX;
                                m[1] = v * scaleY;
                                m[2] = -v * scaleX;
                                m[3] = u * scaleY;
                            } else {
                                m[0] = scaleX;
                                m[1] = 0;
                                m[2] = 0;
                                m[3] = scaleY;
                            }
                            m[4] = tx;
                            m[5] = ty;
                        };
                        Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
                            if (rotation === void 0) {
                                rotation = 0;
                            }
                            if (tx === void 0) {
                                tx = 0;
                            }
                            if (ty === void 0) {
                                ty = 0;
                            }
                            this.createBox(width / 1638.4, height / 1638.4, rotation, tx + width / 2, ty + height / 2);
                        };
                        Matrix.prototype.rotate = function (angle) {
                            angle = +angle;
                            if (angle !== 0) {
                                var m = this._data;
                                var u = cos(angle);
                                var v = sin(angle);
                                var ta = m[0];
                                var tb = m[1];
                                var tc = m[2];
                                var td = m[3];
                                var ttx = m[4];
                                var tty = m[5];
                                m[0] = ta * u - tb * v;
                                m[1] = ta * v + tb * u;
                                m[2] = tc * u - td * v;
                                m[3] = tc * v + td * u;
                                m[4] = ttx * u - tty * v;
                                m[5] = ttx * v + tty * u;
                            }
                        };
                        Matrix.prototype.translate = function (dx, dy) {
                            var m = this._data;
                            m[4] += dx;
                            m[5] += dy;
                        };
                        Matrix.prototype.scale = function (sx, sy) {
                            var m = this._data;
                            if (sx !== 1) {
                                m[0] *= sx;
                                m[2] *= sx;
                                m[4] *= sx;
                            }
                            if (sy !== 1) {
                                m[1] *= sy;
                                m[3] *= sy;
                                m[5] *= sy;
                            }
                        };
                        Matrix.prototype.deltaTransformPoint = function (point) {
                            var x = this._data[0] * point.x + this._data[2] * point.y;
                            var y = this._data[1] * point.x + this._data[3] * point.y;
                            return new this.sec.flash.geom.Point(x, y);
                        };
                        Matrix.prototype.transformX = function (x, y) {
                            var m = this._data;
                            return m[0] * x + m[2] * y + m[4];
                        };
                        Matrix.prototype.transformY = function (x, y) {
                            var m = this._data;
                            return m[1] * x + m[3] * y + m[5];
                        };
                        Matrix.prototype.transformPoint = function (point) {
                            var m = this._data;
                            return new this.sec.flash.geom.Point(m[0] * point.x + m[2] * point.y + m[4], m[1] * point.x + m[3] * point.y + m[5]);
                        };
                        Matrix.prototype.transformPointInPlace = function (point) {
                            var m = this._data;
                            point.setTo(m[0] * point.x + m[2] * point.y + m[4], m[1] * point.x + m[3] * point.y + m[5]);
                            return point;
                        };
                        Matrix.prototype.transformBounds = function (bounds) {
                            var m = this._data;
                            var a = m[0];
                            var b = m[1];
                            var c = m[2];
                            var d = m[3];
                            var tx = m[4];
                            var ty = m[5];
                            var x = bounds.xMin;
                            var y = bounds.yMin;
                            var w = bounds.width;
                            var h = bounds.height;
                            var x0 = Math.round(a * x + c * y + tx);
                            var y0 = Math.round(b * x + d * y + ty);
                            var x1 = Math.round(a * (x + w) + c * y + tx);
                            var y1 = Math.round(b * (x + w) + d * y + ty);
                            var x2 = Math.round(a * (x + w) + c * (y + h) + tx);
                            var y2 = Math.round(b * (x + w) + d * (y + h) + ty);
                            var x3 = Math.round(a * x + c * (y + h) + tx);
                            var y3 = Math.round(b * x + d * (y + h) + ty);
                            var tmp = 0;
                            // Manual Min/Max is a lot faster than calling Math.min/max
                            // X Min-Max
                            if (x0 > x1) {
                                tmp = x0;
                                x0 = x1;
                                x1 = tmp;
                            }
                            if (x2 > x3) {
                                tmp = x2;
                                x2 = x3;
                                x3 = tmp;
                            }
                            bounds.xMin = x0 < x2 ? x0 : x2;
                            bounds.xMax = x1 > x3 ? x1 : x3;
                            // Y Min-Max
                            if (y0 > y1) {
                                tmp = y0;
                                y0 = y1;
                                y1 = tmp;
                            }
                            if (y2 > y3) {
                                tmp = y2;
                                y2 = y3;
                                y3 = tmp;
                            }
                            bounds.yMin = y0 < y2 ? y0 : y2;
                            bounds.yMax = y1 > y3 ? y1 : y3;
                        };
                        Matrix.prototype.getDeterminant = function () {
                            var m = this._data;
                            return m[0] * m[3] - m[1] * m[2];
                        };
                        Matrix.prototype.getScaleX = function () {
                            var m = this._data;
                            if (m[0] === 1 && m[1] === 0) {
                                return 1;
                            }
                            var result = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
                            return this.getDeterminant() < 0 ? -result : result;
                        };
                        Matrix.prototype.getScaleY = function () {
                            var m = this._data;
                            if (m[2] === 0 && m[3] === 1) {
                                return 1;
                            }
                            var result = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
                            return this.getDeterminant() < 0 ? -result : result;
                        };
                        Matrix.prototype.getAbsoluteScaleX = function () {
                            return Math.abs(this.getScaleX());
                        };
                        Matrix.prototype.getAbsoluteScaleY = function () {
                            return Math.abs(this.getScaleY());
                        };
                        Matrix.prototype.getSkewX = function () {
                            return Math.atan2(this._data[3], this._data[2]) - Math.PI / 2;
                        };
                        Matrix.prototype.getSkewY = function () {
                            return Math.atan2(this._data[1], this._data[0]);
                        };
                        Matrix.prototype.copyFrom = function (other) {
                            var m = this._data, n = other._data;
                            m[0] = n[0];
                            m[1] = n[1];
                            m[2] = n[2];
                            m[3] = n[3];
                            m[4] = n[4];
                            m[5] = n[5];
                        };
                        Matrix.prototype.copyFromUntyped = function (object) {
                            var m = this._data;
                            m[0] = object.a;
                            m[1] = object.b;
                            m[2] = object.c;
                            m[3] = object.d;
                            m[4] = object.tx;
                            m[5] = object.ty;
                        };
                        Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
                            var m = this._data;
                            m[0] = a;
                            m[1] = b;
                            m[2] = c;
                            m[3] = d;
                            m[4] = tx;
                            m[5] = ty;
                        };
                        Matrix.prototype.toTwipsInPlace = function () {
                            var m = this._data;
                            m[4] = m[4] * 20 | 0;
                            m[5] = m[5] * 20 | 0;
                            return this;
                        };
                        Matrix.prototype.toPixelsInPlace = function () {
                            var m = this._data;
                            m[4] /= 20;
                            m[5] /= 20;
                            return this;
                        };
                        Matrix.prototype.toSerializedScaleInPlace = function () {
                            var m = this._data;
                            m[0] *= 819.2;
                            m[1] *= 819.2;
                            m[2] *= 819.2;
                            m[3] *= 819.2;
                            return this;
                        };
                        Matrix.prototype.copyRowTo = function (row, vector3D) {
                            var m = this._data;
                            row = row >>> 0;
                            if (row === 0) {
                                vector3D.x = m[0];
                                vector3D.y = m[2];
                                vector3D.z = m[4];
                            } else if (row === 1) {
                                vector3D.x = m[1];
                                vector3D.y = m[3];
                                vector3D.z = m[5];
                            } else if (row === 2) {
                                vector3D.x = 0;
                                vector3D.y = 0;
                                vector3D.z = 1;
                            }
                        };
                        Matrix.prototype.copyColumnTo = function (column, vector3D) {
                            var m = this._data;
                            column = column >>> 0;
                            if (column === 0) {
                                vector3D.x = m[0];
                                vector3D.y = m[1];
                                vector3D.z = 0;
                            } else if (column === 1) {
                                vector3D.x = m[2];
                                vector3D.y = m[3];
                                vector3D.z = 0;
                            } else if (column === 2) {
                                vector3D.x = m[4];
                                vector3D.y = m[5];
                                vector3D.z = 1;
                            }
                        };
                        Matrix.prototype.copyRowFrom = function (row, vector3D) {
                            var m = this._data;
                            row = row >>> 0;
                            if (row === 0) {
                                m[0] = vector3D.x;
                                m[2] = vector3D.y;
                                m[4] = vector3D.z;
                            } else if (row === 1) {
                                m[1] = vector3D.x;
                                m[3] = vector3D.y;
                                m[5] = vector3D.z;
                            }
                        };
                        Matrix.prototype.copyColumnFrom = function (column, vector3D) {
                            var m = this._data;
                            column = column >>> 0;
                            if (column === 0) {
                                m[0] = vector3D.x;
                                m[2] = vector3D.y;
                                m[4] = vector3D.z;
                            } else if (column === 1) {
                                m[1] = vector3D.x;
                                m[3] = vector3D.y;
                                m[5] = vector3D.z;
                            }
                        };
                        /**
                         * Updates the scale and skew componenets of the matrix.
                         */
                        Matrix.prototype.updateScaleAndRotation = function (scaleX, scaleY, skewX, skewY) {
                            var m = this._data;
                            // The common case.
                            if ((skewX === 0 || skewX === TwoPI) && (skewY === 0 || skewY === TwoPI)) {
                                m[0] = scaleX;
                                m[1] = m[2] = 0;
                                m[3] = scaleY;
                                return;
                            }
                            var u = cos(skewX);
                            var v = sin(skewX);
                            if (skewX === skewY) {
                                m[0] = u * scaleX;
                                m[1] = v * scaleX;
                            } else {
                                m[0] = cos(skewY) * scaleX;
                                m[1] = sin(skewY) * scaleX;
                            }
                            m[2] = -v * scaleY;
                            m[3] = u * scaleY;
                        };
                        Matrix.prototype.clone = function () {
                            var m = this._data;
                            return new this.sec.flash.geom.Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);
                        };
                        Matrix.prototype.equals = function (other) {
                            var m = this._data, n = other._data;
                            return m[0] === n[0] && m[1] === n[1] && m[2] === n[2] && m[3] === n[3] && m[4] === n[4] && m[5] === n[5];
                        };
                        Matrix.prototype.toString = function () {
                            var m = this._data;
                            return '(a=' + m[0] + ', b=' + m[1] + ', c=' + m[2] + ', d=' + m[3] + ', tx=' + m[4] + ', ty=' + m[5] + ')';
                        };
                        // Keep in sync with static FromDataBuffer above!
                        Matrix.prototype.writeExternal = function (output) {
                            var m = this._data;
                            output.writeFloat(m[0]);
                            output.writeFloat(m[1]);
                            output.writeFloat(m[2]);
                            output.writeFloat(m[3]);
                            output.writeFloat(m[4]);
                            output.writeFloat(m[5]);
                        };
                        Matrix.classSymbols = null;
                        // [];
                        Matrix.instanceSymbols = null;
                        // ["a", "b", "c", "d", "tx", "ty", "concat",
                        return Matrix;
                    }(AS.ASObject);
                    geom.Matrix = Matrix;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    /*
                     * _matrix stores data by columns
                     *  | 0  4  8  12 |
                     *  | 1  5  9  13 |
                     *  | 2  6 10  14 |
                     *  | 3  7 11  15 |
                     */
                    var precision = 1e-7;
                    var transposeTransform = new Uint32Array([
                        0,
                        4,
                        8,
                        12,
                        1,
                        5,
                        9,
                        13,
                        2,
                        6,
                        10,
                        14,
                        3,
                        7,
                        11,
                        15
                    ]);
                    function getRotationMatrix(theta, u, v, w, a, b, c, sec) {
                        // http://inside.mines.edu/~gmurray/ArbitraryAxisRotation/
                        var u2 = u * u, v2 = v * v, w2 = w * w;
                        var L2 = u2 + v2 + w2, L = Math.sqrt(L2);
                        u /= L;
                        v /= L;
                        w /= L;
                        u2 /= L2;
                        v2 /= L2;
                        w2 /= L2;
                        var cos = Math.cos(theta), sin = Math.sin(theta);
                        return sec.flash.geom.Matrix3D.axClass.FromArray([
                            u2 + (v2 + w2) * cos,
                            u * v * (1 - cos) + w * sin,
                            u * w * (1 - cos) - v * sin,
                            0,
                            u * v * (1 - cos) - w * sin,
                            v2 + (u2 + w2) * cos,
                            v * w * (1 - cos) + u * sin,
                            0,
                            u * w * (1 - cos) + v * sin,
                            v * w * (1 - cos) - u * sin,
                            w2 + (u2 + v2) * cos,
                            0,
                            (a * (v2 + w2) - u * (b * v + c * w)) * (1 - cos) + (b * w - c * v) * sin,
                            (b * (u2 + w2) - v * (a * u + c * w)) * (1 - cos) + (c * u - a * w) * sin,
                            (c * (u2 + v2) - w * (a * u + b * v)) * (1 - cos) + (a * v - b * u) * sin,
                            1
                        ]);
                    }
                    var Matrix3D = function (_super) {
                        __extends(Matrix3D, _super);
                        function Matrix3D(v) {
                            if (v === void 0) {
                                v = null;
                            }
                            _super.call(this);
                            this._matrix = new Float32Array(16);
                            if (v && v.length >= 16) {
                                this.copyRawDataFrom(v, 0, false);
                            } else {
                                this.identity();
                            }
                        }
                        Matrix3D.FromArray = function (matrix) {
                            var result = Object.create(this.tPrototype);
                            result._matrix = new Float32Array(matrix);
                            return result;
                        };
                        Matrix3D.interpolate = function (thisMat, toMat, percent) {
                            thisMat = thisMat;
                            toMat = toMat;
                            percent = +percent;
                            release || notImplemented('public flash.geom.Matrix3D::static interpolate');
                            return;
                        };
                        Matrix3D.prototype.setTargetDisplayObject = function (object) {
                            if (this._displayObject) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.Matrix3DRefCannontBeShared);
                            }
                            this._displayObject = object;
                        };
                        Matrix3D.prototype.resetTargetDisplayObject = function () {
                            release || Shumway.Debug.assert(this._displayObject);
                            this._displayObject = null;
                        };
                        Object.defineProperty(Matrix3D.prototype, 'rawData', {
                            get: function () {
                                var result = new this.sec.Float64Vector();
                                this.copyRawDataTo(result, 0, false);
                                return result;
                            },
                            set: function (v) {
                                this.copyRawDataFrom(v, 0, false);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix3D.prototype, 'position', {
                            get: function () {
                                var m = this._matrix;
                                return new this.sec.flash.geom.Vector3D(m[12], m[13], m[14]);
                            },
                            set: function (pos) {
                                var m = this._matrix;
                                m[12] = pos.x;
                                m[13] = pos.y;
                                m[14] = pos.z;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Matrix3D.prototype, 'determinant', {
                            get: function () {
                                var m = this._matrix;
                                var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                                var d;
                                d = m11 * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24)) - m21 * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14)) + m31 * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14)) - m41 * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                                return d;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Matrix3D.prototype.clone = function () {
                            return this.sec.flash.geom.Matrix3D.axClass.FromArray(this._matrix);
                        };
                        Matrix3D.prototype.copyToMatrix3D = function (dest) {
                            dest = dest;
                            dest._matrix.set(this._matrix);
                        };
                        Matrix3D.prototype.append = function (lhs) {
                            var ma = lhs._matrix, mb = this._matrix, m = this._matrix;
                            var ma11 = ma[0], ma12 = ma[4], ma13 = ma[8], ma14 = ma[12], ma21 = ma[1], ma22 = ma[5], ma23 = ma[9], ma24 = ma[13], ma31 = ma[2], ma32 = ma[6], ma33 = ma[10], ma34 = ma[14], ma41 = ma[3], ma42 = ma[7], ma43 = ma[11], ma44 = ma[15];
                            var mb11 = mb[0], mb12 = mb[4], mb13 = mb[8], mb14 = mb[12], mb21 = mb[1], mb22 = mb[5], mb23 = mb[9], mb24 = mb[13], mb31 = mb[2], mb32 = mb[6], mb33 = mb[10], mb34 = mb[14], mb41 = mb[3], mb42 = mb[7], mb43 = mb[11], mb44 = mb[15];
                            m[0] = ma11 * mb11 + ma12 * mb21 + ma13 * mb31 + ma14 * mb41;
                            m[1] = ma21 * mb11 + ma22 * mb21 + ma23 * mb31 + ma24 * mb41;
                            m[2] = ma31 * mb11 + ma32 * mb21 + ma33 * mb31 + ma34 * mb41;
                            m[3] = ma41 * mb11 + ma42 * mb21 + ma43 * mb31 + ma44 * mb41;
                            m[4] = ma11 * mb12 + ma12 * mb22 + ma13 * mb32 + ma14 * mb42;
                            m[5] = ma21 * mb12 + ma22 * mb22 + ma23 * mb32 + ma24 * mb42;
                            m[6] = ma31 * mb12 + ma32 * mb22 + ma33 * mb32 + ma34 * mb42;
                            m[7] = ma41 * mb12 + ma42 * mb22 + ma43 * mb32 + ma44 * mb42;
                            m[8] = ma11 * mb13 + ma12 * mb23 + ma13 * mb33 + ma14 * mb43;
                            m[9] = ma21 * mb13 + ma22 * mb23 + ma23 * mb33 + ma24 * mb43;
                            m[10] = ma31 * mb13 + ma32 * mb23 + ma33 * mb33 + ma34 * mb43;
                            m[11] = ma41 * mb13 + ma42 * mb23 + ma43 * mb33 + ma44 * mb43;
                            m[12] = ma11 * mb14 + ma12 * mb24 + ma13 * mb34 + ma14 * mb44;
                            m[13] = ma21 * mb14 + ma22 * mb24 + ma23 * mb34 + ma24 * mb44;
                            m[14] = ma31 * mb14 + ma32 * mb24 + ma33 * mb34 + ma34 * mb44;
                            m[15] = ma41 * mb14 + ma42 * mb24 + ma43 * mb34 + ma44 * mb44;
                        };
                        Matrix3D.prototype.prepend = function (rhs) {
                            var ma = this._matrix, mb = rhs._matrix, m = this._matrix;
                            var ma11 = ma[0], ma12 = ma[4], ma13 = ma[8], ma14 = ma[12], ma21 = ma[1], ma22 = ma[5], ma23 = ma[9], ma24 = ma[13], ma31 = ma[2], ma32 = ma[6], ma33 = ma[10], ma34 = ma[14], ma41 = ma[3], ma42 = ma[7], ma43 = ma[11], ma44 = ma[15];
                            var mb11 = mb[0], mb12 = mb[4], mb13 = mb[8], mb14 = mb[12], mb21 = mb[1], mb22 = mb[5], mb23 = mb[9], mb24 = mb[13], mb31 = mb[2], mb32 = mb[6], mb33 = mb[10], mb34 = mb[14], mb41 = mb[3], mb42 = mb[7], mb43 = mb[11], mb44 = mb[15];
                            m[0] = ma11 * mb11 + ma12 * mb21 + ma13 * mb31 + ma14 * mb41;
                            m[1] = ma21 * mb11 + ma22 * mb21 + ma23 * mb31 + ma24 * mb41;
                            m[2] = ma31 * mb11 + ma32 * mb21 + ma33 * mb31 + ma34 * mb41;
                            m[3] = ma41 * mb11 + ma42 * mb21 + ma43 * mb31 + ma44 * mb41;
                            m[4] = ma11 * mb12 + ma12 * mb22 + ma13 * mb32 + ma14 * mb42;
                            m[5] = ma21 * mb12 + ma22 * mb22 + ma23 * mb32 + ma24 * mb42;
                            m[6] = ma31 * mb12 + ma32 * mb22 + ma33 * mb32 + ma34 * mb42;
                            m[7] = ma41 * mb12 + ma42 * mb22 + ma43 * mb32 + ma44 * mb42;
                            m[8] = ma11 * mb13 + ma12 * mb23 + ma13 * mb33 + ma14 * mb43;
                            m[9] = ma21 * mb13 + ma22 * mb23 + ma23 * mb33 + ma24 * mb43;
                            m[10] = ma31 * mb13 + ma32 * mb23 + ma33 * mb33 + ma34 * mb43;
                            m[11] = ma41 * mb13 + ma42 * mb23 + ma43 * mb33 + ma44 * mb43;
                            m[12] = ma11 * mb14 + ma12 * mb24 + ma13 * mb34 + ma14 * mb44;
                            m[13] = ma21 * mb14 + ma22 * mb24 + ma23 * mb34 + ma24 * mb44;
                            m[14] = ma31 * mb14 + ma32 * mb24 + ma33 * mb34 + ma34 * mb44;
                            m[15] = ma41 * mb14 + ma42 * mb24 + ma43 * mb34 + ma44 * mb44;
                        };
                        Matrix3D.prototype.invert = function () {
                            var d = this.determinant;
                            if (Math.abs(d) < precision) {
                                return false;
                            }
                            d = 1 / d;
                            var m = this._matrix;
                            // operating on transposed matrix
                            var m11 = m[0], m12 = m[1], m13 = m[2], m14 = m[3], m21 = m[4], m22 = m[5], m23 = m[6], m24 = m[7], m31 = m[8], m32 = m[9], m33 = m[10], m34 = m[11], m41 = m[12], m42 = m[13], m43 = m[14], m44 = m[15];
                            m[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
                            m[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
                            m[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
                            m[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
                            m[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
                            m[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
                            m[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
                            m[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
                            m[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
                            m[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
                            m[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
                            m[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
                            m[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
                            m[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
                            m[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
                            m[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
                            return true;
                        };
                        Matrix3D.prototype.identity = function () {
                            var m = this._matrix;
                            m[0] = m[5] = m[10] = m[15] = 1;
                            m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
                        };
                        Matrix3D.prototype.decompose = function (orientationStyle) {
                            if (orientationStyle === void 0) {
                                orientationStyle = 'eulerAngles';
                            }
                            orientationStyle = axCoerceString(orientationStyle);
                            release || notImplemented('public flash.geom.Matrix3D::decompose');
                            return;
                        };
                        Matrix3D.prototype.recompose = function (components, orientationStyle) {
                            if (orientationStyle === void 0) {
                                orientationStyle = 'eulerAngles';
                            }
                            orientationStyle = axCoerceString(orientationStyle);
                            release || notImplemented('public flash.geom.Matrix3D::recompose');
                            return;
                        };
                        Matrix3D.prototype.appendTranslation = function (x, y, z) {
                            x = +x;
                            y = +y;
                            z = +z;
                            var m = this._matrix;
                            var m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                            m[0] += x * m41;
                            m[1] += y * m41;
                            m[2] += z * m41;
                            m[4] += x * m42;
                            m[5] += y * m42;
                            m[6] += z * m42;
                            m[8] += x * m43;
                            m[9] += y * m43;
                            m[10] += z * m43;
                            m[12] += x * m44;
                            m[13] += y * m44;
                            m[14] += z * m44;
                        };
                        Matrix3D.prototype.appendRotation = function (degrees, axis, pivotPoint) {
                            if (pivotPoint === void 0) {
                                pivotPoint = null;
                            }
                            degrees = +degrees;
                            axis = axis;
                            pivotPoint = pivotPoint;
                            this.append(getRotationMatrix(degrees / 180 * Math.PI, axis.x, axis.y, axis.z, pivotPoint ? pivotPoint.x : 0, pivotPoint ? pivotPoint.y : 0, pivotPoint ? pivotPoint.z : 0, this.sec));
                        };
                        Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
                            xScale = +xScale;
                            yScale = +yScale;
                            zScale = +zScale;
                            var m = this._matrix;
                            m[0] *= xScale;
                            m[1] *= yScale;
                            m[2] *= zScale;
                            m[4] *= xScale;
                            m[5] *= yScale;
                            m[6] *= zScale;
                            m[8] *= xScale;
                            m[9] *= yScale;
                            m[10] *= zScale;
                            m[12] *= xScale;
                            m[13] *= yScale;
                            m[14] *= zScale;
                        };
                        Matrix3D.prototype.prependTranslation = function (x, y, z) {
                            x = +x;
                            y = +y;
                            z = +z;
                            var m = this._matrix;
                            var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                            m[12] += m11 * x + m12 * y + m13 * z;
                            m[13] += m21 * x + m22 * y + m23 * z;
                            m[14] += m31 * x + m32 * y + m33 * z;
                            m[15] += m41 * x + m42 * y + m43 * z;
                        };
                        Matrix3D.prototype.prependRotation = function (degrees, axis, pivotPoint) {
                            if (pivotPoint === void 0) {
                                pivotPoint = null;
                            }
                            degrees = +degrees;
                            axis = axis;
                            pivotPoint = pivotPoint;
                            this.prepend(getRotationMatrix(degrees / 180 * Math.PI, axis.x, axis.y, axis.z, pivotPoint ? pivotPoint.x : 0, pivotPoint ? pivotPoint.y : 0, pivotPoint ? pivotPoint.z : 0, this.sec));
                        };
                        Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
                            xScale = +xScale;
                            yScale = +yScale;
                            zScale = +zScale;
                            var m = this._matrix;
                            m[0] *= xScale;
                            m[1] *= xScale;
                            m[2] *= xScale;
                            m[3] *= xScale;
                            m[4] *= yScale;
                            m[5] *= yScale;
                            m[6] *= yScale;
                            m[7] *= yScale;
                            m[8] *= zScale;
                            m[9] *= zScale;
                            m[10] *= zScale;
                            m[11] *= zScale;
                        };
                        Matrix3D.prototype.transformVector = function (v) {
                            var m = this._matrix;
                            var x = v.x, y = v.y, z = v.z;
                            return new this.sec.flash.geom.Vector3D(m[0] * x + m[4] * y + m[8] * z + m[12], m[1] * x + m[5] * y + m[9] * z + m[13], m[2] * x + m[6] * y + m[10] * z + m[14]);
                        };
                        Matrix3D.prototype.deltaTransformVector = function (v) {
                            var m = this._matrix;
                            var x = v.x, y = v.y, z = v.z;
                            return new this.sec.flash.geom.Vector3D(m[0] * x + m[4] * y + m[8] * z, m[1] * x + m[5] * y + m[9] * z, m[2] * x + m[6] * y + m[10] * z);
                        };
                        Matrix3D.prototype.transformVectors = function (vin, vout) {
                            var m = this._matrix;
                            var m11 = m[0], m12 = m[4], m13 = m[8], m14 = m[12], m21 = m[1], m22 = m[5], m23 = m[9], m24 = m[13], m31 = m[2], m32 = m[6], m33 = m[10], m34 = m[14], m41 = m[3], m42 = m[7], m43 = m[11], m44 = m[15];
                            for (var i = 0; i < vin.length - 2; i += 3) {
                                var x = vin.axGetNumericProperty(i), y = vin.axGetNumericProperty(i + 1), z = vin.axGetNumericProperty(i + 2);
                                vout.push(m11 * x + m12 * y + m13 * z + m14);
                                vout.push(m21 * x + m22 * y + m23 * z + m24);
                                vout.push(m31 * x + m32 * y + m33 * z + m34);
                            }
                        };
                        Matrix3D.prototype.transpose = function () {
                            var m = this._matrix;
                            var tmp;
                            tmp = m[1];
                            m[1] = m[4];
                            m[4] = tmp;
                            tmp = m[2];
                            m[2] = m[8];
                            m[5] = tmp;
                            tmp = m[3];
                            m[3] = m[12];
                            m[12] = tmp;
                            tmp = m[6];
                            m[6] = m[9];
                            m[9] = tmp;
                            tmp = m[7];
                            m[7] = m[13];
                            m[13] = tmp;
                            tmp = m[11];
                            m[11] = m[14];
                            m[14] = tmp;
                        };
                        Matrix3D.prototype.pointAt = function (pos, at, up) {
                            if (at === void 0) {
                                at = null;
                            }
                            if (up === void 0) {
                                up = null;
                            }
                            pos = pos;
                            at = at;
                            up = up;
                            release || notImplemented('public flash.geom.Matrix3D::pointAt');
                            return;
                        };
                        Matrix3D.prototype.interpolateTo = function (toMat, percent) {
                            toMat = toMat;
                            percent = +percent;
                            release || notImplemented('public flash.geom.Matrix3D::interpolateTo');
                            return;
                        };
                        Matrix3D.prototype.copyFrom = function (sourceMatrix3D) {
                            sourceMatrix3D = sourceMatrix3D;
                            this._matrix.set(sourceMatrix3D._matrix);
                        };
                        Matrix3D.prototype.copyRawDataTo = function (vector, index, transpose) {
                            if (index === void 0) {
                                index = 0;
                            }
                            if (transpose === void 0) {
                                transpose = false;
                            }
                            vector = vector;
                            index = index >>> 0;
                            transpose = !!transpose;
                            var m = this._matrix;
                            if (transpose) {
                                for (var i = 0, j = index | 0; i < 16; i++, j++) {
                                    vector.axSetNumericProperty(j, m[transposeTransform[i]]);
                                }
                            } else {
                                for (var i = 0, j = index | 0; i < 16; i++, j++) {
                                    vector.axSetNumericProperty(j, m[i]);
                                }
                            }
                        };
                        Matrix3D.prototype.copyRawDataFrom = function (vector, index, transpose) {
                            if (index === void 0) {
                                index = 0;
                            }
                            if (transpose === void 0) {
                                transpose = false;
                            }
                            vector = vector;
                            index = index >>> 0;
                            transpose = !!transpose;
                            var m = this._matrix;
                            if (transpose) {
                                for (var i = 0, j = index | 0; i < 16; i++, j++) {
                                    m[transposeTransform[i]] = vector.axGetNumericProperty(j) || 0;    // removing NaN
                                }
                            } else {
                                for (var i = 0, j = index | 0; i < 16; i++, j++) {
                                    m[i] = vector.axGetNumericProperty(j) || 0;    // removing NaN
                                }
                            }
                        };
                        Matrix3D.prototype.copyRowTo = function (row, vector3D) {
                            row = row >>> 0;
                            vector3D = vector3D;
                            var offset = row | 0;
                            var m = this._matrix;
                            vector3D.x = m[offset];
                            vector3D.y = m[offset + 4];
                            vector3D.z = m[offset + 8];
                            vector3D.w = m[offset + 12];
                        };
                        Matrix3D.prototype.copyColumnTo = function (column, vector3D) {
                            column = column >>> 0;
                            vector3D = vector3D;
                            var offset = column << 2;
                            var m = this._matrix;
                            vector3D.x = m[offset];
                            vector3D.y = m[offset + 1];
                            vector3D.z = m[offset + 2];
                            vector3D.w = m[offset + 3];
                        };
                        Matrix3D.prototype.copyRowFrom = function (row, vector3D) {
                            row = row >>> 0;
                            vector3D = vector3D;
                            var offset = row | 0;
                            var m = this._matrix;
                            m[offset] = vector3D.x;
                            m[offset + 4] = vector3D.y;
                            m[offset + 8] = vector3D.z;
                            m[offset + 12] = vector3D.w;
                        };
                        Matrix3D.prototype.copyColumnFrom = function (column, vector3D) {
                            column = column >>> 0;
                            vector3D = vector3D;
                            var offset = column << 2;
                            var m = this._matrix;
                            m[offset] = vector3D.x;
                            m[offset + 1] = vector3D.y;
                            m[offset + 2] = vector3D.z;
                            m[offset + 3] = vector3D.w;
                        };
                        Matrix3D.classInitializer = null;
                        return Matrix3D;
                    }(AS.ASObject);
                    geom.Matrix3D = Matrix3D;
                    var Orientation3D = function (_super) {
                        __extends(Orientation3D, _super);
                        function Orientation3D() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        Orientation3D.classInitializer = null;
                        // List of static symbols to link.
                        Orientation3D.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Orientation3D.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        Orientation3D.EULER_ANGLES = 'eulerAngles';
                        Orientation3D.AXIS_ANGLE = 'axisAngle';
                        Orientation3D.QUATERNION = 'quaternion';
                        return Orientation3D;
                    }(AS.ASObject);
                    geom.Orientation3D = Orientation3D;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var PerspectiveProjection = function (_super) {
                        __extends(PerspectiveProjection, _super);
                        function PerspectiveProjection() {
                            _super.call(this);
                            this._fieldOfView = 55    /* FOV */;
                            this._centerX = 250    /* CenterX */;
                            this._centerY = 250    /* CenterY */;
                        }
                        PerspectiveProjection.FromDisplayObject = function (displayObject) {
                            release || Shumway.Debug.assert(displayObject);
                            var projection = this.axConstruct();
                            projection._displayObject = displayObject;
                            return projection;
                        };
                        Object.defineProperty(PerspectiveProjection.prototype, 'fieldOfView', {
                            get: function () {
                                release || somewhatImplemented('public flash.geom.PerspectiveProjection::get fieldOfView');
                                return this._displayObject ? this._displayObject._perspectiveProjectionFOV : this._fieldOfView;
                            },
                            set: function (fieldOfViewAngleInDegrees) {
                                fieldOfViewAngleInDegrees = +fieldOfViewAngleInDegrees;
                                release || somewhatImplemented('public flash.geom.PerspectiveProjection::set fieldOfView');
                                if (this._displayObject) {
                                    this._displayObject._perspectiveProjectionFOV = fieldOfViewAngleInDegrees;
                                } else {
                                    this._fieldOfView = fieldOfViewAngleInDegrees;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(PerspectiveProjection.prototype, 'projectionCenter', {
                            get: function () {
                                release || somewhatImplemented('public flash.geom.PerspectiveProjection::get projectionCenter');
                                var centerX;
                                var centerY;
                                if (this._displayObject) {
                                    centerX = this._displayObject._perspectiveProjectionCenterX;
                                    centerY = this._displayObject._perspectiveProjectionCenterY;
                                } else {
                                    centerX = this._centerX;
                                    centerY = this._centerY;
                                }
                                return new this.sec.flash.geom.Point(centerX, centerY);
                            },
                            set: function (p) {
                                release || somewhatImplemented('public flash.geom.PerspectiveProjection::set projectionCenter');
                                if (this._displayObject) {
                                    this._displayObject._perspectiveProjectionCenterX = +p.x;
                                    this._displayObject._perspectiveProjectionCenterY = +p.y;
                                } else {
                                    this._centerX = +p.x;
                                    this._centerY = +p.y;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(PerspectiveProjection.prototype, 'focalLength', {
                            get: function () {
                                release || somewhatImplemented('public flash.geom.PerspectiveProjection::get focalLength');
                                var fov;
                                var centerX;
                                if (this._displayObject) {
                                    fov = this._displayObject._perspectiveProjectionFOV;
                                    centerX = this._displayObject._perspectiveProjectionCenterX;
                                } else {
                                    fov = this._fieldOfView;
                                    centerX = this._centerX;
                                }
                                return 1 / Math.tan(fov * Math.PI / 180 / 2) * centerX;
                            },
                            set: function (value) {
                                value = +value;
                                release || somewhatImplemented('public flash.geom.PerspectiveProjection::set focalLength');
                                var centerX = this._displayObject ? this._displayObject._perspectiveProjectionCenterX : this._centerX;
                                var fov = 2 * Math.atan(centerX / value);
                                if (this._displayObject) {
                                    this._displayObject._perspectiveProjectionFOV = fov;
                                } else {
                                    this._fieldOfView = fov;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        PerspectiveProjection.prototype.toMatrix3D = function () {
                            release || somewhatImplemented('public flash.geom.PerspectiveProjection::toMatrix3D');
                            return new this.sec.flash.geom.Matrix3D();
                        };
                        PerspectiveProjection.prototype.clone = function () {
                            var clone = Object.create(this.axClass.tPrototype);
                            clone._fieldOfView = this._fieldOfView;
                            clone._centerX = this._centerX;
                            clone._centerY = this._centerY;
                            clone._displayObject = this._displayObject;
                            return clone;
                        };
                        PerspectiveProjection.classInitializer = null;
                        return PerspectiveProjection;
                    }(AS.ASObject);
                    geom.PerspectiveProjection = PerspectiveProjection;
                    var Point = function (_super) {
                        __extends(Point, _super);
                        function Point(x, y) {
                            if (x === void 0) {
                                x = 0;
                            }
                            if (y === void 0) {
                                y = 0;
                            }
                            _super.call(this);
                            this.x = +x;
                            this.y = +y;
                        }
                        Object.defineProperty(Point.prototype, 'native_x', {
                            get: function () {
                                return this.x;
                            },
                            set: function (x) {
                                this.x = x;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Point.prototype, 'native_y', {
                            get: function () {
                                return this.y;
                            },
                            set: function (y) {
                                this.y = y;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Point.prototype.Point = function (x, y) {
                            if (x === void 0) {
                                x = 0;
                            }
                            if (y === void 0) {
                                y = 0;
                            }
                            this.x = x;
                            this.y = y;
                        };
                        Object.defineProperty(Point.prototype, 'length', {
                            get: function () {
                                return Math.sqrt(this.x * this.x + this.y * this.y);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Point.interpolate = function (p1, p2, f) {
                            var f1 = 1 - f;
                            return new this.sec.flash.geom.Point(p1.x * f + p2.x * f1, p1.y * f + p2.y * f1);
                        };
                        Point.distance = function (p1, p2) {
                            var dx = p2.x - p1.x;
                            var dy = p2.y - p1.y;
                            return dx === 0 ? Math.abs(dy) : dy === 0 ? Math.abs(dx) : Math.sqrt(dx * dx + dy * dy);
                        };
                        Point.polar = function (length, angle) {
                            length = +length;
                            angle = +angle;
                            return new this.sec.flash.geom.Point(length * Math.cos(angle), length * Math.sin(angle));
                        };
                        Point.prototype.clone = function () {
                            return new this.sec.flash.geom.Point(this.x, this.y);
                        };
                        Point.prototype.offset = function (dx, dy) {
                            this.x += +dx;
                            this.y += +dy;
                        };
                        Point.prototype.equals = function (toCompare) {
                            return this.x === toCompare.x && this.y === toCompare.y;
                        };
                        Point.prototype.subtract = function (v) {
                            return new this.sec.flash.geom.Point(this.x - v.x, this.y - v.y);
                        };
                        Point.prototype.add = function (v) {
                            return new this.sec.flash.geom.Point(this.x + v.x, this.y + v.y);
                        };
                        Point.prototype.normalize = function (thickness) {
                            if (this.x !== 0 || this.y !== 0) {
                                var relativeThickness = +thickness / this.length;
                                this.x *= relativeThickness;
                                this.y *= relativeThickness;
                            }
                        };
                        Point.prototype.copyFrom = function (sourcePoint) {
                            this.x = sourcePoint.x;
                            this.y = sourcePoint.y;
                        };
                        Point.prototype.setTo = function (x, y) {
                            this.x = +x;
                            this.y = +y;
                        };
                        Point.prototype.toTwips = function () {
                            this.x = this.x * 20 | 0;
                            this.y = this.y * 20 | 0;
                            return this;
                        };
                        Point.prototype.toPixels = function () {
                            this.x /= 20;
                            this.y /= 20;
                            return this;
                        };
                        Point.prototype.round = function () {
                            this.x = Math.round(this.x);
                            this.y = Math.round(this.y);
                            return this;
                        };
                        Point.prototype.toString = function () {
                            return '(x=' + this.x + ', y=' + this.y + ')';
                        };
                        // Called whenever the class is initialized.
                        Point.classInitializer = null;
                        // List of static symbols to link.
                        Point.classSymbols = null;
                        // ["interpolate", "distance", "polar"];
                        // List of instance symbols to link.
                        Point.instanceSymbols = null;
                        // ["x", "y", "length", "clone", "offset", "equals", "subtract", "add", "normalize", "copyFrom", "setTo", "toString"];
                        return Point;
                    }(AS.ASObject);
                    geom.Point = Point;
                    var Rectangle = function (_super) {
                        __extends(Rectangle, _super);
                        function Rectangle(x, y, width, height) {
                            if (x === void 0) {
                                x = 0;
                            }
                            if (y === void 0) {
                                y = 0;
                            }
                            if (width === void 0) {
                                width = 0;
                            }
                            if (height === void 0) {
                                height = 0;
                            }
                            _super.call(this);
                            x = +x;
                            y = +y;
                            width = +width;
                            height = +height;
                            this.x = x;
                            this.y = y;
                            this.width = width;
                            this.height = height;
                        }
                        Rectangle.FromBounds = function (bounds) {
                            var xMin = bounds.xMin;
                            var yMin = bounds.yMin;
                            return new this.sec.flash.geom.Rectangle(xMin / 20, yMin / 20, (bounds.xMax - xMin) / 20, (bounds.yMax - yMin) / 20);
                        };
                        Object.defineProperty(Rectangle.prototype, 'native_x', {
                            get: function () {
                                return this.x;
                            },
                            set: function (x) {
                                this.x = x;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'native_y', {
                            get: function () {
                                return this.y;
                            },
                            set: function (y) {
                                this.y = y;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'native_width', {
                            get: function () {
                                return this.width;
                            },
                            set: function (width) {
                                this.width = +width;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'native_height', {
                            get: function () {
                                return this.height;
                            },
                            set: function (height) {
                                this.height = +height;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'left', {
                            get: function () {
                                return this.x;
                            },
                            set: function (value) {
                                value = +value;
                                this.width += this.x - value;
                                this.x = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'right', {
                            get: function () {
                                return this.x + this.width;
                            },
                            set: function (value) {
                                value = +value;
                                this.width = value - this.x;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'top', {
                            get: function () {
                                return this.y;
                            },
                            set: function (value) {
                                value = +value;
                                this.height += this.y - value;
                                this.y = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'bottom', {
                            get: function () {
                                return this.y + this.height;
                            },
                            set: function (value) {
                                value = +value;
                                this.height = value - this.y;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'topLeft', {
                            get: function () {
                                return new this.sec.flash.geom.Point(this.left, this.top);
                            },
                            set: function (value) {
                                this.top = value.y;
                                this.left = value.x;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'bottomRight', {
                            get: function () {
                                return new this.sec.flash.geom.Point(this.right, this.bottom);
                            },
                            set: function (value) {
                                this.bottom = value.y;
                                this.right = value.x;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'size', {
                            get: function () {
                                return new this.sec.flash.geom.Point(this.width, this.height);
                            },
                            set: function (value) {
                                this.width = value.x;
                                this.height = value.y;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Rectangle.prototype, 'area', {
                            get: function () {
                                return this.width * this.height;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Rectangle.prototype.clone = function () {
                            return new this.sec.flash.geom.Rectangle(this.x, this.y, this.width, this.height);
                        };
                        Rectangle.prototype.isEmpty = function () {
                            return this.width <= 0 || this.height <= 0;
                        };
                        Rectangle.prototype.setEmpty = function () {
                            this.x = 0;
                            this.y = 0;
                            this.width = 0;
                            this.height = 0;
                            return this;
                        };
                        Rectangle.prototype.inflate = function (dx, dy) {
                            dx = +dx;
                            dy = +dy;
                            this.x -= dx;
                            this.y -= dy;
                            this.width += dx * 2;
                            this.height += dy * 2;
                        };
                        Rectangle.prototype.inflatePoint = function (point) {
                            this.inflate(point.x, point.y);
                        };
                        Rectangle.prototype.offset = function (dx, dy) {
                            this.x += +dx;
                            this.y += +dy;
                        };
                        Rectangle.prototype.offsetPoint = function (point) {
                            this.offset(point.x, point.y);
                        };
                        Rectangle.prototype.contains = function (x, y) {
                            x = +x;
                            y = +y;
                            return x >= this.x && x < this.right && y >= this.y && y < this.bottom;
                        };
                        Rectangle.prototype.containsPoint = function (point) {
                            return this.contains(point.x, point.y);
                        };
                        Rectangle.prototype.containsRect = function (rect) {
                            var r1 = rect.x + rect.width;
                            var b1 = rect.y + rect.height;
                            var r2 = this.x + this.width;
                            var b2 = this.y + this.height;
                            return rect.x >= this.x && rect.x < r2 && rect.y >= this.y && rect.y < b2 && r1 > this.x && r1 <= r2 && b1 > this.y && b1 <= b2;
                        };
                        Rectangle.prototype.intersection = function (toIntersect) {
                            return this.clone().intersectInPlace(toIntersect);
                        };
                        Rectangle.prototype.intersects = function (toIntersect) {
                            return Math.max(this.x, toIntersect.x) <= Math.min(this.right, toIntersect.right) && Math.max(this.y, toIntersect.y) <= Math.min(this.bottom, toIntersect.bottom);
                        };
                        Rectangle.prototype.intersectInPlace = function (clipRect) {
                            var x0 = this.x;
                            var y0 = this.y;
                            var x1 = clipRect.x;
                            var y1 = clipRect.y;
                            var l = Math.max(x0, x1);
                            var r = Math.min(x0 + this.width, x1 + clipRect.width);
                            if (l <= r) {
                                var t = Math.max(y0, y1);
                                var b = Math.min(y0 + this.height, y1 + clipRect.height);
                                if (t <= b) {
                                    this.setTo(l, t, r - l, b - t);
                                    return this;
                                }
                            }
                            this.setEmpty();
                            return this;
                        };
                        Rectangle.prototype.intersectInPlaceInt32 = function (clipRect) {
                            var x0 = this.x | 0;
                            var y0 = this.y | 0;
                            var w0 = this.width | 0;
                            var h0 = this.height | 0;
                            var x1 = clipRect.x | 0;
                            var w1 = clipRect.width | 0;
                            var l = Math.max(x0, x1) | 0;
                            var r = Math.min(x0 + w0 | 0, x1 + w1 | 0) | 0;
                            if (l <= r) {
                                var y1 = clipRect.y | 0;
                                var h1 = clipRect.height | 0;
                                var t = Math.max(y0, y1) | 0;
                                var b = Math.min(y0 + h0 | 0, y1 + h1 | 0);
                                if (t <= b) {
                                    this.setTo(l, t, r - l, b - t);
                                    return this;
                                }
                            }
                            this.setEmpty();
                            return this;
                        };
                        Rectangle.prototype.union = function (toUnion) {
                            return this.clone().unionInPlace(toUnion);
                        };
                        Rectangle.prototype.unionInPlace = function (toUnion) {
                            if (toUnion.isEmpty()) {
                                return this;
                            }
                            if (this.isEmpty()) {
                                this.copyFrom(toUnion);
                                return this;
                            }
                            var l = Math.min(this.x, toUnion.x);
                            var t = Math.min(this.y, toUnion.y);
                            this.setTo(l, t, Math.max(this.right, toUnion.right) - l, Math.max(this.bottom, toUnion.bottom) - t);
                            return this;
                        };
                        Rectangle.prototype.equals = function (toCompare) {
                            return this === toCompare || this.x === toCompare.x && this.y === toCompare.y && this.width === toCompare.width && this.height === toCompare.height;
                        };
                        Rectangle.prototype.copyFrom = function (sourceRect) {
                            this.x = sourceRect.x;
                            this.y = sourceRect.y;
                            this.width = sourceRect.width;
                            this.height = sourceRect.height;
                        };
                        Rectangle.prototype.setTo = function (x, y, width, height) {
                            this.x = +x;
                            this.y = +y;
                            this.width = +width;
                            this.height = +height;
                        };
                        Rectangle.prototype.toTwips = function () {
                            this.x = this.x * 20 | 0;
                            this.y = this.y * 20 | 0;
                            this.width = this.width * 20 | 0;
                            this.height = this.height * 20 | 0;
                            return this;
                        };
                        Rectangle.prototype.getBaseWidth = function (angle) {
                            var u = Math.abs(Math.cos(angle));
                            var v = Math.abs(Math.sin(angle));
                            return u * this.width + v * this.height;
                        };
                        Rectangle.prototype.getBaseHeight = function (angle) {
                            var u = Math.abs(Math.cos(angle));
                            var v = Math.abs(Math.sin(angle));
                            return v * this.width + u * this.height;
                        };
                        Rectangle.prototype.toPixels = function () {
                            this.x /= 20;
                            this.y /= 20;
                            this.width /= 20;
                            this.height /= 20;
                            return this;
                        };
                        Rectangle.prototype.snapInPlace = function () {
                            var x1 = Math.ceil(this.x + this.width);
                            var y1 = Math.ceil(this.y + this.height);
                            this.x = Math.floor(this.x);
                            this.y = Math.floor(this.y);
                            this.width = x1 - this.x;
                            this.height = y1 - this.y;
                            return this;
                        };
                        Rectangle.prototype.roundInPlace = function () {
                            var x1 = Math.round(this.x + this.width);
                            var y1 = Math.round(this.y + this.height);
                            this.x = Math.round(this.x);
                            this.y = Math.round(this.y);
                            this.width = x1 - this.x;
                            this.height = y1 - this.y;
                            return this;
                        };
                        Rectangle.prototype.toString = function () {
                            return '(x=' + this.x + ', y=' + this.y + ', w=' + this.width + ', h=' + this.height + ')';
                        };
                        Rectangle.prototype.hashCode = function () {
                            var hash = 0;
                            hash += this.x * 20 | 0;
                            hash *= 37;
                            hash += this.y * 20 | 0;
                            hash *= 37;
                            hash += this.width * 20 | 0;
                            hash *= 37;
                            hash += this.height * 20 | 0;
                            return hash;
                        };
                        Rectangle.prototype.writeExternal = function (output) {
                            output.writeFloat(this.x);
                            output.writeFloat(this.y);
                            output.writeFloat(this.width);
                            output.writeFloat(this.height);
                        };
                        Rectangle.prototype.readExternal = function (input) {
                            this.x = input.readFloat();
                            this.y = input.readFloat();
                            this.width = input.readFloat();
                            this.height = input.readFloat();
                        };
                        // Called whenever the class is initialized.
                        Rectangle.classInitializer = null;
                        // List of static symbols to link.
                        Rectangle.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Rectangle.instanceSymbols = null;
                        return Rectangle;
                    }(AS.ASObject);
                    geom.Rectangle = Rectangle;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var checkNullParameter = Shumway.AVMX.checkNullParameter;
                    var Transform = function (_super) {
                        __extends(Transform, _super);
                        function Transform(displayObject) {
                            _super.call(this);
                            if (!displayObject) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.NullPointerError, 'displayObject');
                            }
                            this._displayObject = displayObject;
                        }
                        Object.defineProperty(Transform.prototype, 'matrix', {
                            get: function () {
                                if (this._displayObject._matrix3D) {
                                    return null;
                                }
                                return this._displayObject._getMatrix().clone().toPixelsInPlace();
                            },
                            set: function (value) {
                                if (this._displayObject._matrix3D) {
                                    this._displayObject._matrix3D.resetTargetDisplayObject();
                                    this._displayObject._matrix3D = null;
                                }
                                this._displayObject._setMatrix(value, true);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Transform.prototype, 'colorTransform', {
                            get: function () {
                                return this._displayObject._colorTransform.clone();
                            },
                            set: function (value) {
                                this._displayObject._setColorTransform(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Transform.prototype, 'concatenatedMatrix', {
                            get: function () {
                                var matrix = this._displayObject._getConcatenatedMatrix().clone().toPixelsInPlace();
                                // For some reason, all dimensions are scale 5x for off-stage objects.
                                if (!this._displayObject._stage) {
                                    matrix.scale(5, 5);
                                }
                                return matrix;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Transform.prototype, 'concatenatedColorTransform', {
                            get: function () {
                                return this._displayObject._getConcatenatedColorTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Transform.prototype, 'pixelBounds', {
                            get: function () {
                                // Only somewhat implemented because this is largely untested.
                                release || somewhatImplemented('public flash.geom.Transform::get pixelBounds');
                                var stage = this._displayObject.stage;
                                var targetCoordinateSpace = stage || this._displayObject;
                                var rect = this._displayObject.getRect(targetCoordinateSpace);
                                // For some reason, all dimensions are scale 5x for off-stage objects.
                                if (!stage) {
                                    rect.width *= 5;
                                    rect.height *= 5;
                                }
                                return rect;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Transform.prototype, 'matrix3D', {
                            get: function () {
                                release || somewhatImplemented('public flash.geom.Transform::get matrix3D');
                                // Note: matrix3D returns the original object, *not* a clone.
                                return this._displayObject._matrix3D;
                            },
                            set: function (m) {
                                if (!this.sec.flash.geom.Matrix3D.axIsType(m)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, m, 'flash.geom.Matrix3D');
                                }
                                release || somewhatImplemented('public flash.geom.Transform::set matrix3D');
                                // Setting the displayObject on the matrix can throw an error, so do that first.
                                m.setTargetDisplayObject(this._displayObject);
                                // Note: matrix3D stores the original object, *not* a clone.
                                this._displayObject._matrix3D = m;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Transform.prototype.getRelativeMatrix3D = function (relativeTo) {
                            checkNullParameter(relativeTo, 'relativeTo', this.sec);
                            release || somewhatImplemented('public flash.geom.Transform::getRelativeMatrix3D');
                            var matrix3D = this._displayObject._matrix3D;
                            // TODO: actually calculate the relative matrix.
                            return matrix3D ? matrix3D.clone() : null;
                        };
                        Object.defineProperty(Transform.prototype, 'perspectiveProjection', {
                            get: function () {
                                release || somewhatImplemented('public flash.geom.Transform::get perspectiveProjection');
                                if (!this._displayObject._hasFlags(262144    /* HasPerspectiveProjection */)) {
                                    return null;
                                }
                                var PerspectiveProjectionClass = this.sec.flash.geom.PerspectiveProjection.axClass;
                                return PerspectiveProjectionClass.FromDisplayObject(this._displayObject);
                            },
                            set: function (projection) {
                                release || somewhatImplemented('public flash.geom.Transform::set perspectiveProjection');
                                if (!projection) {
                                    this._displayObject._removeFlags(262144    /* HasPerspectiveProjection */);
                                    return;
                                }
                                this._displayObject._setFlags(262144    /* HasPerspectiveProjection */);
                                this._displayObject._perspectiveProjectionCenterX = +projection._centerX;
                                this._displayObject._perspectiveProjectionCenterY = +projection._centerY;
                                this._displayObject._perspectiveProjectionFOV = +projection._fieldOfView;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Transform.classInitializer = null;
                        return Transform;
                    }(AS.ASObject);
                    geom.Transform = Transform;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var Utils3D = function (_super) {
                        __extends(Utils3D, _super);
                        function Utils3D() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        Utils3D.projectVector = function (m, v) {
                            m = m;
                            v = v;
                            release || notImplemented('public flash.geom.Utils3D::static projectVector');
                            return;
                        };
                        Utils3D.projectVectors = function (m, verts, projectedVerts, uvts) {
                            m = m;
                            verts = verts;
                            projectedVerts = projectedVerts;
                            uvts = uvts;
                            release || notImplemented('public flash.geom.Utils3D::static projectVectors');
                            return;
                        };
                        Utils3D.pointTowards = function (percent, mat, pos, at, up) {
                            if (at === void 0) {
                                at = null;
                            }
                            if (up === void 0) {
                                up = null;
                            }
                            percent = +percent;
                            mat = mat;
                            pos = pos;
                            at = at;
                            up = up;
                            release || notImplemented('public flash.geom.Utils3D::static pointTowards');
                            return;
                        };
                        // Called whenever the class is initialized.
                        Utils3D.classInitializer = null;
                        // List of static symbols to link.
                        Utils3D.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Utils3D.instanceSymbols = null;
                        // [];
                        return Utils3D;
                    }(AS.ASObject);
                    geom.Utils3D = Utils3D;
                    var Vector3D = function (_super) {
                        __extends(Vector3D, _super);
                        function Vector3D(x, y, z, w) {
                            if (x === void 0) {
                                x = 0;
                            }
                            if (y === void 0) {
                                y = 0;
                            }
                            if (z === void 0) {
                                z = 0;
                            }
                            if (w === void 0) {
                                w = 0;
                            }
                            _super.call(this);
                            this.x = +x;
                            this.y = +y;
                            this.z = +z;
                            this.w = +w;
                        }
                        Vector3D.classInitializer = function () {
                            this.X_AXIS = Object.freeze(this.Create(1, 0, 0, 0));
                            this.Y_AXIS = Object.freeze(this.Create(1, 0, 0, 0));
                            this.Z_AXIS = Object.freeze(this.Create(1, 0, 0, 0));
                        };
                        Vector3D.Create = function (x, y, z, w) {
                            var v = Object.create(this.tPrototype);
                            v.x = x;
                            v.y = y;
                            v.z = z;
                            v.w = w;
                            return v;
                        };
                        Object.defineProperty(Vector3D.prototype, 'native_x', {
                            get: function () {
                                return this.x;
                            },
                            set: function (x) {
                                this.x = x;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Vector3D.prototype, 'native_y', {
                            get: function () {
                                return this.y;
                            },
                            set: function (y) {
                                this.y = y;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Vector3D.prototype, 'native_z', {
                            get: function () {
                                return this.z;
                            },
                            set: function (z) {
                                this.z = z;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Vector3D.prototype, 'native_w', {
                            get: function () {
                                return this.w;
                            },
                            set: function (w) {
                                this.w = w;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Vector3D.prototype, 'length', {
                            get: function () {
                                return Math.sqrt(this.lengthSquared);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Vector3D.prototype, 'lengthSquared', {
                            get: function () {
                                return this.x * this.x + this.y * this.y + this.z * this.z;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Vector3D.angleBetween = function (a, b) {
                            // http://chemistry.about.com/od/workedchemistryproblems/a/scalar-product-vectors-problem.htm
                            return Math.acos(a.dotProduct(b) / (a.length * b.length));
                        };
                        Vector3D.distance = function (pt1, pt2) {
                            // http://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions
                            return pt1.subtract(pt2).length;
                        };
                        Vector3D.prototype.dotProduct = function (a) {
                            return this.x * a.x + this.y * a.y + this.z * a.z;
                        };
                        Vector3D.prototype.crossProduct = function (a) {
                            return new this.sec.flash.geom.Vector3D(this.y * a.z - this.z * a.y, this.z * a.x - this.x * a.z, this.x * a.y - this.y * a.x, 1);
                        };
                        Vector3D.prototype.normalize = function () {
                            var length = this.length;
                            if (length !== 0) {
                                this.x /= length;
                                this.y /= length;
                                this.z /= length;
                            } else {
                                this.x = this.y = this.z = 0;
                            }
                            return length;
                        };
                        Vector3D.prototype.scaleBy = function (s) {
                            s = +s;
                            this.x *= s;
                            this.y *= s;
                            this.z *= s;
                        };
                        Vector3D.prototype.incrementBy = function (a) {
                            this.x += a.x;
                            this.y += a.y;
                            this.z += a.z;
                        };
                        Vector3D.prototype.decrementBy = function (a) {
                            this.x -= a.x;
                            this.y -= a.y;
                            this.z -= a.z;
                        };
                        Vector3D.prototype.add = function (a) {
                            return new this.sec.flash.geom.Vector3D(this.x + a.x, this.y + a.y, this.z + a.z);
                        };
                        Vector3D.prototype.subtract = function (a) {
                            return new this.sec.flash.geom.Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
                        };
                        Vector3D.prototype.negate = function () {
                            this.x = -this.x;
                            this.y = -this.y;
                            this.z = -this.z;
                        };
                        Vector3D.prototype.equals = function (toCompare, allFour) {
                            return this.x === toCompare.x && this.y === toCompare.y && this.z === toCompare.z && (!allFour || this.w === toCompare.w);
                        };
                        Vector3D.prototype.nearEquals = function (toCompare, tolerance, allFour) {
                            return Math.abs(this.x - toCompare.x) < tolerance && Math.abs(this.y - toCompare.y) < tolerance && Math.abs(this.z - toCompare.z) < tolerance && (!allFour || Math.abs(this.w - toCompare.w) < tolerance);
                        };
                        Vector3D.prototype.project = function () {
                            this.x /= this.w;
                            this.y /= this.w;
                            this.z /= this.w;
                        };
                        Vector3D.prototype.copyFrom = function (sourceVector3D) {
                            this.x = sourceVector3D.x;
                            this.y = sourceVector3D.y;
                            this.z = sourceVector3D.z;
                        };
                        Vector3D.prototype.setTo = function (xa, ya, za) {
                            this.x = +xa;
                            this.y = +ya;
                            this.z = +za;
                        };
                        Vector3D.prototype.clone = function () {
                            return new this.sec.flash.geom.Vector3D(this.x, this.y, this.z, this.w);
                        };
                        Vector3D.prototype.toString = function () {
                            return 'Vector3D(' + this.x + ', ' + this.y + ', ' + this.z + ')';
                        };
                        return Vector3D;
                    }(AS.ASObject);
                    geom.Vector3D = Vector3D;
                }(geom = flash.geom || (flash.geom = {})));
                var accessibility;
                (function (accessibility) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var Accessibility = function (_super) {
                        __extends(Accessibility, _super);
                        function Accessibility() {
                            _super.call(this);
                        }
                        Object.defineProperty(Accessibility, 'active', {
                            get: function () {
                                release || somewhatImplemented('public flash.accessibility.Accessibility::get active');
                                return Accessibility._active;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Accessibility.sendEvent = function (source, childID, eventType, nonHTML) {
                            if (nonHTML === void 0) {
                                nonHTML = false;
                            }
                            source = source;
                            childID = childID >>> 0;
                            eventType = eventType >>> 0;
                            nonHTML = !!nonHTML;
                            release || release || notImplemented('public flash.accessibility.Accessibility::static sendEvent');
                            return;
                        };
                        Accessibility.updateProperties = function () {
                            release || release || notImplemented('public flash.accessibility.Accessibility::static updateProperties');
                            return;
                        };
                        // Called whenever the class is initialized.
                        Accessibility.classInitializer = null;
                        // List of static symbols to link.
                        Accessibility.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Accessibility.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        Accessibility._active = false;
                        return Accessibility;
                    }(AS.ASObject);
                    accessibility.Accessibility = Accessibility;
                    var AccessibilityImplementation = function (_super) {
                        __extends(AccessibilityImplementation, _super);
                        function AccessibilityImplementation() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        AccessibilityImplementation.classInitializer = null;
                        // List of static symbols to link.
                        AccessibilityImplementation.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        AccessibilityImplementation.instanceSymbols = null;
                        // ["stub", "errno", "get_accRole", "get_accName", "get_accValue", "get_accState", "get_accDefaultAction", "accDoDefaultAction", "isLabeledBy", "getChildIDArray", "accLocation", "get_accSelection", "get_accFocus", "accSelect", "get_selectionAnchorIndex", "get_selectionActiveIndex"];
                        return AccessibilityImplementation;
                    }(AS.ASObject);
                    accessibility.AccessibilityImplementation = AccessibilityImplementation;
                    var AccessibilityProperties = function (_super) {
                        __extends(AccessibilityProperties, _super);
                        function AccessibilityProperties() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        AccessibilityProperties.classInitializer = null;
                        // List of static symbols to link.
                        AccessibilityProperties.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        AccessibilityProperties.instanceSymbols = null;
                        // ["name", "description", "shortcut", "silent", "forceSimple", "noAutoLabeling"];
                        return AccessibilityProperties;
                    }(AS.ASObject);
                    accessibility.AccessibilityProperties = AccessibilityProperties;
                }(accessibility = flash.accessibility || (flash.accessibility = {})));
                var events;
                (function (events) {
                    var assert = Shumway.Debug.assert;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var Event = function (_super) {
                        __extends(Event, _super);
                        function Event(type, bubbles, cancelable) {
                            _super.call(this);
                            this._type = axCoerceString(type);
                            this._bubbles = !!bubbles;
                            this._cancelable = !!cancelable;
                            this._target = null;
                            this._currentTarget = null;
                            this._eventPhase = events.EventPhase.AT_TARGET;
                            this._stopPropagation = false;
                            this._stopImmediatePropagation = false;
                            this._isDefaultPrevented = false;
                        }
                        Event.getInstance = function (type, bubbles, cancelable) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            var instance = this._instances[type];
                            if (!instance) {
                                instance = new this.sec.flash.events.Event(type, bubbles, cancelable);
                                this._instances[type] = instance;
                            }
                            instance._bubbles = bubbles;
                            instance._cancelable = cancelable;
                            return instance;
                        };
                        Event.getBroadcastInstance = function (type, bubbles, cancelable) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            var instance = this._instances[type];
                            if (!instance) {
                                instance = new this.sec.flash.events.Event(type, bubbles, cancelable);
                                this._instances[type] = instance;
                                // Some events are documented as broadcast event in the AS3 docs. We can't set |_isBroadcastEvent| flag in the
                                // constructor because if you create custom events with these types they do capture and bubble.
                                release || assert(Event.isBroadcastEventType(type));
                            }
                            instance._isBroadcastEvent = true;
                            instance._bubbles = bubbles;
                            instance._cancelable = cancelable;
                            return instance;
                        };
                        /**
                         * http://stackoverflow.com/questions/16900176/as3enterframe-event-propagation-understanding-issue
                         */
                        Event.isBroadcastEventType = function (type) {
                            switch (type) {
                            case Event.ENTER_FRAME:
                            case Event.EXIT_FRAME:
                            case Event.FRAME_CONSTRUCTED:
                            case Event.RENDER:
                            case Event.ACTIVATE:
                            case Event.DEACTIVATE:
                                return true;
                            }
                            return false;
                        };
                        Object.defineProperty(Event.prototype, 'type', {
                            get: function () {
                                return this._type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Event.prototype, 'bubbles', {
                            get: function () {
                                return this._bubbles;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Event.prototype, 'cancelable', {
                            get: function () {
                                return this._cancelable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Event.prototype, 'target', {
                            get: function () {
                                return this._target;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Event.prototype, 'currentTarget', {
                            get: function () {
                                return this._currentTarget;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Event.prototype, 'eventPhase', {
                            get: function () {
                                return this._eventPhase;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Event.prototype.stopPropagation = function () {
                            this._stopPropagation = true;
                        };
                        Event.prototype.stopImmediatePropagation = function () {
                            this._stopImmediatePropagation = this._stopPropagation = true;
                        };
                        Event.prototype.preventDefault = function () {
                            if (this._cancelable) {
                                this._isDefaultPrevented = true;
                            }
                        };
                        Event.prototype.isDefaultPrevented = function () {
                            return this._isDefaultPrevented;
                        };
                        Event.prototype.isBroadcastEvent = function () {
                            return !!this._isBroadcastEvent;
                        };
                        Event.prototype.clone = function () {
                            return new this.sec.flash.events.Event(this._type, this._bubbles, this._cancelable);
                        };
                        Event.prototype.toString = function () {
                            return this.formatToString('Event', 'type', 'bubbles', 'cancelable', 'eventPhase');
                        };
                        Event.prototype.formatToString = function (className) {
                            var args = [];
                            for (var _i = 1; _i < arguments.length; _i++) {
                                args[_i - 1] = arguments[_i];
                            }
                            var str = '[' + className;
                            for (var i = 0; i < args.length; i++) {
                                var field = args[i];
                                var value = this.axGetPublicProperty(field);
                                if (typeof value === 'string') {
                                    value = '"' + value + '"';
                                }
                                str += ' ' + field + '=' + value;
                            }
                            return str + ']';
                        };
                        Event.classInitializer = function () {
                            var self = this;
                            self._instances = Shumway.ObjectUtilities.createMap();
                        };
                        // JS -> AS Bindings
                        Event.ACTIVATE = 'activate';
                        Event.ADDED = 'added';
                        Event.ADDED_TO_STAGE = 'addedToStage';
                        Event.CANCEL = 'cancel';
                        Event.CHANGE = 'change';
                        Event.CLEAR = 'clear';
                        Event.CLOSE = 'close';
                        Event.COMPLETE = 'complete';
                        Event.CONNECT = 'connect';
                        Event.COPY = 'copy';
                        Event.CUT = 'cut';
                        Event.DEACTIVATE = 'deactivate';
                        Event.ENTER_FRAME = 'enterFrame';
                        Event.FRAME_CONSTRUCTED = 'frameConstructed';
                        Event.EXIT_FRAME = 'exitFrame';
                        Event.FRAME_LABEL = 'frameLabel';
                        Event.ID3 = 'id3';
                        Event.INIT = 'init';
                        Event.MOUSE_LEAVE = 'mouseLeave';
                        Event.OPEN = 'open';
                        Event.PASTE = 'paste';
                        Event.REMOVED = 'removed';
                        Event.REMOVED_FROM_STAGE = 'removedFromStage';
                        Event.RENDER = 'render';
                        Event.RESIZE = 'resize';
                        Event.SCROLL = 'scroll';
                        Event.TEXT_INTERACTION_MODE_CHANGE = 'textInteractionModeChange';
                        Event.SELECT = 'select';
                        Event.SELECT_ALL = 'selectAll';
                        Event.SOUND_COMPLETE = 'soundComplete';
                        Event.TAB_CHILDREN_CHANGE = 'tabChildrenChange';
                        Event.TAB_ENABLED_CHANGE = 'tabEnabledChange';
                        Event.TAB_INDEX_CHANGE = 'tabIndexChange';
                        Event.UNLOAD = 'unload';
                        Event.FULLSCREEN = 'fullScreen';
                        Event.CONTEXT3D_CREATE = 'context3DCreate';
                        Event.TEXTURE_READY = 'textureReady';
                        Event.VIDEO_FRAME = 'videoFrame';
                        Event.SUSPEND = 'suspend';
                        Event.AVM1_INIT = 'initialize';
                        Event.AVM1_CONSTRUCT = 'construct';
                        Event.AVM1_LOAD = 'load';
                        return Event;
                    }(AS.ASObject);
                    events.Event = Event;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var isNullOrUndefined = Shumway.isNullOrUndefined;
                    var assert = Shumway.Debug.assert;
                    var EventListenerEntry = function () {
                        function EventListenerEntry(listener, useCapture, priority) {
                            this.listener = listener;
                            this.useCapture = useCapture;
                            this.priority = priority;
                        }
                        return EventListenerEntry;
                    }();
                    /**
                     * Implements Copy-On-Write for event listener lists. Event handlers can add and/or remove
                     * event handlers while the events are processed. The easiest way to implement this is to
                     * clone the event listener list before executing the event listeners. This however can be
                     * wasteful, since most of the time, event handlers don't mutate the event list. Here we
                     * implement a simple copy-on-write strategy that clones the entry list if it's been
                     * snapshotted and it's about to be mutated.
                     */
                    var EventListenerList = function () {
                        function EventListenerList() {
                            /**
                             * The number of times the current entry list has been aliased (or snapshotted).
                             */
                            this._aliasCount = 0;
                            this._entries = [];
                        }
                        EventListenerList.prototype.isEmpty = function () {
                            return this._entries.length === 0;
                        };
                        EventListenerList.prototype.insert = function (listener, useCapture, priority) {
                            var entries = this._entries;
                            var index = entries.length;
                            for (var i = index - 1; i >= 0; i--) {
                                var entry = entries[i];
                                if (entry.listener === listener) {
                                    return;
                                }
                                if (priority > entry.priority) {
                                    index = i;
                                } else {
                                    break;
                                }
                            }
                            entries = this.ensureNonAliasedEntries();
                            entries.splice(index, 0, new EventListenerEntry(listener, useCapture, priority));
                        };
                        /**
                         * Make sure we get a fresh list if it's been aliased.
                         */
                        EventListenerList.prototype.ensureNonAliasedEntries = function () {
                            var entries = this._entries;
                            if (this._aliasCount > 0) {
                                entries = this._entries = entries.slice();
                                this._aliasCount = 0;
                            }
                            return entries;
                        };
                        EventListenerList.prototype.remove = function (listener) {
                            var entries = this._entries;
                            for (var i = 0; i < entries.length; i++) {
                                var item = entries[i];
                                if (item.listener === listener) {
                                    this.ensureNonAliasedEntries().splice(i, 1);
                                    return;
                                }
                            }
                        };
                        /**
                         * Get a snapshot of the current entry list.
                         */
                        EventListenerList.prototype.snapshot = function () {
                            this._aliasCount++;
                            return this._entries;
                        };
                        /**
                         * Release the snapshot, hopefully no other mutations occured so we can reuse the entry list.
                         */
                        EventListenerList.prototype.releaseSnapshot = function (snapshot) {
                            // We ignore any non current snapshots.
                            if (this._entries !== snapshot) {
                                return;
                            }
                            if (this._aliasCount > 0) {
                                this._aliasCount--;
                            }
                        };
                        return EventListenerList;
                    }();
                    /**
                     * Broadcast Events
                     *
                     * The logic here is pretty much copied from:
                     * http://www.senocular.com/flash/tutorials/orderofoperations/
                     */
                    var BroadcastEventDispatchQueue = function () {
                        function BroadcastEventDispatchQueue() {
                            this.reset();
                        }
                        BroadcastEventDispatchQueue.prototype.reset = function () {
                            this._queues = Object.create(null);
                        };
                        BroadcastEventDispatchQueue.prototype.add = function (type, target) {
                            release || assert(events.Event.isBroadcastEventType(type), 'Can only register broadcast events.');
                            var queue = this._queues[type] || (this._queues[type] = []);
                            if (queue.indexOf(target) >= 0) {
                                return;
                            }
                            queue.push(target);
                        };
                        BroadcastEventDispatchQueue.prototype.remove = function (type, target) {
                            release || assert(events.Event.isBroadcastEventType(type), 'Can only unregister broadcast events.');
                            var queue = this._queues[type];
                            release || assert(queue, 'There should already be a queue for this.');
                            var index = queue.indexOf(target);
                            release || assert(index >= 0, 'Target should be somewhere in this queue.');
                            queue[index] = null;
                            release || assert(queue.indexOf(target) < 0, 'Target shouldn\'t be in this queue anymore.');
                        };
                        BroadcastEventDispatchQueue.prototype.dispatchEvent = function (event) {
                            release || assert(event.isBroadcastEvent(), 'Cannot dispatch non-broadcast events.');
                            var queue = this._queues[event._type];
                            if (!queue) {
                                return;
                            }
                            if (!release && AS.traceEventsOption.value) {
                                console.log('Broadcast event of type ' + event._type + ' to ' + queue.length + ' listeners');
                            }
                            var nullCount = 0;
                            for (var i = 0; i < queue.length; i++) {
                                var target = queue[i];
                                if (target === null) {
                                    nullCount++;
                                } else {
                                    target.dispatchEvent(event);
                                }
                            }
                            // Compact the queue if there are too many holes in it.
                            if (nullCount > 16 && nullCount > queue.length >> 1) {
                                var compactedQueue = [];
                                for (var i = 0; i < queue.length; i++) {
                                    if (queue[i]) {
                                        compactedQueue.push(queue[i]);
                                    }
                                }
                                this._queues[event.type] = compactedQueue;
                            }
                        };
                        BroadcastEventDispatchQueue.prototype.getQueueLength = function (type) {
                            return this._queues[type] ? this._queues[type].length : 0;
                        };
                        return BroadcastEventDispatchQueue;
                    }();
                    events.BroadcastEventDispatchQueue = BroadcastEventDispatchQueue;
                    /**
                     * The EventDispatcher class is the base class for all classes that dispatch events.
                     * The EventDispatcher class implements the IEventDispatcher interface and is the base class for
                     * the DisplayObject class. The EventDispatcher class allows any object on the display list to be
                     * an event target and as such, to use the methods of the IEventDispatcher interface.
                     */
                    var EventDispatcher = function (_super) {
                        __extends(EventDispatcher, _super);
                        function EventDispatcher(target) {
                            if (target === void 0) {
                                target = null;
                            }
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields(target || this);
                            }
                        }
                        EventDispatcher.classInitializer = function () {
                            this.broadcastEventDispatchQueue = new BroadcastEventDispatchQueue();
                        };
                        EventDispatcher.prototype._initializeFields = function (target) {
                            release || assert(!this._fieldsInitialized);
                            this._fieldsInitialized = true;
                            this._target = target;
                            this._captureListeners = null;
                            this._targetOrBubblingListeners = null;
                        };
                        EventDispatcher.prototype.toString = function () {
                            // EventDispatcher's toString doesn't actually do anything. It just introduces a trait that
                            // forwards to Object.prototype's toString method.
                            return this.sec.AXObject.dPrototype.$BgtoString.axCall(this);
                        };
                        /**
                         * Don't lazily construct listener lists if all we're doing is looking for listener types that
                         * don't exist yet.
                         */
                        EventDispatcher.prototype._getListenersForType = function (useCapture, type) {
                            var listeners = useCapture ? this._captureListeners : this._targetOrBubblingListeners;
                            if (listeners) {
                                return listeners[type];
                            }
                            return null;
                        };
                        /**
                         * Lazily construct listeners lists to avoid object allocation.
                         */
                        EventDispatcher.prototype._getListeners = function (useCapture) {
                            if (useCapture) {
                                return this._captureListeners || (this._captureListeners = Object.create(null));
                            }
                            return this._targetOrBubblingListeners || (this._targetOrBubblingListeners = Object.create(null));
                        };
                        EventDispatcher.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
                            if (useCapture === void 0) {
                                useCapture = false;
                            }
                            if (priority === void 0) {
                                priority = 0;
                            }
                            if (useWeakReference === void 0) {
                                useWeakReference = false;
                            }
                            // The error message always says "2", even though up to five arguments are valid.
                            if (arguments.length < 2 || arguments.length > 5) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'flash.events::EventDispatcher/addEventListener()', 2, arguments.length);
                            }
                            // The type of `listener` is checked before that of `type`.
                            if (!AVMX.axIsCallable(listener)) {
                                // TODO: The Player unevals the `listener`. To some extend, we could, too.
                                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, listener, 'Function');
                            }
                            if (isNullOrUndefined(type)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'type');
                            }
                            type = axCoerceString(type);
                            useCapture = !!useCapture;
                            priority |= 0;
                            useWeakReference = !!useWeakReference;
                            var listeners = this._getListeners(useCapture);
                            var list = listeners[type] || (listeners[type] = new EventListenerList());
                            list.insert(listener, useCapture, priority);
                            // Notify the broadcast event queue. If |useCapture| is set then the Flash player
                            // doesn't seem to register this target.
                            if (!useCapture && events.Event.isBroadcastEventType(type)) {
                                this.sec.flash.events.EventDispatcher.axClass.broadcastEventDispatchQueue.add(type, this);
                            }
                        };
                        EventDispatcher.prototype.removeEventListener = function (type, listener, useCapture) {
                            if (useCapture === void 0) {
                                useCapture = false;
                            }
                            // The error message always says "2", even though 3 arguments are valid.
                            if (arguments.length < 2 || arguments.length > 3) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'flash.events::EventDispatcher/removeEventListener()', 2, arguments.length);
                            }
                            // The type of `listener` is checked before that of `type`.
                            if (!AVMX.axIsCallable(listener)) {
                                // TODO: The Player unevals the `listener`. To some extend, we could, too.
                                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, listener, 'Function');
                            }
                            if (isNullOrUndefined(type)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'type');
                            }
                            type = axCoerceString(type);
                            var listeners = this._getListeners(!!useCapture);
                            var list = listeners[type];
                            if (list) {
                                list.remove(listener);
                                if (list.isEmpty()) {
                                    // Notify the broadcast event queue of the removal.
                                    if (!useCapture && events.Event.isBroadcastEventType(type)) {
                                        this.sec.flash.events.EventDispatcher.axClass.broadcastEventDispatchQueue.remove(type, this);
                                    }
                                    listeners[type] = null;
                                }
                            }
                        };
                        EventDispatcher.prototype._hasTargetOrBubblingEventListener = function (type) {
                            return !!(this._targetOrBubblingListeners && this._targetOrBubblingListeners[type]);
                        };
                        EventDispatcher.prototype._hasCaptureEventListener = function (type) {
                            return !!(this._captureListeners && this._captureListeners[type]);
                        };
                        /**
                         * Faster internal version of |hasEventListener| that doesn't do any argument checking.
                         */
                        EventDispatcher.prototype._hasEventListener = function (type) {
                            return this._hasTargetOrBubblingEventListener(type) || this._hasCaptureEventListener(type);
                        };
                        EventDispatcher.prototype.hasEventListener = function (type) {
                            if (arguments.length !== 1) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'flash.events::EventDispatcher/hasEventListener()', 1, arguments.length);
                            }
                            if (isNullOrUndefined(type)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'type');
                            }
                            type = axCoerceString(type);
                            return this._hasEventListener(type);
                        };
                        EventDispatcher.prototype.willTrigger = function (type) {
                            if (arguments.length !== 1) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'flash.events::EventDispatcher/hasEventListener()', 1, arguments.length);
                            }
                            if (isNullOrUndefined(type)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'type');
                            }
                            type = axCoerceString(type);
                            if (this._hasEventListener(type)) {
                                return true;
                            }
                            if (this.sec.flash.display.DisplayObject.axIsType(this)) {
                                var node = this._parent;
                                do {
                                    if (node._hasEventListener(type)) {
                                        return true;
                                    }
                                } while (node = node._parent);
                            }
                            return false;
                        };
                        /**
                         * Check to see if we can skip event dispatching in case there are no event listeners
                         * for this |event|.
                         */
                        EventDispatcher.prototype._skipDispatchEvent = function (event) {
                            if (this._hasEventListener(event.type)) {
                                return false;
                            }
                            // Broadcast events don't have capturing or bubbling phases so it's a simple check.
                            if (event.isBroadcastEvent()) {
                                return true;
                            } else if (event._bubbles && this.sec.flash.display.DisplayObject.axIsType(this)) {
                                // Check to see if there are any event listeners on the path to the root.
                                for (var node = this._parent; node; node = node._parent) {
                                    if (node._hasEventListener(event.type)) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        };
                        EventDispatcher.prototype.dispatchEvent = function (event) {
                            if (arguments.length !== 1) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'flash.events::EventDispatcher/dispatchEvent()', 1, arguments.length);
                            }
                            if (this._skipDispatchEvent(event)) {
                                return true;
                            }
                            if (!release && AS.traceEventsOption.value) {
                                console.log('Dispatch event of type ' + event._type);
                            }
                            release || AVMX.counter.count('EventDispatcher::dispatchEvent');
                            var type = event._type;
                            var target = this._target;
                            release || AVMX.counter.count('EventDispatcher::dispatchEvent(' + type + ')');
                            /**
                             * 1. Capturing Phase
                             */
                            var keepPropagating = true;
                            var ancestors = [];
                            if (!event.isBroadcastEvent() && this.sec.flash.display.DisplayObject.axIsType(this)) {
                                var node = this._parent;
                                // Gather all parent display objects that have event listeners for this event type.
                                while (node) {
                                    if (node._hasEventListener(type)) {
                                        ancestors.push(node);
                                    }
                                    node = node._parent;
                                }
                                for (var i = ancestors.length - 1; i >= 0 && keepPropagating; i--) {
                                    var ancestor = ancestors[i];
                                    if (!ancestor._hasCaptureEventListener(type)) {
                                        continue;
                                    }
                                    var list = ancestor._getListenersForType(true, type);
                                    release || assert(list);
                                    keepPropagating = EventDispatcher.callListeners(list, event, target, ancestor, events.EventPhase.CAPTURING_PHASE);
                                }
                            }
                            /**
                             * 2. At Target
                             */
                            if (keepPropagating) {
                                var list = this._getListenersForType(false, type);
                                if (list) {
                                    keepPropagating = EventDispatcher.callListeners(list, event, target, target, events.EventPhase.AT_TARGET);
                                }
                            }
                            /**
                             * 3. Bubbling Phase
                             */
                            if (!event.isBroadcastEvent() && keepPropagating && event.bubbles) {
                                for (var i = 0; i < ancestors.length && keepPropagating; i++) {
                                    var ancestor = ancestors[i];
                                    if (!ancestor._hasTargetOrBubblingEventListener(type)) {
                                        continue;
                                    }
                                    var list = ancestor._getListenersForType(false, type);
                                    keepPropagating = EventDispatcher.callListeners(list, event, target, ancestor, events.EventPhase.BUBBLING_PHASE);
                                }
                            }
                            return !event._isDefaultPrevented;
                        };
                        EventDispatcher.callListeners = function (list, event, target, currentTarget, eventPhase) {
                            if (list.isEmpty()) {
                                return true;
                            }
                            /**
                             * If the target is already set then we must clone the event. We can reuse the event object
                             * for all listener callbacks but not when bubbling.
                             */
                            if (event._target) {
                                event = event.axCallPublicProperty('clone', null);
                            }
                            var snapshot = list.snapshot();
                            try {
                                for (var i = 0; i < snapshot.length; i++) {
                                    var entry = snapshot[i];
                                    event._target = target;
                                    event._currentTarget = currentTarget;
                                    event._eventPhase = eventPhase;
                                    typeof entry.listener === 'function' ? entry.listener(event) : entry.listener.call(entry.listener, event);
                                    if (event._stopImmediatePropagation) {
                                        break;
                                    }
                                }
                            } catch (e) {
                                Shumway.Debug.warning('Uncaught error in handler for event ' + event._type + ': ', e);
                            }
                            list.releaseSnapshot(snapshot);
                            return !event._stopPropagation;
                        };
                        return EventDispatcher;
                    }(AS.ASObject);
                    events.EventDispatcher = EventDispatcher;
                    var EventPhase = function (_super) {
                        __extends(EventPhase, _super);
                        function EventPhase() {
                            _super.call(this);
                        }
                        EventPhase.classInitializer = null;
                        EventPhase.classSymbols = null;
                        EventPhase.instanceSymbols = null;
                        // JS -> AS Bindings
                        EventPhase.CAPTURING_PHASE = 1;
                        EventPhase.AT_TARGET = 2;
                        EventPhase.BUBBLING_PHASE = 3;
                        return EventPhase;
                    }(AS.ASObject);
                    events.EventPhase = EventPhase;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var TextEvent = function (_super) {
                        __extends(TextEvent, _super);
                        function TextEvent(type, bubbles, cancelable, text) {
                            _super.call(this, type, bubbles, cancelable);
                            this._text = text;
                        }
                        Object.defineProperty(TextEvent.prototype, 'text', {
                            get: function () {
                                return this._text;
                            },
                            set: function (value) {
                                this._text = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        TextEvent.prototype.clone = function () {
                            var textEvent = new this.sec.flash.events.TextEvent(this.type, this.bubbles, this.cancelable, this.text);
                            //this.copyNativeData(textEvent);
                            return textEvent;
                        };
                        TextEvent.prototype.toString = function () {
                            return this.formatToString('TextEvent', 'type', 'bubbles', 'cancelable', 'text');
                        };
                        TextEvent.prototype.copyNativeData = function (event) {
                            release || notImplemented('public flash.events.TextEvent::copyNativeData');
                        };
                        TextEvent.classInitializer = null;
                        TextEvent.classSymbols = null;
                        TextEvent.instanceSymbols = null;
                        TextEvent.LINK = 'link';
                        TextEvent.TEXT_INPUT = 'textInput';
                        return TextEvent;
                    }(flash.events.Event);
                    events.TextEvent = TextEvent;
                    var ErrorEvent = function (_super) {
                        __extends(ErrorEvent, _super);
                        function ErrorEvent(type, bubbles, cancelable, text, id) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (text === void 0) {
                                text = '';
                            }
                            if (id === void 0) {
                                id = 0;
                            }
                            _super.call(this, type, bubbles, cancelable, text);
                            this.setID(id);
                        }
                        ErrorEvent.prototype.setID = function (id) {
                            this._id = id;
                        };
                        Object.defineProperty(ErrorEvent.prototype, 'errorID', {
                            get: function () {
                                return this._id;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ErrorEvent.prototype.clone = function () {
                            return new this.sec.flash.events.ErrorEvent(this.type, this.bubbles, this.cancelable, this.text, this.errorID);
                        };
                        ErrorEvent.prototype.toString = function () {
                            return this.formatToString('ErrorEvent', 'type', 'bubbles', 'cancelable', 'text', 'errorID');
                        };
                        ErrorEvent.classInitializer = null;
                        ErrorEvent.classSymbols = null;
                        ErrorEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        ErrorEvent.ERROR = 'error';
                        return ErrorEvent;
                    }(flash.events.TextEvent);
                    events.ErrorEvent = ErrorEvent;
                    var AsyncErrorEvent = function (_super) {
                        __extends(AsyncErrorEvent, _super);
                        function AsyncErrorEvent(type, bubbles, cancelable, text, error) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (text === void 0) {
                                text = '';
                            }
                            if (error === void 0) {
                                error = null;
                            }
                            _super.call(this, type, bubbles, cancelable, text);
                            this.$Bgerror = error;
                        }
                        Object.defineProperty(AsyncErrorEvent.prototype, 'error', {
                            get: function () {
                                return this.$Bgerror;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        AsyncErrorEvent.prototype.clone = function () {
                            return new this.sec.flash.events.AsyncErrorEvent(this._type, this._bubbles, this._cancelable, this._text, this.$Bgerror);
                        };
                        AsyncErrorEvent.prototype.toString = function () {
                            return this.formatToString('AsyncErrorEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'text', 'error');
                        };
                        AsyncErrorEvent.ASYNC_ERROR = 'asyncError';
                        AsyncErrorEvent.classInitializer = null;
                        return AsyncErrorEvent;
                    }(flash.events.ErrorEvent);
                    events.AsyncErrorEvent = AsyncErrorEvent;
                    var GameInputEvent = function (_super) {
                        __extends(GameInputEvent, _super);
                        function GameInputEvent(type, bubbles, cancelable, device) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (device === void 0) {
                                device = null;
                            }
                            _super.call(this, type, bubbles, cancelable);
                            // TODO: coerce
                            this.device = device;
                        }
                        GameInputEvent.classInitializer = null;
                        GameInputEvent.classSymbols = null;
                        GameInputEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        GameInputEvent.DEVICE_ADDED = 'deviceAdded';
                        GameInputEvent.DEVICE_REMOVED = 'deviceRemoved';
                        return GameInputEvent;
                    }(flash.events.Event);
                    events.GameInputEvent = GameInputEvent;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var GestureEvent = function (_super) {
                        __extends(GestureEvent, _super);
                        function GestureEvent(type, bubbles, cancelable, phase, localX, localY, ctrlKey, altKey, shiftKey) {
                            if (bubbles === void 0) {
                                bubbles = true;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (phase === void 0) {
                                phase = null;
                            }
                            if (localX === void 0) {
                                localX = 0;
                            }
                            if (localY === void 0) {
                                localY = 0;
                            }
                            if (ctrlKey === void 0) {
                                ctrlKey = false;
                            }
                            if (altKey === void 0) {
                                altKey = false;
                            }
                            if (shiftKey === void 0) {
                                shiftKey = false;
                            }
                            _super.call(this, type, bubbles, cancelable);
                            this._phase = axCoerceString(phase);
                            this._localX = +localX;
                            this._localY = +localY;
                            this._ctrlKey = !!ctrlKey;
                            this._altKey = !!altKey;
                            this._shiftKey = !!shiftKey;
                        }
                        Object.defineProperty(GestureEvent.prototype, 'localX', {
                            // AS -> JS Bindings
                            get: function () {
                                return this._localX;
                            },
                            set: function (value) {
                                this._localX = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GestureEvent.prototype, 'localY', {
                            get: function () {
                                return this._localY;
                            },
                            set: function (value) {
                                this._localY = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GestureEvent.prototype, 'stageX', {
                            get: function () {
                                release || somewhatImplemented('public flash.events.GestureEvent::stageX');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GestureEvent.prototype, 'stageY', {
                            get: function () {
                                release || somewhatImplemented('public flash.events.GestureEvent::stageY');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GestureEvent.prototype, 'ctrlKey', {
                            get: function () {
                                return this._ctrlKey;
                            },
                            set: function (value) {
                                this._ctrlKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GestureEvent.prototype, 'altKey', {
                            get: function () {
                                return this._altKey;
                            },
                            set: function (value) {
                                this._altKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GestureEvent.prototype, 'shiftKey', {
                            get: function () {
                                return this._shiftKey;
                            },
                            set: function (value) {
                                this._shiftKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GestureEvent.prototype, 'phase', {
                            get: function () {
                                return this._phase;
                            },
                            set: function (value) {
                                this._phase = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GestureEvent.prototype.updateAfterEvent = function () {
                            release || somewhatImplemented('public flash.events.GestureEvent::updateAfterEvent');
                        };
                        GestureEvent.prototype.NativeCtor = function (phase, localX, localY, ctrlKey, altKey, shiftKey) {
                            this._phase = axCoerceString(phase);
                            this._localX = +localX;
                            this._localY = +localY;
                            this._ctrlKey = !!ctrlKey;
                            this._altKey = !!altKey;
                            this._shiftKey = !!shiftKey;
                        };
                        GestureEvent.prototype.clone = function () {
                            return new this.sec.flash.events.GestureEvent(this.type, this.bubbles, this.cancelable, this.phase, this.localX, this.localY, this.ctrlKey, this.altKey, this.shiftKey);
                        };
                        GestureEvent.prototype.toString = function () {
                            return this.formatToString('GestureEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'localX', 'localY', 'ctrlKey', 'altKey', 'shiftKey');
                        };
                        GestureEvent.classInitializer = null;
                        GestureEvent.classSymbols = null;
                        GestureEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        GestureEvent.GESTURE_TWO_FINGER_TAP = 'gestureTwoFingerTap';
                        return GestureEvent;
                    }(flash.events.Event);
                    events.GestureEvent = GestureEvent;
                    var HTTPStatusEvent = function (_super) {
                        __extends(HTTPStatusEvent, _super);
                        function HTTPStatusEvent(type, bubbles, cancelable, status) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (status === void 0) {
                                status = 0;
                            }
                            _super.call(this, type, bubbles, cancelable);
                            this._status = status | 0;
                        }
                        HTTPStatusEvent.prototype._setStatus = function (value) {
                            this._status = value;
                        };
                        Object.defineProperty(HTTPStatusEvent.prototype, 'status', {
                            get: function () {
                                return this._status;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        HTTPStatusEvent.prototype.clone = function () {
                            return new this.sec.flash.events.HTTPStatusEvent(this.type, this.bubbles, this.cancelable, this.status);
                        };
                        HTTPStatusEvent.prototype.toString = function () {
                            return this.formatToString('HTTPStatusEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'status');
                        };
                        HTTPStatusEvent.classInitializer = null;
                        HTTPStatusEvent.HTTP_STATUS = 'httpStatus';
                        HTTPStatusEvent.HTTP_RESPONSE_STATUS = 'httpResponseStatus';
                        return HTTPStatusEvent;
                    }(flash.events.Event);
                    events.HTTPStatusEvent = HTTPStatusEvent;
                    var IOErrorEvent = function (_super) {
                        __extends(IOErrorEvent, _super);
                        function IOErrorEvent(type, bubbles, cancelable, text, id) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (text === void 0) {
                                text = '';
                            }
                            if (id === void 0) {
                                id = 0;
                            }
                            _super.call(this, type, bubbles, cancelable, text, id);
                        }
                        IOErrorEvent.prototype.clone = function () {
                            var event = new this.sec.flash.events.IOErrorEvent(this.type, this.bubbles, this.cancelable, this.text, this.errorID);
                            //this.copyNativeData(event);
                            return event;
                        };
                        IOErrorEvent.prototype.toString = function () {
                            return this.formatToString('IOErrorEvent', 'type', 'bubbles', 'cancelable', 'text', 'errorID');
                        };
                        IOErrorEvent.classInitializer = null;
                        IOErrorEvent.classSymbols = null;
                        IOErrorEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        IOErrorEvent.IO_ERROR = 'ioError';
                        IOErrorEvent.NETWORK_ERROR = 'networkError';
                        IOErrorEvent.DISK_ERROR = 'diskError';
                        IOErrorEvent.VERIFY_ERROR = 'verifyError';
                        return IOErrorEvent;
                    }(flash.events.ErrorEvent);
                    events.IOErrorEvent = IOErrorEvent;
                    var KeyboardEvent = function (_super) {
                        __extends(KeyboardEvent, _super);
                        function KeyboardEvent(type, bubbles, cancelable, charCodeValue, keyCodeValue, keyLocationValue, ctrlKeyValue, altKeyValue, shiftKeyValue) {
                            if (bubbles === void 0) {
                                bubbles = true;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (charCodeValue === void 0) {
                                charCodeValue = 0;
                            }
                            if (keyCodeValue === void 0) {
                                keyCodeValue = 0;
                            }
                            if (keyLocationValue === void 0) {
                                keyLocationValue = 0;
                            }
                            if (ctrlKeyValue === void 0) {
                                ctrlKeyValue = false;
                            }
                            if (altKeyValue === void 0) {
                                altKeyValue = false;
                            }
                            if (shiftKeyValue === void 0) {
                                shiftKeyValue = false;
                            }
                            _super.call(this, type, bubbles, cancelable);
                            this._charCode = charCodeValue >>> 0;
                            this._keyCode = keyCodeValue >>> 0;
                            this._keyLocation = keyLocationValue >>> 0;
                            this._ctrlKey = !!ctrlKeyValue;
                            this._altKey = !!altKeyValue;
                            this._shiftKey = !!shiftKeyValue;
                        }
                        Object.defineProperty(KeyboardEvent.prototype, 'charCode', {
                            get: function () {
                                return this._charCode;
                            },
                            set: function (value) {
                                this._charCode = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(KeyboardEvent.prototype, 'keyCode', {
                            get: function () {
                                return this._keyCode;
                            },
                            set: function (value) {
                                this._keyCode = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(KeyboardEvent.prototype, 'keyLocation', {
                            get: function () {
                                return this._keyLocation;
                            },
                            set: function (value) {
                                this._keyLocation = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(KeyboardEvent.prototype, 'ctrlKey', {
                            get: function () {
                                return this._ctrlKey;
                            },
                            set: function (value) {
                                this._ctrlKey = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(KeyboardEvent.prototype, 'altKey', {
                            get: function () {
                                return this._altKey;
                            },
                            set: function (value) {
                                this._altKey = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(KeyboardEvent.prototype, 'shiftKey', {
                            get: function () {
                                return this._shiftKey;
                            },
                            set: function (value) {
                                this._shiftKey = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        KeyboardEvent.prototype.clone = function () {
                            return new this.sec.flash.events.KeyboardEvent(this.type, this.bubbles, this.cancelable, this.charCode, this.keyCode, this.keyLocation, this.ctrlKey, this.altKey, this.shiftKey);
                        };
                        KeyboardEvent.prototype.toString = function () {
                            return this.formatToString('KeyboardEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'charCode', 'keyCode', 'keyLocation', 'ctrlKey', 'altKey', 'shiftKey');
                        };
                        KeyboardEvent.prototype.updateAfterEvent = function () {
                            this.sec.player.requestRendering();
                        };
                        KeyboardEvent.classInitializer = null;
                        KeyboardEvent.classSymbols = null;
                        KeyboardEvent.instanceSymbols = null;
                        KeyboardEvent.KEY_DOWN = 'keyDown';
                        KeyboardEvent.KEY_UP = 'keyUp';
                        return KeyboardEvent;
                    }(flash.events.Event);
                    events.KeyboardEvent = KeyboardEvent;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var MouseEvent = function (_super) {
                        __extends(MouseEvent, _super);
                        function MouseEvent(type, bubbles, cancelable, localX, localY, relatedObject, ctrlKey, altKey, shiftKey, buttonDown, delta) {
                            if (bubbles === void 0) {
                                bubbles = true;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (localX === void 0) {
                                localX = undefined;
                            }
                            if (localY === void 0) {
                                localY = undefined;
                            }
                            if (relatedObject === void 0) {
                                relatedObject = null;
                            }
                            if (ctrlKey === void 0) {
                                ctrlKey = false;
                            }
                            if (altKey === void 0) {
                                altKey = false;
                            }
                            if (shiftKey === void 0) {
                                shiftKey = false;
                            }
                            if (buttonDown === void 0) {
                                buttonDown = false;
                            }
                            if (delta === void 0) {
                                delta = 0;
                            }
                            _super.call(this, type, bubbles, cancelable);
                            this._localX = localX;
                            this._localY = localY;
                            this._relatedObject = relatedObject;
                            this._ctrlKey = ctrlKey;
                            this._altKey = altKey;
                            this._shiftKey = shiftKey;
                            this._buttonDown = buttonDown;
                            this._delta = delta;
                        }
                        /**
                         * AS3 mouse event names don't match DOM even names, so map them here.
                         */
                        MouseEvent.typeFromDOMType = function (name) {
                            switch (name) {
                            case 'click':
                                return MouseEvent.CLICK;
                            case 'dblclick':
                                return MouseEvent.DOUBLE_CLICK;
                            case 'mousedown':
                                return MouseEvent.MOUSE_DOWN;
                            case 'mouseout':
                            case 'mouseover':
                            case 'mousemove':
                                return MouseEvent.MOUSE_MOVE;
                            case 'mouseup':
                                return MouseEvent.MOUSE_UP;
                            default:
                                notImplemented(name);
                            }
                        };
                        Object.defineProperty(MouseEvent.prototype, 'localX', {
                            get: function () {
                                return this._localX / 20 | 0;
                            },
                            set: function (value) {
                                this._localX = value * 20 | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'localY', {
                            get: function () {
                                return this._localY / 20 | 0;
                            },
                            set: function (value) {
                                this._localY = value * 20 | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'stageX', {
                            get: function () {
                                if (isNaN(this.localX + this.localY)) {
                                    return Number.NaN;
                                }
                                return this._getGlobalPoint().x / 20 | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'stageY', {
                            get: function () {
                                if (isNaN(this.localX + this.localY)) {
                                    return Number.NaN;
                                }
                                return this._getGlobalPoint().y / 20 | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'movementX', {
                            get: function () {
                                return this._movementX || 0;
                            },
                            set: function (value) {
                                this._movementX = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'movementY', {
                            get: function () {
                                return this._movementY || 0;
                            },
                            set: function (value) {
                                this._movementY = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'delta', {
                            get: function () {
                                return this._delta;
                            },
                            set: function (value) {
                                this._delta = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'ctrlKey', {
                            get: function () {
                                return this._ctrlKey;
                            },
                            set: function (value) {
                                this._ctrlKey = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'altKey', {
                            get: function () {
                                return this._altKey;
                            },
                            set: function (value) {
                                this._altKey = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'shiftKey', {
                            get: function () {
                                return this._shiftKey;
                            },
                            set: function (value) {
                                this._shiftKey = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'buttonDown', {
                            get: function () {
                                return this._buttonDown;
                            },
                            set: function (value) {
                                this._buttonDown = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'relatedObject', {
                            get: function () {
                                return this._relatedObject;
                            },
                            set: function (value) {
                                this._relatedObject = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseEvent.prototype, 'isRelatedObjectInaccessible', {
                            get: function () {
                                return this._isRelatedObjectInaccessible;
                            },
                            set: function (value) {
                                this._isRelatedObjectInaccessible = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        MouseEvent.prototype.updateAfterEvent = function () {
                            this.sec.player.requestRendering();
                        };
                        MouseEvent.prototype._getGlobalPoint = function () {
                            var point = this._position;
                            if (!point) {
                                point = this._position = new this.sec.flash.geom.Point();
                            }
                            if (this.target) {
                                point.setTo(this._localX, this._localY);
                                var m = this._target._getConcatenatedMatrix();
                                m.transformPointInPlace(point);
                            } else {
                                point.setTo(0, 0);
                            }
                            return point;
                        };
                        MouseEvent.prototype.clone = function () {
                            return new this.sec.flash.events.MouseEvent(this.type, this.bubbles, this.cancelable, this.localX, this.localY, this.relatedObject, this.ctrlKey, this.altKey, this.shiftKey, this.buttonDown, this.delta);
                        };
                        MouseEvent.prototype.toString = function () {
                            return this.formatToString('MouseEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'localX', 'localY', 'relatedObject', 'ctrlKey', 'altKey', 'shiftKey', 'buttonDown', 'delta');
                        };
                        MouseEvent.classInitializer = null;
                        MouseEvent.classSymbols = null;
                        MouseEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        MouseEvent.CLICK = 'click';
                        MouseEvent.DOUBLE_CLICK = 'doubleClick';
                        MouseEvent.MOUSE_DOWN = 'mouseDown';
                        MouseEvent.MOUSE_MOVE = 'mouseMove';
                        MouseEvent.MOUSE_OUT = 'mouseOut';
                        MouseEvent.MOUSE_OVER = 'mouseOver';
                        MouseEvent.MOUSE_UP = 'mouseUp';
                        MouseEvent.RELEASE_OUTSIDE = 'releaseOutside';
                        MouseEvent.MOUSE_WHEEL = 'mouseWheel';
                        MouseEvent.ROLL_OUT = 'rollOut';
                        MouseEvent.ROLL_OVER = 'rollOver';
                        MouseEvent.MIDDLE_CLICK = 'middleClick';
                        MouseEvent.MIDDLE_MOUSE_DOWN = 'middleMouseDown';
                        MouseEvent.MIDDLE_MOUSE_UP = 'middleMouseUp';
                        MouseEvent.RIGHT_CLICK = 'rightClick';
                        MouseEvent.RIGHT_MOUSE_DOWN = 'rightMouseDown';
                        MouseEvent.RIGHT_MOUSE_UP = 'rightMouseUp';
                        MouseEvent.CONTEXT_MENU = 'contextMenu';
                        return MouseEvent;
                    }(flash.events.Event);
                    events.MouseEvent = MouseEvent;
                    var NetStatusEvent = function (_super) {
                        __extends(NetStatusEvent, _super);
                        function NetStatusEvent(type, bubbles, cancelable, info) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (info === void 0) {
                                info = null;
                            }
                            _super.call(this, type, bubbles, cancelable);
                            this._info = info;
                        }
                        Object.defineProperty(NetStatusEvent.prototype, 'info', {
                            get: function () {
                                return this._info;
                            },
                            set: function (value) {
                                this._info = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetStatusEvent.prototype.clone = function () {
                            return new this.sec.flash.events.NetStatusEvent(this.type, this.bubbles, this.cancelable, this.info);
                        };
                        NetStatusEvent.prototype.toString = function () {
                            return this.formatToString('NetStatusEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'info');
                        };
                        NetStatusEvent.classInitializer = null;
                        NetStatusEvent.classSymbols = null;
                        NetStatusEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        NetStatusEvent.NET_STATUS = 'netStatus';
                        return NetStatusEvent;
                    }(flash.events.Event);
                    events.NetStatusEvent = NetStatusEvent;
                    var ProgressEvent = function (_super) {
                        __extends(ProgressEvent, _super);
                        function ProgressEvent(type, bubbles, cancelable, bytesLoaded, bytesTotal) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (bytesLoaded === void 0) {
                                bytesLoaded = 0;
                            }
                            if (bytesTotal === void 0) {
                                bytesTotal = 0;
                            }
                            _super.call(this, type, bubbles, cancelable);
                            this._bytesLoaded = bytesLoaded;
                            this._bytesTotal = bytesTotal;
                        }
                        Object.defineProperty(ProgressEvent.prototype, 'bytesLoaded', {
                            get: function () {
                                return this._bytesLoaded;
                            },
                            set: function (value) {
                                this._bytesLoaded = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProgressEvent.prototype, 'bytesTotal', {
                            get: function () {
                                return this._bytesTotal;
                            },
                            set: function (value) {
                                this._bytesTotal = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ProgressEvent.prototype.clone = function () {
                            return new this.sec.flash.events.ProgressEvent(this._type, this._bubbles, this._cancelable, this._bytesLoaded, this._bytesTotal);
                        };
                        ProgressEvent.prototype.toString = function () {
                            return this.formatToString('ProgressEvent', 'bubbles', 'cancelable', 'eventPhase', 'bytesLoaded', 'bytesTotal');
                        };
                        ProgressEvent.classInitializer = null;
                        ProgressEvent.classSymbols = null;
                        ProgressEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        ProgressEvent.PROGRESS = 'progress';
                        ProgressEvent.SOCKET_DATA = 'socketData';
                        return ProgressEvent;
                    }(flash.events.Event);
                    events.ProgressEvent = ProgressEvent;
                    var SecurityErrorEvent = function (_super) {
                        __extends(SecurityErrorEvent, _super);
                        function SecurityErrorEvent(type, bubbles, cancelable, text, id) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (text === void 0) {
                                text = '';
                            }
                            if (id === void 0) {
                                id = 0;
                            }
                            _super.call(this, type, bubbles, cancelable, text, id);
                        }
                        SecurityErrorEvent.classInitializer = null;
                        SecurityErrorEvent.classSymbols = null;
                        SecurityErrorEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        SecurityErrorEvent.SECURITY_ERROR = 'securityError';
                        return SecurityErrorEvent;
                    }(flash.events.ErrorEvent);
                    events.SecurityErrorEvent = SecurityErrorEvent;
                    var StatusEvent = function (_super) {
                        __extends(StatusEvent, _super);
                        function StatusEvent(type, bubbles, cancelable, code, level) {
                            if (bubbles === void 0) {
                                bubbles = false;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (code === void 0) {
                                code = '';
                            }
                            if (level === void 0) {
                                level = '';
                            }
                            _super.call(this, type, bubbles, cancelable);
                            this._code = AVMX.axCoerceString(code);
                            this._level = AVMX.axCoerceString(level);
                        }
                        Object.defineProperty(StatusEvent.prototype, 'level', {
                            get: function () {
                                return this._level;
                            },
                            set: function (value) {
                                this._level = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(StatusEvent.prototype, 'code', {
                            get: function () {
                                return this._code;
                            },
                            set: function (value) {
                                this._code = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        StatusEvent.prototype.clone = function () {
                            return new this.sec.flash.events.StatusEvent(this._type, this._bubbles, this._cancelable, this._code, this._level);
                        };
                        StatusEvent.prototype.toString = function () {
                            return this.formatToString('StatusEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'code', 'level');
                        };
                        StatusEvent.classInitializer = null;
                        StatusEvent.STATUS = 'status';
                        return StatusEvent;
                    }(flash.events.Event);
                    events.StatusEvent = StatusEvent;
                    var TimerEvent = function (_super) {
                        __extends(TimerEvent, _super);
                        function TimerEvent(type, bubbles, cancelable) {
                            _super.call(this, type, bubbles, cancelable);
                        }
                        TimerEvent.prototype.clone = function () {
                            return new this.sec.flash.events.TimerEvent(this.type, this.bubbles, this.cancelable);
                        };
                        TimerEvent.prototype.toString = function () {
                            return this.formatToString('TimerEvent', 'type', 'bubbles', 'cancelable', 'eventPhase');
                        };
                        TimerEvent.prototype.updateAfterEvent = function () {
                            this.sec.player.requestRendering();
                        };
                        TimerEvent.classInitializer = null;
                        TimerEvent.classSymbols = null;
                        TimerEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        TimerEvent.TIMER = 'timer';
                        TimerEvent.TIMER_COMPLETE = 'timerComplete';
                        return TimerEvent;
                    }(flash.events.Event);
                    events.TimerEvent = TimerEvent;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var TouchEvent = function (_super) {
                        __extends(TouchEvent, _super);
                        function TouchEvent(type, bubbles, cancelable, touchPointID, isPrimaryTouchPoint, localX, localY, sizeX, sizeY, pressure, relatedObject, ctrlKey, altKey, shiftKey) {
                            if (bubbles === void 0) {
                                bubbles = true;
                            }
                            if (cancelable === void 0) {
                                cancelable = false;
                            }
                            if (touchPointID === void 0) {
                                touchPointID = 0;
                            }
                            if (isPrimaryTouchPoint === void 0) {
                                isPrimaryTouchPoint = false;
                            }
                            if (localX === void 0) {
                                localX = NaN;
                            }
                            if (localY === void 0) {
                                localY = NaN;
                            }
                            if (sizeX === void 0) {
                                sizeX = NaN;
                            }
                            if (sizeY === void 0) {
                                sizeY = NaN;
                            }
                            if (pressure === void 0) {
                                pressure = NaN;
                            }
                            if (relatedObject === void 0) {
                                relatedObject = null;
                            }
                            if (ctrlKey === void 0) {
                                ctrlKey = false;
                            }
                            if (altKey === void 0) {
                                altKey = false;
                            }
                            if (shiftKey === void 0) {
                                shiftKey = false;
                            }
                            _super.call(this, type, bubbles, cancelable);
                        }
                        Object.defineProperty(TouchEvent.prototype, 'touchPointID', {
                            get: function () {
                                return this._touchPointID;
                            },
                            set: function (value) {
                                this._touchPointID = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'isPrimaryTouchPoint', {
                            get: function () {
                                return this._isPrimaryTouchPoint;
                            },
                            set: function (value) {
                                this._isPrimaryTouchPoint = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'localX', {
                            get: function () {
                                return this._localX;
                            },
                            set: function (value) {
                                this._localX = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'localY', {
                            get: function () {
                                return this._localY;
                            },
                            set: function (value) {
                                this._localY = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'sizeX', {
                            get: function () {
                                return this._sizeX;
                            },
                            set: function (value) {
                                this._sizeX = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'sizeY', {
                            get: function () {
                                return this._sizeY;
                            },
                            set: function (value) {
                                this._sizeY = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'pressure', {
                            get: function () {
                                return this._pressure;
                            },
                            set: function (value) {
                                this._pressure = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'relatedObject', {
                            get: function () {
                                return this._relatedObject;
                            },
                            set: function (value) {
                                this._relatedObject = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'ctrlKey', {
                            get: function () {
                                return this._ctrlKey;
                            },
                            set: function (value) {
                                this._ctrlKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'altKey', {
                            get: function () {
                                return this._altKey;
                            },
                            set: function (value) {
                                this._altKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'shiftKey', {
                            get: function () {
                                return this._shiftKey;
                            },
                            set: function (value) {
                                this._shiftKey = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'stageX', {
                            get: function () {
                                somewhatImplemented('TouchEvent::get stageX');
                                return this._localX;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'stageY', {
                            get: function () {
                                somewhatImplemented('TouchEvent::get stageY');
                                return this._localY;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TouchEvent.prototype, 'isRelatedObjectInaccessible', {
                            get: function () {
                                return this._isRelatedObjectInaccessible;
                            },
                            set: function (value) {
                                this._isRelatedObjectInaccessible = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        TouchEvent.prototype.clone = function () {
                            return new this.sec.flash.events.TouchEvent(this.type, this.bubbles, this.cancelable, this.touchPointID, this.isPrimaryTouchPoint, this.localX, this.localY, this.sizeX, this.sizeY, this.pressure, this.relatedObject, this.ctrlKey, this.altKey, this.shiftKey);
                        };
                        TouchEvent.prototype.toString = function () {
                            return this.formatToString('TouchEvent', 'type', 'bubbles', 'cancelable', 'eventPhase', 'touchPointID', 'isPrimaryTouchPoint', 'localX', 'localY', 'sizeX', 'sizeY', 'pressure', 'relatedObject', 'ctrlKey', 'altKey', 'shiftKey');
                        };
                        TouchEvent.prototype.updateAfterEvent = function () {
                            this.sec.player.requestRendering();
                        };
                        TouchEvent.classInitializer = null;
                        TouchEvent.classSymbols = null;
                        TouchEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        TouchEvent.TOUCH_BEGIN = 'touchBegin';
                        TouchEvent.TOUCH_END = 'touchEnd';
                        TouchEvent.TOUCH_MOVE = 'touchMove';
                        TouchEvent.TOUCH_OVER = 'touchOver';
                        TouchEvent.TOUCH_OUT = 'touchOut';
                        TouchEvent.TOUCH_ROLL_OVER = 'touchRollOver';
                        TouchEvent.TOUCH_ROLL_OUT = 'touchRollOut';
                        TouchEvent.TOUCH_TAP = 'touchTap';
                        TouchEvent.PROXIMITY_BEGIN = 'proximityBegin';
                        TouchEvent.PROXIMITY_END = 'proximityEnd';
                        TouchEvent.PROXIMITY_MOVE = 'proximityMove';
                        TouchEvent.PROXIMITY_OUT = 'proximityOut';
                        TouchEvent.PROXIMITY_OVER = 'proximityOver';
                        TouchEvent.PROXIMITY_ROLL_OUT = 'proximityRollOut';
                        TouchEvent.PROXIMITY_ROLL_OVER = 'proximityRollOver';
                        return TouchEvent;
                    }(flash.events.Event);
                    events.TouchEvent = TouchEvent;
                    var UncaughtErrorEvent = function (_super) {
                        __extends(UncaughtErrorEvent, _super);
                        function UncaughtErrorEvent(type, bubbles, cancelable, error_in) {
                            if (type === void 0) {
                                type = 'uncaughtError';
                            }
                            if (bubbles === void 0) {
                                bubbles = true;
                            }
                            if (cancelable === void 0) {
                                cancelable = true;
                            }
                            if (error_in === void 0) {
                                error_in = null;
                            }
                            _super.call(this, type, bubbles, cancelable, error_in);
                        }
                        UncaughtErrorEvent.classInitializer = null;
                        UncaughtErrorEvent.classSymbols = null;
                        UncaughtErrorEvent.instanceSymbols = null;
                        // JS -> AS Bindings
                        UncaughtErrorEvent.UNCAUGHT_ERROR = 'uncaughtError';
                        return UncaughtErrorEvent;
                    }(flash.events.ErrorEvent);
                    events.UncaughtErrorEvent = UncaughtErrorEvent;
                    var UncaughtErrorEvents = function (_super) {
                        __extends(UncaughtErrorEvents, _super);
                        function UncaughtErrorEvents() {
                            _super.call(this);
                        }
                        UncaughtErrorEvents.classInitializer = null;
                        UncaughtErrorEvents.classSymbols = null;
                        UncaughtErrorEvents.instanceSymbols = null;
                        return UncaughtErrorEvents;
                    }(flash.events.EventDispatcher);
                    events.UncaughtErrorEvents = UncaughtErrorEvents;
                }(events = flash.events || (flash.events = {})));
                var display;
                (function (display) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var isNullOrUndefined = Shumway.isNullOrUndefined;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var checkNullParameter = Shumway.AVMX.checkNullParameter;
                    var assert = Shumway.Debug.assert;
                    var Bounds = Shumway.Bounds;
                    var geom = flash.geom;
                    var events = flash.events;
                    var displayObjectSyncID = 0;
                    var DisplayObject = function (_super) {
                        __extends(DisplayObject, _super);
                        function DisplayObject() {
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                            this._addReference();
                            this._setFlags(256    /* Constructed */);
                        }
                        /**
                         * Every displayObject is assigned an unique integer ID.
                         */
                        DisplayObject.getNextSyncID = function () {
                            return displayObjectSyncID++;
                        };
                        // Called whenever the class is initialized.
                        DisplayObject.classInitializer = function () {
                            this.reset();
                        };
                        DisplayObject.reset = function () {
                            this._advancableInstances = new Shumway.WeakList();
                        };
                        /**
                         * Creates a new display object from a symbol and initializes its animated display properties.
                         * Calling its constructor is optional at this point, since that can happen in a later frame
                         * phase.
                         */
                        DisplayObject.prototype.createAnimatedDisplayObject = function (symbol, placeObjectTag, callConstructor) {
                            var symbolClass = symbol.symbolClass;
                            var bitmapDataClass = this.sec.flash.display.BitmapData.axClass;
                            if (symbolClass === bitmapDataClass || bitmapDataClass.dPrototype.isPrototypeOf(symbolClass.dPrototype)) {
                                symbolClass = this.sec.flash.display.Bitmap.axClass;
                            }
                            var instance = AS.constructClassFromSymbol(symbol, symbolClass);
                            if (placeObjectTag.flags & 32    /* HasName */) {
                                instance._name = placeObjectTag.name;
                            }
                            instance._setFlags(4096    /* AnimatedByTimeline */);
                            instance._animate(placeObjectTag);
                            if (callConstructor) {
                                instance.axInitializer();
                            }
                            return instance;
                        };
                        /**
                         * Runs one full turn of the frame events cycle.
                         *
                         * Frame navigation methods on MovieClip can trigger nested frame events cycles. These nested
                         * cycles do everything the outermost cycle does, except for broadcasting the ENTER_FRAME
                         * event.
                         *
                         * If runScripts is true, no events are dispatched and Movieclip frame scripts are run. This
                         * is true for nested cycles, too. (We keep static state for that.)
                         */
                        DisplayObject.performFrameNavigation = function (mainLoop, runScripts) {
                            if (mainLoop) {
                                this._runScripts = runScripts;
                            } else {
                                runScripts = this._runScripts;
                            }
                            release || assert(this._advancableInstances.length < 1024 * 16, 'Too many advancable instances.');
                            // Step 1: Remove timeline objects that don't exist on new frame, update existing ones with
                            // new properties, and declare, but not create, new ones, update numChildren.
                            // NOTE: the Order Of Operations senocular article is wrong on this: timeline objects are
                            // removed from stage at the beginning of a frame, just as new objects are declared at that
                            // point.
                            // Also, changed properties of existing objects are updated here instead of during frame
                            // construction after ENTER_FRAME.
                            // Thus, all these can be done together.
                            AVMX.enterTimeline('DisplayObject.InitFrame');
                            this._advancableInstances.forEach(function (value) {
                                value._initFrame(mainLoop);
                            });
                            AVMX.leaveTimeline();
                            // Step 2: Dispatch ENTER_FRAME, only called in outermost invocation.
                            AVMX.enterTimeline('DisplayObject.EnterFrame');
                            if (mainLoop && runScripts) {
                                this._broadcastFrameEvent(events.Event.ENTER_FRAME);
                            }
                            AVMX.leaveTimeline();
                            // Step 3: Create new timeline objects.
                            AVMX.enterTimeline('DisplayObject.ConstructFrame');
                            this._advancableInstances.forEach(function (value) {
                                value._constructFrame();
                            });
                            AVMX.leaveTimeline();
                            // Step 4: Dispatch FRAME_CONSTRUCTED.
                            if (runScripts) {
                                AVMX.enterTimeline('DisplayObject.FrameConstructed');
                                this._broadcastFrameEvent(events.Event.FRAME_CONSTRUCTED);
                                AVMX.leaveTimeline();
                                // Step 5: Run frame scripts
                                // Flash seems to enqueue all frame scripts recursively, starting at the root of each
                                // independent object graph. That can be the stage or a container that isn't itself on
                                // stage, but has (grand-)children.
                                // The order in which these independent graphs are processed seems not to follow a
                                // specific system: in some testing scenarios all independent graphs are processes before
                                // the stage, in others the first-created such graph is processes *after* the stage, all
                                // others before the stage. There might be other permutations of this, but it seems
                                // doubtful anybody could reasonably rely on the exact details of all this.
                                // Of course, nothing guarantees that there isn't content that accidentally does, so it'd
                                // be nice to eventually get this right.
                                AVMX.enterTimeline('DisplayObject.EnqueueFrameScripts');
                                var displayObjectContainerClass = this.sec.flash.display.DisplayObjectContainer.axClass;
                                this._advancableInstances.forEach(function (value) {
                                    var container = value;
                                    if (displayObjectContainerClass.axIsType(container) && !container.parent) {
                                        container._enqueueFrameScripts();
                                    }
                                });
                                this._stage._enqueueFrameScripts();
                                AVMX.leaveTimeline();
                                AVMX.enterTimeline('DisplayObject.RunFrameScript');
                                var movieClipClass = this.sec.flash.display.MovieClip.axClass;
                                if (movieClipClass.frameNavigationModel === 1    /* SWF1 */) {
                                    movieClipClass.runAvm1FrameScripts();
                                } else {
                                    movieClipClass.runFrameScripts();
                                }
                                AVMX.leaveTimeline();
                                // Step 6: Dispatch EXIT_FRAME.
                                AVMX.enterTimeline('DisplayObject.ExitFrame');
                                this._broadcastFrameEvent(events.Event.EXIT_FRAME);
                                AVMX.leaveTimeline();
                            } else {
                                display.MovieClip.reset();
                            }
                            if (mainLoop) {
                                this._runScripts = true;
                            }
                        };
                        /**
                         * Dispatches a frame event on all instances of DisplayObjects.
                         */
                        DisplayObject._broadcastFrameEvent = function (type) {
                            var eventsPackage = this.sec.flash.events;
                            var event = eventsPackage.Event.axClass.getBroadcastInstance(type);
                            eventsPackage.EventDispatcher.axClass.broadcastEventDispatchQueue.dispatchEvent(event);
                        };
                        DisplayObject.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this, this);
                            this._id = this.sec.flash.display.DisplayObject.axClass.getNextSyncID();
                            this._flags = 1    /* Visible */ | 2    /* InvalidLineBounds */ | 4    /* InvalidFillBounds */ | 32    /* InvalidConcatenatedMatrix */ | 64    /* InvalidInvertedConcatenatedMatrix */ | 536870912    /* DirtyDescendents */;
                            this._dirtyFlags = 4    /* DirtyGraphics */ | 1    /* DirtyMatrix */ | 64    /* DirtyColorTransform */ | 128    /* DirtyMask */ | 256    /* DirtyClipDepth */ | 512    /* DirtyMiscellaneousProperties */;
                            this._root = null;
                            this._stage = null;
                            this._setInitialName();
                            this._parent = null;
                            this._mask = null;
                            this._z = 0;
                            this._scaleX = 1;
                            this._scaleY = 1;
                            this._skewX = 0;
                            this._skewY = 0;
                            this._scaleZ = 1;
                            this._rotation = 0;
                            this._rotationX = 0;
                            this._rotationY = 0;
                            this._rotationZ = 0;
                            this._width = 0;
                            this._height = 0;
                            this._opaqueBackground = null;
                            this._scrollRect = null;
                            this._filters = null;
                            this._blendMode = display.BlendMode.NORMAL;
                            // No need to take ownership: scale9Grid is never changed.
                            this._scale9Grid = this._symbol ? this._symbol.scale9Grid : null;
                            this._loaderInfo = null;
                            this._accessibilityProperties = null;
                            this._fillBounds = new Bounds(0, 0, 0, 0);
                            this._lineBounds = new Bounds(0, 0, 0, 0);
                            this._clipDepth = -1;
                            var matrixClass = this.sec.flash.geom.Matrix;
                            this._concatenatedMatrix = new matrixClass();
                            this._invertedConcatenatedMatrix = new matrixClass();
                            this._matrix = new matrixClass();
                            this._invertedMatrix = new matrixClass();
                            this._matrix3D = null;
                            this._perspectiveProjectionFOV = 55    /* FOV */;
                            this._perspectiveProjectionCenterX = 250    /* CenterX */;
                            this._perspectiveProjectionCenterY = 250    /* CenterY */;
                            var colorTransformClass = this.sec.flash.geom.ColorTransform;
                            this._colorTransform = new colorTransformClass();
                            this._concatenatedColorTransform = new colorTransformClass();
                            this._depth = -1;
                            this._ratio = 0;
                            this._index = -1;
                            this._maskedObject = null;
                            this._mouseOver = false;
                            this._mouseDown = false;
                            this._graphics = null;
                            this._children = null;
                            this._referenceCount = 0;
                        };
                        /**
                         * Sets the object's initial name to adhere to the 'instanceN' naming scheme.
                         */
                        DisplayObject.prototype._setInitialName = function () {
                            this._name = 'instance' + this.sec.flash.display.DisplayObject.axClass._instanceID++;
                        };
                        DisplayObject.prototype._setParent = function (parent, depth) {
                            var oldParent = this._parent;
                            release || assert(parent !== this);
                            this._parent = parent;
                            this._setDepth(depth);
                            if (parent) {
                                this._addReference();
                                var bubblingFlags = 0    /* None */;
                                if (this._hasFlags(8192    /* HasFrameScriptPending */)) {
                                    bubblingFlags |= 16384    /* ContainsFrameScriptPendingChildren */;
                                }
                                if (this._hasAnyDirtyFlags(1023    /* Dirty */)) {
                                    bubblingFlags |= 536870912    /* DirtyDescendents */;
                                }
                                if (this._hasAnyFlags(536920064    /* Bubbling */)) {
                                    bubblingFlags |= this._flags & 536920064    /* Bubbling */;
                                }
                                if (bubblingFlags) {
                                    parent._propagateFlagsUp(bubblingFlags);
                                }
                            }
                            if (oldParent) {
                                this._removeReference();
                            }
                        };
                        DisplayObject.prototype._setDepth = function (value) {
                            if (value > -1) {
                                this._setFlags(2048    /* OwnedByTimeline */);
                            } else {
                                this._removeFlags(2048    /* OwnedByTimeline */);
                            }
                            this._depth = value;
                        };
                        DisplayObject.prototype._setFillAndLineBoundsFromWidthAndHeight = function (width, height) {
                            this._fillBounds.width = width;
                            this._fillBounds.height = height;
                            this._lineBounds.width = width;
                            this._lineBounds.height = height;
                            this._removeFlags(2    /* InvalidLineBounds */ | 4    /* InvalidFillBounds */);
                            this._invalidateParentFillAndLineBounds(true, true);
                        };
                        DisplayObject.prototype._setFillAndLineBoundsFromSymbol = function (symbol) {
                            release || assert(symbol.fillBounds || symbol.lineBounds, 'Fill or Line bounds are not defined in the symbol.');
                            if (symbol.fillBounds) {
                                this._fillBounds.copyFrom(symbol.fillBounds);
                                this._removeFlags(4    /* InvalidFillBounds */);
                            }
                            if (symbol.lineBounds) {
                                this._lineBounds.copyFrom(symbol.lineBounds);
                                this._removeFlags(2    /* InvalidLineBounds */);
                            }
                            this._invalidateParentFillAndLineBounds(!!symbol.fillBounds, !!symbol.lineBounds);
                        };
                        DisplayObject.prototype._setFlags = function (flags) {
                            this._flags |= flags;
                        };
                        /**
                         * Use this to set dirty flags so that we can also propagate the dirty child bit.
                         */
                        DisplayObject.prototype._setDirtyFlags = function (flags) {
                            this._dirtyFlags |= flags;
                            if (this._parent) {
                                // Notify parent that it has a dirty descendent.
                                this._parent._propagateFlagsUp(536870912    /* DirtyDescendents */);
                            }
                        };
                        DisplayObject.prototype._removeDirtyFlags = function (flags) {
                            this._dirtyFlags &= ~flags;
                        };
                        DisplayObject.prototype._hasDirtyFlags = function (flags) {
                            return (this._dirtyFlags & flags) === flags;
                        };
                        DisplayObject.prototype._hasAnyDirtyFlags = function (flags) {
                            return !!(this._dirtyFlags & flags);
                        };
                        DisplayObject.prototype._toggleFlags = function (flags, on) {
                            if (on) {
                                this._flags |= flags;
                            } else {
                                this._flags &= ~flags;
                            }
                        };
                        DisplayObject.prototype._removeFlags = function (flags) {
                            this._flags &= ~flags;
                        };
                        DisplayObject.prototype._hasFlags = function (flags) {
                            return (this._flags & flags) === flags;
                        };
                        DisplayObject.prototype._hasAnyFlags = function (flags) {
                            return !!(this._flags & flags);
                        };
                        /**
                         * Propagates flags up the display list. Propagation stops if all flags are already set.
                         */
                        DisplayObject.prototype._propagateFlagsUp = function (flags) {
                            if (this._hasFlags(flags)) {
                                return;
                            }
                            this._setFlags(flags);
                            var parent = this._parent;
                            if (parent) {
                                parent._propagateFlagsUp(flags);
                            }
                        };
                        /**
                         * Propagates flags down the display list. Non-containers just set the flags on themselves.
                         *
                         * Overridden in DisplayObjectContainer.
                         */
                        DisplayObject.prototype._propagateFlagsDown = function (flags) {
                            this._setFlags(flags);
                        };
                        /**
                         * Finds the nearest ancestor with a given set of flags that are either turned on or off.
                         */
                        DisplayObject.prototype._findNearestAncestor = function (flags, on) {
                            var node = this;
                            while (node) {
                                if (node._hasFlags(flags) === on) {
                                    return node;
                                }
                                node = node._parent;
                            }
                            return null;
                        };
                        DisplayObject.prototype._findFurthestAncestorOrSelf = function () {
                            var node = this;
                            while (node) {
                                if (!node._parent) {
                                    return node;
                                }
                                node = node._parent;
                            }
                        };
                        /**
                         * Tests if this display object is an ancestor of the specified display object.
                         */
                        DisplayObject.prototype._isAncestor = function (child) {
                            var node = child;
                            while (node) {
                                if (node === this) {
                                    return true;
                                }
                                node = node._parent;
                            }
                            return false;
                        };
                        /**
                         * Clamps the rotation value to the range (-180, 180).
                         */
                        DisplayObject._clampRotation = function (value) {
                            value %= 360;
                            if (value > 180) {
                                value -= 360;
                            } else if (value < -180) {
                                value += 360;
                            }
                            return value;
                        };
                        /**
                         * Return's a list of ancestors excluding the |last|, the return list is reused.
                         */
                        DisplayObject._getAncestors = function (node, last) {
                            var path = DisplayObject._path;
                            path.length = 0;
                            while (node && node !== last) {
                                path.push(node);
                                node = node._parent;
                            }
                            release || assert(node === last, 'Last ancestor is not an ancestor.');
                            return path;
                        };
                        /**
                         * Computes the combined transformation matrixes of this display object and all of its parents.
                         * It is not the same as |transform.concatenatedMatrix|, the latter also includes the screen
                         * space matrix.
                         */
                        DisplayObject.prototype._getConcatenatedMatrix = function () {
                            if (this._hasFlags(32    /* InvalidConcatenatedMatrix */)) {
                                if (this._parent) {
                                    this._parent._getConcatenatedMatrix().preMultiplyInto(this._getMatrix(), this._concatenatedMatrix);
                                } else {
                                    this._concatenatedMatrix.copyFrom(this._getMatrix());
                                }
                                this._removeFlags(32    /* InvalidConcatenatedMatrix */);
                            }
                            return this._concatenatedMatrix;
                        };
                        DisplayObject.prototype._getInvertedConcatenatedMatrix = function () {
                            if (this._hasFlags(64    /* InvalidInvertedConcatenatedMatrix */)) {
                                this._getConcatenatedMatrix().invertInto(this._invertedConcatenatedMatrix);
                                this._removeFlags(64    /* InvalidInvertedConcatenatedMatrix */);
                            }
                            return this._invertedConcatenatedMatrix;
                        };
                        DisplayObject.prototype._setMatrix = function (matrix, toTwips) {
                            if (!toTwips && this._matrix.equals(matrix)) {
                                // No need to dirty the matrix if it's equal to the current matrix.
                                return;
                            }
                            var m = this._matrix;
                            m.copyFrom(matrix);
                            if (toTwips) {
                                m.toTwipsInPlace();
                            }
                            this._scaleX = m.getScaleX();
                            this._scaleY = m.getScaleY();
                            this._skewX = matrix.getSkewX();
                            this._skewY = matrix.getSkewY();
                            this._rotation = DisplayObject._clampRotation(this._skewY * 180 / Math.PI);
                            this._removeFlags(8    /* InvalidMatrix */);
                            this._setFlags(16    /* InvalidInvertedMatrix */);
                            this._setDirtyFlags(1    /* DirtyMatrix */);
                            this._invalidatePosition();
                        };
                        /**
                         * Returns an updated matrix if the current one is invalid.
                         */
                        DisplayObject.prototype._getMatrix = function () {
                            if (this._hasFlags(8    /* InvalidMatrix */)) {
                                this._matrix.updateScaleAndRotation(this._scaleX, this._scaleY, this._skewX, this._skewY);
                                this._removeFlags(8    /* InvalidMatrix */);
                            }
                            return this._matrix;
                        };
                        DisplayObject.prototype._getInvertedMatrix = function () {
                            if (this._hasFlags(16    /* InvalidInvertedMatrix */)) {
                                this._getMatrix().invertInto(this._invertedMatrix);
                                this._removeFlags(16    /* InvalidInvertedMatrix */);
                            }
                            return this._invertedMatrix;
                        };
                        /**
                         * Computes the combined transformation color matrixes of this display object and all of its
                         * ancestors.
                         */
                        DisplayObject.prototype._getConcatenatedColorTransform = function () {
                            if (!this.stage) {
                                return this._colorTransform.clone();
                            }
                            // Compute the concatenated color transforms for this node and all of its ancestors.
                            if (this._hasFlags(128    /* InvalidConcatenatedColorTransform */)) {
                                var ancestor = this._findNearestAncestor(128    /* InvalidConcatenatedColorTransform */, false);
                                var path = DisplayObject._getAncestors(this, ancestor);
                                var i = path.length - 1;
                                var stageClass = this.sec.flash.display.Stage;
                                if (stageClass.axIsType(path[i])) {
                                    i--;
                                }
                                var m = ancestor && !stageClass.axIsType(ancestor) ? ancestor._concatenatedColorTransform.clone() : new this.sec.flash.geom.ColorTransform();
                                while (i >= 0) {
                                    ancestor = path[i--];
                                    release || assert(ancestor._hasFlags(128    /* InvalidConcatenatedColorTransform */));
                                    m.preMultiply(ancestor._colorTransform);
                                    m.convertToFixedPoint();
                                    ancestor._concatenatedColorTransform.copyFrom(m);
                                    ancestor._removeFlags(128    /* InvalidConcatenatedColorTransform */);
                                }
                            }
                            return this._concatenatedColorTransform;
                        };
                        DisplayObject.prototype._setColorTransform = function (colorTransform) {
                            if (this._colorTransform.equals(colorTransform)) {
                                return;
                            }
                            this._colorTransform.copyFrom(colorTransform);
                            this._colorTransform.convertToFixedPoint();
                            this._propagateFlagsDown(128    /* InvalidConcatenatedColorTransform */);
                            this._setDirtyFlags(64    /* DirtyColorTransform */);
                        };
                        /**
                         * Invalidates the fill- and lineBounds of this display object along with all of its ancestors.
                         */
                        DisplayObject.prototype._invalidateFillAndLineBounds = function (fill, line) {
                            /* TODO: We should only propagate this bit if the bounds are actually changed. We can do the
                             * bounds computation eagerly if the number of children is low. If there are no changes in the
                             * bounds we don't need to propagate the bit. */
                            this._propagateFlagsUp((line ? 2    /* InvalidLineBounds */ : 0) | (fill ? 4    /* InvalidFillBounds */ : 0));
                        };
                        DisplayObject.prototype._invalidateParentFillAndLineBounds = function (fill, line) {
                            if (this._parent) {
                                this._parent._invalidateFillAndLineBounds(fill, line);
                            }
                        };
                        /**
                         * Computes the bounding box for all of this display object's content, its graphics and all of
                         * its children.
                         */
                        DisplayObject.prototype._getContentBounds = function (includeStrokes) {
                            if (includeStrokes === void 0) {
                                includeStrokes = true;
                            }
                            // Tobias: What about filters?
                            var invalidFlag;
                            var bounds;
                            if (includeStrokes) {
                                invalidFlag = 2    /* InvalidLineBounds */;
                                bounds = this._lineBounds;
                            } else {
                                invalidFlag = 4    /* InvalidFillBounds */;
                                bounds = this._fillBounds;
                            }
                            if (this._hasFlags(invalidFlag)) {
                                var graphics = this._getGraphics();
                                if (graphics) {
                                    bounds.copyFrom(graphics._getContentBounds(includeStrokes));
                                } else {
                                    bounds.setToSentinels();
                                }
                                this._getChildBounds(bounds, includeStrokes);
                                this._removeFlags(invalidFlag);
                            }
                            return bounds;
                        };
                        /**
                         * Empty base case: DisplayObject cannot have children, but several distinct subclasses can.
                         * Overridden in DisplayObjectContainer, SimpleButton, and AVM1Movie.
                         */
                        DisplayObject.prototype._getChildBounds = function (bounds, includeStrokes) {
                        };
                        /**
                         * Gets the bounds of this display object relative to another coordinate space. The
                         * transformation matrix from the local coordinate space to the target coordinate space is
                         * computed using:
                         *
                         *   this.concatenatedMatrix * inverse(target.concatenatedMatrix)
                         *
                         * If the |targetCoordinateSpace| is |null| then assume the identity coordinate space.
                         */
                        DisplayObject.prototype._getTransformedBounds = function (targetCoordinateSpace, includeStroke) {
                            var bounds = this._getContentBounds(includeStroke).clone();
                            if (targetCoordinateSpace === this || bounds.isEmpty()) {
                                return bounds;
                            }
                            var m;
                            if (targetCoordinateSpace) {
                                m = this.sec.flash.geom.Matrix.axClass.TEMP_MATRIX;
                                var invertedTargetMatrix = targetCoordinateSpace._getInvertedConcatenatedMatrix();
                                invertedTargetMatrix.preMultiplyInto(this._getConcatenatedMatrix(), m);
                            } else {
                                m = this._getConcatenatedMatrix();
                            }
                            m.transformBounds(bounds);
                            return bounds;
                        };
                        /**
                         * Detaches this object from being animated by the timeline. This happens whenever a display
                         * property of this object is changed by user code.
                         */
                        DisplayObject.prototype._stopTimelineAnimation = function () {
                            this._removeFlags(4096    /* AnimatedByTimeline */);
                        };
                        /**
                         * Marks this object as having its matrix changed.
                         *
                         * Propagates flags both up- and (via invalidatePosition) downwards, so is quite costly.
                         * TODO: check if we can usefully combine all upwards-propagated flags here.
                         */
                        DisplayObject.prototype._invalidateMatrix = function () {
                            this._setDirtyFlags(1    /* DirtyMatrix */);
                            this._setFlags(8    /* InvalidMatrix */ | 16    /* InvalidInvertedMatrix */);
                            this._invalidatePosition();
                        };
                        /**
                         * Marks this object as having been moved in its parent display object.
                         */
                        DisplayObject.prototype._invalidatePosition = function () {
                            this._propagateFlagsDown(32    /* InvalidConcatenatedMatrix */ | 64    /* InvalidInvertedConcatenatedMatrix */);
                            this._invalidateParentFillAndLineBounds(true, true);
                        };
                        /**
                         * Animates this object's display properties.
                         */
                        DisplayObject.prototype._animate = function (placeObjectTag) {
                            release || assert(this._hasFlags(4096    /* AnimatedByTimeline */));
                            var reset = !(placeObjectTag.flags & 1    /* Move */) && placeObjectTag.flags & 2    /* HasCharacter */;
                            var matrixClass = this.sec.flash.geom.Matrix.axClass;
                            if (placeObjectTag.flags & 4    /* HasMatrix */) {
                                matrixClass.TEMP_MATRIX.copyFromUntyped(placeObjectTag.matrix);
                                this._setMatrix(matrixClass.TEMP_MATRIX, false);
                            } else if (reset) {
                                this._setMatrix(matrixClass.FROZEN_IDENTITY_MATRIX, false);
                            }
                            var colorTransformClass = this.sec.flash.geom.ColorTransform.axClass;
                            if (placeObjectTag.flags & 8    /* HasColorTransform */) {
                                colorTransformClass.TEMP_COLOR_TRANSFORM.copyFromUntyped(placeObjectTag.cxform);
                                this._setColorTransform(colorTransformClass.TEMP_COLOR_TRANSFORM);
                            } else if (reset) {
                                this._setColorTransform(colorTransformClass.FROZEN_IDENTITY_COLOR_TRANSFORM);
                            }
                            if (placeObjectTag.flags & 16    /* HasRatio */ || reset) {
                                var ratio = placeObjectTag.ratio | 0;
                                if (ratio !== this._ratio) {
                                    release || assert(ratio >= 0 && ratio <= 65535);
                                    this._ratio = ratio;
                                    this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                                }
                            }
                            if (placeObjectTag.flags & 64    /* HasClipDepth */ || reset) {
                                var clipDepth = placeObjectTag.clipDepth === undefined ? -1 : placeObjectTag.clipDepth;
                                if (clipDepth !== this._clipDepth) {
                                    this._clipDepth = clipDepth;
                                    this._setDirtyFlags(256    /* DirtyClipDepth */);
                                }
                            }
                            if (placeObjectTag.flags & 256    /* HasFilterList */) {
                                var filtersPackage = this.sec.flash.filters;
                                var filters = [];
                                var swfFilters = placeObjectTag.filters;
                                for (var i = 0; i < swfFilters.length; i++) {
                                    var obj = swfFilters[i];
                                    var filter;
                                    switch (obj.type) {
                                    case 0:
                                        filter = filtersPackage.DropShadowFilter.axClass.FromUntyped(obj);
                                        break;
                                    case 1:
                                        filter = filtersPackage.BlurFilter.axClass.FromUntyped(obj);
                                        break;
                                    case 2:
                                        filter = filtersPackage.GlowFilter.axClass.FromUntyped(obj);
                                        break;
                                    case 3:
                                        filter = filtersPackage.BevelFilter.axClass.FromUntyped(obj);
                                        break;
                                    case 4:
                                        filter = filtersPackage.GradientGlowFilter.axClass.FromUntyped(obj);
                                        break;
                                    case 5:
                                        filter = filtersPackage.ConvolutionFilter.axClass.FromUntyped(obj);
                                        break;
                                    case 6:
                                        filter = filtersPackage.ColorMatrixFilter.axClass.FromUntyped(obj);
                                        break;
                                    case 7:
                                        filter = filtersPackage.GradientBevelFilter.axClass.FromUntyped(obj);
                                        break;
                                    default:
                                        release || assert(filter, 'Unknown filter type.');
                                    }
                                    filters.push(filter);
                                }
                                this._filters = filters;
                                this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                            } else if (reset && this._filters) {
                                this._filters = null;
                                this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                            }
                            if (placeObjectTag.flags & 512    /* HasBlendMode */ || reset) {
                                var blendMode = flash.display.BlendMode.fromNumber(placeObjectTag.blendMode === undefined ? 1 : placeObjectTag.blendMode);
                                if (blendMode !== this._blendMode) {
                                    this._blendMode = blendMode;
                                    this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                                }
                            }
                            if (placeObjectTag.flags & 1024    /* HasCacheAsBitmap */ || reset) {
                                var cacheAsBitmap = placeObjectTag.bmpCache > 0;
                                if (cacheAsBitmap !== this._hasFlags(65536    /* CacheAsBitmap */)) {
                                    this._toggleFlags(65536    /* CacheAsBitmap */, cacheAsBitmap);
                                    this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                                }
                            }
                            if (placeObjectTag.flags & 8192    /* HasVisible */ || reset) {
                                var visible = placeObjectTag.visibility === undefined || placeObjectTag.visibility;
                                if (visible !== this._hasFlags(1    /* Visible */)) {
                                    this._toggleFlags(1    /* Visible */, visible);
                                    this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                                }
                            }
                        };
                        /**
                         * Dispatches an event on this object and all its descendants.
                         */
                        DisplayObject.prototype._propagateEvent = function (event) {
                            this.visit(function (node) {
                                node.dispatchEvent(event);
                                return 0    /* Continue */;
                            }, 0    /* None */);
                        };
                        Object.defineProperty(DisplayObject.prototype, 'x', {
                            get: function () {
                                return this._getX();
                            },
                            set: function (value) {
                                value = value * 20 | 0;
                                this._stopTimelineAnimation();
                                if (this._canHaveTextContent()) {
                                    var bounds = this._getContentBounds();
                                    value -= bounds.xMin;
                                }
                                if (value === this._matrix.tx) {
                                    return;
                                }
                                this._matrix.tx = value;
                                this._invertedMatrix.tx = -value;
                                this._invalidatePosition();
                                this._setDirtyFlags(1    /* DirtyMatrix */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype._getX = function () {
                            var value = this._matrix.tx;
                            if (this._canHaveTextContent()) {
                                var bounds = this._getContentBounds();
                                value += bounds.xMin;
                            }
                            return value / 20;
                        };
                        Object.defineProperty(DisplayObject.prototype, 'y', {
                            get: function () {
                                return this._getY();
                            },
                            set: function (value) {
                                value = value * 20 | 0;
                                this._stopTimelineAnimation();
                                if (this._canHaveTextContent()) {
                                    var bounds = this._getContentBounds();
                                    value -= bounds.yMin;
                                }
                                if (value === this._matrix.ty) {
                                    return;
                                }
                                this._matrix.ty = value;
                                this._invertedMatrix.ty = -value;
                                this._invalidatePosition();
                                this._setDirtyFlags(1    /* DirtyMatrix */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype._getY = function () {
                            var value = this._matrix.ty;
                            if (this._canHaveTextContent()) {
                                var bounds = this._getContentBounds();
                                value += bounds.yMin;
                            }
                            return value / 20;
                        };
                        Object.defineProperty(DisplayObject.prototype, 'scaleX', {
                            /**
                             * In Flash player, this always returns a positive number for some reason. This however, is not
                             * the case for scaleY.
                             */
                            get: function () {
                                return Math.abs(this._scaleX);
                            },
                            set: function (value) {
                                value = +value;
                                this._stopTimelineAnimation();
                                if (value === this._scaleX) {
                                    return;
                                }
                                this._scaleX = value;
                                this._invalidateMatrix();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'scaleY', {
                            get: function () {
                                return this._scaleY;
                            },
                            set: function (value) {
                                value = +value;
                                this._stopTimelineAnimation();
                                if (value === this._scaleY) {
                                    return;
                                }
                                this._scaleY = value;
                                this._invalidateMatrix();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'scaleZ', {
                            get: function () {
                                return this._scaleZ;
                            },
                            set: function (value) {
                                value = +value;
                                release || somewhatImplemented('public DisplayObject::set scaleZ');
                                this._scaleZ = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'rotation', {
                            get: function () {
                                return this._rotation;
                            },
                            set: function (value) {
                                value = +value;
                                this._stopTimelineAnimation();
                                value = DisplayObject._clampRotation(value);
                                if (value === this._rotation) {
                                    return;
                                }
                                var delta = value - this._rotation;
                                var angle = delta / 180 * Math.PI;
                                this._skewX += angle;
                                this._skewY += angle;
                                this._rotation = value;
                                this._invalidateMatrix();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'rotationX', {
                            get: function () {
                                return this._rotationX;
                            },
                            set: function (value) {
                                value = +value;
                                release || somewhatImplemented('public DisplayObject::set rotationX');
                                this._rotationZ = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'rotationY', {
                            get: function () {
                                return this._rotationY;
                            },
                            set: function (value) {
                                value = +value;
                                release || somewhatImplemented('public DisplayObject::set rotationY');
                                this._rotationY = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'rotationZ', {
                            get: function () {
                                return this._rotationZ;
                            },
                            set: function (value) {
                                value = +value;
                                release || somewhatImplemented('public DisplayObject::set rotationZ');
                                this._rotationZ = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'width', {
                            /**
                             * The width of this display object in its parent coordinate space.
                             */
                            get: function () {
                                return this._getWidth();
                            },
                            /**
                             * Attempts to change the width of this display object by changing its scaleX / scaleY
                             * properties. The scaleX property is set to the specified |width| value / baseWidth
                             * of the object in its parent cooridnate space with rotation applied.
                             */
                            set: function (value) {
                                this._setWidth(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // `get width` is overriden in `Stage` and has to be able to call this.
                        DisplayObject.prototype._getWidth = function () {
                            return this._getTransformedBounds(this._parent, true).width / 20;
                        };
                        // `set width` is overriden in `Stage` and has to be able to call this.
                        DisplayObject.prototype._setWidth = function (value) {
                            value = value * 20 | 0;
                            this._stopTimelineAnimation();
                            if (value < 0) {
                                return;
                            }
                            var contentBounds = this._getContentBounds(true);
                            if (this._canHaveTextContent()) {
                                var bounds = this._getContentBounds();
                                this._setFillAndLineBoundsFromWidthAndHeight(value, contentBounds.height);
                                return;
                            }
                            var bounds = this._getTransformedBounds(this._parent, true);
                            var angle = this._rotation / 180 * Math.PI;
                            var baseWidth = contentBounds.getBaseWidth(angle);
                            if (!baseWidth) {
                                return;
                            }
                            var baseHeight = contentBounds.getBaseHeight(angle);
                            this._scaleY = bounds.height / baseHeight;
                            this._scaleX = value / baseWidth;
                            this._invalidateMatrix();
                        };
                        Object.defineProperty(DisplayObject.prototype, 'height', {
                            /**
                             * The height of this display object in its parent coordinate space.
                             */
                            get: function () {
                                return this._getHeight();
                            },
                            /**
                             * Attempts to change the height of this display object by changing its scaleY / scaleX
                             * properties. The scaleY property is set to the specified |height| value / baseHeight
                             * of the object in its parent cooridnate space with rotation applied.
                             */
                            set: function (value) {
                                this._setHeight(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // `get height` is overriden in `Stage` and has to be able to call this.
                        DisplayObject.prototype._getHeight = function () {
                            var bounds = this._getTransformedBounds(this._parent, true);
                            return bounds.height / 20;
                        };
                        // `set height` is overriden in `Stage` and has to be able to call this.
                        DisplayObject.prototype._setHeight = function (value) {
                            value = value * 20 | 0;
                            this._stopTimelineAnimation();
                            if (value < 0) {
                                return;
                            }
                            var contentBounds = this._getContentBounds(true);
                            if (this._canHaveTextContent()) {
                                var bounds = this._getContentBounds();
                                this._setFillAndLineBoundsFromWidthAndHeight(contentBounds.width, value);
                                return;
                            }
                            var bounds = this._getTransformedBounds(this._parent, true);
                            var angle = this._rotation / 180 * Math.PI;
                            var baseHeight = contentBounds.getBaseHeight(angle);
                            if (!baseHeight) {
                                return;
                            }
                            var baseWidth = contentBounds.getBaseWidth(angle);
                            this._scaleY = value / baseHeight;
                            this._scaleX = bounds.width / baseWidth;
                            this._invalidateMatrix();
                        };
                        Object.defineProperty(DisplayObject.prototype, 'mask', {
                            get: function () {
                                return this._mask;
                            },
                            /**
                             * Sets the mask for this display object. This does not affect the bounds.
                             */
                            set: function (value) {
                                if (this._mask === value || value === this) {
                                    return;
                                }
                                if (value && value._maskedObject) {
                                    value._maskedObject.mask = null;
                                }
                                if (this._mask) {
                                    this._mask._maskedObject = null;
                                }
                                this._mask = value;
                                if (value) {
                                    value._maskedObject = this;
                                }
                                this._setDirtyFlags(128    /* DirtyMask */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'transform', {
                            get: function () {
                                return this._getTransform();
                            },
                            set: function (value) {
                                this._stopTimelineAnimation();
                                if (value.matrix3D) {
                                    this._matrix3D = value.matrix3D;
                                } else {
                                    this._setMatrix(value.matrix, true);
                                }
                                this._setColorTransform(value.colorTransform);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype._getTransform = function () {
                            return new this.sec.flash.geom.Transform(this);
                        };
                        DisplayObject.prototype.destroy = function () {
                            this._setFlags(512    /* Destroyed */);
                        };
                        Object.defineProperty(DisplayObject.prototype, 'root', {
                            /**
                             * Walks up the tree to find this display object's root. An object is classified
                             * as a root if its _root property points to itself. Root objects are the Stage,
                             * the main timeline object and a Loader's content.
                             */
                            get: function () {
                                var node = this;
                                do {
                                    if (node._root === node) {
                                        return node;
                                    }
                                    node = node._parent;
                                } while (node);
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'stage', {
                            /**
                             * Walks up the tree to find this display object's stage, the first object whose
                             * |_stage| property points to itself.
                             */
                            get: function () {
                                var node = this;
                                do {
                                    if (node._stage === node) {
                                        release || assert(this.sec.flash.display.Stage.axIsType(node));
                                        return node;
                                    }
                                    node = node._parent;
                                } while (node);
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'name', {
                            get: function () {
                                return this._name;
                            },
                            set: function (value) {
                                checkNullParameter(value, 'name', this.sec);
                                if (this._hasFlags(2048    /* OwnedByTimeline */)) {
                                    // In AVM2, setting the name of a timline-placed DisplayObject throws.
                                    if (this._symbol && !this._symbol.isAVM1Object) {
                                        this.sec.throwError('IllegalOperationError', AVMX.Errors.TimelineObjectNameSealedError);
                                    }
                                    return;
                                }
                                this._name = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'parent', {
                            get: function () {
                                return this._parent;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'alpha', {
                            get: function () {
                                return this._colorTransform.alphaMultiplier;
                            },
                            set: function (value) {
                                this._stopTimelineAnimation();
                                value = +value;
                                if (value === this._colorTransform.alphaMultiplier) {
                                    return;
                                }
                                this._colorTransform.alphaMultiplier = value;
                                this._colorTransform.convertToFixedPoint();
                                this._propagateFlagsDown(128    /* InvalidConcatenatedColorTransform */);
                                this._setDirtyFlags(64    /* DirtyColorTransform */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'blendMode', {
                            get: function () {
                                return this._blendMode;
                            },
                            set: function (value) {
                                this._stopTimelineAnimation();
                                value = axCoerceString(value);
                                if (value === this._blendMode) {
                                    return;
                                }
                                if (display.BlendMode.toNumber(value) < 0) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidEnumError, 'blendMode');
                                }
                                this._blendMode = value;
                                this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'scale9Grid', {
                            get: function () {
                                return this._getScale9Grid();
                            },
                            set: function (innerRectangle) {
                                this._stopTimelineAnimation();
                                this._scale9Grid = Bounds.FromRectangle(innerRectangle);
                                this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype._getScale9Grid = function () {
                            var rectangleClass = this.sec.flash.geom.Rectangle.axClass;
                            return this._scale9Grid ? rectangleClass.FromBounds(this._scale9Grid) : null;
                        };
                        Object.defineProperty(DisplayObject.prototype, 'cacheAsBitmap', {
                            /**
                             * This is always true if a filter is applied.
                             */
                            get: function () {
                                return this._getCacheAsBitmap();
                            },
                            set: function (value) {
                                if (this._hasFlags(65536    /* CacheAsBitmap */)) {
                                    return;
                                }
                                this._toggleFlags(65536    /* CacheAsBitmap */, !!value);
                                this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype._getCacheAsBitmap = function () {
                            return this._filters && this._filters.length > 0 || this._hasFlags(65536    /* CacheAsBitmap */);
                        };
                        Object.defineProperty(DisplayObject.prototype, 'filters', {
                            /**
                             * References to the internal |_filters| array and its BitmapFilter objects are never leaked
                             * outside of this class. The get/set filters accessors always return deep clones of this
                             * array.
                             */
                            get: function () {
                                return this._getFilters();
                            },
                            set: function (value_) {
                                var value = value_ ? value_.value : null;
                                if (!this._filters) {
                                    this._filters = [];
                                }
                                var changed = false;
                                if (isNullOrUndefined(value)) {
                                    changed = this._filters.length > 0;
                                    this._filters.length = 0;
                                } else {
                                    var bitmapFilterClass = this.sec.flash.filters.BitmapFilter.axClass;
                                    this._filters = value.map(function (x) {
                                        if (!bitmapFilterClass.axIsType(x)) {
                                            this.sec.throwError('TypeError', AVMX.Errors.ParamTypeError, '0', 'Filter');
                                        }
                                        return x.clone();
                                    });
                                    changed = true;
                                }
                                if (changed) {
                                    this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype._getFilters = function () {
                            var filters = this._filters ? this._filters.map(function (x) {
                                return x.clone();
                            }) : [];
                            return this.sec.createArray(filters);
                        };
                        Object.defineProperty(DisplayObject.prototype, 'visible', {
                            get: function () {
                                return this._hasFlags(1    /* Visible */);
                            },
                            /**
                             * Marks this display object as visible / invisible. This does not affect the bounds.
                             */
                            set: function (value) {
                                value = !!value;
                                if (value === this._hasFlags(1    /* Visible */)) {
                                    return;
                                }
                                this._toggleFlags(1    /* Visible */, value);
                                this._setDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'z', {
                            get: function () {
                                return this._z;
                            },
                            set: function (value) {
                                value = +value;
                                this._z = value;
                                release || somewhatImplemented('public DisplayObject::set z');
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype.getBounds = function (targetCoordinateSpace) {
                            targetCoordinateSpace = targetCoordinateSpace || this;
                            var rectangleClass = this.sec.flash.geom.Rectangle.axClass;
                            return rectangleClass.FromBounds(this._getTransformedBounds(targetCoordinateSpace, true));
                        };
                        DisplayObject.prototype.getRect = function (targetCoordinateSpace) {
                            targetCoordinateSpace = targetCoordinateSpace || this;
                            var rectangleClass = this.sec.flash.geom.Rectangle.axClass;
                            return rectangleClass.FromBounds(this._getTransformedBounds(targetCoordinateSpace, false));
                        };
                        /**
                         * Converts a point from the global coordinate space into the local coordinate space.
                         */
                        DisplayObject.prototype.globalToLocal = function (point) {
                            var m = this._getInvertedConcatenatedMatrix();
                            var p = m.transformPointInPlace(point.clone().toTwips()).round();
                            return p.toPixels();
                        };
                        /**
                         * Converts a point form the local coordinate sapce into the global coordinate space.
                         */
                        DisplayObject.prototype.localToGlobal = function (point) {
                            var m = this._getConcatenatedMatrix();
                            var p = m.transformPointInPlace(point.clone().toTwips()).round();
                            return p.toPixels();
                        };
                        DisplayObject.prototype.globalToLocal3D = function (point) {
                            release || notImplemented('public DisplayObject::globalToLocal3D');
                            return null;
                        };
                        DisplayObject.prototype.localToGlobal3D = function (point) {
                            release || notImplemented('public DisplayObject::localToGlobal3D');
                            return null;
                        };
                        DisplayObject.prototype.local3DToGlobal = function (point3d) {
                            release || notImplemented('public DisplayObject::local3DToGlobal');
                            return null;
                        };
                        /**
                         * Tree visitor that lets you skip nodes or return early.
                         */
                        DisplayObject.prototype.visit = function (visitor, visitorFlags, displayObjectFlags) {
                            if (displayObjectFlags === void 0) {
                                displayObjectFlags = 0    /* None */;
                            }
                            var stack;
                            var displayObject;
                            var displayObjectContainer;
                            var frontToBack = visitorFlags & 8    /* FrontToBack */;
                            stack = [this];
                            while (stack.length > 0) {
                                displayObject = stack.pop();
                                var flags = 0    /* None */;
                                if (visitorFlags & 16    /* Filter */ && !displayObject._hasAnyFlags(displayObjectFlags)) {
                                    flags = 2    /* Skip */;
                                } else {
                                    flags = visitor(displayObject);
                                }
                                if (flags === 0    /* Continue */) {
                                    var children = displayObject._children;
                                    if (children) {
                                        var length = children.length;
                                        for (var i = 0; i < length; i++) {
                                            var child = children[frontToBack ? i : length - 1 - i];
                                            stack.push(child);
                                        }
                                    }
                                } else if (flags === 1    /* Stop */) {
                                    return;
                                }
                            }
                        };
                        Object.defineProperty(DisplayObject.prototype, 'loaderInfo', {
                            /**
                             * Returns the loader info for this display object's root.
                             */
                            get: function () {
                                var root = this.root;
                                if (root) {
                                    release || assert(root._loaderInfo, 'No LoaderInfo object found on root.');
                                    return root._loaderInfo;
                                }
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * Only these objects can have graphics.
                         */
                        DisplayObject.prototype._canHaveGraphics = function () {
                            return false;
                        };
                        /**
                         * Gets the graphics object of this object. Shapes, MorphShapes, and Sprites override this.
                         */
                        DisplayObject.prototype._getGraphics = function () {
                            return null;
                        };
                        /**
                         * Only these objects can have text content.
                         */
                        DisplayObject.prototype._canHaveTextContent = function () {
                            return false;
                        };
                        /**
                         * Gets the text content of this object. StaticTexts and TextFields override this.
                         */
                        DisplayObject.prototype._getTextContent = function () {
                            return null;
                        };
                        /**
                         * Lazily construct a graphics object.
                         */
                        DisplayObject.prototype._ensureGraphics = function () {
                            release || assert(this._canHaveGraphics());
                            if (this._graphics) {
                                return this._graphics;
                            }
                            this._graphics = new this.sec.flash.display.Graphics();
                            this._graphics._setParent(this);
                            this._invalidateFillAndLineBounds(true, true);
                            this._setDirtyFlags(4    /* DirtyGraphics */);
                            return this._graphics;
                        };
                        /**
                         * Sets this object's graphics or text content. Happens when an animated Shape or StaticText
                         * object is initialized from a symbol or replaced by a timeline command using the same symbol
                         * as this object was initialized from.
                         */
                        DisplayObject.prototype._setStaticContentFromSymbol = function (symbol) {
                            release || assert(!symbol.dynamic);
                            if (symbol instanceof flash.display.ShapeSymbol) {
                                release || assert(this._canHaveGraphics());
                                var newGraphics = symbol.graphics;
                                if (this._graphics === newGraphics) {
                                    return;
                                }
                                this._graphics = newGraphics;
                                this._setDirtyFlags(4    /* DirtyGraphics */);
                            } else if (symbol instanceof flash.text.TextSymbol) {
                                release || assert(this.sec.flash.text.StaticText.axIsType(this));
                                var newTextContent = symbol.textContent;
                                if (this._textContent === newTextContent) {
                                    return;
                                }
                                this._textContent = newTextContent;
                                this._setDirtyFlags(8    /* DirtyTextContent */);
                            }
                            this._symbol = symbol;
                            this._setFillAndLineBoundsFromSymbol(symbol);
                        };
                        /**
                         * Checks if the bounding boxes of two display objects overlap, this happens in the global
                         * coordinate coordinate space.
                         *
                         * Two objects overlap even if one or both are not on the stage, as long as their bounds
                         * in the global coordinate space overlap.
                         */
                        DisplayObject.prototype.hitTestObject = function (other) {
                            release || assert(other && this.sec.flash.display.DisplayObject.axIsType(other));
                            var a = this, b = other;
                            var aBounds = a._getContentBounds(false).clone();
                            var bBounds = b._getContentBounds(false).clone();
                            a._getConcatenatedMatrix().transformBounds(aBounds);
                            b._getConcatenatedMatrix().transformBounds(bBounds);
                            return aBounds.intersects(bBounds);
                        };
                        /**
                         * The |globalX| and |globalY| arguments are in global coordinates. The |shapeFlag| indicates
                         * whether the hit test should be on the actual shape of the object or just its bounding box.
                         *
                         * Note: shapeFlag is optional, but the type coercion will do the right thing for it, so we
                         * don't need to take the overhead from being explicit about that.
                         */
                        DisplayObject.prototype.hitTestPoint = function (globalX, globalY, shapeFlag) {
                            globalX = +globalX * 20 | 0;
                            globalY = +globalY * 20 | 0;
                            shapeFlag = !!shapeFlag;
                            var testingType = shapeFlag ? 2    /* HitTestShape */ : 0    /* HitTestBounds */;
                            return !!this._containsGlobalPoint(globalX, globalY, testingType, null);
                        };
                        /**
                         * Internal implementation of all point intersection checks.
                         *
                         * _containsPoint is used for
                         *  - mouse/drop target finding
                         *  - getObjectsUnderPoint
                         *  - hitTestPoint
                         *
                         * Mouse/Drop target finding and getObjectsUnderPoint require checking against the exact shape,
                         * and making sure that the checked coordinates aren't hidden through masking or clipping.
                         *
                         * hitTestPoint never checks for clipping, and masking only for testingType HitTestShape.
                         *
                         * The `objects` object is used for collecting objects for `getObjectsUnderPoint` or looking
                         * for a drop target. If it is supplied, objects for which `_containsPointDirectly` is true are
                         * added to it.
                         *
                         * Overridden in DisplayObjectContainer, Sprite and SimpleButton.
                         */
                        DisplayObject.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                            var result = this._boundsAndMaskContainPoint(globalX, globalY, localX, localY, testingType);
                            // We're done if either we don't have a hit, or if we're only interested in matching bounds
                            // or bounds + mask. That is true for HitTestPoint without shapeFlag set.
                            if (result === 0    /* None */ || testingType < 2    /* HitTestShape */) {
                                return result;
                            }
                            var containsPoint = this._containsPointDirectly(localX, localY, globalX, globalY);
                            if (containsPoint && objects) {
                                if (testingType === 5    /* Drop */) {
                                    // For Drop, replace previous hit with current one.
                                    objects[0] = this;
                                } else if (testingType === 4    /* ObjectsUnderPoint */ || this.sec.flash.display.InteractiveObject.axIsType(this) && this._mouseEnabled) {
                                    // For getObjectsUnderPoint, push all direct hits, for mouse target finding
                                    // InteractiveObjects only.
                                    objects.push(this);
                                }
                            }
                            return containsPoint ? 2    /* Shape */ : result;
                        };
                        DisplayObject.prototype._containsGlobalPoint = function (globalX, globalY, testingType, objects) {
                            var matrix = this._getInvertedConcatenatedMatrix();
                            var localX = matrix.transformX(globalX, globalY);
                            var localY = matrix.transformY(globalX, globalY);
                            return this._containsPoint(globalX, globalY, localX, localY, testingType, objects);
                        };
                        /**
                         * Fast check if a point can intersect the receiver object. Returns true if
                         * - the object is visible OR hit testing is performed for one of the `hitTest{Point,Object}`
                         *   methods.
                         * - the point is within the receiver's bounds
                         * - for testingType values other than HitTestBounds, the point intersects with the a mask,
                         *   if the object has one.
                         *
                         * Note that the callers are expected to have both local and global coordinates available
                         * anyway, so _boundsAndMaskContainPoint takes both to avoid recalculating them.
                         */
                        DisplayObject.prototype._boundsAndMaskContainPoint = function (globalX, globalY, localX, localY, testingType) {
                            if (testingType >= 1    /* HitTestBoundsAndMask */ && this._hasFlags(32768    /* ContainsMorph */)) {
                                // If this display object is a MorphShape or contains at least one descendant that is, then
                                // bailing out too early might lead to a wrong hit test result, since the reported bounds
                                // of MorphShapes are always the one of their start shapes and don't take the current morph
                                // ratio into account. We have to make sure we always hit test MorphShape instances on
                                // graphics level.
                                return 1    /* Bounds */;
                            }
                            if (testingType >= 3    /* Mouse */ && !this._hasFlags(1    /* Visible */) || !this._getContentBounds().contains(localX, localY)) {
                                return 0    /* None */;
                            }
                            if (testingType === 0    /* HitTestBounds */ || !this._mask) {
                                return 1    /* Bounds */;
                            }
                            return this._mask._containsGlobalPoint(globalX, globalY, 1    /* HitTestBoundsAndMask */, null);
                        };
                        /**
                         * Tests if the receiver's own visual content intersects with the given point.
                         * In the base implementation, this just returns false, because not all DisplayObjects can
                         * ever match.
                         * Overridden in Shape, MorphShape, Sprite, Bitmap, Video, and TextField.
                         */
                        DisplayObject.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                            return false;
                        };
                        Object.defineProperty(DisplayObject.prototype, 'scrollRect', {
                            get: function () {
                                return this._getScrollRect();
                            },
                            set: function (value) {
                                value = value;
                                this._scrollRect = value ? value.clone() : null;
                                /* TODO: Figure out how to deal with the bounds and hit testing when scroll rects are applied.
                                 * The Flash implementation appears to be broken. */
                                release || somewhatImplemented('public DisplayObject::set scrollRect');
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype._getScrollRect = function () {
                            return this._scrollRect ? this._scrollRect.clone() : null;
                        };
                        Object.defineProperty(DisplayObject.prototype, 'opaqueBackground', {
                            get: function () {
                                return this._opaqueBackground;
                            },
                            /**
                             * Sets the opaque background color. By default this is |null|, which indicates that no opaque
                             * color is set. Otherwise this is an unsinged number.
                             */
                            set: function (value) {
                                release || assert(value === null || Shumway.isInteger(value));
                                this._opaqueBackground = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * Returns the distance between this object and a given ancestor.
                         */
                        DisplayObject.prototype._getDistance = function (ancestor) {
                            var d = 0;
                            var node = this;
                            while (node && node !== ancestor) {
                                d++;
                                node = node._parent;
                            }
                            return d;
                        };
                        /**
                         * Finds the nearest common ancestor with a given node.
                         */
                        DisplayObject.prototype.findNearestCommonAncestor = function (node) {
                            if (!node) {
                                return null;
                            }
                            var ancestor = this;
                            var d1 = ancestor._getDistance(null);
                            var d2 = node._getDistance(null);
                            while (d1 > d2) {
                                ancestor = ancestor._parent;
                                d1--;
                            }
                            while (d2 > d1) {
                                node = node._parent;
                                d2--;
                            }
                            while (ancestor !== node) {
                                ancestor = ancestor._parent;
                                node = node._parent;
                            }
                            return ancestor;
                        };
                        /**
                         * Returns the current mouse position relative to this object.
                         */
                        DisplayObject.prototype._getLocalMousePosition = function () {
                            var position = this.sec.flash.ui.Mouse.axClass._currentPosition;
                            return this.globalToLocal(position);
                        };
                        Object.defineProperty(DisplayObject.prototype, 'mouseX', {
                            get: function () {
                                return this._getLocalMousePosition().x;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'mouseY', {
                            get: function () {
                                return this._getLocalMousePosition().y;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplayObject.prototype.debugName = function (withFlags) {
                            if (withFlags === void 0) {
                                withFlags = false;
                            }
                            var name = this._id + ' [' + this._depth + ']: (' + this._referenceCount + ') ' + this;
                            if (withFlags) {
                                var flagNames = [];
                                for (var i = 0; i < 32; i++) {
                                    if (this._hasFlags(1 << i)) {
                                        flagNames.push(String([1 << i]));
                                    }
                                }
                                name += ' ' + flagNames.join('|');
                            }
                            return name;
                        };
                        DisplayObject.prototype.debugNameShort = function () {
                            return '[' + this._depth + ':' + this._id + ']: (' + this._referenceCount + ') {' + this._flags + '} ' + this;
                        };
                        DisplayObject.prototype.hashCode = function () {
                            return this.getBounds(null).hashCode();
                        };
                        DisplayObject.prototype.getAncestorCount = function () {
                            return 0;
                        };
                        DisplayObject.prototype.debugTrace = function (writer, maxDistance, name) {
                            if (writer === void 0) {
                                writer = new Shumway.IndentingWriter();
                            }
                            if (maxDistance === void 0) {
                                maxDistance = 1024;
                            }
                            if (name === void 0) {
                                name = '';
                            }
                            var self = this;
                            this.visit(function (node) {
                                var distance = node._getDistance(self);
                                if (distance > maxDistance) {
                                    return 2    /* Skip */;
                                }
                                var prefix = name + Shumway.StringUtilities.multiple(' ', distance);
                                writer.writeLn(prefix + node.debugNameShort() + ', bounds: ' + node.getBounds(null).toString());
                                return 0    /* Continue */;
                            }, 0    /* None */);
                        };
                        DisplayObject.prototype._addReference = function () {
                            this._referenceCount++;
                        };
                        DisplayObject.prototype._removeReference = function () {
                            // TODO: Uncomment this assertion once we're sure reference counting works correctly.
                            // assert (this._referenceCount > 0);
                            this._referenceCount--;
                            if (this._referenceCount !== 0 || !this._children) {
                                return;
                            }
                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                children[i]._removeReference();
                            }
                        };
                        /**
                         * Returns script precedence sequence based on placeObjectTag. Creates every
                         * time a new array, so it's safe to modify it.
                         * @private
                         */
                        DisplayObject.prototype._getScriptPrecedence = function () {
                            if (!this._parent) {
                                return [];
                            }
                            var result = this._parent._getScriptPrecedence();
                            if (this._placeObjectTag) {
                                result.push(this._placeObjectTag.actionBlocksPrecedence);
                            }
                            return result;
                        };
                        Object.defineProperty(DisplayObject.prototype, 'accessibilityProperties', {
                            get: function () {
                                return this._accessibilityProperties;
                            },
                            set: function (value) {
                                // In Flash this does not do copying.
                                // TODO: coerce to the correct type.
                                this._accessibilityProperties = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObject.prototype, 'blendShader', {
                            set: function (value) {
                                release || somewhatImplemented('public DisplayObject::set blendShader');
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * DisplayObject#name is set to an initial value of 'instanceN', where N is auto-incremented.
                         * This is true for all DisplayObjects except for Stage, so it happens in an overrideable
                         * method.
                         */
                        DisplayObject._instanceID = 1;
                        // List of static symbols to link.
                        DisplayObject.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        DisplayObject.instanceSymbols = null;
                        // ["hitTestObject", "hitTestPoint"];
                        DisplayObject._runScripts = true;
                        /**
                         * Used as a temporary array to avoid allocations.
                         */
                        DisplayObject._path = [];
                        return DisplayObject;
                    }(flash.events.EventDispatcher);
                    display.DisplayObject = DisplayObject;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var assert = Shumway.Debug.assert;
                    var Bitmap = function (_super) {
                        __extends(Bitmap, _super);
                        function Bitmap(bitmapData, pixelSnapping, smoothing) {
                            if (bitmapData === void 0) {
                                bitmapData = null;
                            }
                            if (pixelSnapping === void 0) {
                                pixelSnapping = 'auto';
                            }
                            if (smoothing === void 0) {
                                smoothing = false;
                            }
                            if (this._symbol && !this._fieldsInitialized) {
                                this.applySymbol();
                            }
                            _super.call(this);
                            if (!this._symbol) {
                                this.bitmapData = bitmapData;
                                this._pixelSnapping = axCoerceString(pixelSnapping);
                                this._smoothing = !!smoothing;
                            }
                        }
                        Bitmap.prototype.applySymbol = function () {
                            release || assert(this._symbol);
                            this._initializeFields();
                            var symbol = this._symbol;
                            var symbolClass = symbol.symbolClass;
                            // If the symbol class inherits from Bitmap, we are already within its initializer.
                            // Make sure to create a BitmapData instance here to avoid recursively calling the
                            // initializer again.
                            var bitmapClass = this.sec.flash.display.Bitmap.axClass;
                            if (bitmapClass.dPrototype.isPrototypeOf(symbolClass.dPrototype)) {
                                symbolClass = this.sec.flash.display.BitmapData.axClass;
                            }
                            // TODO: I don't think BitmapData symbol objects can change, so they don't need back
                            // references to this Bitmap.
                            this._bitmapData = AS.constructClassFromSymbol(symbol, symbolClass);
                            this._pixelSnapping = null;
                            this._smoothing = null;
                            this._setFillAndLineBoundsFromWidthAndHeight(symbol.width * 20 | 0, symbol.height * 20 | 0);
                        };
                        Object.defineProperty(Bitmap.prototype, 'pixelSnapping', {
                            get: function () {
                                return this._pixelSnapping;
                            },
                            set: function (value) {
                                if (display.PixelSnapping.toNumber(value) < 0) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidEnumError, 'pixelSnapping');
                                }
                                this._pixelSnapping = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Bitmap.prototype, 'smoothing', {
                            get: function () {
                                return this._smoothing;
                            },
                            set: function (value) {
                                this._smoothing = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Bitmap.prototype, 'bitmapData', {
                            get: function () {
                                return this._bitmapData;
                            },
                            set: function (value) {
                                if (this._bitmapData !== value) {
                                    if (this._bitmapData) {
                                        this._bitmapData._removeBitmapReferrer(this);
                                    }
                                    if (value) {
                                        value._addBitmapReferrer(this);
                                    }
                                }
                                this._bitmapData = value;
                                if (value) {
                                    this._setFillAndLineBoundsFromWidthAndHeight(value.width * 20 | 0, value.height * 20 | 0);
                                }
                                this._invalidateParentFillAndLineBounds(true, true);
                                this._setDirtyFlags(16    /* DirtyBitmapData */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Bitmap.prototype._getContentBounds = function (includeStrokes) {
                            if (includeStrokes === void 0) {
                                includeStrokes = true;
                            }
                            if (this._bitmapData) {
                                return this._bitmapData._getContentBounds();
                            }
                            return new Shumway.Bounds(0, 0, 0, 0);
                        };
                        Bitmap.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                            // If this override is reached, the content bounds have already been checked, which is all
                            // we need to do.
                            release || assert(this._getContentBounds().contains(localX, localY));
                            return true;
                        };
                        // Called whenever the class is initialized.
                        Bitmap.classInitializer = null;
                        // List of static symbols to link.
                        Bitmap.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Bitmap.instanceSymbols = null;
                        // [];
                        return Bitmap;
                    }(flash.display.DisplayObject);
                    display.Bitmap = Bitmap;
                    var assert = Shumway.Debug.assert;
                    var warning = Shumway.Debug.warning;
                    var Shape = function (_super) {
                        __extends(Shape, _super);
                        function Shape() {
                            if (this._symbol && !this._fieldsInitialized) {
                                this.applySymbol();
                            }
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                        }
                        Shape.prototype.applySymbol = function () {
                            this._initializeFields();
                            release || assert(this._symbol);
                            // TODO: Check what do do if the computed bounds of the graphics object don't
                            // match those given by the symbol.
                            this._setStaticContentFromSymbol(this._symbol);
                        };
                        Shape.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this);
                            this._graphics = null;
                        };
                        Shape.prototype._canHaveGraphics = function () {
                            return true;
                        };
                        Shape.prototype._getGraphics = function () {
                            return this._graphics;
                        };
                        Object.defineProperty(Shape.prototype, 'graphics', {
                            get: function () {
                                return this._ensureGraphics();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Shape.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                            var graphics = this._getGraphics();
                            return !!graphics && graphics._containsPoint(localX, localY, true, 0);
                        };
                        Shape.classInitializer = null;
                        return Shape;
                    }(flash.display.DisplayObject);
                    display.Shape = Shape;
                    var ShapeSymbol = function (_super) {
                        __extends(ShapeSymbol, _super);
                        function ShapeSymbol(data, symbolClass) {
                            _super.call(this, data, symbolClass, false);
                            this.graphics = null;
                        }
                        ShapeSymbol.FromData = function (data, loaderInfo) {
                            var symbol = new ShapeSymbol(data, loaderInfo.sec.flash.display.Shape.axClass);
                            symbol._setBoundsFromData(data);
                            symbol.graphics = flash.display.Graphics.FromData(data, loaderInfo);
                            symbol.processRequires(data.require, loaderInfo);
                            return symbol;
                        };
                        ShapeSymbol.prototype.processRequires = function (dependencies, loaderInfo) {
                            if (!dependencies) {
                                return;
                            }
                            var textures = this.graphics.getUsedTextures();
                            for (var i = 0; i < dependencies.length; i++) {
                                var symbol = loaderInfo.getSymbolById(dependencies[i]);
                                if (!symbol) {
                                    if (dependencies[i] !== 65535) {
                                        // Id 65535 is somehow used invalidly in lots of embedded shapes created by the
                                        // authoring tool, so don't warn about that.
                                        warning('Bitmap symbol ' + dependencies[i] + ' required by shape, but not defined.');
                                    }
                                    textures.push(null);
                                    // TODO: handle null-textures from invalid SWFs correctly.
                                    continue;
                                }
                                textures.push(symbol.getSharedInstance());
                            }
                        };
                        return ShapeSymbol;
                    }(Shumway.Timeline.DisplaySymbol);
                    display.ShapeSymbol = ShapeSymbol;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var events = flash.events;
                    var InteractiveObject = function (_super) {
                        __extends(InteractiveObject, _super);
                        function InteractiveObject() {
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                        }
                        InteractiveObject.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this);
                            this._tabEnabled = false;
                            this._tabIndex = -1;
                            this._focusRect = null;
                            this._mouseEnabled = true;
                            this._doubleClickEnabled = false;
                            this._accessibilityImplementation = null;
                            this._softKeyboardInputAreaOfInterest = null;
                            this._needsSoftKeyboard = false;
                            this._contextMenu = null;
                        };
                        Object.defineProperty(InteractiveObject.prototype, 'tabEnabled', {
                            get: function () {
                                return this._tabEnabled;
                            },
                            set: function (enabled) {
                                enabled = !!enabled;
                                var old = this._tabEnabled;
                                this._tabEnabled = enabled;
                                if (old !== enabled) {
                                    this.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.TAB_ENABLED_CHANGE, true));
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(InteractiveObject.prototype, 'tabIndex', {
                            get: function () {
                                return this._tabIndex;
                            },
                            set: function (index) {
                                index = index | 0;
                                var old = this._tabIndex;
                                this._tabIndex = index;
                                if (old !== index) {
                                    this.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.TAB_INDEX_CHANGE, true));
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(InteractiveObject.prototype, 'focusRect', {
                            get: function () {
                                return this._focusRect;
                            },
                            /**
                             * The given |focusRect| can be one of: |true|, |false| or |null|.
                             */
                            set: function (focusRect) {
                                release || somewhatImplemented('public flash.display.InteractiveObject::set focusRect');
                                this._focusRect = focusRect;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(InteractiveObject.prototype, 'mouseEnabled', {
                            get: function () {
                                return this._mouseEnabled;
                            },
                            set: function (enabled) {
                                this._mouseEnabled = !!enabled;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(InteractiveObject.prototype, 'doubleClickEnabled', {
                            get: function () {
                                return this._doubleClickEnabled;
                            },
                            set: function (enabled) {
                                this._doubleClickEnabled = !!enabled;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(InteractiveObject.prototype, 'accessibilityImplementation', {
                            get: function () {
                                return this._accessibilityImplementation;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.display.InteractiveObject::set' + ' accessibilityImplementation');
                                this._accessibilityImplementation = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(InteractiveObject.prototype, 'softKeyboardInputAreaOfInterest', {
                            get: function () {
                                return this._softKeyboardInputAreaOfInterest;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.display.InteractiveObject::set' + ' softKeyboardInputAreaOfInterest');
                                this._softKeyboardInputAreaOfInterest = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(InteractiveObject.prototype, 'needsSoftKeyboard', {
                            get: function () {
                                return this._needsSoftKeyboard;
                            },
                            set: function (value) {
                                value = !!value;
                                release || somewhatImplemented('public flash.display.InteractiveObject::set needsSoftKeyboard');
                                this._needsSoftKeyboard = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(InteractiveObject.prototype, 'contextMenu', {
                            get: function () {
                                return this._contextMenu;
                            },
                            set: function (cm) {
                                cm = cm;
                                release || somewhatImplemented('public flash.display.InteractiveObject::set contextMenu');
                                this._contextMenu = cm;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        InteractiveObject.prototype.requestSoftKeyboard = function () {
                            release || somewhatImplemented('public flash.display.InteractiveObject::requestSoftKeyboard');
                            return false;
                        };
                        InteractiveObject.classInitializer = null;
                        return InteractiveObject;
                    }(flash.display.DisplayObject);
                    display.InteractiveObject = InteractiveObject;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var assert = Shumway.Debug.assert;
                    var SimpleButton = function (_super) {
                        __extends(SimpleButton, _super);
                        function SimpleButton(upState, overState, downState, hitTestState) {
                            if (this._symbol && !this._fieldsInitialized) {
                                this.applySymbol();
                            }
                            _super.call(this);
                            this.sec.flash.display.DisplayObject.axClass._advancableInstances.push(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                            if (!this._symbol) {
                                if (upState) {
                                    this.upState = upState;
                                }
                                if (overState) {
                                    this.overState = overState;
                                }
                                if (downState) {
                                    this.downState = downState;
                                }
                                if (hitTestState) {
                                    this.hitTestState = hitTestState;
                                }
                                this._updateButton();
                            }
                        }
                        SimpleButton.prototype.applySymbol = function () {
                            release || assert(this._symbol);
                            this._initializeFields();
                            var symbol = this._symbol;
                            if (symbol.upState) {
                                this._upState = this.createAnimatedDisplayObject(symbol.upState.symbol, symbol.upState.placeObjectTag, true);
                            }
                            if (symbol.overState) {
                                this._overState = this.createAnimatedDisplayObject(symbol.overState.symbol, symbol.overState.placeObjectTag, true);
                            }
                            if (symbol.downState) {
                                this._downState = this.createAnimatedDisplayObject(symbol.downState.symbol, symbol.downState.placeObjectTag, true);
                            }
                            if (symbol.hitTestState) {
                                this._hitTestState = this.createAnimatedDisplayObject(symbol.hitTestState.symbol, symbol.hitTestState.placeObjectTag, true);
                            }
                            this._updateButton();
                        };
                        SimpleButton.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this);
                            this._useHandCursor = true;
                            this._enabled = true;
                            this._trackAsMenu = false;
                            this._upState = null;
                            this._overState = null;
                            this._downState = null;
                            this._hitTestState = null;
                            this._currentState = null;
                            this._children = [];
                        };
                        SimpleButton.prototype._initFrame = function (advance) {
                            if (advance) {
                                this._updateButton();
                            }
                        };
                        SimpleButton.prototype._constructFrame = function () {
                        };
                        Object.defineProperty(SimpleButton.prototype, 'useHandCursor', {
                            get: function () {
                                return this._useHandCursor;
                            },
                            set: function (value) {
                                this._useHandCursor = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SimpleButton.prototype, 'enabled', {
                            get: function () {
                                return this._enabled;
                            },
                            set: function (value) {
                                this._enabled = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SimpleButton.prototype, 'trackAsMenu', {
                            get: function () {
                                return this._trackAsMenu;
                            },
                            set: function (value) {
                                value = !!value;
                                release || notImplemented('public flash.display.SimpleButton::set trackAsMenu');
                                return;    // this._trackAsMenu = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SimpleButton.prototype, 'upState', {
                            get: function () {
                                return this._upState;
                            },
                            set: function (value) {
                                var old = this._upState;
                                if (value._parent) {
                                    value._parent.removeChild(value);
                                }
                                this._upState = value;
                                if (this._currentState === old) {
                                    this._updateButton();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SimpleButton.prototype, 'overState', {
                            get: function () {
                                return this._overState;
                            },
                            set: function (value) {
                                var old = this._overState;
                                if (value._parent) {
                                    value._parent.removeChild(value);
                                }
                                this._overState = value;
                                if (this._currentState === old) {
                                    this._updateButton();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SimpleButton.prototype, 'downState', {
                            get: function () {
                                return this._downState;
                            },
                            set: function (value) {
                                var old = this._downState;
                                if (value._parent) {
                                    value._parent.removeChild(value);
                                }
                                this._downState = value;
                                if (this._currentState === old) {
                                    this._updateButton();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SimpleButton.prototype, 'hitTestState', {
                            get: function () {
                                return this._hitTestState;
                            },
                            set: function (value) {
                                this._hitTestState = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SimpleButton.prototype, 'soundTransform', {
                            get: function () {
                                release || notImplemented('public flash.display.SimpleButton::get soundTransform');
                                return;    // return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                sndTransform = sndTransform;
                                release || notImplemented('public flash.display.SimpleButton::set soundTransform');
                                return;    // this._soundTransform = sndTransform;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * Override of DisplayObject#_containsPoint that applies the test on hitTestState if
                         * that is defined.
                         */
                        SimpleButton.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                            var target = testingType === 3    /* Mouse */ ? this._hitTestState : this._currentState;
                            if (!target) {
                                return 0    /* None */;
                            }
                            // Hit testing relies on being able to get combined transforms and all that, so, a parent.
                            target._parent = this;
                            var result = target._containsGlobalPoint(globalX, globalY, testingType, objects);
                            target._parent = null;
                            // For mouse target finding, SimpleButtons always return themselves as the hit.
                            if (result !== 0    /* None */ && testingType === 3    /* Mouse */ && objects && this._mouseEnabled) {
                                objects[0] = this;
                                release || assert(objects.length === 1);
                            }
                            return result;
                        };
                        /**
                         * Override of DisplayObject#_getChildBounds that retrieves the current hitTestState's bounds.
                         */
                        SimpleButton.prototype._getChildBounds = function (bounds, includeStrokes) {
                            if (!this._currentState) {
                                return;
                            }
                            this._currentState._parent = this;
                            bounds.unionInPlace(this._currentState._getTransformedBounds(this, includeStrokes));
                            this._currentState._parent = null;
                        };
                        SimpleButton.prototype._propagateFlagsDown = function (flags) {
                            if (this._hasFlags(flags)) {
                                return;
                            }
                            this._setFlags(flags);
                            this._upState && this._upState._propagateFlagsDown(flags);
                            this._overState && this._overState._propagateFlagsDown(flags);
                            this._downState && this._downState._propagateFlagsDown(flags);
                            this._hitTestState && this._hitTestState._propagateFlagsDown(flags);
                        };
                        SimpleButton.prototype._updateButton = function () {
                            var state;
                            if (this._mouseOver) {
                                state = this._mouseDown ? this._downState : this._overState;
                            } else {
                                state = this._upState;
                            }
                            if (state === this._currentState) {
                                return;
                            }
                            if (this._currentState) {
                            }
                            this._currentState = state;
                            if (this._stage) {
                            }
                            if (state) {
                                this._children[0] = state;
                            } else {
                                this._children.length = 0;
                            }
                            this._setDirtyFlags(2    /* DirtyChildren */);
                            this._invalidateFillAndLineBounds(true, true);
                        };
                        // Called whenever the class is initialized.
                        SimpleButton.classInitializer = null;
                        // List of static symbols to link.
                        SimpleButton.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        SimpleButton.instanceSymbols = null;
                        // [];
                        return SimpleButton;
                    }(flash.display.InteractiveObject);
                    display.SimpleButton = SimpleButton;
                    var ButtonState = function () {
                        function ButtonState(symbol, placeObjectTag) {
                            this.symbol = symbol;
                            this.placeObjectTag = placeObjectTag;
                        }
                        return ButtonState;
                    }();
                    display.ButtonState = ButtonState;
                    var ButtonSymbol = function (_super) {
                        __extends(ButtonSymbol, _super);
                        function ButtonSymbol(data, loaderInfo) {
                            _super.call(this, data, loaderInfo.sec.flash.display.SimpleButton.axClass, true);
                            this.upState = null;
                            this.overState = null;
                            this.downState = null;
                            this.hitTestState = null;
                            this.loaderInfo = loaderInfo;
                        }
                        ButtonSymbol.FromData = function (data, loaderInfo) {
                            var symbol = new ButtonSymbol(data, loaderInfo);
                            if (loaderInfo.actionScriptVersion === display.ActionScriptVersion.ACTIONSCRIPT2) {
                                symbol.isAVM1Object = true;
                            }
                            var states = data.states;
                            var character = null;
                            var placeObjectTag;
                            for (var stateName in states) {
                                var controlTags = states[stateName];
                                if (controlTags.length === 1) {
                                    placeObjectTag = controlTags[0];
                                    character = loaderInfo.getSymbolById(placeObjectTag.symbolId);
                                    if (!character) {
                                        continue;
                                    }
                                } else {
                                    placeObjectTag = {
                                        code: 4    /* CODE_PLACE_OBJECT */,
                                        flags: 1    /* Move */,
                                        depth: 1
                                    };
                                    character = new flash.display.SpriteSymbol({
                                        id: -1,
                                        className: null,
                                        env: null
                                    }, loaderInfo);
                                    character.frames.push(new Shumway.SWF.SWFFrame(controlTags));
                                }
                                symbol[stateName + 'State'] = new ButtonState(character, placeObjectTag);
                            }
                            return symbol;
                        };
                        return ButtonSymbol;
                    }(Shumway.Timeline.DisplaySymbol);
                    display.ButtonSymbol = ButtonSymbol;
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var mixHash = Shumway.HashUtilities.mixHash;
                    var checkParameterType = Shumway.AVMX.checkParameterType;
                    var clamp = Shumway.NumberUtilities.clamp;
                    var events = flash.events;
                    var DisplayObjectContainer = function (_super) {
                        __extends(DisplayObjectContainer, _super);
                        function DisplayObjectContainer() {
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                            this._setDirtyFlags(2    /* DirtyChildren */);
                        }
                        DisplayObjectContainer.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this);
                            this._tabChildren = true;
                            this._mouseChildren = true;
                            // Might already have been initialized from a symbol.
                            this._children = this._children || [];
                        };
                        /**
                         * This object's children have changed.
                         */
                        DisplayObjectContainer.prototype._invalidateChildren = function () {
                            this._setDirtyFlags(2    /* DirtyChildren */);
                            this._invalidateFillAndLineBounds(true, true);
                        };
                        /**
                         * Propagates flags down the display list. Propagation stops if all flags are already set.
                         */
                        DisplayObjectContainer.prototype._propagateFlagsDown = function (flags) {
                            if (this._hasFlags(flags)) {
                                return;
                            }
                            this._setFlags(flags);
                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                children[i]._propagateFlagsDown(flags);
                            }
                        };
                        /**
                         * Calls the constructors of new children placed by timeline commands.
                         */
                        DisplayObjectContainer.prototype._constructChildren = function () {
                            release || AVMX.counter.count('DisplayObjectContainer::_constructChildren');
                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                var child = children[i];
                                if (child._hasFlags(256    /* Constructed */)) {
                                    continue;
                                }
                                try {
                                    child.axInitializer();
                                } catch (e) {
                                    Shumway.Debug.warning('caught error executing child constructor in constructChildren: ', e);
                                }
                                //child.class.instanceConstructorNoInitialize.call(child);
                                child._removeReference();
                                if (child._name) {
                                    this.axSetPublicProperty(child._name, child);
                                }
                                child._setFlags(256    /* Constructed */);
                                var eventClass = this.sec.flash.events.Event.axClass;
                                if (child._hasFlags(131072    /* HasPlaceObjectInitPending */)) {
                                    child._removeFlags(131072    /* HasPlaceObjectInitPending */);
                                    var avm1Context = child._symbol.avm1Context;
                                    Shumway.AVM1.Lib.initializeAVM1Object(child, avm1Context, child._placeObjectTag);
                                    try {
                                        child.dispatchEvent(eventClass.getInstance(events.Event.AVM1_INIT));
                                    } catch (e) {
                                        Shumway.Debug.warning('caught error under DisplayObjectContainer AVM1_INIT event: ', e);
                                    }
                                    try {
                                        child.dispatchEvent(eventClass.getInstance(events.Event.AVM1_CONSTRUCT));
                                    } catch (e) {
                                        Shumway.Debug.warning('caught error under DisplayObjectContainer AVM1_CONSTRUCT event: ', e);
                                    }
                                    if (child.hasEventListener(events.Event.AVM1_LOAD)) {
                                        child._setFlags(1024    /* NeedsLoadEvent */);
                                        this._propagateFlagsUp(16384    /* ContainsFrameScriptPendingChildren */);
                                    }
                                }
                                try {
                                    child.dispatchEvent(eventClass.getInstance(events.Event.ADDED, true));
                                } catch (e) {
                                    Shumway.Debug.warning('caught error under DisplayObject ADDED event: ', e);
                                }
                                if (child.stage) {
                                    try {
                                        child.dispatchEvent(eventClass.getInstance(events.Event.ADDED_TO_STAGE));
                                    } catch (e) {
                                        Shumway.Debug.warning('caught error under DisplayObject ADDED_TO_STAGE event: ', e);
                                    }
                                }
                            }
                        };
                        DisplayObjectContainer.prototype._enqueueFrameScripts = function () {
                            if (this._hasFlags(16384    /* ContainsFrameScriptPendingChildren */)) {
                                this._removeFlags(16384    /* ContainsFrameScriptPendingChildren */);
                                var children = this._children;
                                for (var i = 0; i < children.length; i++) {
                                    var child = children[i];
                                    if (this.sec.flash.display.DisplayObjectContainer.axIsType(child) || this.sec.flash.display.AVM1Movie.axIsType(child)) {
                                        child._enqueueFrameScripts();
                                    }
                                }
                            }
                        };
                        Object.defineProperty(DisplayObjectContainer.prototype, 'numChildren', {
                            get: function () {
                                return this._getNumChildren();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // `get numChildren` is overridden in `Stage` and has to be able to call this.
                        DisplayObjectContainer.prototype._getNumChildren = function () {
                            return this._children.length;
                        };
                        Object.defineProperty(DisplayObjectContainer.prototype, 'textSnapshot', {
                            get: function () {
                                release || notImplemented('public DisplayObjectContainer::get textSnapshot');
                                return;    // return this._textSnapshot;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplayObjectContainer.prototype, 'tabChildren', {
                            get: function () {
                                return this._getTabChildren();
                            },
                            set: function (enable) {
                                this._setTabChildren(enable);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // `get tabChildren` is overridden in `Stage` and has to be able to call this.
                        DisplayObjectContainer.prototype._getTabChildren = function () {
                            return this._tabChildren;
                        };
                        // `set tabChildren` is overridden in `Stage` and has to be able to call this.
                        DisplayObjectContainer.prototype._setTabChildren = function (enable) {
                            enable = !!enable;
                            var old = this._tabChildren;
                            this._tabChildren = enable;
                            if (old !== enable) {
                                this.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.TAB_CHILDREN_CHANGE, true));
                            }
                        };
                        Object.defineProperty(DisplayObjectContainer.prototype, 'mouseChildren', {
                            get: function () {
                                return this._getMouseChildren();
                            },
                            set: function (enable) {
                                this._setMouseChildren(enable);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // `get mouseChildren` is overridden in `Stage` and has to be able to call this.
                        DisplayObjectContainer.prototype._getMouseChildren = function () {
                            return this._mouseChildren;
                        };
                        // `set mouseChildren` is overridden in `Stage` and has to be able to call this.
                        DisplayObjectContainer.prototype._setMouseChildren = function (enable) {
                            this._mouseChildren = !!enable;
                        };
                        DisplayObjectContainer.prototype.addChild = function (child) {
                            return this.addChildAt(child, this._children.length);
                        };
                        /**
                         * Adds a child at a given index. The index must be within the range [0 ... children.length].
                         * Note that this is different than the range setChildIndex expects.
                         */
                        DisplayObjectContainer.prototype.addChildAt = function (child, index) {
                            checkParameterType(child, 'child', this.sec.flash.display.DisplayObject.axClass);
                            release || AVMX.counter.count('DisplayObjectContainer::addChildAt');
                            index = index | 0;
                            release || assert(child._hasFlags(256    /* Constructed */), 'Child is not fully constructed.');
                            if (child === this) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.CantAddSelfError);
                            }
                            if (this.sec.flash.display.DisplayObjectContainer.axIsType(child) && child.contains(this)) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.CantAddParentError);
                            }
                            var children = this._children;
                            if (index < 0 || index > children.length) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            if (child._parent === this) {
                                this.setChildIndex(child, clamp(index, 0, children.length - 1));
                                return child;
                            }
                            // TODO: check what happens if a listener for REMOVE throws an error. Does the element get
                            // reparented nevertheless?
                            if (child._parent) {
                                // Loader overrides removeChildAt to throw an exception. We still want to use it, so we
                                // always call the original version here.
                                DisplayObjectContainer.prototype.removeChildAt.call(child._parent, child._parent.getChildIndex(child));
                                // The children list could have been mutated as a result of |removeChild|.
                                index = clamp(index, 0, children.length);
                            }
                            for (var i = children.length - 1; i >= index; i--) {
                                children[i]._index++;
                            }
                            children.splice(index, 0, child);
                            child._setParent(this, -1);
                            child._index = index;
                            child._invalidatePosition();
                            this._invalidateChildren();
                            child._addReference();
                            child.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.ADDED, true));
                            // ADDED event handlers may remove the child from the stage, in such cases
                            // we should not dispatch the ADDED_TO_STAGE event.
                            if (child.stage) {
                                child._propagateEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.ADDED_TO_STAGE));
                            }
                            return child;
                        };
                        /**
                         * Adds a timeline object to this container. The new child is added after the last object that
                         * exists at a smaller depth, or before the first object that exists at a greater depth. If no
                         * other timeline object is found, the new child is added to the front(top) of all other
                         * children.
                         *
                         * Note that this differs from `addChildAt` in that the depth isn't an index in the `children`
                         * array, and doesn't have to be in the dense range [0..children.length].
                         */
                        DisplayObjectContainer.prototype.addTimelineObjectAtDepth = function (child, depth) {
                            release || AVMX.counter.count('DisplayObjectContainer::addTimelineObjectAtDepth');
                            depth = depth | 0;
                            var children = this._children;
                            var maxIndex = children.length - 1;
                            var index = maxIndex + 1;
                            for (var i = maxIndex; i >= 0; i--) {
                                var current = children[i];
                                if (current._depth > -1) {
                                    if (current._depth < depth) {
                                        index = i + 1;
                                        break;
                                    }
                                    index = i;
                                }
                            }
                            if (index > maxIndex) {
                                children.push(child);
                                child._index = index;
                            } else {
                                children.splice(index, 0, child);
                                for (var i = index; i < children.length; i++) {
                                    children[i]._index = i;
                                }
                            }
                            child._setParent(this, depth);
                            child._invalidatePosition();
                            this._invalidateChildren();
                        };
                        DisplayObjectContainer.prototype.removeChild = function (child) {
                            checkParameterType(child, 'child', this.sec.flash.display.DisplayObject.axClass);
                            return this.removeChildAt(this.getChildIndex(child));
                        };
                        DisplayObjectContainer.prototype.removeChildAt = function (index) {
                            release || AVMX.counter.count('DisplayObjectContainer::removeChildAt');
                            index = index | 0;
                            var children = this._children;
                            if (index < 0 || index >= children.length) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            var child = children[index];
                            if (child._hasFlags(256    /* Constructed */)) {
                                child.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.REMOVED, true));
                                if (this.stage) {
                                    child._propagateEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.REMOVED_FROM_STAGE));
                                }
                                // Children list might have been mutated by the REMOVED or REMOVED_FROM_STAGE event,
                                // we may need to operate on the new index of the child.
                                index = this.getChildIndex(child);
                            }
                            children.splice(index, 1);
                            for (var i = children.length - 1; i >= index; i--) {
                                children[i]._index--;
                            }
                            child._setParent(null, -1);
                            child._index = -1;
                            child._invalidatePosition();
                            this._invalidateChildren();
                            return child;
                        };
                        DisplayObjectContainer.prototype.getChildIndex = function (child) {
                            checkParameterType(child, 'child', this.sec.flash.display.DisplayObject.axClass);
                            if (child._parent !== this) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.NotAChildError);
                            }
                            return child._index;
                        };
                        /**
                         * Sets the index of a child. The index must be within the range [0 ... children.length - 1].
                         */
                        DisplayObjectContainer.prototype.setChildIndex = function (child, index) {
                            index = index | 0;
                            checkParameterType(child, 'child', this.sec.flash.display.DisplayObject.axClass);
                            var children = this._children;
                            if (index < 0 || index >= children.length) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            if (child._parent !== this) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.NotAChildError);
                            }
                            child._setDepth(-1);
                            var currentIndex = this.getChildIndex(child);
                            if (children.length === 1 || currentIndex === index) {
                                return;
                            }
                            if (index === currentIndex + 1 || index === currentIndex - 1) {
                                // We can't call |swapChildrenAt| here because we don't want to affect the depth value.
                                this._swapChildrenAt(currentIndex, index);
                            } else {
                                children.splice(currentIndex, 1);
                                children.splice(index, 0, child);
                                var i = currentIndex < index ? currentIndex : index;
                                while (i < children.length) {
                                    children[i]._index = i++;
                                }
                            }
                            this._invalidateChildren();
                        };
                        DisplayObjectContainer.prototype.getChildAt = function (index) {
                            index = index | 0;
                            var children = this._children;
                            if (index < 0 || index >= children.length) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            var child = this._lookupChildByIndex(index, 0    /* DEFAULT */);
                            if (!child) {
                                return null;
                            }
                            child._addReference();
                            return child;
                        };
                        /**
                         * Returns the timeline object that exists at the specified depth.
                         */
                        DisplayObjectContainer.prototype.getTimelineObjectAtDepth = function (depth) {
                            depth = depth | 0;
                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                var child = children[i];
                                if (child._depth > depth) {
                                    break;
                                }
                                if (child._depth === depth) {
                                    return child;
                                }
                            }
                            return null;
                        };
                        /**
                         * Returns the last child index that is covered by the clip depth.
                         */
                        DisplayObjectContainer.prototype.getClipDepthIndex = function (depth) {
                            depth = depth | 0;
                            var children = this._children;
                            var index = this._children.length - 1;
                            var first = true;
                            for (var i = index; i >= 0; i--) {
                                var child = children[i];
                                // Ignore children that don't have a depth value.
                                if (child._depth < 0) {
                                    continue;
                                }
                                // Usually we return the index of the first child that has a depth value less than or
                                // equal to the specified depth. However, Flash seems to clip all remaining children,
                                // including those that don't have a depth value if the clip appears at the end.
                                if (child._depth <= depth) {
                                    return first ? index : i;
                                }
                                first = false;
                            }
                            return 0;
                        };
                        DisplayObjectContainer.prototype.getChildByName = function (name) {
                            name = axCoerceString(name);
                            var child = this._lookupChildByName(name, 0    /* DEFAULT */);
                            if (child) {
                                child._addReference();
                                return child;
                            }
                            return null;
                        };
                        /**
                         * Returns the child display object instance that exists at given index without creating a
                         * reference nor taking ownership.
                         */
                        DisplayObjectContainer.prototype._lookupChildByIndex = function (index, options) {
                            var child = this._children[index];
                            if (child && (child._hasFlags(256    /* Constructed */) || options & 2    /* INCLUDE_NON_INITIALIZED */)) {
                                return child;
                            }
                            return null;
                        };
                        /**
                         * Returns the child display object that exists with given name without creating a reference
                         * nor taking ownership.
                         */
                        DisplayObjectContainer.prototype._lookupChildByName = function (name, options) {
                            var children = this._children;
                            if (children.length === 0) {
                                return null;
                            }
                            for (var i = 0; i < children.length; i++) {
                                var child = children[i];
                                if (!child._hasFlags(256    /* Constructed */) && !(options & 2    /* INCLUDE_NON_INITIALIZED */)) {
                                    continue;
                                }
                                if (child._name === name) {
                                    return child;
                                }
                            }
                            if (!(options & 1    /* IGNORE_CASE */)) {
                                return null;
                            }
                            // Trying again in non-case sensitive mode (mostly for AVM1).
                            name = name.toLowerCase();
                            for (var i = 0; i < children.length; i++) {
                                var child = children[i];
                                if (!child._hasFlags(256    /* Constructed */) && !(options & 2    /* INCLUDE_NON_INITIALIZED */)) {
                                    continue;
                                }
                                if (child._name.toLowerCase() === name) {
                                    return child;
                                }
                            }
                            return null;
                        };
                        /**
                         * Override of DisplayObject#_containsPoint that takes children into consideration.
                         */
                        DisplayObjectContainer.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                            return this._containsPointImpl(globalX, globalY, localX, localY, testingType, objects, false);
                        };
                        DisplayObjectContainer.prototype._containsPointImpl = function (globalX, globalY, localX, localY, testingType, objects, skipBoundsCheck) {
                            var result;
                            if (!skipBoundsCheck) {
                                result = this._boundsAndMaskContainPoint(globalX, globalY, localX, localY, testingType);
                                // Same as in the DisplayObject base case, we're done if we don't have a hit or are only
                                // looking for bounds + mask checks.
                                if (result === 0    /* None */ || testingType < 2    /* HitTestShape */) {
                                    return result;
                                }
                            }
                            var anyChildHit = false;
                            var children = this._getUnclippedChildren(testingType, globalX, globalY);
                            for (var i = children ? children.length : 0; i--;) {
                                var child = children[i];
                                if (child._maskedObject) {
                                    continue;
                                }
                                result = child._containsGlobalPoint(globalX, globalY, testingType, objects);
                                if (result !== 2    /* Shape */) {
                                    continue;
                                }
                                // For hit testing, a single match suffices.
                                if (testingType < 3    /* Mouse */) {
                                    return result;
                                }
                                anyChildHit = true;
                                if (testingType >= 4    /* ObjectsUnderPoint */) {
                                    continue;
                                }
                                release || assert(testingType === 3    /* Mouse */);
                                release || assert(objects.length <= 1);
                                // If this object itself is mouse-disabled, we have to ensure that no nested object is
                                // returned as a result.
                                if (!this._mouseEnabled) {
                                    objects.length = 0;
                                    return result;
                                }
                                // If this container disables mouseChildren, any matched child establish the container as
                                // the match.
                                if (!this._mouseChildren) {
                                    objects[0] = this;
                                }
                                if (objects.length !== 0) {
                                    release || assert(this.sec.flash.display.InteractiveObject.axIsType(objects[0]));
                                    return 2    /* Shape */;
                                }
                            }
                            // We need to always test the container itself for getObjectsUnderPoint or when looking for a
                            // drop target. Otherwise, it's only required if no child (interactive or not) was hit.
                            if (anyChildHit && testingType < 4    /* ObjectsUnderPoint */) {
                                if (testingType === 3    /* Mouse */ && objects.length === 0) {
                                    objects[0] = this;
                                }
                                return 2    /* Shape */;
                            }
                            var selfHit = this._containsPointDirectly(localX, localY, globalX, globalY);
                            if (selfHit) {
                                if (testingType === 5    /* Drop */) {
                                    // For Drop, replace previous hit with current one.
                                    objects[0] = this;
                                } else if (testingType === 4    /* ObjectsUnderPoint */ || objects && this._mouseEnabled) {
                                    objects.push(this);
                                }
                            }
                            return anyChildHit || selfHit ? 2    /* Shape */ : 0    /* None */;
                        };
                        DisplayObjectContainer.prototype._getUnclippedChildren = function (testingType, globalX, globalY) {
                            // Clipping masks complicate hit testing: for mouse target finding, where performance is
                            // most important, we want to test highest children first, then go down. OTOH, we want to
                            // test clipping masks before the elements they clip, potentially saving costly tests against
                            // lots of elements. However, clipping masks affect siblings with higher child indices, so
                            // by going top-to-bottom, we discover them after the clipped content. To get around that,
                            // we iterate over the children once and detect any clipping masks. If we find at least one,
                            // we copy all the non-clipped elements into a new array, over which we then iterate without
                            // having to test clipping.
                            // Note: if speed is an issue, we could set a flag on containers that have at least one
                            // clipping mask and do this step only if that flag is set.
                            var children = this._children;
                            if (!children) {
                                return null;
                            }
                            var unclippedChildren;
                            // Lazily created.
                            for (var i = 0; children && i < children.length; i++) {
                                var child = children[i];
                                if (child._clipDepth !== -1) {
                                    if (!unclippedChildren) {
                                        unclippedChildren = children.slice(0, i);
                                    }
                                    // Clipping masks are simply ignored for HitTestPoint purposes.
                                    if (testingType === 2    /* HitTestShape */) {
                                        continue;
                                    }
                                    release || assert(testingType >= 3    /* Mouse */);
                                    // If the point isn't contained in the clipping mask, we can skip all the clipped objects.
                                    // We pass HitTestShape here because we never want to collect hit objects, which the
                                    // higher testing types would attempt to do.
                                    var containsPoint = child._containsGlobalPoint(globalX, globalY, 2    /* HitTestShape */, null);
                                    if (!containsPoint) {
                                        i = this.getClipDepthIndex(child._clipDepth);
                                    }
                                    continue;
                                }
                                if (unclippedChildren) {
                                    unclippedChildren.push(child);
                                }
                            }
                            return unclippedChildren || children;
                        };
                        /**
                         * Override of DisplayObject#_getChildBounds that union all childrens's
                         * bounds into the bounds.
                         */
                        DisplayObjectContainer.prototype._getChildBounds = function (bounds, includeStrokes) {
                            var children = this._children;
                            for (var i = 0; i < children.length; i++) {
                                bounds.unionInPlace(children[i]._getTransformedBounds(this, includeStrokes));
                            }
                        };
                        /**
                         * Returns an array of all leaf objects under the given point in global coordinates.
                         * A leaf node in this context is an object that itself contains visual content, so it can be
                         * any of Shape, Sprite, MovieClip, Bitmap, Video, and TextField.
                         * Note that, while the Flash documentation makes it sound like it doesn't, the result also
                         * contains the receiver object if that matches the criteria above.
                         */
                        DisplayObjectContainer.prototype.getObjectsUnderPoint = function (globalPoint) {
                            release || AVMX.counter.count('DisplayObjectContainer::getObjectsUnderPoint');
                            var globalX = globalPoint.x * 20 | 0;
                            var globalY = globalPoint.y * 20 | 0;
                            var objects = [];
                            this._containsGlobalPoint(globalX, globalY, 4    /* ObjectsUnderPoint */, objects);
                            // getObjectsUnderPoint returns results in exactly the opposite order we collect them in.
                            return this.sec.createArrayUnsafe(objects.reverse());
                        };
                        DisplayObjectContainer.prototype.areInaccessibleObjectsUnderPoint = function (point) {
                            point = point;
                            release || notImplemented('public DisplayObjectContainer::areInaccessibleObjectsUnderPoint');
                            return;
                        };
                        DisplayObjectContainer.prototype.contains = function (child) {
                            checkParameterType(child, 'child', this.sec.flash.display.DisplayObject.axClass);
                            return this._isAncestor(child);
                        };
                        DisplayObjectContainer.prototype.swapChildrenAt = function (index1, index2) {
                            index1 = index1 | 0;
                            index2 = index2 | 0;
                            var children = this._children;
                            if (index1 < 0 || index1 >= children.length || index2 < 0 || index2 >= children.length) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            // Always call _swapChildrenAt to make sure _setDepth(-1) is called on both children.
                            this._swapChildrenAt(index1, index2);
                            if (index1 !== index2) {
                                this._invalidateChildren();
                            }
                        };
                        DisplayObjectContainer.prototype._swapChildrenAt = function (index1, index2) {
                            var children = this._children;
                            var child1 = children[index1];
                            var child2 = children[index2];
                            children[index2] = child1;
                            child1._setDepth(-1);
                            child1._index = index2;
                            children[index1] = child2;
                            child2._setDepth(-1);
                            child2._index = index1;
                        };
                        DisplayObjectContainer.prototype.swapChildren = function (child1, child2) {
                            // Flash prints out 'child' for both non-null |child1| and |child2|.
                            checkParameterType(child1, 'child', this.sec.flash.display.DisplayObject.axClass);
                            checkParameterType(child2, 'child', this.sec.flash.display.DisplayObject.axClass);
                            this.swapChildrenAt(this.getChildIndex(child1), this.getChildIndex(child2));
                        };
                        DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {
                            if (beginIndex === void 0) {
                                beginIndex = 0;
                            }
                            if (endIndex === void 0) {
                                endIndex = 2147483647;
                            }
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            if (beginIndex < 0 || endIndex < 0 || endIndex < beginIndex || endIndex >= this._children.length) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            var count = endIndex - beginIndex + 1;
                            if (count > 0) {
                                while (count--) {
                                    this.removeChildAt(beginIndex);
                                }
                            }
                        };
                        DisplayObjectContainer.prototype.hashCode = function () {
                            var hash = 0;
                            for (var i = 0; i < this.numChildren; i++) {
                                var child = this.getChildAt(i);
                                if (child) {
                                    hash = mixHash(hash, this.getChildAt(i).hashCode());
                                }
                            }
                            return mixHash(hash, this.getBounds(null).hashCode());
                        };
                        /**
                         * This is a very slow recursive function that should not be used in performance critical code.
                         */
                        DisplayObjectContainer.prototype.getAncestorCount = function () {
                            var count = 0;
                            for (var i = 0; i < this.numChildren; i++) {
                                var child = this.getChildAt(i);
                                if (child) {
                                    count += 1 + this.getChildAt(i).getAncestorCount();
                                }
                            }
                            return count;
                        };
                        DisplayObjectContainer.bindings = null;
                        DisplayObjectContainer.classSymbols = null;
                        DisplayObjectContainer.classInitializer = null;
                        return DisplayObjectContainer;
                    }(flash.display.InteractiveObject);
                    display.DisplayObjectContainer = DisplayObjectContainer;
                    var JointStyle = function (_super) {
                        __extends(JointStyle, _super);
                        function JointStyle() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        JointStyle.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return JointStyle.ROUND;
                            case 1:
                                return JointStyle.BEVEL;
                            case 2:
                                return JointStyle.MITER;
                            default:
                                return null;
                            }
                        };
                        JointStyle.toNumber = function (value) {
                            switch (value) {
                            case JointStyle.ROUND:
                                return 0;
                            case JointStyle.BEVEL:
                                return 1;
                            case JointStyle.MITER:
                                return 2;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        JointStyle.classInitializer = null;
                        // List of static symbols to link.
                        JointStyle.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        JointStyle.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        JointStyle.ROUND = 'round';
                        JointStyle.BEVEL = 'bevel';
                        JointStyle.MITER = 'miter';
                        return JointStyle;
                    }(AS.ASObject);
                    display.JointStyle = JointStyle;
                    var CapsStyle = function (_super) {
                        __extends(CapsStyle, _super);
                        function CapsStyle() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        CapsStyle.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return CapsStyle.ROUND;
                            case 1:
                                return CapsStyle.NONE;
                            case 2:
                                return CapsStyle.SQUARE;
                            default:
                                return null;
                            }
                        };
                        CapsStyle.toNumber = function (value) {
                            switch (value) {
                            case CapsStyle.ROUND:
                                return 0;
                            case CapsStyle.NONE:
                                return 1;
                            case CapsStyle.SQUARE:
                                return 2;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        CapsStyle.classInitializer = null;
                        // List of static symbols to link.
                        CapsStyle.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        CapsStyle.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        CapsStyle.ROUND = 'round';
                        CapsStyle.NONE = 'none';
                        CapsStyle.SQUARE = 'square';
                        return CapsStyle;
                    }(AS.ASObject);
                    display.CapsStyle = CapsStyle;
                    var LineScaleMode = function (_super) {
                        __extends(LineScaleMode, _super);
                        function LineScaleMode() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        LineScaleMode.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return LineScaleMode.NONE;
                            case 1:
                                return LineScaleMode.NORMAL;
                            case 2:
                                return LineScaleMode.VERTICAL;
                            case 3:
                                return LineScaleMode.HORIZONTAL;
                            default:
                                return null;
                            }
                        };
                        LineScaleMode.toNumber = function (value) {
                            switch (value) {
                            case LineScaleMode.NONE:
                                return 0;
                            case LineScaleMode.NORMAL:
                                return 1;
                            case LineScaleMode.VERTICAL:
                                return 2;
                            case LineScaleMode.HORIZONTAL:
                                return 3;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        LineScaleMode.classInitializer = null;
                        // List of static symbols to link.
                        LineScaleMode.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        LineScaleMode.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        LineScaleMode.NORMAL = 'normal';
                        LineScaleMode.VERTICAL = 'vertical';
                        LineScaleMode.HORIZONTAL = 'horizontal';
                        LineScaleMode.NONE = 'none';
                        return LineScaleMode;
                    }(AS.ASObject);
                    display.LineScaleMode = LineScaleMode;
                    var GradientType = function (_super) {
                        __extends(GradientType, _super);
                        function GradientType() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        GradientType.fromNumber = function (n) {
                            switch (n) {
                            case 16    /* Linear */:
                                return GradientType.LINEAR;
                            case 18    /* Radial */:
                                return GradientType.RADIAL;
                            default:
                                return null;
                            }
                        };
                        GradientType.toNumber = function (value) {
                            switch (value) {
                            case GradientType.LINEAR:
                                return 16    /* Linear */;
                            case GradientType.RADIAL:
                                return 18    /* Radial */;
                            default:
                                return -1;
                            }
                        };
                        GradientType.classInitializer = null;
                        GradientType.classSymbols = null;
                        // [];
                        GradientType.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        GradientType.LINEAR = 'linear';
                        GradientType.RADIAL = 'radial';
                        return GradientType;
                    }(AS.ASObject);
                    display.GradientType = GradientType;
                    var SpreadMethod = function (_super) {
                        __extends(SpreadMethod, _super);
                        function SpreadMethod() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        SpreadMethod.fromNumber = function (n) {
                            switch (n) {
                            case 0    /* Pad */:
                                return SpreadMethod.PAD;
                            case 1    /* Reflect */:
                                return SpreadMethod.REFLECT;
                            case 2    /* Repeat */:
                                return SpreadMethod.REPEAT;
                            default:
                                return null;
                            }
                        };
                        SpreadMethod.toNumber = function (value) {
                            switch (value) {
                            case SpreadMethod.PAD:
                                return 0    /* Pad */;
                            case SpreadMethod.REFLECT:
                                return 1    /* Reflect */;
                            case SpreadMethod.REPEAT:
                                return 2    /* Repeat */;
                            default:
                                return -1;
                            }
                        };
                        SpreadMethod.classInitializer = null;
                        SpreadMethod.classSymbols = null;
                        // [];
                        SpreadMethod.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        SpreadMethod.PAD = 'pad';
                        SpreadMethod.REFLECT = 'reflect';
                        SpreadMethod.REPEAT = 'repeat';
                        return SpreadMethod;
                    }(AS.ASObject);
                    display.SpreadMethod = SpreadMethod;
                    var InterpolationMethod = function (_super) {
                        __extends(InterpolationMethod, _super);
                        function InterpolationMethod() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        InterpolationMethod.fromNumber = function (n) {
                            switch (n) {
                            case 0    /* RGB */:
                                return InterpolationMethod.RGB;
                            case 1    /* LinearRGB */:
                                return InterpolationMethod.LINEAR_RGB;
                            default:
                                return null;
                            }
                        };
                        InterpolationMethod.toNumber = function (value) {
                            switch (value) {
                            case InterpolationMethod.RGB:
                                return 0    /* RGB */;
                            case InterpolationMethod.LINEAR_RGB:
                                return 1    /* LinearRGB */;
                            default:
                                return -1;
                            }
                        };
                        InterpolationMethod.classInitializer = null;
                        InterpolationMethod.classSymbols = null;
                        // [];
                        InterpolationMethod.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        InterpolationMethod.RGB = 'rgb';
                        InterpolationMethod.LINEAR_RGB = 'linearRGB';
                        return InterpolationMethod;
                    }(AS.ASObject);
                    display.InterpolationMethod = InterpolationMethod;
                    var GraphicsBitmapFill = function (_super) {
                        __extends(GraphicsBitmapFill, _super);
                        function GraphicsBitmapFill(bitmapData, matrix, repeat, smooth) {
                            if (bitmapData === void 0) {
                                bitmapData = null;
                            }
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (repeat === void 0) {
                                repeat = true;
                            }
                            if (smooth === void 0) {
                                smooth = false;
                            }
                            _super.call(this);
                            this.bitmapData = bitmapData;
                            this.matrix = matrix;
                            this.repeat = !!repeat;
                            this.smooth = !!smooth;
                        }
                        // Called whenever the class is initialized.
                        GraphicsBitmapFill.classInitializer = null;
                        // List of static symbols to link.
                        GraphicsBitmapFill.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GraphicsBitmapFill.instanceSymbols = null;
                        // ["bitmapData", "matrix", "repeat", "smooth"];
                        return GraphicsBitmapFill;
                    }(AS.ASObject);
                    display.GraphicsBitmapFill = GraphicsBitmapFill;
                    var GraphicsEndFill = function (_super) {
                        __extends(GraphicsEndFill, _super);
                        function GraphicsEndFill() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        GraphicsEndFill.classInitializer = null;
                        // List of static symbols to link.
                        GraphicsEndFill.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GraphicsEndFill.instanceSymbols = null;
                        // [];
                        return GraphicsEndFill;
                    }(AS.ASObject);
                    display.GraphicsEndFill = GraphicsEndFill;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var GraphicsGradientFill = function (_super) {
                        __extends(GraphicsGradientFill, _super);
                        function GraphicsGradientFill(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                            if (type === void 0) {
                                type = 'linear';
                            }
                            if (colors === void 0) {
                                colors = null;
                            }
                            if (alphas === void 0) {
                                alphas = null;
                            }
                            if (ratios === void 0) {
                                ratios = null;
                            }
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (spreadMethod === void 0) {
                                spreadMethod = 'pad';
                            }
                            if (interpolationMethod === void 0) {
                                interpolationMethod = 'rgb';
                            }
                            if (focalPointRatio === void 0) {
                                focalPointRatio = 0;
                            }
                            _super.call(this);
                            this.type = axCoerceString(type);
                            this.colors = colors;
                            this.alphas = alphas;
                            this.ratios = ratios;
                            this.matrix = matrix;
                            this.spreadMethod = spreadMethod;
                            this.interpolationMethod = axCoerceString(interpolationMethod);
                            this.focalPointRatio = +focalPointRatio;
                        }
                        GraphicsGradientFill.classInitializer = null;
                        return GraphicsGradientFill;
                    }(AS.ASObject);
                    display.GraphicsGradientFill = GraphicsGradientFill;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var GraphicsPath = function (_super) {
                        __extends(GraphicsPath, _super);
                        function GraphicsPath(commands, data, winding) {
                            if (commands === void 0) {
                                commands = null;
                            }
                            if (data === void 0) {
                                data = null;
                            }
                            if (winding === void 0) {
                                winding = 'evenOdd';
                            }
                            _super.call(this);
                            this.commands = commands;
                            this.data = data;
                            this.winding = axCoerceString(winding);
                        }
                        // Called whenever the class is initialized.
                        GraphicsPath.classInitializer = null;
                        // List of static symbols to link.
                        GraphicsPath.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GraphicsPath.instanceSymbols = null;
                        // ["commands", "data", "_winding", "winding", "winding", "moveTo", "lineTo", "curveTo", "cubicCurveTo", "wideLineTo", "wideMoveTo", "ensureLists"];
                        return GraphicsPath;
                    }(AS.ASObject);
                    display.GraphicsPath = GraphicsPath;
                    var GraphicsPathCommand = function (_super) {
                        __extends(GraphicsPathCommand, _super);
                        function GraphicsPathCommand() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        GraphicsPathCommand.classInitializer = null;
                        // List of static symbols to link.
                        GraphicsPathCommand.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GraphicsPathCommand.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        GraphicsPathCommand.NO_OP = undefined;
                        GraphicsPathCommand.MOVE_TO = 1;
                        GraphicsPathCommand.LINE_TO = 2;
                        GraphicsPathCommand.CURVE_TO = 3;
                        GraphicsPathCommand.WIDE_MOVE_TO = 4;
                        GraphicsPathCommand.WIDE_LINE_TO = 5;
                        GraphicsPathCommand.CUBIC_CURVE_TO = 6;
                        return GraphicsPathCommand;
                    }(AS.ASObject);
                    display.GraphicsPathCommand = GraphicsPathCommand;
                    var GraphicsPathWinding = function (_super) {
                        __extends(GraphicsPathWinding, _super);
                        function GraphicsPathWinding() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        GraphicsPathWinding.classInitializer = null;
                        // List of static symbols to link.
                        GraphicsPathWinding.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GraphicsPathWinding.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        GraphicsPathWinding.EVEN_ODD = 'evenOdd';
                        GraphicsPathWinding.NON_ZERO = 'nonZero';
                        return GraphicsPathWinding;
                    }(AS.ASObject);
                    display.GraphicsPathWinding = GraphicsPathWinding;
                    var GraphicsSolidFill = function (_super) {
                        __extends(GraphicsSolidFill, _super);
                        function GraphicsSolidFill(color, alpha) {
                            if (color === void 0) {
                                color = 0;
                            }
                            if (alpha === void 0) {
                                alpha = 1;
                            }
                            _super.call(this);
                            this.color = color >>> 0;
                            this.alpha = +alpha;
                        }
                        // Called whenever the class is initialized.
                        GraphicsSolidFill.classInitializer = null;
                        // List of static symbols to link.
                        GraphicsSolidFill.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GraphicsSolidFill.instanceSymbols = null;
                        // ["color", "alpha"];
                        return GraphicsSolidFill;
                    }(AS.ASObject);
                    display.GraphicsSolidFill = GraphicsSolidFill;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var GraphicsStroke = function (_super) {
                        __extends(GraphicsStroke, _super);
                        function GraphicsStroke(thickness, pixelHinting, scaleMode, caps, joints, miterLimit, fill) {
                            if (thickness === void 0) {
                                thickness = NaN;
                            }
                            if (pixelHinting === void 0) {
                                pixelHinting = false;
                            }
                            if (scaleMode === void 0) {
                                scaleMode = 'normal';
                            }
                            if (caps === void 0) {
                                caps = 'none';
                            }
                            if (joints === void 0) {
                                joints = 'round';
                            }
                            if (miterLimit === void 0) {
                                miterLimit = 3;
                            }
                            if (fill === void 0) {
                                fill = null;
                            }
                            _super.call(this);
                            this.thickness = +thickness;
                            this.pixelHinting = !!pixelHinting;
                            this.scaleMode = axCoerceString(scaleMode);
                            this.caps = axCoerceString(caps);
                            this.joints = axCoerceString(joints);
                            this.miterLimit = +miterLimit;
                            this.fill = fill;
                        }
                        // Called whenever the class is initialized.
                        GraphicsStroke.classInitializer = null;
                        // List of static symbols to link.
                        GraphicsStroke.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GraphicsStroke.instanceSymbols = null;
                        // ["thickness", "pixelHinting", "miterLimit", "fill", "_scaleMode", "_caps", "_joints", "scaleMode", "scaleMode", "caps", "caps", "joints", "joints"];
                        return GraphicsStroke;
                    }(AS.ASObject);
                    display.GraphicsStroke = GraphicsStroke;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var GraphicsTrianglePath = function (_super) {
                        __extends(GraphicsTrianglePath, _super);
                        function GraphicsTrianglePath(vertices, indices, uvtData, culling) {
                            if (vertices === void 0) {
                                vertices = null;
                            }
                            if (indices === void 0) {
                                indices = null;
                            }
                            if (uvtData === void 0) {
                                uvtData = null;
                            }
                            if (culling === void 0) {
                                culling = 'none';
                            }
                            _super.call(this);
                            // TODO: coerce to vector types
                            this.vertices = vertices;
                            this.indices = indices;
                            this.uvtData = uvtData;
                            this.culling = axCoerceString(culling);
                        }
                        // Called whenever the class is initialized.
                        GraphicsTrianglePath.classInitializer = null;
                        // List of static symbols to link.
                        GraphicsTrianglePath.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GraphicsTrianglePath.instanceSymbols = null;
                        // ["indices", "vertices", "uvtData", "_culling", "culling", "culling"];
                        return GraphicsTrianglePath;
                    }(AS.ASObject);
                    display.GraphicsTrianglePath = GraphicsTrianglePath;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var clamp = Shumway.NumberUtilities.clamp;
                    var Bounds = Shumway.Bounds;
                    var assert = Shumway.Debug.assert;
                    var assertUnreachable = Shumway.Debug.assertUnreachable;
                    var GradientType = flash.display.GradientType;
                    var SpreadMethod = flash.display.SpreadMethod;
                    var InterpolationMethod = flash.display.InterpolationMethod;
                    var LineScaleMode = flash.display.LineScaleMode;
                    var CapsStyle = flash.display.CapsStyle;
                    var JointStyle = flash.display.JointStyle;
                    var ShapeData = Shumway.ShapeData;
                    function distanceSq(x1, y1, x2, y2) {
                        var dX = x2 - x1;
                        var dY = y2 - y1;
                        return dX * dX + dY * dY;
                    }
                    function quadraticBezier(from, cp, to, t) {
                        var inverseT = 1 - t;
                        return from * inverseT * inverseT + 2 * cp * inverseT * t + to * t * t;
                    }
                    function quadraticBezierExtreme(from, cp, to) {
                        var t = (from - cp) / (from - 2 * cp + to);
                        if (t < 0) {
                            return from;
                        }
                        if (t > 1) {
                            return to;
                        }
                        return quadraticBezier(from, cp, to, t);
                    }
                    function cubicBezier(from, cp, cp2, to, t) {
                        var tSq = t * t;
                        var inverseT = 1 - t;
                        var inverseTSq = inverseT * inverseT;
                        return from * inverseT * inverseTSq + 3 * cp * t * inverseTSq + 3 * cp2 * inverseT * tSq + to * t * tSq;
                    }
                    function cubicBezierExtremes(from, cp, cp2, to) {
                        var d1 = cp - from;
                        var d2 = cp2 - cp;
                        // We only ever need d2 * 2
                        d2 *= 2;
                        var d3 = to - cp2;
                        // Prevent division by zero by very slightly changing d3 if that would happen
                        if (d1 + d3 === d2) {
                            d3 *= 1.0001;
                        }
                        var fHead = 2 * d1 - d2;
                        var part1 = d2 - 2 * d1;
                        var fCenter = Math.sqrt(part1 * part1 - 4 * d1 * (d1 - d2 + d3));
                        var fTail = 2 * (d1 - d2 + d3);
                        var t1 = (fHead + fCenter) / fTail;
                        var t2 = (fHead - fCenter) / fTail;
                        var result = [];
                        if (t1 >= 0 && t1 <= 1) {
                            result.push(Math.round(cubicBezier(from, cp, cp2, to, t1)));
                        }
                        if (t2 >= 0 && t2 <= 1) {
                            result.push(Math.round(cubicBezier(from, cp, cp2, to, t2)));
                        }
                        return result;
                    }
                    function cubicXAtY(x0, y0, cx, cy, cx1, cy1, x1, y1, y) {
                        var dX = 3 * (cx - x0);
                        var dY = 3 * (cy - y0);
                        var bX = 3 * (cx1 - cx) - dX;
                        var bY = 3 * (cy1 - cy) - dY;
                        var c3X = x1 - x0 - dX - bX;
                        var c3Y = y1 - y0 - dY - bY;
                        // Find one root - any root - then factor out (t-r) to get a quadratic poly.
                        function f(t) {
                            return t * (dY + t * (bY + t * c3Y)) + y0 - y;
                        }
                        function pointAt(t) {
                            if (t < 0) {
                                t = 0;
                            } else if (t > 1) {
                                t = 1;
                            }
                            return x0 + t * (dX + t * (bX + t * c3X));
                        }
                        // Bisect the specified range to isolate an interval with a root.
                        function bisectCubicBezierRange(f, l, r, limit) {
                            if (Math.abs(r - l) <= limit) {
                                return;
                            }
                            var middle = 0.5 * (l + r);
                            if (f(l) * f(r) <= 0) {
                                left = l;
                                right = r;
                                return;
                            }
                            bisectCubicBezierRange(f, l, middle, limit);
                            bisectCubicBezierRange(f, middle, r, limit);
                        }
                        // some curves that loop around on themselves may require bisection
                        var left = 0;
                        var right = 1;
                        bisectCubicBezierRange(f, 0, 1, 0.05);
                        // experiment with tolerance - but not too tight :)
                        var t0 = findRoot(left, right, f, 50, 0.000001);
                        var evalResult = Math.abs(f(t0));
                        if (evalResult > 0.00001) {
                            return [];
                        }
                        var result = [];
                        if (t0 <= 1) {
                            result.push(pointAt(t0));
                        }
                        // Factor theorem: t-r is a factor of the cubic polynomial if r is a root.
                        // Use this to reduce to a quadratic poly. using synthetic division
                        var a = c3Y;
                        var b = t0 * a + bY;
                        var c = t0 * b + dY;
                        // Process the quadratic for the remaining two possible roots
                        var d = b * b - 4 * a * c;
                        if (d < 0) {
                            return result;
                        }
                        d = Math.sqrt(d);
                        a = 1 / (a + a);
                        var t1 = (d - b) * a;
                        var t2 = (-b - d) * a;
                        if (t1 >= 0 && t1 <= 1) {
                            result.push(pointAt(t1));
                        }
                        if (t2 >= 0 && t2 <= 1) {
                            result.push(pointAt(t2));
                        }
                        return result;
                    }
                    function findRoot(x0, x2, f, maxIterations, epsilon) {
                        var x1;
                        var y0;
                        var y1;
                        var y2;
                        var b;
                        var c;
                        var y10;
                        var y20;
                        var y21;
                        var xm;
                        var ym;
                        var temp;
                        var xmlast = x0;
                        y0 = f(x0);
                        if (y0 === 0) {
                            return x0;
                        }
                        y2 = f(x2);
                        if (y2 === 0) {
                            return x2;
                        }
                        if (y2 * y0 > 0) {
                            // dispatchEvent( new Event(ERROR) );
                            return x0;
                        }
                        var __iter = 0;
                        for (var i = 0; i < maxIterations; ++i) {
                            __iter++;
                            x1 = 0.5 * (x2 + x0);
                            y1 = f(x1);
                            if (y1 === 0) {
                                return x1;
                            }
                            if (Math.abs(x1 - x0) < epsilon) {
                                return x1;
                            }
                            if (y1 * y0 > 0) {
                                temp = x0;
                                x0 = x2;
                                x2 = temp;
                                temp = y0;
                                y0 = y2;
                                y2 = temp;
                            }
                            y10 = y1 - y0;
                            y21 = y2 - y1;
                            y20 = y2 - y0;
                            if (y2 * y20 < 2 * y1 * y10) {
                                x2 = x1;
                                y2 = y1;
                            } else {
                                b = (x1 - x0) / y10;
                                c = (y10 - y21) / (y21 * y20);
                                xm = x0 - b * y0 * (1 - c * y1);
                                ym = f(xm);
                                if (ym === 0) {
                                    return xm;
                                }
                                if (Math.abs(xm - xmlast) < epsilon) {
                                    return xm;
                                }
                                xmlast = xm;
                                if (ym * y0 < 0) {
                                    x2 = xm;
                                    y2 = ym;
                                } else {
                                    x0 = xm;
                                    y0 = ym;
                                    x2 = x1;
                                    y2 = y1;
                                }
                            }
                        }
                        return x1;
                    }
                    // See http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                    function rayIntersectsLine(x, y, x1, y1, x2, y2) {
                        return y2 > y !== y1 > y && x < (x1 - x2) * (y - y2) / (y1 - y2) + x2;
                    }
                    function rayFullyCrossesCurve(x, y, fromX, fromY, cpX, cpY, toX, toY) {
                        if (cpY > y === fromY > y && toY > y === fromY > y) {
                            return false;
                        }
                        if (fromX >= x && cpX >= x && toX >= x) {
                            return true;
                        }
                        // Finding the intersections with our ray means solving a quadratic
                        // equation of the form y = ax^2 + bx + c for y.
                        // See http://en.wikipedia.org/wiki/Quadratic_equation and
                        // http://code.google.com/p/degrafa/source/browse/trunk/Degrafa/com/degrafa/geometry/AdvancedQuadraticBezier.as?r=613#394
                        var a = fromY - 2 * cpY + toY;
                        var c = fromY - y;
                        var b = 2 * (cpY - fromY);
                        var d = b * b - 4 * a * c;
                        if (d < 0) {
                            return false;
                        }
                        d = Math.sqrt(d);
                        a = 1 / (a + a);
                        var t1 = (d - b) * a;
                        var t2 = (-b - d) * a;
                        var crosses = false;
                        if (t1 >= 0 && t1 <= 1 && quadraticBezier(fromX, cpX, toX, t1) > x) {
                            crosses = !crosses;
                        }
                        if (t2 >= 0 && t2 <= 1 && quadraticBezier(fromX, cpX, toX, t2) > x) {
                            crosses = !crosses;
                        }
                        return crosses;
                    }
                    function rayFullyCrossesCubicCurve(x, y, fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY) {
                        var curveStartsAfterY = fromY > y;
                        if (cpY > y === curveStartsAfterY && cp2Y > y === curveStartsAfterY && toY > y === curveStartsAfterY) {
                            return false;
                        }
                        if (fromX < x && cpX < x && cp2X < x && toX < x) {
                            return false;
                        }
                        var crosses = false;
                        var roots = cubicXAtY(fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY, y);
                        for (var i = roots.length; i; i--) {
                            if (roots[i] >= x) {
                                crosses = !crosses;
                            }
                        }
                        return crosses;
                    }
                    // end of GFX geometry.ts
                    var Graphics = function (_super) {
                        __extends(Graphics, _super);
                        function Graphics() {
                            _super.call(this);
                            this._id = flash.display.DisplayObject.getNextSyncID();
                            this._graphicsData = new ShapeData();
                            this._textures = [];
                            this._fillBounds = new Bounds(134217728, 134217728, 134217728, 134217728);
                            this._lineBounds = new Bounds(134217728, 134217728, 134217728, 134217728);
                            this._lastX = this._lastY = 0;
                            this._boundsIncludeLastCoordinates = true;
                            this._parent = null;
                            this._topLeftStrokeWidth = this._bottomRightStrokeWidth = 0;
                            this._isDirty = true;
                        }
                        Graphics.FromData = function (data, loaderInfo) {
                            var graphics = new loaderInfo.sec.flash.display.Graphics();
                            graphics._graphicsData = ShapeData.FromPlainObject(data.shape);
                            if (data.lineBounds) {
                                graphics._lineBounds.copyFrom(data.lineBounds);
                                graphics._fillBounds.copyFrom(data.fillBounds || data.lineBounds);
                            }
                            return graphics;
                        };
                        Graphics.prototype.getGraphicsData = function () {
                            return this._graphicsData;
                        };
                        Graphics.prototype.getUsedTextures = function () {
                            return this._textures;
                        };
                        /**
                         * Flash special-cases lines that are 1px and 3px wide.
                         * They're offset by 0.5px to the bottom-right.
                         */
                        Graphics.prototype._setStrokeWidth = function (width) {
                            switch (width) {
                            case 1:
                                this._topLeftStrokeWidth = 0;
                                this._bottomRightStrokeWidth = 1;
                                break;
                            case 3:
                                this._topLeftStrokeWidth = 1;
                                this._bottomRightStrokeWidth = 2;
                                break;
                            default:
                                var half = Math.ceil(width * 0.5) | 0;
                                this._topLeftStrokeWidth = half;
                                this._bottomRightStrokeWidth = half;
                                break;
                            }
                        };
                        Graphics.prototype._setParent = function (parent) {
                            release || assert(!this._parent);
                            this._parent = parent;
                        };
                        Graphics.prototype._invalidate = function () {
                            release || assert(this._parent, 'Graphics instances must have a parent.');
                            this._parent._invalidateFillAndLineBounds(true, true);
                            this._parent._propagateFlagsUp(536870912    /* DirtyDescendents */);
                            this._isDirty = true;
                        };
                        Graphics.prototype._getContentBounds = function (includeStrokes) {
                            if (includeStrokes === void 0) {
                                includeStrokes = true;
                            }
                            return includeStrokes ? this._lineBounds : this._fillBounds;
                        };
                        Graphics.prototype.clear = function () {
                            if (this._graphicsData.isEmpty()) {
                                return;
                            }
                            this._graphicsData.clear();
                            this._textures.length = 0;
                            this._fillBounds.setToSentinels();
                            this._lineBounds.setToSentinels();
                            this._lastX = this._lastY = 0;
                            this._boundsIncludeLastCoordinates = false;
                            this._invalidate();
                        };
                        /**
                         * Sets a solid color and opacity as the fill for subsequent drawing commands.
                         *
                         * @see http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/display/Graphics.html#beginFill%28%29
                         * @param color
                         * @param alpha While any Number is a valid input, the value is clamped to [0,1] and then scaled
                         * to an integer in the interval [0,0xff].
                         */
                        Graphics.prototype.beginFill = function (color, alpha) {
                            if (alpha === void 0) {
                                alpha = 1;
                            }
                            color = color >>> 0 & 16777215;
                            alpha = Math.round(clamp(+alpha, -1, 1) * 255) | 0;
                            this._graphicsData.beginFill(color << 8 | alpha);
                        };
                        Graphics.prototype.beginGradientFill = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (spreadMethod === void 0) {
                                spreadMethod = 'pad';
                            }
                            if (interpolationMethod === void 0) {
                                interpolationMethod = 'rgb';
                            }
                            if (focalPointRatio === void 0) {
                                focalPointRatio = 0;
                            }
                            this._writeGradientStyle(2    /* BeginGradientFill */, type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio, false);
                        };
                        Graphics.prototype.beginBitmapFill = function (bitmap, matrix, repeat, smooth) {
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (repeat === void 0) {
                                repeat = true;
                            }
                            if (smooth === void 0) {
                                smooth = false;
                            }
                            this._writeBitmapStyle(3    /* BeginBitmapFill */, bitmap, matrix, repeat, smooth, false);
                        };
                        Graphics.prototype.endFill = function () {
                            this._graphicsData.endFill();
                        };
                        //    beginShaderFill(shader: flash.display.Shader, matrix: flash.geom.Matrix = null): void {
                        //      //shader = shader; matrix = matrix;
                        //      release || notImplemented("public flash.display.Graphics::beginShaderFill"); return;
                        //    }
                        Graphics.prototype.lineStyle = function (thickness, color, alpha, pixelHinting, scaleMode, caps, joints, miterLimit) {
                            if (color === void 0) {
                                color = 0;
                            }
                            if (alpha === void 0) {
                                alpha = 1;
                            }
                            if (pixelHinting === void 0) {
                                pixelHinting = false;
                            }
                            if (scaleMode === void 0) {
                                scaleMode = 'normal';
                            }
                            if (caps === void 0) {
                                caps = null;
                            }
                            if (joints === void 0) {
                                joints = null;
                            }
                            if (miterLimit === void 0) {
                                miterLimit = 3;
                            }
                            thickness = +thickness;
                            color = color >>> 0 & 16777215;
                            alpha = Math.round(clamp(+alpha, -1, 1) * 255);
                            pixelHinting = !!pixelHinting;
                            scaleMode = axCoerceString(scaleMode);
                            caps = axCoerceString(caps);
                            joints = axCoerceString(joints);
                            miterLimit = clamp(+miterLimit | 0, 0, 255);
                            // Flash stops drawing strokes whenever a thickness is supplied that can't be coerced to a
                            // number.
                            if (isNaN(thickness)) {
                                this._setStrokeWidth(0);
                                this._graphicsData.endLine();
                                return;
                            }
                            thickness = clamp(+thickness, 0, 255) * 20 | 0;
                            this._setStrokeWidth(thickness);
                            // If `scaleMode` is invalid, "normal" is used.
                            var lineScaleMode = LineScaleMode.toNumber(axCoerceString(scaleMode));
                            if (lineScaleMode < 0) {
                                lineScaleMode = LineScaleMode.toNumber(LineScaleMode.NORMAL);
                            }
                            // If `caps` is invalid, "normal" is used.
                            var capsStyle = CapsStyle.toNumber(axCoerceString(caps));
                            if (capsStyle < 0) {
                                capsStyle = CapsStyle.toNumber(CapsStyle.ROUND);
                            }
                            // If `joints` is invalid, "normal" is used.
                            var jointStyle = JointStyle.toNumber(axCoerceString(joints));
                            if (jointStyle < 0) {
                                jointStyle = JointStyle.toNumber(JointStyle.ROUND);
                            }
                            this._graphicsData.lineStyle(thickness, color << 8 | alpha, pixelHinting, lineScaleMode, capsStyle, jointStyle, miterLimit);
                        };
                        Graphics.prototype.lineGradientStyle = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (spreadMethod === void 0) {
                                spreadMethod = 'pad';
                            }
                            if (interpolationMethod === void 0) {
                                interpolationMethod = 'rgb';
                            }
                            if (focalPointRatio === void 0) {
                                focalPointRatio = 0;
                            }
                            this._writeGradientStyle(6    /* LineStyleGradient */, type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio, !this._graphicsData.hasLines);
                        };
                        Graphics.prototype.lineBitmapStyle = function (bitmap, matrix, repeat, smooth) {
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (repeat === void 0) {
                                repeat = true;
                            }
                            if (smooth === void 0) {
                                smooth = false;
                            }
                            this._writeBitmapStyle(7    /* LineStyleBitmap */, bitmap, matrix, repeat, smooth, !this._graphicsData.hasLines);
                        };
                        Graphics.prototype.drawRect = function (x, y, width, height) {
                            x = x * 20 | 0;
                            y = y * 20 | 0;
                            var x2 = x + (width * 20 | 0);
                            var y2 = y + (height * 20 | 0);
                            if (x !== this._lastX || y !== this._lastY) {
                                this._graphicsData.moveTo(x, y);
                            }
                            this._graphicsData.lineTo(x2, y);
                            this._graphicsData.lineTo(x2, y2);
                            this._graphicsData.lineTo(x, y2);
                            this._graphicsData.lineTo(x, y);
                            this._extendBoundsByPoint(x2, y2);
                            this._applyLastCoordinates(x, y);
                            this._invalidate();
                        };
                        Graphics.prototype.drawRoundRect = function (x, y, width, height, ellipseWidth, ellipseHeight) {
                            x = +x;
                            y = +y;
                            width = +width;
                            height = +height;
                            ellipseWidth = +ellipseWidth;
                            ellipseHeight = +ellipseHeight;
                            if (!ellipseHeight || !ellipseWidth) {
                                this.drawRect(x, y, width, height);
                                return;
                            }
                            var radiusX = ellipseWidth / 2 | 0;
                            var radiusY = ellipseHeight / 2 | 0;
                            var hw = width / 2;
                            var hh = height / 2;
                            if (radiusX > hw) {
                                radiusX = hw;
                            }
                            if (radiusY > hh) {
                                radiusY = hh;
                            }
                            if (hw === radiusX && hh === radiusY) {
                                if (radiusX === radiusY) {
                                    this.drawCircle(x + radiusX, y + radiusY, radiusX);
                                } else {
                                    this.drawEllipse(x, y, radiusX * 2, radiusY * 2);
                                }
                                return;
                            }
                            //    A-----B
                            //  H         C
                            //  G         D
                            //    F-----E
                            //
                            // Drawing starts and stops at `D`. This is visible when the drawn shape forms part of a
                            // larger shape, with which it is then connected at `D`.
                            var right = x + width;
                            var bottom = y + height;
                            var xlw = x + radiusX;
                            var xrw = right - radiusX;
                            var ytw = y + radiusY;
                            var ybw = bottom - radiusY;
                            this.moveTo(right, ybw);
                            this.curveTo(right, bottom, xrw, bottom);
                            this.lineTo(xlw, bottom);
                            this.curveTo(x, bottom, x, ybw);
                            this.lineTo(x, ytw);
                            this.curveTo(x, y, xlw, y);
                            this.lineTo(xrw, y);
                            this.curveTo(right, y, right, ytw);
                            this.lineTo(right, ybw);
                        };
                        Graphics.prototype.drawRoundRectComplex = function (x, y, width, height, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius) {
                            x = +x;
                            y = +y;
                            width = +width;
                            height = +height;
                            topLeftRadius = +topLeftRadius;
                            topRightRadius = +topRightRadius;
                            bottomLeftRadius = +bottomLeftRadius;
                            bottomRightRadius = +bottomRightRadius;
                            if (!(topLeftRadius | topRightRadius | bottomLeftRadius | bottomRightRadius)) {
                                this.drawRect(x, y, width, height);
                                return;
                            }
                            var right = x + width;
                            var bottom = y + height;
                            var xtl = x + topLeftRadius;
                            this.moveTo(right, bottom - bottomRightRadius);
                            this.curveTo(right, bottom, right - bottomRightRadius, bottom);
                            this.lineTo(x + bottomLeftRadius, bottom);
                            this.curveTo(x, bottom, x, bottom - bottomLeftRadius);
                            this.lineTo(x, y + topLeftRadius);
                            this.curveTo(x, y, xtl, y);
                            this.lineTo(right - topRightRadius, y);
                            this.curveTo(right, y, right, y + topRightRadius);
                            this.lineTo(right, bottom - bottomRightRadius);
                        };
                        Graphics.prototype.drawCircle = function (x, y, radius) {
                            // TODO: Implement these using arcs not ellipses. The latter is not
                            // visually correct when the stroke is very thick and the circle is
                            // very small.
                            radius = +radius;
                            this.drawEllipse(+x - radius, +y - radius, radius * 2, radius * 2);
                        };
                        /**
                         * Here x and y are the top-left coordinates of the bounding box of the
                         * ellipse not the center as is the case for circles.
                         */
                        Graphics.prototype.drawEllipse = function (x, y, width, height) {
                            x = +x;
                            y = +y;
                            width = +width;
                            height = +height;
                            /*
                             *          , - ~ 3 ~ - ,
                             *      , '               ' ,
                             *    ,                       ,
                             *   ,                         ,
                             *  ,                           ,
                             *  2             o             0
                             *  ,                           ,
                             *   ,                         ,
                             *    ,                       ,
                             *      ,                  , '
                             *        ' - , _ 1 _ ,  '
                             */
                            var rx = width / 2;
                            var ry = height / 2;
                            // Move x, y to the middle of the ellipse.
                            x += rx;
                            y += ry;
                            var currentX = x + rx;
                            var currentY = y;
                            this.moveTo(currentX, currentY);
                            // 0
                            var startAngle = 0;
                            var u = 1;
                            var v = 0;
                            for (var i = 0; i < 4; i++) {
                                var endAngle = startAngle + Math.PI / 2;
                                var kappa = 4 / 3 * Math.tan((endAngle - startAngle) / 4);
                                var cp1x = currentX - v * kappa * rx;
                                var cp1y = currentY + u * kappa * ry;
                                u = Math.cos(endAngle);
                                v = Math.sin(endAngle);
                                currentX = x + u * rx;
                                currentY = y + v * ry;
                                var cp2x = currentX + v * kappa * rx;
                                var cp2y = currentY - u * kappa * ry;
                                this.cubicCurveTo(cp1x, cp1y, cp2x, cp2y, currentX, currentY);
                                startAngle = endAngle;
                            }
                        };
                        Graphics.prototype.moveTo = function (x, y) {
                            x = x * 20 | 0;
                            y = y * 20 | 0;
                            this._graphicsData.moveTo(x, y);
                            // Don't use _applyLastCoordinates because that extends the bounds objects, too.
                            this._lastX = x;
                            this._lastY = y;
                            this._boundsIncludeLastCoordinates = false;
                        };
                        Graphics.prototype.lineTo = function (x, y) {
                            x = x * 20 | 0;
                            y = y * 20 | 0;
                            this._graphicsData.lineTo(x, y);
                            this._applyLastCoordinates(x, y);
                            this._invalidate();
                        };
                        Graphics.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
                            controlX = controlX * 20 | 0;
                            controlY = controlY * 20 | 0;
                            anchorX = anchorX * 20 | 0;
                            anchorY = anchorY * 20 | 0;
                            this._graphicsData.curveTo(controlX, controlY, anchorX, anchorY);
                            if (controlX < this._lastX || controlX > anchorX) {
                                this._extendBoundsByX(quadraticBezierExtreme(this._lastX, controlX, anchorX) | 0);
                            }
                            if (controlY < this._lastY || controlY > anchorY) {
                                this._extendBoundsByY(quadraticBezierExtreme(this._lastY, controlY, anchorY) | 0);
                            }
                            this._applyLastCoordinates(anchorX, anchorY);
                            this._invalidate();
                        };
                        Graphics.prototype.cubicCurveTo = function (controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
                            controlX1 = controlX1 * 20 | 0;
                            controlY1 = controlY1 * 20 | 0;
                            controlX2 = controlX2 * 20 | 0;
                            controlY2 = controlY2 * 20 | 0;
                            anchorX = anchorX * 20 | 0;
                            anchorY = anchorY * 20 | 0;
                            this._graphicsData.cubicCurveTo(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY);
                            var extremes;
                            var i;
                            var fromX = this._lastX;
                            var fromY = this._lastY;
                            if (controlX1 < fromX || controlX2 < fromX || controlX1 > anchorX || controlX2 > anchorX) {
                                extremes = cubicBezierExtremes(fromX, controlX1, controlX2, anchorX);
                                for (i = extremes.length; i--;) {
                                    this._extendBoundsByX(extremes[i] | 0);
                                }
                            }
                            if (controlY1 < fromY || controlY2 < fromY || controlY1 > anchorY || controlY2 > anchorY) {
                                extremes = cubicBezierExtremes(fromY, controlY1, controlY2, anchorY);
                                for (i = extremes.length; i--;) {
                                    this._extendBoundsByY(extremes[i] | 0);
                                }
                            }
                            this._applyLastCoordinates(anchorX, anchorY);
                            this._invalidate();
                        };
                        Graphics.prototype.copyFrom = function (sourceGraphics) {
                            this._graphicsData = sourceGraphics._graphicsData.clone();
                            this._fillBounds = sourceGraphics._fillBounds.clone();
                            this._lineBounds = sourceGraphics._lineBounds.clone();
                            this._textures = sourceGraphics._textures.concat();
                            this._lastX = sourceGraphics._lastX;
                            this._lastY = sourceGraphics._lastY;
                            this._boundsIncludeLastCoordinates = sourceGraphics._boundsIncludeLastCoordinates;
                            this._invalidate();
                        };
                        //    lineShaderStyle(shader: flash.display.Shader, matrix: flash.geom.Matrix = null): void {
                        //      //shader = shader; matrix = matrix;
                        //      release || notImplemented("public flash.display.Graphics::lineShaderStyle"); return;
                        //    }
                        Graphics.prototype.drawPath = function (commands, data, winding) {
                            if (winding === void 0) {
                                winding = 'evenOdd';
                            }
                            commands = commands;
                            data = data;
                            winding = axCoerceString(winding);
                            release || notImplemented('public flash.display.Graphics::drawPath');
                            return;
                        };
                        Graphics.prototype.drawTriangles = function (vertices, indices, uvtData, culling) {
                            if (indices === void 0) {
                                indices = null;
                            }
                            if (uvtData === void 0) {
                                uvtData = null;
                            }
                            if (culling === void 0) {
                                culling = 'none';
                            }
                            vertices = vertices;
                            indices = indices;
                            uvtData = uvtData;
                            culling = axCoerceString(culling);
                            release || notImplemented('public flash.display.Graphics::drawTriangles');
                            return;
                        };
                        Graphics.prototype.drawGraphicsData = function (graphicsData) {
                            graphicsData = graphicsData;
                            release || notImplemented('public flash.display.Graphics::drawGraphicsData');
                            return;
                        };
                        /**
                         * Tests if the specified point is within this graphics path.
                         */
                        Graphics.prototype._containsPoint = function (x, y, includeLines, ratio) {
                            var hasLines = this._graphicsData.hasLines;
                            if (!ratio && !(includeLines && hasLines ? this._lineBounds : this._fillBounds).contains(x, y)) {
                                return false;
                            }
                            //      enterTimeline("Graphics._containsPoint");
                            var containsPoint = false;
                            // If we have any fills at all, tt's vastly more likely that the point is in a fill,
                            // so test that first.
                            if (this._graphicsData.hasFills) {
                                containsPoint = this._fillContainsPoint(x, y, ratio);
                            } else {
                                release || assert(hasLines, 'Can\'t have non-empty bounds without line or fill set.');
                            }
                            if (!containsPoint && includeLines) {
                                containsPoint = this._linesContainsPoint(x, y, ratio);
                            }
                            //      leaveTimeline();
                            return containsPoint;
                        };
                        Graphics.prototype._fillContainsPoint = function (x, y, ratio) {
                            //      enterTimeline("Graphics._fillContainsPoint");
                            var data = this._graphicsData;
                            var commands = data.commands;
                            var commandsCount = data.commandsPosition;
                            var coordinates = data.coordinates;
                            var morphCoordinates = data.morphCoordinates;
                            var coordinatesIndex = 0;
                            var fromX = 0;
                            var fromY = 0;
                            var toX = 0;
                            var toY = 0;
                            var cpX;
                            var cpY;
                            var formOpen = false;
                            var fillActive = false;
                            var formOpenX = 0;
                            var formOpenY = 0;
                            var inside = false;
                            // Description of serialization format can be found in ShapeData.
                            // Rough outline of the algorithm's mode of operation:
                            // from x,y an infinite ray to the right is "cast". All operations are then
                            // tested for intersections with this ray, where each intersection means
                            // switching between being outside and inside the shape.
                            for (var commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                                var command = commands[commandIndex];
                                switch (command) {
                                case 9    /* MoveTo */:
                                    release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                    if (formOpen && fillActive && rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                                        inside = !inside;
                                    }
                                    formOpen = true;
                                    fromX = formOpenX = coordinates[coordinatesIndex++];
                                    fromY = formOpenY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        fromX = formOpenX += (morphCoordinates[coordinatesIndex - 2] - formOpenX) * ratio;
                                        fromY = formOpenY += (morphCoordinates[coordinatesIndex - 2] - formOpenY) * ratio;
                                    }
                                    // Continue outer loop.
                                    continue;
                                case 10    /* LineTo */:
                                    release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                    toX = coordinates[coordinatesIndex++];
                                    toY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                        toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                    }
                                    if (fillActive && rayIntersectsLine(x, y, fromX, fromY, toX, toY)) {
                                        inside = !inside;
                                    }
                                    break;
                                case 11    /* CurveTo */:
                                    release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                                    cpX = coordinates[coordinatesIndex++];
                                    cpY = coordinates[coordinatesIndex++];
                                    toX = coordinates[coordinatesIndex++];
                                    toY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        cpX += (morphCoordinates[coordinatesIndex - 4] - cpX) * ratio;
                                        cpY += (morphCoordinates[coordinatesIndex - 3] - cpY) * ratio;
                                        toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                        toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                    }
                                    if (fillActive && rayFullyCrossesCurve(x, y, fromX, fromY, cpX, cpY, toX, toY)) {
                                        inside = !inside;
                                    }
                                    break;
                                case 12    /* CubicCurveTo */:
                                    release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                                    cpX = coordinates[coordinatesIndex++];
                                    cpY = coordinates[coordinatesIndex++];
                                    var cp2X = coordinates[coordinatesIndex++];
                                    var cp2Y = coordinates[coordinatesIndex++];
                                    toX = coordinates[coordinatesIndex++];
                                    toY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        cpX += (morphCoordinates[coordinatesIndex - 6] - cpX) * ratio;
                                        cpY += (morphCoordinates[coordinatesIndex - 5] - cpY) * ratio;
                                        cp2X += (morphCoordinates[coordinatesIndex - 4] - cp2X) * ratio;
                                        cp2Y += (morphCoordinates[coordinatesIndex - 3] - cp2Y) * ratio;
                                        toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                        toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                    }
                                    if (fillActive && rayFullyCrossesCubicCurve(x, y, fromX, fromY, cpX, cpY, cp2X, cp2Y, toX, toY)) {
                                        inside = !inside;
                                    }
                                    break;
                                case 1    /* BeginSolidFill */:
                                case 2    /* BeginGradientFill */:
                                case 3    /* BeginBitmapFill */:
                                case 4    /* EndFill */:
                                    if (formOpen && fillActive && rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                                        inside = !inside;
                                    }
                                    // If we close a sub-shape, we can return earlier if our point was inside of its path.
                                    if (inside) {
                                        return true;
                                    }
                                    formOpen = false;
                                    fillActive = command !== 4    /* EndFill */;
                                    break;
                                case 5    /* LineStyleSolid */:
                                    coordinatesIndex++;
                                    // Skip thickness
                                    break;
                                case 6    /* LineStyleGradient */:
                                case 7    /* LineStyleBitmap */:
                                case 8    /* LineEnd */:
                                    break;
                                default:
                                    release || assertUnreachable('Invalid command ' + command + ' encountered at index' + (commandIndex - 1) + ' of ' + commandsCount);
                                }
                                fromX = toX;
                                fromY = toY;
                            }
                            release || assert(commandIndex === commandsCount);
                            release || assert(coordinatesIndex === data.coordinatesPosition);
                            if (formOpen && fillActive && rayIntersectsLine(x, y, fromX, fromY, formOpenX, formOpenY)) {
                                inside = !inside;
                            }
                            //      leaveTimeline();
                            return inside;
                        };
                        Graphics.prototype._linesContainsPoint = function (x, y, ratio) {
                            //      enterTimeline("Graphics._lineContainsPoint");
                            var data = this._graphicsData;
                            var commands = data.commands;
                            var commandsCount = data.commandsPosition;
                            var coordinates = data.coordinates;
                            var morphCoordinates = data.morphCoordinates;
                            var coordinatesIndex = 0;
                            var fromX = 0;
                            var fromY = 0;
                            var toX = 0;
                            var toY = 0;
                            var cpX;
                            var cpY;
                            var curveX;
                            var curveY;
                            var t;
                            var width = 0;
                            var halfWidth = 0;
                            var halfWidthSq = 0;
                            var minX = 0;
                            var maxX = 0;
                            var minY = 0;
                            var maxY = 0;
                            // Description of serialization format can be found in ShapeData.
                            for (var commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                                var command = commands[commandIndex];
                                switch (command) {
                                case 9    /* MoveTo */:
                                    release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                    fromX = coordinates[coordinatesIndex++];
                                    fromY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        fromX += (morphCoordinates[coordinatesIndex - 2] - fromX) * ratio;
                                        fromY += (morphCoordinates[coordinatesIndex - 1] - fromY) * ratio;
                                    }
                                    // Continue outer loop.
                                    continue;
                                case 10    /* LineTo */:
                                    release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                                    if (width === 0) {
                                        fromX = coordinates[coordinatesIndex++];
                                        fromY = coordinates[coordinatesIndex++];
                                        if (ratio) {
                                            fromX += (morphCoordinates[coordinatesIndex - 2] - fromX) * ratio;
                                            fromY += (morphCoordinates[coordinatesIndex - 1] - fromY) * ratio;
                                        }
                                        continue;
                                    }
                                    toX = coordinates[coordinatesIndex++];
                                    toY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                        toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                    }
                                    // Lines with length == 0 aren't rendered.
                                    if (fromX === toX && fromY === toY) {
                                        break;
                                    }
                                    // Eliminate based on bounds.
                                    if (maxX < fromX && maxX < toX || minX > fromX && minX > toX || maxY < fromY && maxY < toY || minY > fromY && minY > toY) {
                                        break;
                                    }
                                    // Vertical and horizontal lines are a certain hit at this point
                                    if (toX === fromX || toY === fromY) {
                                        return true;
                                    }
                                    // http://stackoverflow.com/a/1501725/517791
                                    t = ((x - fromX) * (toX - fromX) + (y - fromY) * (toY - fromY)) / distanceSq(fromX, fromY, toX, toY);
                                    if (t < 0) {
                                        if (distanceSq(x, y, fromX, fromY) <= halfWidthSq) {
                                            return true;
                                        }
                                        break;
                                    }
                                    if (t > 1) {
                                        if (distanceSq(x, y, toX, toY) <= halfWidthSq) {
                                            return true;
                                        }
                                        break;
                                    }
                                    if (distanceSq(x, y, fromX + t * (toX - fromX), fromY + t * (toY - fromY)) <= halfWidthSq) {
                                        return true;
                                    }
                                    break;
                                case 11    /* CurveTo */:
                                    release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                                    if (width === 0) {
                                        coordinatesIndex += 2;
                                        fromX = coordinates[coordinatesIndex++];
                                        fromY = coordinates[coordinatesIndex++];
                                        if (ratio) {
                                            fromX += (morphCoordinates[coordinatesIndex - 2] - fromX) * ratio;
                                            fromY += (morphCoordinates[coordinatesIndex - 1] - fromY) * ratio;
                                        }
                                        continue;
                                    }
                                    cpX = coordinates[coordinatesIndex++];
                                    cpY = coordinates[coordinatesIndex++];
                                    toX = coordinates[coordinatesIndex++];
                                    toY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        cpX += (morphCoordinates[coordinatesIndex - 4] - cpX) * ratio;
                                        cpY += (morphCoordinates[coordinatesIndex - 3] - cpY) * ratio;
                                        toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                        toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                    }
                                    // Eliminate based on bounds
                                    var extremeX = quadraticBezierExtreme(fromX, cpX, toX);
                                    if (maxX < fromX && maxX < extremeX && maxX < toX || minX > fromX && minX > extremeX && minX > toX) {
                                        break;
                                    }
                                    var extremeY = quadraticBezierExtreme(fromY, cpY, toY);
                                    if (maxY < fromY && maxY < extremeY && maxY < toY || minY > fromY && minY > extremeY && minY > toY) {
                                        break;
                                    }
                                    // So, this is very much not ideal, but I'll punt on proper curve
                                    // hit-testing for now and just sample an amount of points that seems
                                    // sufficient.
                                    for (t = 0; t < 1; t += 0.02) {
                                        curveX = quadraticBezier(fromX, cpX, toX, t);
                                        if (curveX < minX || curveX > maxX) {
                                            continue;
                                        }
                                        curveY = quadraticBezier(fromY, cpY, toY, t);
                                        if (curveY < minY || curveY > maxY) {
                                            continue;
                                        }
                                        if ((x - curveX) * (x - curveX) + (y - curveY) * (y - curveY) < halfWidthSq) {
                                            return true;
                                        }
                                    }
                                    break;
                                case 12    /* CubicCurveTo */:
                                    release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                                    if (width === 0) {
                                        coordinatesIndex += 4;
                                        fromX = coordinates[coordinatesIndex++];
                                        fromX = coordinates[coordinatesIndex++];
                                        if (ratio) {
                                            fromX += (morphCoordinates[coordinatesIndex - 2] - fromX) * ratio;
                                            fromY += (morphCoordinates[coordinatesIndex - 1] - fromY) * ratio;
                                        }
                                        continue;
                                    }
                                    cpX = coordinates[coordinatesIndex++];
                                    cpY = coordinates[coordinatesIndex++];
                                    var cp2X = coordinates[coordinatesIndex++];
                                    var cp2Y = coordinates[coordinatesIndex++];
                                    toX = coordinates[coordinatesIndex++];
                                    toY = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        cpX += (morphCoordinates[coordinatesIndex - 6] - cpX) * ratio;
                                        cpY += (morphCoordinates[coordinatesIndex - 5] - cpY) * ratio;
                                        cp2X += (morphCoordinates[coordinatesIndex - 4] - cp2X) * ratio;
                                        cp2Y += (morphCoordinates[coordinatesIndex - 3] - cp2Y) * ratio;
                                        toX += (morphCoordinates[coordinatesIndex - 2] - toX) * ratio;
                                        toY += (morphCoordinates[coordinatesIndex - 1] - toY) * ratio;
                                    }
                                    // Eliminate based on bounds
                                    var extremesX = cubicBezierExtremes(fromX, cpX, cp2X, toX);
                                    while (extremesX.length < 2) {
                                        extremesX.push(toX);
                                    }
                                    if (maxX < fromX && maxX < toX && maxX < extremesX[0] && maxX < extremesX[1] || minX > fromX && minX > toX && minX > extremesX[0] && minX > extremesX[1]) {
                                        break;
                                    }
                                    var extremesY = cubicBezierExtremes(fromY, cpY, cp2Y, toY);
                                    while (extremesY.length < 2) {
                                        extremesY.push(toY);
                                    }
                                    if (maxY < fromY && maxY < toY && maxY < extremesY[0] && maxY < extremesY[1] || minY > fromY && minY > toY && minY > extremesY[0] && minY > extremesY[1]) {
                                        break;
                                    }
                                    // So, this is very much not ideal, but I'll punt on proper curve
                                    // hit-testing for now and just sample an amount of points that seems
                                    // sufficient.
                                    for (t = 0; t < 1; t += 0.02) {
                                        curveX = cubicBezier(fromX, cpX, cp2X, toX, t);
                                        if (curveX < minX || curveX > maxX) {
                                            continue;
                                        }
                                        curveY = cubicBezier(fromY, cpY, cp2Y, toY, t);
                                        if (curveY < minY || curveY > maxY) {
                                            continue;
                                        }
                                        if ((x - curveX) * (x - curveX) + (y - curveY) * (y - curveY) < halfWidthSq) {
                                            return true;
                                        }
                                    }
                                    break;
                                case 5    /* LineStyleSolid */:
                                    width = coordinates[coordinatesIndex++];
                                    if (ratio) {
                                        width += (morphCoordinates[coordinatesIndex - 1] - width) * ratio;
                                    }
                                    halfWidth = width >> 2;
                                    halfWidthSq = halfWidth * halfWidth;
                                    minX = x - halfWidth;
                                    maxX = x + halfWidth;
                                    minY = y - halfWidth;
                                    maxY = y + halfWidth;
                                    break;
                                case 1    /* BeginSolidFill */:
                                case 2    /* BeginGradientFill */:
                                case 3    /* BeginBitmapFill */:
                                case 4    /* EndFill */:
                                case 6    /* LineStyleGradient */:
                                case 7    /* LineStyleBitmap */:
                                case 8    /* LineEnd */:
                                    break;
                                default:
                                    release || assertUnreachable('Invalid command ' + command + ' encountered at index' + (commandIndex - 1) + ' of ' + commandsCount);
                                }
                                fromX = toX;
                                fromY = toY;
                            }
                            release || assert(commandIndex === commandsCount);
                            release || assert(coordinatesIndex === data.coordinatesPosition);
                            //      leaveTimeline();
                            return false;
                        };
                        /**
                         * Bitmaps are specified the same for fills and strokes, so we only need to serialize them
                         * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
                         * be one of PathCommand.BeginBitmapFill and PathCommand.LineStyleBitmap.
                         *
                         * This method doesn't actually write anything if the `skipWrite` argument is true. In that
                         * case, it only does arguments checks so the right exceptions are thrown.
                         */
                        Graphics.prototype._writeBitmapStyle = function (pathCommand, bitmap, matrix, repeat, smooth, skipWrite) {
                            if (Shumway.isNullOrUndefined(bitmap)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'bitmap');
                            }
                            if (!this.sec.flash.display.BitmapData.axIsType(bitmap)) {
                                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, 'bitmap', 'flash.display.BitmapData');
                            }
                            if (Shumway.isNullOrUndefined(matrix)) {
                                matrix = this.sec.flash.geom.Matrix.axClass.FROZEN_IDENTITY_MATRIX;
                            } else if (!this.sec.flash.geom.Matrix.axIsType(matrix)) {
                                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, 'matrix', 'flash.geom.Matrix');
                            }
                            repeat = !!repeat;
                            smooth = !!smooth;
                            if (skipWrite) {
                                return;
                            }
                            var index = this._textures.length;
                            this._textures.push(bitmap);
                            this._graphicsData.beginBitmap(pathCommand, index, matrix, repeat, smooth);
                        };
                        /**
                         * Gradients are specified the same for fills and strokes, so we only need to serialize them
                         * once. The Parameter `pathCommand` is treated as the actual command to serialize, and must
                         * be one of PathCommand.BeginGradientFill and PathCommand.LineStyleGradient.
                         *
                         * This method doesn't actually write anything if the `skipWrite` argument is true. In that
                         * case, it only does arguments checks so the right exceptions are thrown.
                         */
                        Graphics.prototype._writeGradientStyle = function (pathCommand, type, colors_, alphas_, ratios_, matrix, spreadMethod, interpolationMethod, focalPointRatio, skipWrite) {
                            if (Shumway.isNullOrUndefined(type)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'type');
                            }
                            var gradientType = GradientType.toNumber(axCoerceString(type));
                            if (gradientType < 0) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.InvalidEnumError, 'type');
                            }
                            if (Shumway.isNullOrUndefined(colors_)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'colors');
                            }
                            var arrayClass = this.sec.AXArray;
                            if (!arrayClass.axIsInstanceOf(colors_)) {
                                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, 'colors', 'Array');
                            }
                            var colors = colors_.value;
                            if (Shumway.isNullOrUndefined(alphas_)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'alphas');
                            }
                            if (!arrayClass.axIsInstanceOf(alphas_)) {
                                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, 'alphas', 'Array');
                            }
                            var alphas = alphas_.value;
                            if (Shumway.isNullOrUndefined(ratios_)) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'ratios');
                            }
                            if (!arrayClass.axIsInstanceOf(ratios_)) {
                                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, 'ratios', 'Array');
                            }
                            var ratios = ratios_.value;
                            var colorsRGBA = [];
                            var coercedRatios = [];
                            var colorStops = colors.length;
                            var recordsValid = colorStops === alphas.length && colorStops === ratios.length;
                            if (recordsValid) {
                                for (var i = 0; i < colorStops; i++) {
                                    var ratio = +ratios[i];
                                    if (ratio > 255 || ratio < 0) {
                                        recordsValid = false;
                                        break;
                                    }
                                    colorsRGBA[i] = colors[i] << 8 & 4294967040 | clamp(+alphas[i], 0, 1) * 255;
                                    coercedRatios[i] = ratio;
                                }
                            }
                            // If the colors, alphas and ratios arrays don't all have the same length or if any of the
                            // given ratios falls outside [0,0xff], Flash just ignores the gradient style.
                            if (!recordsValid) {
                                return;
                            }
                            if (Shumway.isNullOrUndefined(matrix)) {
                                matrix = this.sec.flash.geom.Matrix.axClass.FROZEN_IDENTITY_MATRIX;
                            } else if (!this.sec.flash.geom.Matrix.axIsType(matrix)) {
                                this.sec.throwError('TypeError', AVMX.Errors.CheckTypeFailedError, 'matrix', 'flash.geom.Matrix');
                            }
                            if (skipWrite) {
                                return;
                            }
                            // If `spreadMethod` is invalid, "pad" is used.
                            var spread = SpreadMethod.toNumber(axCoerceString(spreadMethod));
                            if (spread < 0) {
                                spread = SpreadMethod.toNumber(SpreadMethod.PAD);
                            }
                            // If `interpolationMethod` is invalid, "rgb" is used.
                            var interpolation = InterpolationMethod.toNumber(axCoerceString(interpolationMethod));
                            if (interpolation < 0) {
                                interpolation = InterpolationMethod.toNumber(InterpolationMethod.RGB);
                            }
                            // Matrix has to be transformed to ShapeMatrix because the scaling is totally different.
                            var scaledMatrix = {
                                a: matrix.a * 819.2,
                                b: matrix.b * 819.2,
                                c: matrix.c * 819.2,
                                d: matrix.d * 819.2,
                                tx: matrix.tx,
                                ty: matrix.ty
                            };
                            // Focal point is scaled by 0xff, divided by 2, rounded and stored as a signed short.
                            focalPointRatio = clamp(+focalPointRatio, -1, 1) / 2 * 255 | 0;
                            this._graphicsData.beginGradient(pathCommand, colorsRGBA, coercedRatios, gradientType, scaledMatrix, spread, interpolation, focalPointRatio);
                        };
                        Graphics.prototype._extendBoundsByPoint = function (x, y) {
                            this._extendBoundsByX(x);
                            this._extendBoundsByY(y);
                        };
                        Graphics.prototype._extendBoundsByX = function (x) {
                            this._fillBounds.extendByX(x);
                            var bounds = this._lineBounds;
                            if (bounds.xMin === 134217728) {
                                bounds.xMin = x - this._topLeftStrokeWidth;
                                bounds.xMax = x + this._bottomRightStrokeWidth;
                            } else {
                                bounds.xMin = Math.min(x - this._topLeftStrokeWidth, bounds.xMin);
                                bounds.xMax = Math.max(x + this._bottomRightStrokeWidth, bounds.xMax);
                            }
                        };
                        Graphics.prototype._extendBoundsByY = function (y) {
                            this._fillBounds.extendByY(y);
                            var bounds = this._lineBounds;
                            if (bounds.yMin === 134217728) {
                                bounds.yMin = y - this._topLeftStrokeWidth;
                                bounds.yMax = y + this._bottomRightStrokeWidth;
                            } else {
                                bounds.yMin = Math.min(y - this._topLeftStrokeWidth, bounds.yMin);
                                bounds.yMax = Math.max(y + this._bottomRightStrokeWidth, bounds.yMax);
                            }
                        };
                        Graphics.prototype._applyLastCoordinates = function (x, y) {
                            if (!this._boundsIncludeLastCoordinates) {
                                this._extendBoundsByPoint(this._lastX, this._lastY);
                            }
                            this._boundsIncludeLastCoordinates = true;
                            this._lastX = x;
                            this._lastY = y;
                            this._extendBoundsByPoint(x, y);
                        };
                        Graphics.classInitializer = null;
                        return Graphics;
                    }(AS.ASObject);
                    display.Graphics = Graphics;
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var Timeline = Shumway.Timeline;
                    var clamp = Shumway.NumberUtilities.clamp;
                    var DragMode;
                    (function (DragMode) {
                        DragMode[DragMode['Inactive'] = 0] = 'Inactive';
                        // Indicates that the dragged object is locked to the center of the mouse position.
                        DragMode[DragMode['LockToPointer'] = 1] = 'LockToPointer';
                        // Indicates that the dragged object is locked to the point where the dragging process started.
                        DragMode[DragMode['PreserveDistance'] = 2] = 'PreserveDistance';
                    }(DragMode || (DragMode = {})));
                    var Sprite = function (_super) {
                        __extends(Sprite, _super);
                        function Sprite() {
                            if (this._symbol && !this._fieldsInitialized) {
                                this.applySymbol();
                            }
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                            this._constructChildren();
                        }
                        Sprite.prototype.applySymbol = function () {
                            release || assert(this._symbol);
                            this._initializeFields();
                            var symbol = this._symbol;
                            if (symbol.isRoot) {
                                this._root = this;
                            }
                            this._children = [];
                            if (symbol.numFrames && symbol.frames.length > 0) {
                                // For a SWF's root symbol, all frames are added after initialization, with
                                // _initializeChildren called after the first frame is added.
                                this._initializeChildren(symbol.frames[0]);
                            }
                        };
                        Sprite.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this);
                            this._graphics = null;
                            this._buttonMode = false;
                            this._dropTarget = null;
                            this._hitArea = null;
                            this._useHandCursor = true;
                            this._dragMode = DragMode.Inactive;
                            this._dragDeltaX = 0;
                            this._dragDeltaY = 0;
                            this._dragBounds = null;
                            this._hitTarget = null;
                        };
                        Sprite.prototype._addFrame = function (frame) {
                            var frames = this._symbol.frames;
                            frames.push(frame);
                            if (frames.length === 1) {
                                this._initializeChildren(frame);
                            }
                        };
                        Sprite.prototype._initializeChildren = function (frame) {
                            if (frame.controlTags) {
                                this._processControlTags(frame.controlTags, false);
                            }
                        };
                        Sprite.prototype._processControlTags = function (tags, backwards) {
                            // When seeking backwards all timeline objects will be removed unless they are placed again.
                            if (backwards) {
                                var children = this._children.slice();
                                for (var i = 0; i < children.length; i++) {
                                    var child = children[i];
                                    if (child._depth < 0) {
                                        continue;
                                    }
                                    // For AVM1 objects, children with depth 16384 (0 from API point of view)
                                    // are not removed.
                                    if ('_as2Object' in child && child._depth >= 16384) {
                                        continue;
                                    }
                                    var tag = null;
                                    // Look for a control tag tag that places an object at the same depth as the current
                                    // child.
                                    for (var j = 0; j < tags.length; j++) {
                                        if (tags[j].depth === child._depth) {
                                            tag = tags[j];
                                            break;
                                        }
                                    }
                                    // If no such tag was found or a different object is placed, remove the current child.
                                    if (!tag || child._symbol.id !== tag.symbolId || child._ratio !== (tag.ratio | 0)) {
                                        this._removeAnimatedChild(child);
                                    }
                                }
                            }
                            var loaderInfo = this._symbol.loaderInfo;
                            for (var i = 0; i < tags.length; i++) {
                                // We may have a mix of the parsed and unparsed tags.
                                var parsedOrUnparsedTag = tags[i];
                                var tag = parsedOrUnparsedTag.tagCode === undefined ? parsedOrUnparsedTag : loaderInfo._file.getParsedTag(parsedOrUnparsedTag);
                                switch (tag.code) {
                                case 5    /* CODE_REMOVE_OBJECT */:
                                case 28    /* CODE_REMOVE_OBJECT2 */:
                                    var child = this.getTimelineObjectAtDepth(tag.depth | 0);
                                    if (child) {
                                        this._removeAnimatedChild(child);
                                    }
                                    break;
                                case 4    /* CODE_PLACE_OBJECT */:
                                case 26    /* CODE_PLACE_OBJECT2 */:
                                case 70    /* CODE_PLACE_OBJECT3 */:
                                    var placeObjectTag = tag;
                                    var depth = placeObjectTag.depth;
                                    var child = this.getTimelineObjectAtDepth(depth);
                                    var hasCharacter = placeObjectTag.symbolId > -1;
                                    // Check for invalid flag constellations.
                                    if (placeObjectTag.flags & 1    /* Move */) {
                                        // Invalid case 1: Move flag set but no child found at given depth.
                                        if (!child) {
                                            //  Ignore the current tag.
                                            break;
                                        }
                                    } else if (!hasCharacter || child && !(backwards && hasCharacter)) {
                                        // Invalid case 2: Neither Move nor HasCharacter flag set.
                                        // Invalid case 3: HasCharacter flag set but given depth is already occupied by a
                                        // another object (only if seeking forward).
                                        Shumway.Debug.warning('Warning: Failed to place object at depth ' + depth + '.');
                                        break;
                                    }
                                    var symbol = null;
                                    if (hasCharacter) {
                                        symbol = loaderInfo.getSymbolById(placeObjectTag.symbolId);
                                        // The Flash Player ignores references to undefined symbols here. So should we.
                                        if (!symbol) {
                                            break;
                                        }
                                    }
                                    if (child) {
                                        if (symbol && !symbol.dynamic) {
                                            // If the current object is of a simple type (for now Shapes, MorphShapes and
                                            // StaticText) only its static content is updated instead of replacing it with a
                                            // new instance. TODO: Handle
                                            // http://wahlers.com.br/claus/blog/hacking-swf-2-placeobject-and-ratio/.
                                            child._setStaticContentFromSymbol(symbol);
                                        }
                                        // We animate the object only if a user script didn't touch any of the properties
                                        // this would affect.
                                        if (child._hasFlags(4096    /* AnimatedByTimeline */)) {
                                            child._animate(tag);
                                        }
                                    } else {
                                        // Place a new instance of the symbol.
                                        child = this.createAnimatedDisplayObject(symbol, placeObjectTag, false);
                                        this.addTimelineObjectAtDepth(child, depth);
                                        if (symbol.isAVM1Object) {
                                            child._placeObjectTag = placeObjectTag;
                                            child._setFlags(131072    /* HasPlaceObjectInitPending */);
                                        }
                                    }
                                    break;
                                }
                            }
                        };
                        Sprite.prototype._removeAnimatedChild = function (child) {
                            this.removeChild(child);
                            if (child._name) {
                                if (this.axGetPublicProperty(child._name) === child) {
                                    this.axSetPublicProperty(child._name, null);
                                }
                            }
                            if (child._maskedObject) {
                                child._maskedObject.mask = null;
                            }
                        };
                        Sprite.prototype._canHaveGraphics = function () {
                            return true;
                        };
                        Sprite.prototype._getGraphics = function () {
                            return this._graphics;
                        };
                        Object.defineProperty(Sprite.prototype, 'graphics', {
                            get: function () {
                                return this._ensureGraphics();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sprite.prototype, 'buttonMode', {
                            get: function () {
                                return this._buttonMode;
                            },
                            set: function (value) {
                                this._buttonMode = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sprite.prototype, 'dropTarget', {
                            get: function () {
                                return this._dropTarget;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sprite.prototype, 'hitArea', {
                            get: function () {
                                return this._hitArea;
                            },
                            set: function (value) {
                                value = value;
                                if (this._hitArea === value) {
                                    return;
                                }
                                if (value && value._hitTarget) {
                                    value._hitTarget._hitArea = null;
                                }
                                this._hitArea = value;
                                if (value) {
                                    value._hitTarget = this;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sprite.prototype, 'useHandCursor', {
                            get: function () {
                                return this._useHandCursor;
                            },
                            set: function (value) {
                                this._useHandCursor = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sprite.prototype, 'soundTransform', {
                            get: function () {
                                release || notImplemented('public flash.display.Sprite::get soundTransform');
                                return;    // return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                sndTransform = sndTransform;
                                release || notImplemented('public flash.display.Sprite::set soundTransform');
                                return;    // this._soundTransform = sndTransform;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * Returns the current mouse position relative to this object.
                         */
                        Sprite.prototype._getDragMousePosition = function () {
                            var position = this.sec.flash.ui.Mouse.axClass._currentPosition;
                            if (this._parent) {
                                position = this._parent.globalToLocal(position);
                            }
                            return position;
                        };
                        Sprite.prototype.startDrag = function (lockCenter, bounds) {
                            if (lockCenter === void 0) {
                                lockCenter = false;
                            }
                            if (bounds === void 0) {
                                bounds = null;
                            }
                            lockCenter = !!lockCenter;
                            if (lockCenter) {
                                this._dragMode = DragMode.LockToPointer;
                            } else {
                                this._dragMode = DragMode.PreserveDistance;
                                var mousePosition = this._getDragMousePosition();
                                this._dragDeltaX = this.x - mousePosition.x;
                                this._dragDeltaY = this.y - mousePosition.y;
                            }
                            this._dragBounds = bounds;
                            // TODO: Our mouse handling logic looks up draggableObject on stage.sec.flash.ui.Mouse.axClass
                            // to update its position. Could there be a case where stage.sec !== this.sec?
                            this.sec.flash.ui.Mouse.axClass.draggableObject = this;
                        };
                        Sprite.prototype.stopDrag = function () {
                            if (this.sec.flash.ui.Mouse.axClass.draggableObject === this) {
                                this.sec.flash.ui.Mouse.axClass.draggableObject = null;
                                this._dragMode = DragMode.Inactive;
                                this._dragDeltaX = 0;
                                this._dragDeltaY = 0;
                                this._dragBounds = null;
                            }
                        };
                        Sprite.prototype._updateDragState = function (dropTarget) {
                            if (dropTarget === void 0) {
                                dropTarget = null;
                            }
                            var mousePosition = this._getDragMousePosition();
                            var newX = mousePosition.x;
                            var newY = mousePosition.y;
                            if (this._dragMode === DragMode.PreserveDistance) {
                                // Preserve the distance to the point where the dragging process started.
                                newX += this._dragDeltaX;
                                newY += this._dragDeltaY;
                            }
                            if (this._dragBounds) {
                                // Clamp new position to constraint bounds.
                                var bounds = this._dragBounds;
                                newX = clamp(newX, bounds.left, bounds.right);
                                newY = clamp(newY, bounds.top, bounds.bottom);
                            }
                            this.x = newX;
                            this.y = newY;
                            this._dropTarget = dropTarget;
                        };
                        Sprite.prototype.startTouchDrag = function (touchPointID, lockCenter, bounds) {
                            if (lockCenter === void 0) {
                                lockCenter = false;
                            }
                            if (bounds === void 0) {
                                bounds = null;
                            }
                            touchPointID = touchPointID | 0;
                            lockCenter = !!lockCenter;
                            bounds = bounds;
                            release || notImplemented('public flash.display.Sprite::startTouchDrag');
                            return;
                        };
                        Sprite.prototype.stopTouchDrag = function (touchPointID) {
                            touchPointID = touchPointID | 0;
                            release || notImplemented('public flash.display.Sprite::stopTouchDrag');
                            return;
                        };
                        Sprite.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                            // If looking for a drop target, ignore this object if it is the one being dragged.
                            if (testingType === 5    /* Drop */ && this._dragMode > DragMode.Inactive) {
                                return;
                            }
                            var result = this._boundsAndMaskContainPoint(globalX, globalY, localX, localY, testingType);
                            if (!result && testingType === 3    /* Mouse */ && this._hitArea && this._mouseEnabled) {
                                var matrix = this._hitArea._getInvertedConcatenatedMatrix();
                                var hitAreaLocalX = matrix.transformX(globalX, globalY);
                                var hitAreaLocalY = matrix.transformY(globalX, globalY);
                                result = this._hitArea._boundsAndMaskContainPoint(globalX, globalY, hitAreaLocalX, hitAreaLocalY, testingType);
                            }
                            if (result === 0    /* None */ || testingType < 2    /* HitTestShape */) {
                                return result;
                            }
                            return this._containsPointImpl(globalX, globalY, localX, localY, testingType, objects, true);
                        };
                        Sprite.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                            if (this._hitArea) {
                                return !!this._hitArea._containsGlobalPoint(globalX, globalY, 2    /* HitTestShape */, null);
                            }
                            var graphics = this._getGraphics();
                            return !!graphics && graphics._containsPoint(localX, localY, true, 0);
                        };
                        Sprite.classInitializer = null;
                        // List of static symbols to link.
                        Sprite.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Sprite.instanceSymbols = null;
                        // [];
                        return Sprite;
                    }(flash.display.DisplayObjectContainer);
                    display.Sprite = Sprite;
                    var SpriteSymbol = function (_super) {
                        __extends(SpriteSymbol, _super);
                        function SpriteSymbol(data, loaderInfo) {
                            _super.call(this, data, loaderInfo.app.sec.flash.display.MovieClip.axClass, true);
                            this.numFrames = 1;
                            this.frames = [];
                            this.labels = [];
                            this.loaderInfo = loaderInfo;
                        }
                        SpriteSymbol.FromData = function (data, loaderInfo) {
                            var symbol = new SpriteSymbol(data, loaderInfo);
                            symbol.numFrames = data.frameCount;
                            if (loaderInfo.actionScriptVersion === display.ActionScriptVersion.ACTIONSCRIPT2) {
                                symbol.isAVM1Object = true;
                                symbol.avm1Context = loaderInfo._avm1Context;
                            }
                            var frames = data.frames;
                            var frameLabelCtor = loaderInfo.app.sec.flash.display.FrameLabel;
                            for (var i = 0; i < frames.length; i++) {
                                var frame = loaderInfo.getFrame(data, i);
                                if (frame.labelName) {
                                    symbol.labels.push(new frameLabelCtor(frame.labelName, i + 1));
                                }
                                symbol.frames.push(frame);
                            }
                            return symbol;
                        };
                        return SpriteSymbol;
                    }(Timeline.DisplaySymbol);
                    display.SpriteSymbol = SpriteSymbol;
                    var assert = Shumway.Debug.assert;
                    var assertUnreachable = Shumway.Debug.assertUnreachable;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var Telemetry = Shumway.Telemetry;
                    var events = flash.events;
                    var MovieClipSoundsManager = function () {
                        function MovieClipSoundsManager(mc) {
                            this._mc = mc;
                            this._startSoundRegistrations = null;
                            this._soundStream = null;
                        }
                        MovieClipSoundsManager.prototype.registerStartSounds = function (frameNum, soundStartInfo) {
                            if (this._startSoundRegistrations === null) {
                                this._startSoundRegistrations = {};
                            }
                            this._startSoundRegistrations[frameNum] = soundStartInfo;
                        };
                        MovieClipSoundsManager.prototype.initSoundStream = function (streamInfo) {
                            this._soundStream = new display.MovieClipSoundStream(streamInfo, this._mc);
                        };
                        MovieClipSoundsManager.prototype.addSoundStreamBlock = function (frameNum, streamBlock) {
                            if (this._soundStream) {
                                this._soundStream.appendBlock(frameNum, streamBlock);
                            }
                        };
                        MovieClipSoundsManager.prototype._startSounds = function (frameNum) {
                            var starts = this._startSoundRegistrations[frameNum];
                            if (starts) {
                                var sounds = this._soundClips || (this._soundClips = {});
                                var loaderInfo = this._mc.loaderInfo;
                                for (var i = 0; i < starts.length; i++) {
                                    var start = starts[i];
                                    var symbolId = start.soundId;
                                    var info = start.soundInfo;
                                    var sound = sounds[symbolId];
                                    if (!sound) {
                                        var symbolInfo = loaderInfo.getSymbolById(symbolId);
                                        if (!symbolInfo) {
                                            continue;
                                        }
                                        var symbolClass = symbolInfo.symbolClass;
                                        var soundObj = AS.constructClassFromSymbol(symbolInfo, symbolClass);
                                        sounds[symbolId] = sound = { object: soundObj };
                                    }
                                    var stop = info.flags & 32    /* Stop */;
                                    if (sound.channel && stop) {
                                        sound.channel.stop();
                                        sound.channel = null;
                                    }
                                    if (!stop && (!sound.channel || !sound.channel.playing)) {
                                        // TODO envelope, in/out point
                                        var loops = info.flags & 4    /* HasLoops */ ? info.loopCount : 0;
                                        sound.channel = sound.object.play(0, loops);
                                    }
                                }
                            }
                        };
                        MovieClipSoundsManager.prototype.syncSounds = function (frameNum) {
                            if (this._startSoundRegistrations !== null) {
                                this._startSounds(frameNum);
                            }
                            if (this._soundStream) {
                                this._soundStream.playFrame(frameNum);
                            }
                        };
                        return MovieClipSoundsManager;
                    }();
                    function compareFrameScripts(a, b) {
                        if (!a.precedence) {
                            return !b.precedence ? 0 : -1;
                        } else if (!b.precedence) {
                            return 1;
                        }
                        var i = 0;
                        while (i < a.precedence.length && i < b.precedence.length && a.precedence[i] === b.precedence[i]) {
                            i++;
                        }
                        if (i >= a.precedence.length) {
                            return a.precedence.length === b.precedence.length ? 0 : -1;
                        } else {
                            return i >= b.precedence.length ? 1 : a.precedence[i] - b.precedence[i];
                        }
                    }
                    var MovieClip = function (_super) {
                        __extends(MovieClip, _super);
                        function MovieClip() {
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                        }
                        // Called whenever the class is initialized.
                        MovieClip.classInitializer = function () {
                            this.reset();
                        };
                        MovieClip.reset = function () {
                            this.frameNavigationModel = 10    /* SWF10 */;
                            this._callQueue = [];
                        };
                        MovieClip.runFrameScripts = function () {
                            AVMX.enterTimeline('MovieClip.executeFrame');
                            var movieClipClass = this.sec.flash.display.MovieClip.axClass;
                            var displayObjectClass = this.sec.flash.display.DisplayObject.axClass;
                            var queue = movieClipClass._callQueue;
                            movieClipClass._callQueue = [];
                            for (var i = 0; i < queue.length; i++) {
                                var instance = queue[i];
                                instance._allowFrameNavigation = false;
                                instance.callFrame(instance._currentFrame);
                                instance._allowFrameNavigation = true;
                                // If the destination frame isn't the same as before the `callFrame` operation, a frame
                                // navigation has happened inside the frame script. In that case, we didn't immediately
                                // run frame navigation as described in `_gotoFrameAbs`. Instead, we have to do it here.
                                if (instance._nextFrame !== instance._currentFrame) {
                                    if (movieClipClass.frameNavigationModel === 9    /* SWF9 */) {
                                        instance._advanceFrame();
                                        instance._constructFrame();
                                        instance._removeFlags(8192    /* HasFrameScriptPending */);
                                        instance.callFrame(instance._currentFrame);
                                    } else {
                                        displayObjectClass.performFrameNavigation(false, true);
                                    }
                                }
                            }
                            AVMX.leaveTimeline();
                        };
                        MovieClip.runAvm1FrameScripts = function () {
                            AVMX.enterTimeline('MovieClip.runAvm1FrameScripts');
                            var movieClipClass = this.sec.flash.display.MovieClip.axClass;
                            var displayObjectClass = this.sec.flash.display.DisplayObject.axClass;
                            var queue = movieClipClass._callQueue;
                            movieClipClass._callQueue = [];
                            var unsortedScripts = [];
                            for (var i = 0; i < queue.length; i++) {
                                var instance = queue[i];
                                instance.queueAvm1FrameScripts(instance._currentFrame, unsortedScripts);
                            }
                            if (unsortedScripts.length) {
                                unsortedScripts.sort(compareFrameScripts);
                                for (var i = 0; i < queue.length; i++) {
                                    var instance = queue[i];
                                    instance._allowFrameNavigation = false;
                                }
                                var frameScripts = unsortedScripts;
                                for (var i = 0; i < frameScripts.length; i++) {
                                    var script = frameScripts[i];
                                    var mc = script.context;
                                    release || assert(mc);
                                    script.call(mc);
                                }
                                for (var i = 0; i < queue.length; i++) {
                                    var instance = queue[i];
                                    instance._allowFrameNavigation = true;
                                    if (instance._nextFrame !== instance._currentFrame) {
                                        displayObjectClass.performFrameNavigation(false, true);
                                    }
                                }
                            }
                            AVMX.leaveTimeline();
                        };
                        MovieClip.prototype.applySymbol = function () {
                            _super.prototype.applySymbol.call(this);
                            this.sec.flash.display.DisplayObject.axClass._advancableInstances.push(this);
                            var symbol = this._symbol;
                            this._totalFrames = symbol.numFrames;
                            this._currentFrame = 1;
                            if (!symbol.isRoot) {
                                this.addScene('', symbol.labels, 0, symbol.numFrames);
                            }
                            this._frames = symbol.frames;
                            if (symbol.isAVM1Object) {
                                if (symbol.avm1Name) {
                                    this.name = symbol.avm1Name;
                                }
                            }
                        };
                        // This method is called when children are being constructed and AVM1 scripts
                        // is about to be run.
                        MovieClip.prototype._initAvm1Data = function () {
                            var symbol = this._symbol;
                            var frames = symbol.frames;
                            if (frames) {
                                for (var i = 0; i < frames.length; i++) {
                                    var frameInfo = frames[i];
                                    this._initAvm1FrameData(i, frameInfo);
                                }
                            }
                        };
                        // Adds missing AVM1 scripts data to the AS3 object frameScripts and events.
                        MovieClip.prototype._initAvm1FrameData = function (frameIndex, frameInfo) {
                            var symbol = this._symbol;
                            var avm1Context = symbol.avm1Context;
                            if (frameInfo.exports) {
                                var exports = frameInfo.exports;
                                for (var i = 0; i < exports.length; i++) {
                                    var asset = exports[i];
                                    avm1Context.addAsset(asset.className, asset.symbolId, null);
                                }
                            }
                            var initActionBlocks = frameInfo.initActionBlocks;
                            if (initActionBlocks) {
                                this._addAvm1InitActionBlocks(frameIndex, initActionBlocks);
                            }
                            var actionBlocks = frameInfo.actionBlocks;
                            if (actionBlocks) {
                                this._addAvm1FrameScripts(frameIndex, actionBlocks);
                            }
                        };
                        MovieClip.prototype._addAvm1FrameScripts = function (frameIndex, actionsBlocks) {
                            for (var i = 0; i < actionsBlocks.length; i++) {
                                var actionsBlock = actionsBlocks[i];
                                var symbol = this._symbol;
                                var avm1Context = symbol.avm1Context;
                                var actionsData = avm1Context.actionsDataFactory.createActionsData(actionsBlock.actionsData, 's' + symbol.id + 'f' + frameIndex + 'i' + i);
                                var script = function (actionsData) {
                                    var as2MovieClip = Shumway.AVM1.Lib.getAVM1Object(this, avm1Context);
                                    avm1Context.executeActions(actionsData, as2MovieClip);
                                }.bind(this, actionsData);
                                script.precedence = this._getScriptPrecedence().concat(actionsBlock.precedence);
                                this.addFrameScript(frameIndex, script);
                            }
                        };
                        /**
                         * AVM1 InitActionBlocks are executed once, before the children are initialized for a frame.
                         * That matches AS3's enterFrame event, so we can add an event listener that just bails
                         * as long as the target frame isn't reached, and executes the InitActionBlock once it is.
                         *
                         * After that, the listener removes itself.
                         */
                        MovieClip.prototype._addAvm1InitActionBlocks = function (frameIndex, actionsBlocks) {
                            function executeInitActions() {
                                var symbol = self._symbol;
                                var avm1Context = symbol.avm1Context;
                                var as2MovieClip = Shumway.AVM1.Lib.getAVM1Object(self, avm1Context);
                                for (var i = 0; i < actionsBlocks.length; i++) {
                                    var actionsData = avm1Context.actionsDataFactory.createActionsData(actionsBlocks[i].actionsData, 's' + symbol.id + 'f' + frameIndex + 'i' + i);
                                    avm1Context.executeActions(actionsData, as2MovieClip);
                                }
                            }
                            var self = this;
                            if (this.currentFrame === frameIndex + 1) {
                                executeInitActions();
                                return;
                            }
                            var enterFrameListener = function () {
                                if (self.currentFrame !== frameIndex + 1) {
                                    return;
                                }
                                self.removeEventListener('enterFrame', enterFrameListener);
                                executeInitActions();
                            };
                            this.addEventListener('enterFrame', enterFrameListener);
                        };
                        MovieClip.prototype.removeChildAt = function (index) {
                            var child = _super.prototype.removeChildAt.call(this, index);
                            if (this._as2Object && child._name) {
                                var avm1Child = Shumway.AVM1.Lib.getAVM1Object(child, this._as2Object.context);
                                // Not all display objects are reflected in AVM1, so not all need to be removed.
                                avm1Child && this._as2Object._removeChildName(avm1Child, child._name);
                            }
                            return child;
                        };
                        MovieClip.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this);
                            this._currentFrame = 0;
                            this._totalFrames = 1;
                            this._trackAsMenu = false;
                            this._scenes = [];
                            if (!this._symbol) {
                                this.addScene('', [], 0, 1);
                            }
                            this._enabled = true;
                            this._isPlaying = false;
                            this._frames = [];
                            this._frameScripts = [];
                            this._nextFrame = 1;
                            this._stopped = false;
                            this._allowFrameNavigation = true;
                            this._sounds = null;
                            this._buttonFrames = Object.create(null);
                            this._currentButtonState = null;
                        };
                        MovieClip.prototype._addFrame = function (frameInfo) {
                            var spriteSymbol = this._symbol;
                            var frames = spriteSymbol.frames;
                            frames.push(frameInfo);
                            if (frameInfo.labelName) {
                                // Frame indices are 1-based, so use frames.length after pushing the frame.
                                this.addFrameLabel(frameInfo.labelName, frames.length);
                            }
                            if (frameInfo.soundStreamHead) {
                                this._initSoundStream(frameInfo.soundStreamHead);
                            }
                            if (frameInfo.soundStreamBlock) {
                                // Frame indices are 1-based, so use frames.length after pushing the frame.
                                this._addSoundStreamBlock(frames.length, frameInfo.soundStreamBlock);
                            }
                            if (spriteSymbol.isAVM1Object && this._hasFlags(256    /* Constructed */)) {
                                var avm1Context = spriteSymbol.avm1Context;
                                this._initAvm1FrameData(frames.length - 1, frameInfo);
                            }
                            if (frames.length === 1) {
                                this._initializeChildren(frames[0]);
                            }
                        };
                        MovieClip.prototype._initFrame = function (advance) {
                            if (advance) {
                                if (this.buttonMode) {
                                    var state = null;
                                    if (this._mouseOver) {
                                        state = this._mouseDown ? '_down' : '_over';
                                    } else if (this._currentButtonState !== null) {
                                        state = '_up';
                                    }
                                    if (state !== this._currentButtonState && this._buttonFrames[state]) {
                                        this.stop();
                                        this._gotoFrame(state, null);
                                        this._currentButtonState = state;
                                        this._advanceFrame();
                                        return;
                                    }
                                }
                                if (this._totalFrames > 1 && !this._stopped && this._hasFlags(256    /* Constructed */)) {
                                    this._nextFrame++;
                                }
                            }
                            this._advanceFrame();
                            if (this._symbol && this._symbol.isAVM1Object && !this._hasFlags(256    /* Constructed */)) {
                                this._initAvm1Data();
                            }
                        };
                        MovieClip.prototype._constructFrame = function () {
                            this._constructChildren();
                        };
                        MovieClip.prototype._enqueueFrameScripts = function () {
                            var addToCallQueue = false;
                            if (this._hasFlags(1024    /* NeedsLoadEvent */)) {
                                addToCallQueue = true;
                            }
                            if (this._hasFlags(8192    /* HasFrameScriptPending */)) {
                                this._removeFlags(8192    /* HasFrameScriptPending */);
                                addToCallQueue = true;
                            }
                            if (addToCallQueue) {
                                this.sec.flash.display.MovieClip.axClass._callQueue.push(this);
                            }
                            _super.prototype._enqueueFrameScripts.call(this);
                        };
                        Object.defineProperty(MovieClip.prototype, 'currentFrame', {
                            get: function () {
                                var frame = this._currentFrame;
                                if (!this._allowFrameNavigation && this.sec.flash.display.MovieClip.axClass.frameNavigationModel === 1    /* SWF1 */) {
                                    // AVM1 needs to return a frame we already navigated during scripts execution.
                                    frame = this._nextFrame;
                                }
                                return frame - this._sceneForFrameIndex(frame).offset;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'framesLoaded', {
                            get: function () {
                                return this._frames.length;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'totalFrames', {
                            get: function () {
                                return this._totalFrames;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'trackAsMenu', {
                            get: function () {
                                return this._trackAsMenu;
                            },
                            set: function (value) {
                                this._trackAsMenu = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'scenes', {
                            get: function () {
                                var scenes = this._scenes ? this._scenes.map(function (x) {
                                    return x.clone();
                                }) : [];
                                return this.sec.createArrayUnsafe(scenes);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'currentScene', {
                            get: function () {
                                var scene = this._sceneForFrameIndex(this._currentFrame);
                                return scene.clone();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'currentLabel', {
                            get: function () {
                                var label = this._labelForFrame(this._currentFrame);
                                return label ? label.name : null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'currentLabels', {
                            get: function () {
                                return this._sceneForFrameIndex(this._currentFrame).labels;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'currentFrameLabel', {
                            get: function () {
                                var scene = this._sceneForFrameIndex(this._currentFrame);
                                var label = scene.getLabelByFrame(this._currentFrame - scene.offset);
                                return label && label.name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'enabled', {
                            get: function () {
                                return this._enabled;
                            },
                            set: function (value) {
                                this._enabled = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MovieClip.prototype, 'isPlaying', {
                            get: function () {
                                return this._isPlaying;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        MovieClip.prototype.play = function () {
                            if (this._totalFrames > 1) {
                                this._isPlaying = true;
                            }
                            this._stopped = false;
                        };
                        MovieClip.prototype.stop = function () {
                            this._isPlaying = false;
                            this._stopped = true;
                        };
                        /**
                         * Resolves frame and scene into absolute frame number. If scene is not specified,
                         * the current scene is used. In legacy mode, it might return `undefined` if frame/scene
                         * was not found.
                         */
                        MovieClip.prototype._getAbsFrameNumber = function (frame, sceneName) {
                            var navigationModel = this.sec.flash.display.MovieClip.axClass.frameNavigationModel;
                            var legacyMode = navigationModel !== 10    /* SWF10 */;
                            var scene;
                            if (sceneName !== null) {
                                sceneName = axCoerceString(sceneName);
                                var scenes = this._scenes;
                                release || assert(scenes.length, 'There should be at least one scene defined.');
                                for (var i = 0; i < scenes.length; i++) {
                                    scene = scenes[i];
                                    if (scene.name === sceneName) {
                                        break;
                                    }
                                }
                                if (i === scenes.length) {
                                    if (legacyMode) {
                                        return undefined;    // noop for SWF9 and below
                                    }
                                    this.sec.throwError('ArgumentError', AVMX.Errors.SceneNotFoundError, sceneName);
                                }
                            } else {
                                scene = this._sceneForFrameIndex(this._currentFrame);
                            }
                            // Amazingly, the `frame` argument, while first coerced to string, is then interpreted as a
                            // frame index even if a label with the same name exists.
                            /* tslint:disable */
                            var frameNum = parseInt(frame, 10);
                            if (frameNum != frame) {
                                var label = scene.getLabelByName(frame, legacyMode);
                                if (!label) {
                                    if (legacyMode) {
                                        return undefined;    // noop for SWF9 and below
                                    }
                                    this.sec.throwError('ArgumentError', AVMX.Errors.FrameLabelNotFoundError, frame, sceneName);
                                }
                                frameNum = label.frame;
                            }
                            /* tslint:enable */
                            return scene.offset + frameNum;
                        };
                        /**
                         * Implementation for both gotoAndPlay and gotoAndStop.
                         *
                         * Technically, we should throw all errors from those functions directly so the stack is
                         * correct.
                         * We might at some point do that by explicitly inlining this function using some build step.
                         */
                        MovieClip.prototype._gotoFrame = function (frame, sceneName) {
                            var frameNum = this._getAbsFrameNumber(frame, sceneName);
                            if (frameNum === undefined) {
                                return;
                            }
                            this._gotoFrameAbs(frameNum);
                        };
                        MovieClip.prototype._gotoFrameAbs = function (frame) {
                            if (frame < 1) {
                                frame = 1;
                            } else if (frame > this._totalFrames) {
                                frame = this._totalFrames;
                            }
                            if (frame === this._nextFrame) {
                                return;
                            }
                            this._nextFrame = frame;
                            // Frame navigation only happens immediately if not triggered from under a frame script.
                            if (this._allowFrameNavigation) {
                                if (this.sec.flash.display.MovieClip.axClass.frameNavigationModel === 9    /* SWF9 */) {
                                    // In FP 9, the only thing that happens on inter-frame navigation is advancing the frame
                                    // and constructing new timeline objects.
                                    this._advanceFrame();
                                    this._constructFrame();
                                } else {
                                    // Frame navigation in an individual timeline triggers an iteration of the whole
                                    // frame navigation cycle in FP 10+. This includes broadcasting frame events to *all*
                                    // display objects.
                                    this.sec.flash.display.DisplayObject.axClass.performFrameNavigation(false, true);
                                }
                            }
                        };
                        MovieClip.prototype._advanceFrame = function () {
                            var currentFrame = this._currentFrame;
                            var nextFrame = this._nextFrame;
                            if (nextFrame > this._totalFrames) {
                                nextFrame = 1;
                            }
                            if (currentFrame === nextFrame) {
                                // If nextFrame was > this._totalFrames, it has to be written back here, otherwise it'll
                                // just be incremented ever further.
                                this._nextFrame = nextFrame;
                                return;
                            }
                            if (nextFrame > this.framesLoaded) {
                                // If nextFrame was > this._totalFrames, it has to be written back here, otherwise it'll
                                // just be incremented ever further.
                                this._nextFrame = nextFrame;
                                // TODO
                                return;
                            }
                            var currentSwfFrame = this._frames[currentFrame - 1];
                            var nextSwfFrame = this._frames[nextFrame - 1];
                            if (nextSwfFrame !== currentSwfFrame) {
                                this._seekToFrame(nextFrame);
                                if (nextSwfFrame.controlTags) {
                                    var tags = nextSwfFrame.controlTags;
                                    var soundStarts;
                                    for (var i = 0; i < tags.length; i++) {
                                        var tag = tags[i];
                                        // controlTags might contain parsed and unparsed tags.
                                        if (tag.tagCode === 15    /* CODE_START_SOUND */ || tag.tagCode === 61    /* CODE_VIDEO_FRAME */) {
                                            var loaderInfo = this._symbol.loaderInfo;
                                            tag = loaderInfo._file.getParsedTag(tag);
                                        }
                                        if (tag.code === 15    /* CODE_START_SOUND */) {
                                            if (!soundStarts) {
                                                soundStarts = [];
                                            }
                                            soundStarts.push(new Shumway.Timeline.SoundStart(tag.soundId, tag.soundInfo));
                                        } else if (tag.tagCode === 61    /* CODE_VIDEO_FRAME */) {
                                        }
                                    }
                                    if (soundStarts) {
                                        this._registerStartSounds(nextFrame, soundStarts);
                                    }
                                }
                            }
                            if (this._frameScripts[nextFrame]) {
                                this._setFlags(8192    /* HasFrameScriptPending */);
                                this._parent && this._propagateFlagsUp(16384    /* ContainsFrameScriptPendingChildren */);
                            }
                            this._currentFrame = this._nextFrame = nextFrame;
                            this._syncSounds(nextFrame);
                        };
                        MovieClip.prototype._seekToFrame = function (frame) {
                            var currentFrame = this._currentFrame;
                            var frames = this._frames;
                            if (frame === currentFrame + 1) {
                                var nextSwfFrame = frames[frame - 1];
                                if (nextSwfFrame.controlTags) {
                                    this._processControlTags(nextSwfFrame.controlTags, false);
                                }
                                return;
                            }
                            var currentSwfFrame = frames[currentFrame - 1];
                            var loaderInfo = this._symbol.loaderInfo;
                            var backwards = frame < currentFrame;
                            var controlTags = [];
                            var removedObjects;
                            // We scan all control tags in reverse order and make sure we only apply those related to
                            // objects that exist in the new frame.
                            var i = frame;
                            var n = backwards ? 0 : currentFrame;
                            while (i-- > n) {
                                var swfFrame = frames[i];
                                if (swfFrame === currentSwfFrame) {
                                    continue;
                                }
                                currentSwfFrame = swfFrame;
                                var tags = swfFrame.controlTags;
                                if (!tags) {
                                    continue;
                                }
                                var j = tags.length;
                                while (j--) {
                                    // We may have a mix of the parsed and unparsed tags.
                                    var parsedOrUnparsedTag = tags[j];
                                    var tag = parsedOrUnparsedTag.tagCode === undefined ? parsedOrUnparsedTag : loaderInfo._file.getParsedTag(parsedOrUnparsedTag);
                                    switch (tag.code) {
                                    case 5    /* CODE_REMOVE_OBJECT */:
                                    case 28    /* CODE_REMOVE_OBJECT2 */:
                                        if (!removedObjects) {
                                            removedObjects = Object.create(null);
                                        }
                                        removedObjects[tag.depth] = true;
                                        if (!backwards) {
                                            controlTags.push(tag);
                                        }
                                        break;
                                    case 4    /* CODE_PLACE_OBJECT */:
                                    case 26    /* CODE_PLACE_OBJECT2 */:
                                    case 70    /* CODE_PLACE_OBJECT3 */:
                                        if (!(removedObjects && removedObjects[tag.depth])) {
                                            controlTags.push(tag);
                                        }
                                        break;
                                    default:
                                        controlTags.push(tag);
                                    }
                                }
                            }
                            // Bring the order back to normal.
                            controlTags.reverse();
                            this._processControlTags(controlTags, backwards);
                        };
                        /**
                         * Because that's how it's mostly used, the current frame is stored as an offset into the
                         * entire timeline. Sometimes, we need to know which scene it falls into. This utility
                         * function answers that.
                         */
                        MovieClip.prototype._sceneForFrameIndex = function (frameIndex) {
                            var scenes = this._scenes;
                            // A gotoAnd* might be invoked by script before the first advanceFrame call. In that case,
                            // _currentFrame is 0, which means this function is called with frameIndex being 0.
                            // We just return the first scene in that case.
                            if (frameIndex === 0) {
                                return scenes[0];
                            }
                            for (var i = 0; i < scenes.length; i++) {
                                var scene = scenes[i];
                                if (scene.offset < frameIndex && scene.offset + scene.numFrames >= frameIndex) {
                                    return scene;
                                }
                            }
                            release || assertUnreachable('Must have at least one scene covering all frames.');
                        };
                        /**
                         * Frame indices are stored as offsets into the entire timline, whereas labels are stored
                         * in their scenes. This utility function iterates over scenes and their labels to find
                         * the label clostest to, but not after the target frame.
                         */
                        MovieClip.prototype._labelForFrame = function (frame) {
                            var scenes = this._scenes;
                            var label = null;
                            for (var i = 0; i < scenes.length; i++) {
                                var scene = scenes[i];
                                if (scene.offset > frame) {
                                    return label;
                                }
                                var labels = scene.labels.value;
                                for (var j = 0; j < labels.length; j++) {
                                    var currentLabel = labels[j];
                                    if (currentLabel.frame > frame - scene.offset) {
                                        return label;
                                    }
                                    label = currentLabel;
                                }
                            }
                            return label;
                        };
                        MovieClip.prototype.callFrame = function (frame) {
                            frame = frame | 0;
                            var frameScripts = this._frameScripts[frame];
                            if (!frameScripts) {
                                return;
                            }
                            for (var i = 0; i < frameScripts.length; i++) {
                                var script = frameScripts[i];
                                try {
                                    script.call(this);    // REDUX ? why it was frameScript.$Bgcall(thisArg);
                                } catch (e) {
                                    Telemetry.instance.reportTelemetry({
                                        topic: 'error',
                                        error: 2    /* AVM2_ERROR */
                                    });
                                    //if ($DEBUG) {
                                    //  console.error('error ' + e + ', stack: \n' + e.stack);
                                    //}
                                    this.stop();
                                    throw e;
                                }
                            }
                        };
                        MovieClip.prototype.queueAvm1FrameScripts = function (frame, queue) {
                            // AVM1 action blocks must be executed exactly in the same order they appear in the SWF
                            // file. We keep track of the position for each action block at parsing time and carry that
                            // information on to their wrapping functions (via the precedence property). Here we queue
                            // up all such functions so we can sort and execute them after this loop.
                            if (this._hasFlags(1024    /* NeedsLoadEvent */)) {
                                this._removeFlags(1024    /* NeedsLoadEvent */);
                                release || assert(this._symbol);
                                var handler = function () {
                                    var eventClass = this.sec.flash.events.Event.axClass;
                                    this.dispatchEvent(eventClass.getInstance(events.Event.AVM1_LOAD));
                                }.bind(this);
                                handler.precedence = this._getScriptPrecedence();
                                handler.context = this;
                                queue.push(handler);
                            }
                            var frameScripts = this._frameScripts[frame];
                            if (frameScripts) {
                                for (var j = 0; j < frameScripts.length; j++) {
                                    var script = frameScripts[j];
                                    script.context = this;
                                    queue.push(script);
                                }
                            }
                        };
                        MovieClip.prototype.nextFrame = function () {
                            this.gotoAndStop(this._currentFrame + 1);
                        };
                        MovieClip.prototype.prevFrame = function () {
                            this.gotoAndStop(this._currentFrame - 1);
                        };
                        MovieClip.prototype.gotoAndPlay = function (frame, scene) {
                            if (scene === void 0) {
                                scene = null;
                            }
                            // Argument handling for gotoAnd* is a bit peculiar:
                            // - too many arguments throw just as too few do
                            // - the `sceneName` argument is coerced first
                            // - the `frame` argument is coerced to string, but `undefined` results in `"null"`
                            if (arguments.length === 0 || arguments.length > 2) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'flash.display::MovieClip/gotoAndPlay()', 1, arguments.length);
                            }
                            scene = axCoerceString(scene);
                            frame = axCoerceString(frame) + '';
                            // The axCoerceString returns `null` for `undefined`.
                            this.play();
                            this._gotoFrame(frame, scene);
                        };
                        MovieClip.prototype.gotoAndStop = function (frame, scene) {
                            if (scene === void 0) {
                                scene = null;
                            }
                            // See comment in gotoAndPlay for an explanation of the arguments handling stuff.
                            if (arguments.length === 0 || arguments.length > 2) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.WrongArgumentCountError, 'flash.display::MovieClip/gotoAndPlay()', 1, arguments.length);
                            }
                            scene = axCoerceString(scene);
                            frame = axCoerceString(frame) + '';
                            // The axCoerceString returns `null` for `undefined`.
                            this.stop();
                            this._gotoFrame(frame, scene);
                        };
                        /**
                         * Takes pairs of `frameIndex`, `script` arguments and adds the `script`s to the `_frameScripts`
                         * Array.
                         *
                         * Undocumented method used to implement the old timeline concept in AS3.
                         */
                        MovieClip.prototype.addFrameScript = function (frameIndex, script) {
                            if (!this._currentFrame) {
                                return;
                            }
                            // arguments are pairs of frameIndex and script/function
                            // frameIndex is in range 0..totalFrames-1
                            var numArgs = arguments.length;
                            if (numArgs & 1) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.TooFewArgumentsError, numArgs, numArgs + 1);
                            }
                            var frameScripts = this._frameScripts;
                            var totalFrames = this._totalFrames;
                            for (var i = 0; i < numArgs; i += 2) {
                                var frameNum = (arguments[i] | 0) + 1;
                                if (frameNum < 1 || frameNum > totalFrames) {
                                    continue;
                                }
                                var fn = arguments[i + 1];
                                var list = frameScripts[frameNum];
                                if (list) {
                                    if (fn.precedence) {
                                        list.push(fn);
                                    } else {
                                        list[0] = fn;
                                    }
                                } else {
                                    frameScripts[frameNum] = [fn];
                                }
                                if (frameNum === this._currentFrame) {
                                    this._setFlags(8192    /* HasFrameScriptPending */);
                                    this._parent && this._propagateFlagsUp(16384    /* ContainsFrameScriptPendingChildren */);
                                }
                            }
                        };
                        Object.defineProperty(MovieClip.prototype, '_isFullyLoaded', {
                            get: function () {
                                return this.framesLoaded >= this.totalFrames;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        MovieClip.prototype._registerStartSounds = function (frameNum, soundStartInfo) {
                            if (this._sounds === null) {
                                this._sounds = new MovieClipSoundsManager(this);
                            }
                            this._sounds.registerStartSounds(frameNum, soundStartInfo);
                        };
                        MovieClip.prototype._initSoundStream = function (streamInfo) {
                            if (this._sounds === null) {
                                this._sounds = new MovieClipSoundsManager(this);
                            }
                            this._sounds.initSoundStream(streamInfo);
                        };
                        MovieClip.prototype._addSoundStreamBlock = function (frameNum, streamBlock) {
                            if (this._sounds === null) {
                                this._sounds = new MovieClipSoundsManager(this);
                            }
                            this._sounds.addSoundStreamBlock(frameNum, streamBlock);
                        };
                        MovieClip.prototype._syncSounds = function (frameNum) {
                            if (this._sounds !== null) {
                                this._sounds.syncSounds(frameNum);
                            }
                        };
                        MovieClip.prototype.addScene = function (name, labels_, offset, numFrames) {
                            var labels = this.sec.createArrayUnsafe(labels_);
                            this._scenes.push(new this.sec.flash.display.Scene(name, labels, offset, numFrames));
                        };
                        MovieClip.prototype.addFrameLabel = function (name, frame) {
                            var scene = this._sceneForFrameIndex(frame);
                            if (!scene.getLabelByName(name, false)) {
                                scene.labels.value.push(new this.sec.flash.display.FrameLabel(name, frame - scene.offset));
                            }
                        };
                        MovieClip.prototype.prevScene = function () {
                            var currentScene = this._sceneForFrameIndex(this._currentFrame);
                            if (currentScene.offset === 0) {
                                return;
                            }
                            // Since scene offsets are 0-based, the current scene's offset, treated as a frame index,
                            // is the previous scene's last frame.
                            this._gotoFrameAbs(this._sceneForFrameIndex(currentScene.offset).offset + 1);
                        };
                        MovieClip.prototype.nextScene = function () {
                            var currentScene = this._sceneForFrameIndex(this._currentFrame);
                            if (currentScene.offset + currentScene.numFrames === this._totalFrames) {
                                return;
                            }
                            this._gotoFrameAbs(currentScene.offset + currentScene.numFrames + 1);
                        };
                        MovieClip.prototype._containsPointImpl = function (globalX, globalY, localX, localY, testingType, objects, skipBoundsCheck) {
                            var result = _super.prototype._containsPointImpl.call(this, globalX, globalY, localX, localY, testingType, objects, true);
                            // In AVM1 SWFs, MovieClips are transparent to the mouse as long as they don't have a handler
                            // attached to them for any of the button-related events.
                            if (result === 2    /* Shape */ && testingType === 3    /* Mouse */ && '_as2Object' in this && !this.buttonMode && objects[0] === this) {
                                objects.length = 0;
                            }
                            return result;
                        };
                        // List of static symbols to link.
                        MovieClip.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        MovieClip.instanceSymbols = null;
                        // ["currentLabels"];
                        return MovieClip;
                    }(flash.display.Sprite);
                    display.MovieClip = MovieClip;
                    var MP3DecoderSession = Shumway.SWF.MP3DecoderSession;
                    var MP3_MIME_TYPE = 'audio/mpeg';
                    var HTMLAudioElementAdapter = function () {
                        function HTMLAudioElementAdapter(sec, element) {
                            this._sec = sec;
                            this._element = element;
                        }
                        Object.defineProperty(HTMLAudioElementAdapter.prototype, 'isReady', {
                            get: function () {
                                return !!this._channel;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(HTMLAudioElementAdapter.prototype, 'element', {
                            get: function () {
                                return this._element;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(HTMLAudioElementAdapter.prototype, 'currentTime', {
                            get: function () {
                                return this._element.currentTime;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        HTMLAudioElementAdapter.prototype.playFrom = function (time) {
                            var element = this._element;
                            if (element.paused) {
                                element.play();
                                element.addEventListener('playing', function setTime(e) {
                                    element.removeEventListener('playing', setTime);
                                    element.currentTime = time;
                                });
                            } else {
                                element.currentTime = time;
                            }
                        };
                        Object.defineProperty(HTMLAudioElementAdapter.prototype, 'paused', {
                            get: function () {
                                return this._element.paused;
                            },
                            set: function (value) {
                                var element = this._element;
                                if (value) {
                                    if (!element.paused) {
                                        element.pause();
                                    }
                                } else {
                                    if (element.paused) {
                                        element.play();
                                    }
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        HTMLAudioElementAdapter.prototype.createChannel = function () {
                            this._channel = flash.media.SoundChannel.initializeFromAudioElement(this._sec, this._element);
                        };
                        HTMLAudioElementAdapter.prototype.queueData = function (frame) {
                            Shumway.Debug.abstractMethod('HTMLAudioElementAdapter::queueData');
                        };
                        HTMLAudioElementAdapter.prototype.finish = function () {
                            Shumway.Debug.abstractMethod('HTMLAudioElementAdapter::finish');
                        };
                        return HTMLAudioElementAdapter;
                    }();
                    var MediaSourceStreamAdapter = function (_super) {
                        __extends(MediaSourceStreamAdapter, _super);
                        function MediaSourceStreamAdapter(sec, element) {
                            _super.call(this, sec, element);
                            this._mediaSource = new MediaSource();
                            this._sourceBuffer = null;
                            this._updating = false;
                            this._loading = true;
                            this._rawFrames = [];
                            this._isReady = false;
                            this._mediaSource.addEventListener('sourceopen', this._openMediaSource.bind(this));
                            this.element.src = URL.createObjectURL(this._mediaSource);
                        }
                        MediaSourceStreamAdapter.prototype._appendSoundData = function () {
                            if (this._rawFrames.length === 0 || this._updating || !this._sourceBuffer) {
                                return;
                            }
                            if (!this._loading) {
                                this._mediaSource.endOfStream();
                                return;
                            }
                            this._updating = true;
                            // There is an issue when multiple appendBuffers are added in a sequence,
                            // pushing frames one-by-one.
                            this._sourceBuffer.appendBuffer(this._rawFrames.shift());
                            // Making MediaSourceStreamAdapter be ready on first packet.
                            if (!this._isReady) {
                                this._isReady = true;
                                this.createChannel();
                            }
                        };
                        MediaSourceStreamAdapter.prototype._openMediaSource = function () {
                            var sourceBuffer = this._mediaSource.addSourceBuffer(MP3_MIME_TYPE);
                            sourceBuffer.addEventListener('update', function () {
                                this._updating = false;
                                this._appendSoundData();
                            }.bind(this));
                            this._sourceBuffer = sourceBuffer;
                            this._appendSoundData();
                        };
                        MediaSourceStreamAdapter.prototype.queueData = function (frame) {
                            this._rawFrames.push(frame.data);
                            this._appendSoundData();
                        };
                        MediaSourceStreamAdapter.prototype.finish = function () {
                            this._loading = false;
                            this._appendSoundData();
                        };
                        return MediaSourceStreamAdapter;
                    }(HTMLAudioElementAdapter);
                    var BlobStreamAdapter = function (_super) {
                        __extends(BlobStreamAdapter, _super);
                        function BlobStreamAdapter(sec, element) {
                            _super.call(this, sec, element);
                            this._rawFrames = [];
                        }
                        BlobStreamAdapter.prototype.queueData = function (frame) {
                            this._rawFrames.push(frame.data);
                        };
                        BlobStreamAdapter.prototype.finish = function () {
                            var blob = new Blob(this._rawFrames);
                            this.element.src = URL.createObjectURL(blob);
                            this.createChannel();
                        };
                        return BlobStreamAdapter;
                    }(HTMLAudioElementAdapter);
                    function syncTime(element, movieClip) {
                        var initialized = false;
                        var startMediaTime, startRealTime;
                        element.addEventListener('timeupdate', function (e) {
                            if (!initialized) {
                                startMediaTime = element.currentTime;
                                startRealTime = performance.now();
                                initialized = true;
                                //movieClip._stage._frameScheduler.startTrackDelta();
                                return;
                            }
                            var mediaDelta = element.currentTime - startMediaTime;
                            var realDelta = performance.now() - startRealTime;    //movieClip._stage._frameScheduler.setDelta(realDelta - mediaDelta * 1000);
                        });
                        element.addEventListener('pause', function (e) {
                            //movieClip._stage._frameScheduler.endTrackDelta();
                            initialized = false;
                        });
                        element.addEventListener('seeking', function (e) {
                            //movieClip._stage._frameScheduler.endTrackDelta();
                            initialized = false;
                        });
                    }
                    var WebAudioAdapter = function () {
                        function WebAudioAdapter(sec, data) {
                            this._sec = sec;
                            this._channel = null;
                            this._sound = null;
                            this._data = data;
                            this._position = 0;
                        }
                        Object.defineProperty(WebAudioAdapter.prototype, 'currentTime', {
                            get: function () {
                                return NaN;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        WebAudioAdapter.prototype.playFrom = function (time) {
                        };
                        Object.defineProperty(WebAudioAdapter.prototype, 'paused', {
                            get: function () {
                                return false;
                            },
                            set: function (value) {
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebAudioAdapter.prototype, 'isReady', {
                            get: function () {
                                return !!this._channel;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        WebAudioAdapter.prototype.queueData = function (frame) {
                            this._data.pcm.set(frame.pcm, this._position);
                            this._position += frame.pcm.length;
                        };
                        WebAudioAdapter.prototype.finish = function () {
                            // TODO Start from some seek offset, stopping
                            var sound = flash.media.Sound.initializeFromPCMData(this._sec, this._data);
                            var channel = sound.play();
                            this._sound = sound;
                            this._channel = channel;
                        };
                        return WebAudioAdapter;
                    }();
                    var WebAudioMP3Adapter = function (_super) {
                        __extends(WebAudioMP3Adapter, _super);
                        function WebAudioMP3Adapter(sec, data) {
                            _super.call(this, sec, data);
                            this._decoderPosition = 0;
                            this._decoderSession = new MP3DecoderSession();
                            this._decoderSession.onframedata = function (frameData) {
                                var position = this._decoderPosition;
                                data.pcm.set(frameData, position);
                                this._decoderPosition = position + frameData.length;
                            }.bind(this);
                            this._decoderSession.onclosed = function () {
                                WebAudioAdapter.prototype.finish.call(this);
                            }.bind(this);
                            this._decoderSession.onerror = function (error) {
                                Shumway.Debug.warning('MP3DecoderSession error: ' + error);
                            };
                        }
                        WebAudioMP3Adapter.prototype.queueData = function (frame) {
                            this._decoderSession.pushAsync(frame.data);
                        };
                        WebAudioMP3Adapter.prototype.finish = function () {
                            this._decoderSession.close();
                        };
                        return WebAudioMP3Adapter;
                    }(WebAudioAdapter);
                    var MovieClipSoundStream = function () {
                        function MovieClipSoundStream(streamInfo, movieClip) {
                            this.movieClip = movieClip;
                            this.decode = streamInfo.decode.bind(streamInfo);
                            this.data = {
                                sampleRate: streamInfo.sampleRate,
                                channels: streamInfo.channels
                            };
                            this.seekIndex = [];
                            this.position = 0;
                            this.wasFullyLoaded = false;
                            this.expectedFrame = 0;
                            this.waitFor = 0;
                            var sec = movieClip.sec;
                            var isMP3 = streamInfo.format === 'mp3';
                            if (isMP3 && !AS.webAudioMP3Option.value) {
                                var element = document.createElement('audio');
                                element.preload = 'metadata';
                                // for mobile devices
                                element.loop = false;
                                syncTime(element, movieClip);
                                if (element.canPlayType(MP3_MIME_TYPE)) {
                                    this.element = element;
                                    if (!AS.mediaSourceMP3Option.value) {
                                        this.soundStreamAdapter = new BlobStreamAdapter(sec, element);
                                    } else if (typeof MediaSource !== 'undefined' && MediaSource.isTypeSupported(MP3_MIME_TYPE)) {
                                        this.soundStreamAdapter = new MediaSourceStreamAdapter(sec, element);
                                    } else {
                                        // Falls back to blob playback.
                                        Shumway.Debug.warning('MediaSource is not supported');
                                        this.soundStreamAdapter = new BlobStreamAdapter(sec, element);
                                    }
                                    return;
                                }
                            }
                            // TODO fix streamInfo.samplesCount name -- its actually average value
                            var totalSamples = (streamInfo.samplesCount + 1) * this.movieClip.totalFrames * streamInfo.channels;
                            this.data.pcm = new Float32Array(totalSamples);
                            this.soundStreamAdapter = !isMP3 ? new WebAudioAdapter(sec, this.data) : new WebAudioMP3Adapter(sec, this.data);
                        }
                        MovieClipSoundStream.prototype.appendBlock = function (frameNum, streamBlock) {
                            var decodedBlock = this.decode(streamBlock);
                            var streamPosition = this.position;
                            this.seekIndex[frameNum] = streamPosition + decodedBlock.seek * this.data.channels;
                            this.position = streamPosition + decodedBlock.samplesCount * this.data.channels;
                            this.soundStreamAdapter.queueData(decodedBlock);
                        };
                        MovieClipSoundStream.prototype.playFrame = function (frameNum) {
                            if (isNaN(this.seekIndex[frameNum])) {
                                return;
                            }
                            var PAUSE_WHEN_OF_SYNC_GREATER = 1;
                            var PLAYBACK_ADJUSTMENT = 0.25;
                            if (!this.wasFullyLoaded && this.movieClip._isFullyLoaded) {
                                this.wasFullyLoaded = true;
                                this.soundStreamAdapter.finish();
                            }
                            if (this.soundStreamAdapter.isReady && !isNaN(this.soundStreamAdapter.currentTime)) {
                                var soundStreamData = this.data;
                                var time = this.seekIndex[frameNum] / soundStreamData.sampleRate / soundStreamData.channels;
                                var elementTime = this.soundStreamAdapter.currentTime;
                                if (this.expectedFrame !== frameNum) {
                                    this.soundStreamAdapter.playFrom(time);
                                } else if (this.waitFor > 0) {
                                    if (this.waitFor <= time) {
                                        this.soundStreamAdapter.paused = false;
                                        this.waitFor = 0;
                                    }
                                } else if (elementTime - time > PAUSE_WHEN_OF_SYNC_GREATER) {
                                    Shumway.Debug.warning('Sound is faster than frames by ' + (elementTime - time));
                                    this.waitFor = elementTime - PLAYBACK_ADJUSTMENT;
                                    this.soundStreamAdapter.paused = true;
                                } else if (time - elementTime > PAUSE_WHEN_OF_SYNC_GREATER) {
                                    Shumway.Debug.warning('Sound is slower than frames by ' + (time - elementTime));
                                    this.soundStreamAdapter.playFrom(time + PLAYBACK_ADJUSTMENT);
                                }
                                this.expectedFrame = frameNum + 1;
                            }
                        };
                        return MovieClipSoundStream;
                    }();
                    display.MovieClipSoundStream = MovieClipSoundStream;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var assert = Shumway.Debug.assert;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var Stage = function (_super) {
                        __extends(Stage, _super);
                        function Stage() {
                            _super.call(this);
                            this._root = this;
                            this._stage = this;
                            this._frameRate = 24;
                            this._scaleMode = display.StageScaleMode.SHOW_ALL;
                            this._align = '';
                            this._stageWidth = 0;
                            this._stageHeight = 0;
                            this._showDefaultContextMenu = true;
                            this._focus = null;
                            this._colorCorrection = display.ColorCorrection.DEFAULT;
                            this._colorCorrectionSupport = display.ColorCorrectionSupport.DEFAULT_OFF;
                            this._stageFocusRect = true;
                            this._quality = display.StageQuality.HIGH;
                            this._displayState = null;
                            this._fullScreenSourceRect = null;
                            this._mouseLock = false;
                            var objectVectorClass = this.sec.getVectorClass(this.sec.AXObject);
                            this._stageVideos = objectVectorClass.axConstruct([
                                0,
                                true
                            ]);
                            this._stage3Ds = objectVectorClass.axConstruct([
                                0,
                                true
                            ]);
                            this._colorARGB = 4294967295;
                            this._fullScreenWidth = 0;
                            this._fullScreenHeight = 0;
                            this._wmodeGPU = false;
                            this._softKeyboardRect = new this.sec.flash.geom.Rectangle();
                            this._allowsFullScreen = false;
                            this._allowsFullScreenInteractive = false;
                            this._contentsScaleFactor = 1;
                            this._displayContextInfo = null;
                            this._timeout = -1;
                            this._stageContainerWidth = -1;
                            this._stageContainerHeight = -1;
                            this._setFlags(262144    /* HasPerspectiveProjection */);
                            /**
                             * Indicates if a Render event was requested by calling the |invalid| function.
                             */
                            this._invalidated = false;
                        }
                        Stage.prototype.setRoot = function (root) {
                            this.addTimelineObjectAtDepth(root, 0);
                        };
                        Object.defineProperty(Stage.prototype, 'frameRate', {
                            get: function () {
                                return this._frameRate;
                            },
                            set: function (value) {
                                this._frameRate = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'scaleMode', {
                            get: function () {
                                return this._scaleMode;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                if (flash.display.StageScaleMode.toNumber(value) < 0) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidEnumError, 'scaleMode');
                                }
                                if (this._scaleMode !== value) {
                                    this._isDirty = true;
                                    this._scaleMode = value;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'align', {
                            get: function () {
                                return this._align;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                var n = flash.display.StageAlign.toNumber(value);
                                release || assert(n >= 0);
                                var newValue = flash.display.StageAlign.fromNumber(n);
                                if (this._align !== newValue) {
                                    this._isDirty = true;
                                    this._align = newValue;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'stageWidth', {
                            get: function () {
                                if (this.scaleMode !== display.StageScaleMode.NO_SCALE) {
                                    return this._stageWidth / 20 | 0;
                                }
                                release || assert(this._stageContainerWidth >= 0);
                                return this._stageContainerWidth;
                            },
                            set: function (value) {
                                // While the setter doesn't change the stored value, it still coerces the `value` parameter.
                                // This is script-visible if the value is something like `{valueOf: function(){throw 1}}`.
                                value = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Stage.prototype._setInitialName = function () {
                            this._name = null;
                        };
                        /**
                         * Non-AS3-available setter. In AS3, the `stageWidth` setter is silently ignored.
                         */
                        Stage.prototype.setStageWidth = function (value) {
                            release || assert((value | 0) === value);
                            var newValue = value * 20 | 0;
                            if (this._stageWidth !== newValue) {
                                this._isDirty = true;
                                this._stageWidth = newValue;
                            }
                        };
                        Object.defineProperty(Stage.prototype, 'stageHeight', {
                            get: function () {
                                if (this.scaleMode !== display.StageScaleMode.NO_SCALE) {
                                    return this._stageHeight / 20 | 0;
                                }
                                release || assert(this._stageContainerHeight >= 0);
                                return this._stageContainerHeight;
                            },
                            set: function (value) {
                                // While the setter doesn't change the stored value, it still coerces the `value` parameter.
                                // This is script-visible if the value is something like `{valueOf: function(){throw 1}}`.
                                value = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * Non-AS3-available setter. In AS3, the `stageHeight` setter is silently ignored.
                         */
                        Stage.prototype.setStageHeight = function (value) {
                            release || assert((value | 0) === value);
                            var newValue = value * 20 | 0;
                            if (this._stageHeight !== newValue) {
                                this._isDirty = true;
                                this._stageHeight = newValue;
                            }
                        };
                        /**
                         * Almost the same as color setter, except it preserves alpha channel.
                         * @param value
                         */
                        Stage.prototype.setStageColor = function (value) {
                            if (this._colorARGB !== value) {
                                this._isDirty = true;
                                this._colorARGB = value;
                            }
                        };
                        /**
                         * Non-AS3-available setter. Notifies the stage that the dimensions of the stage container have changed.
                         */
                        Stage.prototype.setStageContainerSize = function (width, height, pixelRatio) {
                            // Flash doesn't fire a resize event if the pixel ratio has changed, but it needs to be set if
                            // a resize event gets dispatched as a result of a size change.
                            this._contentsScaleFactor = pixelRatio;
                            var sizeHasChanged = this._stageContainerWidth !== width || this._stageContainerHeight !== height;
                            if (sizeHasChanged) {
                                this._stageContainerWidth = width;
                                this._stageContainerHeight = height;
                                if (this.scaleMode === display.StageScaleMode.NO_SCALE) {
                                    this.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(flash.events.Event.RESIZE));
                                }
                            }
                        };
                        Object.defineProperty(Stage.prototype, 'showDefaultContextMenu', {
                            get: function () {
                                return this._showDefaultContextMenu;
                            },
                            set: function (value) {
                                this._showDefaultContextMenu = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'focus', {
                            get: function () {
                                return this._focus;
                            },
                            set: function (newFocus) {
                                this._focus = newFocus;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'colorCorrection', {
                            get: function () {
                                return this._colorCorrection;
                            },
                            set: function (value) {
                                //this._colorCorrection = axCoerceString(value);
                                release || notImplemented('public flash.display.Stage::set colorCorrection');
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'colorCorrectionSupport', {
                            get: function () {
                                return this._colorCorrectionSupport;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'stageFocusRect', {
                            get: function () {
                                return this._stageFocusRect;
                            },
                            set: function (on) {
                                this._stageFocusRect = !!on;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'quality', {
                            get: function () {
                                return this._quality.toUpperCase();    // Return value is always uppercase
                            },
                            set: function (value) {
                                // TODO: The *linear versions return just *, stripping the "linear" part
                                // Value is compared case-insensitively, and has default handling, so '' is ok.
                                value = (axCoerceString(value) || '').toLowerCase();
                                if (flash.display.StageQuality.toNumber(value) < 0) {
                                    value = flash.display.StageQuality.HIGH;
                                }
                                this._quality = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'displayState', {
                            get: function () {
                                return this._displayState;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                // TODO: This should only be allowed if the embedding page allows full screen mode.
                                if (flash.display.StageDisplayState.toNumber(value) < 0) {
                                    value = flash.display.StageDisplayState.NORMAL;
                                }
                                if (this._displayState !== value) {
                                    this._isDirty = true;
                                    this._displayState = value;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'fullScreenSourceRect', {
                            get: function () {
                                return this._fullScreenSourceRect;
                            },
                            set: function (value) {
                                //this._fullScreenSourceRect = value;
                                release || notImplemented('public flash.display.Stage::set fullScreenSourceRect');
                                return;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'mouseLock', {
                            get: function () {
                                return this._mouseLock;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.display.Stage::set mouseLock');
                                this._mouseLock = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'stageVideos', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.Stage::get stageVideos');
                                return this._stageVideos;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'stage3Ds', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.Stage::get stage3Ds');
                                return this._stage3Ds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'color', {
                            get: function () {
                                return this._colorARGB;
                            },
                            set: function (rgb) {
                                var newValue = rgb | 4278190080;
                                // Flash player forces the alpha channel to 0xff.
                                if (this._colorARGB !== newValue) {
                                    this._isDirty = true;
                                    this._colorARGB = newValue;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'alpha', {
                            get: function () {
                                return this._colorTransform.alphaMultiplier;
                            },
                            set: function (alpha) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'fullScreenWidth', {
                            get: function () {
                                return this._fullScreenWidth;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'fullScreenHeight', {
                            get: function () {
                                return this._fullScreenHeight;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'wmodeGPU', {
                            get: function () {
                                return this._wmodeGPU;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'softKeyboardRect', {
                            get: function () {
                                return this._softKeyboardRect;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'allowsFullScreen', {
                            get: function () {
                                return this._allowsFullScreen;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'allowsFullScreenInteractive', {
                            get: function () {
                                return this._allowsFullScreenInteractive;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'contentsScaleFactor', {
                            get: function () {
                                return this._contentsScaleFactor;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'displayContextInfo', {
                            get: function () {
                                return this._displayContextInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Stage.prototype.removeChildAt = function (index) {
                            this.requireOwnerPermissions();
                            return _super.prototype.removeChildAt.call(this, index);
                        };
                        Stage.prototype.swapChildrenAt = function (index1, index2) {
                            this.requireOwnerPermissions();
                            _super.prototype.swapChildrenAt.call(this, index1, index2);
                        };
                        Object.defineProperty(Stage.prototype, 'width', {
                            get: function () {
                                this.requireOwnerPermissions();
                                return this._getWidth();
                            },
                            set: function (value) {
                                this.requireOwnerPermissions();
                                this._setWidth(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'height', {
                            get: function () {
                                this.requireOwnerPermissions();
                                return this._getHeight();
                            },
                            set: function (value) {
                                this.requireOwnerPermissions();
                                this._setHeight(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'mouseChildren', {
                            get: function () {
                                this.requireOwnerPermissions();
                                return this._getMouseChildren();
                            },
                            set: function (value) {
                                this.requireOwnerPermissions();
                                this._setMouseChildren(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'numChildren', {
                            get: function () {
                                this.requireOwnerPermissions();
                                return this._getNumChildren();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'tabChildren', {
                            get: function () {
                                this.requireOwnerPermissions();
                                return this._getTabChildren();
                            },
                            set: function (value) {
                                this.requireOwnerPermissions();
                                this._setTabChildren(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Stage.prototype.addChild = function (child) {
                            this.requireOwnerPermissions();
                            return _super.prototype.addChild.call(this, child);
                        };
                        Stage.prototype.addChildAt = function (child, index) {
                            this.requireOwnerPermissions();
                            return _super.prototype.addChildAt.call(this, child, index);
                        };
                        Stage.prototype.setChildIndex = function (child, index) {
                            this.requireOwnerPermissions();
                            _super.prototype.setChildIndex.call(this, child, index);
                        };
                        Stage.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
                            this.requireOwnerPermissions();
                            _super.prototype.addEventListener.call(this, type, listener, useCapture, priority, useWeakReference);
                        };
                        Stage.prototype.hasEventListener = function (type) {
                            this.requireOwnerPermissions();
                            return _super.prototype.hasEventListener.call(this, type);
                        };
                        Stage.prototype.willTrigger = function (type) {
                            this.requireOwnerPermissions();
                            return _super.prototype.willTrigger.call(this, type);
                        };
                        Stage.prototype.dispatchEvent = function (event) {
                            this.requireOwnerPermissions();
                            return _super.prototype.dispatchEvent.call(this, event);
                        };
                        Stage.prototype.invalidate = function () {
                            this._invalidated = true;
                        };
                        Stage.prototype.isFocusInaccessible = function () {
                            release || notImplemented('public flash.display.Stage::isFocusInaccessible');
                            return;
                        };
                        Stage.prototype.requireOwnerPermissions = function () {
                        };
                        Stage.prototype.render = function () {
                            if (!this._invalidated) {
                                return;
                            }
                            this.sec.flash.display.DisplayObject.axClass._broadcastFrameEvent(flash.events.Event.RENDER);
                            this._invalidated = false;
                        };
                        Object.defineProperty(Stage.prototype, 'name', {
                            get: function () {
                                return this._name;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'mask', {
                            get: function () {
                                return this._mask;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'visible', {
                            get: function () {
                                return this._hasFlags(1    /* Visible */);
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'x', {
                            get: function () {
                                return this._getX();
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'y', {
                            get: function () {
                                return this._getY();
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'z', {
                            get: function () {
                                return this._z;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'scaleX', {
                            get: function () {
                                return Math.abs(this._scaleX);
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'scaleY', {
                            get: function () {
                                return this._scaleY;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'scaleZ', {
                            get: function () {
                                return this._scaleZ;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'rotation', {
                            get: function () {
                                return this._rotation;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'rotationX', {
                            get: function () {
                                return this._rotationX;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'rotationY', {
                            get: function () {
                                return this._rotationX;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'rotationZ', {
                            get: function () {
                                return this._rotationX;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'cacheAsBitmap', {
                            get: function () {
                                return this._getCacheAsBitmap();
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'opaqueBackground', {
                            get: function () {
                                return this._opaqueBackground;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'scrollRect', {
                            get: function () {
                                return this._getScrollRect();
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'filters', {
                            get: function () {
                                return this._getFilters();
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'blendMode', {
                            get: function () {
                                return this._blendMode;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'transform', {
                            get: function () {
                                return this._getTransform();
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'accessibilityProperties', {
                            get: function () {
                                return this._accessibilityProperties;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'scale9Grid', {
                            get: function () {
                                return this._getScale9Grid();
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'tabEnabled', {
                            get: function () {
                                return this._tabEnabled;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'tabIndex', {
                            get: function () {
                                return this._tabIndex;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'focusRect', {
                            get: function () {
                                return this._focusRect;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'mouseEnabled', {
                            get: function () {
                                return this._mouseEnabled;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'accessibilityImplementation', {
                            get: function () {
                                return this._accessibilityImplementation;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'textSnapshot', {
                            get: function () {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Stage.prototype, 'contextMenu', {
                            get: function () {
                                return this._contextMenu;
                            },
                            set: function (value) {
                                this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidStageMethodError);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Stage.classInitializer = null;
                        Stage.classSymbols = null;
                        // [];
                        Stage.instanceSymbols = null;
                        return Stage;
                    }(flash.display.DisplayObjectContainer);
                    display.Stage = Stage;
                    var ActionScriptVersion = function (_super) {
                        __extends(ActionScriptVersion, _super);
                        function ActionScriptVersion() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        ActionScriptVersion.classInitializer = null;
                        // List of static symbols to link.
                        ActionScriptVersion.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        ActionScriptVersion.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        ActionScriptVersion.ACTIONSCRIPT2 = 2;
                        ActionScriptVersion.ACTIONSCRIPT3 = 3;
                        return ActionScriptVersion;
                    }(AS.ASObject);
                    display.ActionScriptVersion = ActionScriptVersion;
                    var BlendMode = function (_super) {
                        __extends(BlendMode, _super);
                        function BlendMode() {
                            _super.call(this);
                        }
                        /**
                         * Returns the blend mode string from the numeric value that appears in the
                         * swf file.
                         */
                        BlendMode.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                            case 1:
                                return BlendMode.NORMAL;
                            case 2:
                                return BlendMode.LAYER;
                            case 3:
                                return BlendMode.MULTIPLY;
                            case 4:
                                return BlendMode.SCREEN;
                            case 5:
                                return BlendMode.LIGHTEN;
                            case 6:
                                return BlendMode.DARKEN;
                            case 7:
                                return BlendMode.DIFFERENCE;
                            case 8:
                                return BlendMode.ADD;
                            case 9:
                                return BlendMode.SUBTRACT;
                            case 10:
                                return BlendMode.INVERT;
                            case 11:
                                return BlendMode.ALPHA;
                            case 12:
                                return BlendMode.ERASE;
                            case 13:
                                return BlendMode.OVERLAY;
                            case 14:
                                return BlendMode.HARDLIGHT;
                            default:
                                return null;
                            }
                        };
                        BlendMode.toNumber = function (value) {
                            switch (value) {
                            case BlendMode.NORMAL:
                                return 1;
                            case BlendMode.LAYER:
                                return 2;
                            case BlendMode.MULTIPLY:
                                return 3;
                            case BlendMode.SCREEN:
                                return 4;
                            case BlendMode.LIGHTEN:
                                return 5;
                            case BlendMode.DARKEN:
                                return 6;
                            case BlendMode.DIFFERENCE:
                                return 7;
                            case BlendMode.ADD:
                                return 8;
                            case BlendMode.SUBTRACT:
                                return 9;
                            case BlendMode.INVERT:
                                return 10;
                            case BlendMode.ALPHA:
                                return 11;
                            case BlendMode.ERASE:
                                return 12;
                            case BlendMode.OVERLAY:
                                return 13;
                            case BlendMode.HARDLIGHT:
                                return 14;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        BlendMode.classInitializer = null;
                        // List of static symbols to link.
                        BlendMode.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        BlendMode.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        BlendMode.NORMAL = 'normal';
                        BlendMode.LAYER = 'layer';
                        BlendMode.MULTIPLY = 'multiply';
                        BlendMode.SCREEN = 'screen';
                        BlendMode.LIGHTEN = 'lighten';
                        BlendMode.DARKEN = 'darken';
                        BlendMode.ADD = 'add';
                        BlendMode.SUBTRACT = 'subtract';
                        BlendMode.DIFFERENCE = 'difference';
                        BlendMode.INVERT = 'invert';
                        BlendMode.OVERLAY = 'overlay';
                        BlendMode.HARDLIGHT = 'hardlight';
                        BlendMode.ALPHA = 'alpha';
                        BlendMode.ERASE = 'erase';
                        BlendMode.SHADER = 'shader';
                        return BlendMode;
                    }(AS.ASObject);
                    display.BlendMode = BlendMode;
                    var ColorCorrection = function (_super) {
                        __extends(ColorCorrection, _super);
                        function ColorCorrection() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        ColorCorrection.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return ColorCorrection.DEFAULT;
                            case 1:
                                return ColorCorrection.ON;
                            case 2:
                                return ColorCorrection.OFF;
                            default:
                                return null;
                            }
                        };
                        ColorCorrection.toNumber = function (value) {
                            switch (value) {
                            case ColorCorrection.DEFAULT:
                                return 0;
                            case ColorCorrection.ON:
                                return 1;
                            case ColorCorrection.OFF:
                                return 2;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        ColorCorrection.classInitializer = null;
                        // List of static symbols to link.
                        ColorCorrection.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        ColorCorrection.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        ColorCorrection.DEFAULT = 'default';
                        ColorCorrection.ON = 'on';
                        ColorCorrection.OFF = 'off';
                        return ColorCorrection;
                    }(AS.ASObject);
                    display.ColorCorrection = ColorCorrection;
                    var ColorCorrectionSupport = function (_super) {
                        __extends(ColorCorrectionSupport, _super);
                        function ColorCorrectionSupport() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        ColorCorrectionSupport.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return ColorCorrectionSupport.UNSUPPORTED;
                            case 1:
                                return ColorCorrectionSupport.DEFAULT_ON;
                            case 2:
                                return ColorCorrectionSupport.DEFAULT_OFF;
                            default:
                                return null;
                            }
                        };
                        ColorCorrectionSupport.toNumber = function (value) {
                            switch (value) {
                            case ColorCorrectionSupport.UNSUPPORTED:
                                return 0;
                            case ColorCorrectionSupport.DEFAULT_ON:
                                return 1;
                            case ColorCorrectionSupport.DEFAULT_OFF:
                                return 2;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        ColorCorrectionSupport.classInitializer = null;
                        // List of static symbols to link.
                        ColorCorrectionSupport.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        ColorCorrectionSupport.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        ColorCorrectionSupport.UNSUPPORTED = 'unsupported';
                        ColorCorrectionSupport.DEFAULT_ON = 'defaultOn';
                        ColorCorrectionSupport.DEFAULT_OFF = 'defaultOff';
                        return ColorCorrectionSupport;
                    }(AS.ASObject);
                    display.ColorCorrectionSupport = ColorCorrectionSupport;
                    var FocusDirection = function (_super) {
                        __extends(FocusDirection, _super);
                        function FocusDirection() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        FocusDirection.classInitializer = null;
                        // List of static symbols to link.
                        FocusDirection.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        FocusDirection.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        FocusDirection.TOP = 'top';
                        FocusDirection.BOTTOM = 'bottom';
                        FocusDirection.NONE = 'none';
                        return FocusDirection;
                    }(AS.ASObject);
                    display.FocusDirection = FocusDirection;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var FrameLabel = function (_super) {
                        __extends(FrameLabel, _super);
                        function FrameLabel(name, frame) {
                            _super.call(this);
                            this._name = axCoerceString(name);
                            this._frame = frame | 0;
                        }
                        Object.defineProperty(FrameLabel.prototype, 'name', {
                            get: function () {
                                return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FrameLabel.prototype, 'frame', {
                            get: function () {
                                return this._frame;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        FrameLabel.prototype.clone = function () {
                            return new this.sec.flash.display.FrameLabel(this._name, this._frame);
                        };
                        // Called whenever the class is initialized.
                        FrameLabel.classInitializer = null;
                        return FrameLabel;
                    }(flash.events.EventDispatcher);
                    display.FrameLabel = FrameLabel;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var assert = Shumway.Debug.assert;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var swap32 = Shumway.IntegerUtilities.swap32;
                    var premultiplyARGB = Shumway.ColorUtilities.premultiplyARGB;
                    var unpremultiplyARGB = Shumway.ColorUtilities.unpremultiplyARGB;
                    var RGBAToARGB = Shumway.ColorUtilities.RGBAToARGB;
                    var indexOf = Shumway.ArrayUtilities.indexOf;
                    /**
                     * Holds blobs of bitmap data in various formats and lets you do basic pixel operations. When
                     * data is unpacked, it is stored as premultiplied ARGB since it's what the SWF encodes bitmaps
                     * as.  This way we don't have to do unecessary byte conversions.
                     */
                    var BitmapData = function (_super) {
                        __extends(BitmapData, _super);
                        function BitmapData(width, height, transparent, fillColorARGB) {
                            if (transparent === void 0) {
                                transparent = true;
                            }
                            if (fillColorARGB === void 0) {
                                fillColorARGB = 4294967295;
                            }
                            width = width | 0;
                            height = height | 0;
                            transparent = !!transparent;
                            fillColorARGB = fillColorARGB | 0;
                            _super.call(this);
                            if (this._symbol) {
                                this.applySymbol();
                                return;
                            }
                            if (width > BitmapData.MAXIMUM_WIDTH || width <= 0 || height > BitmapData.MAXIMUM_HEIGHT || height <= 0 || width * height > BitmapData.MAXIMUM_DIMENSION) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.InvalidBitmapData);
                            }
                            this._rect = new this.sec.flash.geom.Rectangle(0, 0, width, height);
                            this._transparent = transparent;
                            this._id = flash.display.DisplayObject.getNextSyncID();
                            this._setData(new Uint8Array(width * height * 4), Shumway.ImageType.PremultipliedAlphaARGB);
                            var alpha = fillColorARGB >> 24;
                            if (alpha === 0 && transparent) {
                                // No need to do an initial fill since this would all be zeros anyway.
                                this._solidFillColorPBGRA = 0;
                            } else {
                                this.fillRect(this._rect, fillColorARGB);
                            }
                            this._bitmapReferrers = [];
                            release || assert(this._isDirty === !!this._data);
                            release || assert(this._isRemoteDirty === !this._data);
                        }
                        BitmapData.classInitializer = function () {
                            this._temporaryRectangle = new this.sec.flash.geom.Rectangle();
                        };
                        BitmapData.prototype.applySymbol = function () {
                            release || assert(this._symbol);
                            var symbol = this._symbol;
                            release || assert(symbol.syncId);
                            this._rect = new this.sec.flash.geom.Rectangle(0, 0, symbol.width, symbol.height);
                            this._transparent = true;
                            this._id = symbol.syncId;
                            if (symbol.type === Shumway.ImageType.PremultipliedAlphaARGB || symbol.type === Shumway.ImageType.StraightAlphaARGB || symbol.type === Shumway.ImageType.StraightAlphaRGBA) {
                                release || assert(symbol.data);
                                this._setData(symbol.data, symbol.type);
                            } else {
                                this._isDirty = false;
                                this._isRemoteDirty = true;
                            }
                            this._solidFillColorPBGRA = null;
                            this._bitmapReferrers = [];
                        };
                        BitmapData.prototype._setData = function (data, type) {
                            // Alpha images are parsed to Uint8Clamped array. Easiest to just handle here.
                            if (data instanceof Uint8ClampedArray) {
                                data = new Uint8Array(data.buffer);
                            }
                            release || assert(data instanceof Uint8Array);
                            this._data = data;
                            this._type = type;
                            this._view = new Int32Array(data.buffer);
                            this._dataBuffer = DataBuffer.FromArrayBuffer(data.buffer);
                            this._isDirty = true;
                            this._isRemoteDirty = false;
                        };
                        BitmapData.prototype._addBitmapReferrer = function (bitmap) {
                            var index = indexOf(this._bitmapReferrers, bitmap);
                            release || assert(index < 0);
                            this._bitmapReferrers.push(bitmap);
                        };
                        BitmapData.prototype._removeBitmapReferrer = function (bitmap) {
                            var index = indexOf(this._bitmapReferrers, bitmap);
                            release || assert(index >= 0);
                            this._bitmapReferrers[index] = null;
                        };
                        /**
                         * Called whenever the contents of this bitmap data changes.
                         */
                        BitmapData.prototype._invalidate = function () {
                            if (this._isDirty) {
                                return;
                            }
                            this._isDirty = true;
                            this._isRemoteDirty = false;
                            // TODO: We probably don't need to propagate any flags if |_locked| is true.
                            for (var i = 0; i < this._bitmapReferrers.length; i++) {
                                var bitmap = this._bitmapReferrers[i];
                                if (bitmap) {
                                    bitmap._setDirtyFlags(16    /* DirtyBitmapData */);
                                }
                            }
                        };
                        BitmapData.prototype._getTemporaryRectangleFrom = function (rect) {
                            var r = this.sec.flash.display.BitmapData.axClass._temporaryRectangle;
                            r.copyFrom(rect);
                            return r;
                        };
                        BitmapData.prototype.getDataBuffer = function () {
                            return this._dataBuffer;
                        };
                        BitmapData.prototype._getContentBounds = function () {
                            return Shumway.Bounds.FromRectangle(this._rect);
                        };
                        /**
                         * TODO: Not tested.
                         */
                        BitmapData.prototype._getPixelData = function (rect) {
                            var r = this._getTemporaryRectangleFrom(this._rect).intersectInPlace(rect);
                            if (r.isEmpty()) {
                                return;
                            }
                            var xMin = r.x;
                            var xMax = r.x + r.width;
                            var yMin = r.y;
                            var yMax = r.y + r.height;
                            this._ensureBitmapData();
                            var view = this._view;
                            var width = this._rect.width;
                            var output = new Int32Array(r.area);
                            var p = 0;
                            for (var y = yMin; y < yMax; y++) {
                                var offset = y * width;
                                for (var x = xMin; x < xMax; x++) {
                                    var colorBGRA = view[offset + x];
                                    var alpha = colorBGRA & 255;
                                    var colorBGR = colorBGRA >>> 8;
                                    colorBGRA = 255 * colorBGR / alpha << 8 | alpha;
                                    output[p++] = colorBGRA;
                                }
                            }
                            return output;
                        };
                        /**
                         * TODO: Not tested.
                         */
                        BitmapData.prototype._putPixelData = function (rect, input) {
                            var r = this._getTemporaryRectangleFrom(this._rect).intersectInPlace(rect);
                            if (r.isEmpty()) {
                                return;
                            }
                            var xMin = r.x;
                            var xMax = r.x + r.width;
                            var yMin = r.y;
                            var yMax = r.y + r.height;
                            this._ensureBitmapData();
                            var view = this._view;
                            var width = this._rect.width;
                            var p = rect.width * rect.height - r.height + (xMin - rect.x);
                            var padding = rect.width - r.width;
                            var alphaMask = this._transparent ? 0 : 255;
                            for (var y = yMin; y < yMax; y++) {
                                var offset = y * width;
                                for (var x = xMin; x < xMax; x++) {
                                    var colorBGRA = input[p++];
                                    var alpha = colorBGRA & alphaMask;
                                    var colorBGR = colorBGRA >>> 8;
                                    view[offset + x] = ((colorBGR * alpha + 254) / 255 & 16777215) << 8 | alpha;
                                }
                                p += padding;
                            }
                            this._invalidate();
                        };
                        Object.defineProperty(BitmapData.prototype, 'width', {
                            get: function () {
                                return this._rect.width;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BitmapData.prototype, 'height', {
                            get: function () {
                                return this._rect.height;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BitmapData.prototype, 'rect', {
                            get: function () {
                                return this._rect.clone();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BitmapData.prototype, 'transparent', {
                            get: function () {
                                return this._transparent;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        BitmapData.prototype.clone = function () {
                            var bd = Object.create(this.sec.flash.display.BitmapData.axClass.tPrototype);
                            bd._rect = this._rect.clone();
                            bd._transparent = this._transparent;
                            bd._solidFillColorPBGRA = this._solidFillColorPBGRA;
                            bd._bitmapReferrers = [];
                            // TODO: clone without reading back bitmapdata. There's no need for that.
                            this._ensureBitmapData();
                            bd._id = flash.display.DisplayObject.getNextSyncID();
                            bd._setData(new Uint8Array(this._data), this._type);
                            return bd;
                        };
                        /**
                         * Returns an straight alpha RGB pixel value 0x00RRGGBB.
                         */
                        BitmapData.prototype.getPixel = function (x, y) {
                            x = x | 0;
                            y = y | 0;
                            return this.getPixel32(x, y) & 16777215;
                        };
                        /**
                         * Returns an straight alpha ARGB pixel value 0xAARRGGBB.
                         */
                        BitmapData.prototype.getPixel32 = function (x, y) {
                            x = x | 0;
                            y = y | 0;
                            if (!this._rect.contains(x, y)) {
                                return 0;
                            }
                            this._ensureBitmapData();
                            var value = this._view[y * this._rect.width + x];
                            switch (this._type) {
                            case Shumway.ImageType.PremultipliedAlphaARGB:
                                var pARGB = swap32(value);
                                var uARGB = unpremultiplyARGB(pARGB);
                                return uARGB >>> 0;
                            case Shumway.ImageType.StraightAlphaRGBA:
                                return RGBAToARGB(swap32(value));
                            default:
                                Shumway.Debug.notImplemented(Shumway.ImageType[this._type]);
                                return 0;
                            }
                        };
                        BitmapData.prototype.setPixel = function (x, y, uARGB) {
                            // TODO: implement this as a wrapper for setPixel32.
                            x = x | 0;
                            y = y | 0;
                            uARGB = uARGB | 0;
                            if (!this._rect.contains(x, y)) {
                                return;
                            }
                            this._ensureBitmapData();
                            var i = y * this._rect.width + x;
                            var a = this._view[i] & 255;
                            uARGB = uARGB & 16777215 | a << 24;
                            var pARGB = premultiplyARGB(uARGB);
                            this._view[i] = swap32(pARGB);
                            this._invalidate();
                            this._solidFillColorPBGRA = null;
                        };
                        BitmapData.prototype.setPixel32 = function (x, y, uARGB) {
                            x = x | 0;
                            y = y | 0;
                            if (!this._rect.contains(x, y)) {
                                return;
                            }
                            this._ensureBitmapData();
                            var a = uARGB >>> 24;
                            var uRGB = uARGB & 16777215;
                            if (this._transparent) {
                                var uARGB = uRGB | a << 24;
                                var pARGB = premultiplyARGB(uARGB);
                            } else {
                                var pARGB = uRGB | 4278190080;
                            }
                            this._view[y * this._rect.width + x] = swap32(pARGB);
                            this._invalidate();
                            this._solidFillColorPBGRA = null;
                        };
                        BitmapData.prototype.applyFilter = function (sourceBitmapData, sourceRect, destPoint, filter) {
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            filter = filter;
                            release || somewhatImplemented('public flash.display.BitmapData::applyFilter ' + filter);
                            return;
                        };
                        BitmapData.prototype.colorTransform = function (rect, colorTransform) {
                            rect = rect;
                            colorTransform = colorTransform;
                            release || somewhatImplemented('public flash.display.BitmapData::colorTransform');
                            return;
                        };
                        BitmapData.prototype.compare = function (otherBitmapData) {
                            otherBitmapData = otherBitmapData;
                            release || notImplemented('public flash.display.BitmapData::compare');
                            return;
                        };
                        BitmapData.prototype.copyChannel = function (sourceBitmapData, sourceRect, destPoint, sourceChannel, destChannel) {
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            sourceChannel = sourceChannel >>> 0;
                            destChannel = destChannel >>> 0;
                            release || somewhatImplemented('public flash.display.BitmapData::copyChannel');
                            return;
                        };
                        /**
                         * Copies a rectangular region of pixels into the current bitmap data.
                         */
                        BitmapData.prototype.copyPixels = function (sourceBitmapData, sourceRect, destPoint, alphaBitmapData, alphaPoint, mergeAlpha) {
                            if (alphaBitmapData === void 0) {
                                alphaBitmapData = null;
                            }
                            if (alphaPoint === void 0) {
                                alphaPoint = null;
                            }
                            mergeAlpha = !!mergeAlpha;
                            if (alphaBitmapData || alphaPoint) {
                                release || somewhatImplemented('public flash.display.BitmapData::copyPixels - Alpha');
                                return;
                            }
                            // Deal with fractional pixel coordinates, looks like Flash "rounds" the corners of
                            // the source rect, however a width of |0.5| rounds down rather than up so we're not
                            // quite correct here.
                            var sRect;
                            if (sourceRect) {
                                sRect = this._getTemporaryRectangleFrom(sourceRect).roundInPlace();
                            } else {
                                sRect = this.sec.flash.display.BitmapData.axClass._temporaryRectangle.setEmpty();
                            }
                            var tBRect = this._rect;
                            var sBRect = sourceBitmapData._rect;
                            // Clip sRect against SBRect.
                            var sL = Math.max(sRect.x, 0);
                            var sT = Math.max(sRect.y, 0);
                            var sR = Math.min(sRect.x + sRect.width, sBRect.width);
                            var sB = Math.min(sRect.y + sRect.height, sBRect.height);
                            // Compute source rect offsets (in case the source rect had negative x, y coordinates).
                            var oX = sL - sRect.x;
                            var oY = sT - sRect.y;
                            var tL = (destPoint.x | 0) + oX;
                            var tT = (destPoint.y | 0) + oY;
                            if (tL < 0) {
                                sL -= tL;
                                tL = 0;
                            }
                            if (tT < 0) {
                                sT -= tT;
                                tT = 0;
                            }
                            var tW = Math.min(sR - sL, tBRect.width - tL);
                            var tH = Math.min(sB - sT, tBRect.height - tT);
                            if (tW <= 0 || tH <= 0) {
                                return;
                            }
                            var sX = sL;
                            var sY = sT;
                            var tX = tL;
                            var tY = tT;
                            var sStride = sourceBitmapData._rect.width;
                            var tStride = this._rect.width;
                            this._ensureBitmapData();
                            sourceBitmapData._ensureBitmapData();
                            var s = sourceBitmapData._view;
                            var t = this._view;
                            if (sourceBitmapData._type !== this._type) {
                                release || somewhatImplemented('public flash.display.BitmapData::copyPixels - Color Format Conversion');
                            }
                            if (mergeAlpha && this._type !== Shumway.ImageType.PremultipliedAlphaARGB) {
                                release || somewhatImplemented('public flash.display.BitmapData::copyPixels - Merge Alpha');
                                return;
                            }
                            // No reason to copy pixels since since both source and target are the same solid fill,
                            // regardless of alpha blending. (TODO: I think the math works out for mergeAlpha also.)
                            if (this._solidFillColorPBGRA !== null && this._solidFillColorPBGRA === sourceBitmapData._solidFillColorPBGRA) {
                                return;
                            }
                            // Source has a solid fill but is fully opaque, we can get away without alpha blending here.
                            if (sourceBitmapData._solidFillColorPBGRA !== null && (sourceBitmapData._solidFillColorPBGRA & 255) === 255) {
                                mergeAlpha = false;
                            }
                            // Finally do the copy. All the math above is needed just so we don't do any branches inside
                            // this hot loop.
                            if (mergeAlpha) {
                                this._copyPixelsAndMergeAlpha(s, sX, sY, sStride, t, tX, tY, tStride, tW, tH);
                            } else {
                                var sP = sY * sStride + sX | 0;
                                var tP = tY * tStride + tX | 0;
                                if ((tW & 3) === 0) {
                                    for (var y = 0; y < tH; y = y + 1 | 0) {
                                        for (var x = 0; x < tW; x = x + 4 | 0) {
                                            t[tP + x + 0 | 0] = s[sP + x + 0 | 0];
                                            t[tP + x + 1 | 0] = s[sP + x + 1 | 0];
                                            t[tP + x + 2 | 0] = s[sP + x + 2 | 0];
                                            t[tP + x + 3 | 0] = s[sP + x + 3 | 0];
                                        }
                                        sP = sP + sStride | 0;
                                        tP = tP + tStride | 0;
                                    }
                                } else {
                                    for (var y = 0; y < tH; y = y + 1 | 0) {
                                        for (var x = 0; x < tW; x = x + 1 | 0) {
                                            t[tP + x | 0] = s[sP + x | 0];
                                        }
                                        sP = sP + sStride | 0;
                                        tP = tP + tStride | 0;
                                    }
                                }
                            }
                            this._solidFillColorPBGRA = null;
                            this._invalidate();
                        };
                        BitmapData.prototype._copyPixelsAndMergeAlpha = function (s, sX, sY, sStride, t, tX, tY, tStride, tW, tH) {
                            var sP = sY * sStride + sX | 0;
                            var tP = tY * tStride + tX | 0;
                            for (var y = 0; y < tH; y = y + 1 | 0) {
                                for (var x = 0; x < tW; x = x + 1 | 0) {
                                    var spBGRA = s[sP + x | 0];
                                    var sA = spBGRA & 255;
                                    // Optimize for the case where the source pixel is fully opaque or transparent. This
                                    // pays off if the source image has many such pixels but slows down the normal case.
                                    if (sA === 255) {
                                        t[tP + x | 0] = spBGRA;    // Opaque, just copy value over.
                                    } else if (sA === 0) {
                                    } else {
                                        // Compute the blending equation: src.rgb + (dst.rgb * (1 - src.a)). The trick here
                                        // is to compute GA and BR at the same time without pulling apart each channel.
                                        // We use the "double blend trick" (http://stereopsis.com/doubleblend.html) to
                                        // compute GA and BR without unpacking them.
                                        var sGA = spBGRA & 16711935;
                                        var sBR = spBGRA >> 8 & 16711935;
                                        var tpBGRA = t[tP + x | 0];
                                        var tGA = tpBGRA & 16711935;
                                        var tBR = tpBGRA >> 8 & 16711935;
                                        var A = 256 - sA;
                                        tGA = Math.imul(tGA, A) >> 8;
                                        tBR = Math.imul(tBR, A) >> 8;
                                        // TODO: Not sure if target alpha is computed correctly.
                                        t[tP + x | 0] = (sBR + tBR & 16711935) << 8 | sGA + tGA & 16711935;
                                    }
                                }
                                sP = sP + sStride | 0;
                                tP = tP + tStride | 0;
                            }
                        };
                        BitmapData.prototype.dispose = function () {
                            this._rect.setEmpty();
                            this._view = null;
                            this._invalidate();
                        };
                        BitmapData.prototype.draw = function (source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (colorTransform === void 0) {
                                colorTransform = null;
                            }
                            if (blendMode === void 0) {
                                blendMode = null;
                            }
                            if (clipRect === void 0) {
                                clipRect = null;
                            }
                            if (smoothing === void 0) {
                                smoothing = false;
                            }
                            blendMode = axCoerceString(blendMode);
                            smoothing = !!smoothing;
                            release || somewhatImplemented('public flash.display.BitmapData::draw');
                            var serializer = this.sec.player;
                            if (matrix) {
                                matrix = matrix.clone().toTwipsInPlace();
                            }
                            serializer.drawToBitmap(this, source, matrix, colorTransform, blendMode, clipRect, smoothing);
                            this._isRemoteDirty = true;
                        };
                        BitmapData.prototype.drawWithQuality = function (source, matrix, colorTransform, blendMode, clipRect, smoothing, quality) {
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (colorTransform === void 0) {
                                colorTransform = null;
                            }
                            if (blendMode === void 0) {
                                blendMode = null;
                            }
                            if (clipRect === void 0) {
                                clipRect = null;
                            }
                            if (smoothing === void 0) {
                                smoothing = false;
                            }
                            if (quality === void 0) {
                                quality = null;
                            }
                            quality = axCoerceString(quality);
                            release || somewhatImplemented('public flash.display.BitmapData::drawWithQuality');
                            this.draw(source, matrix, colorTransform, blendMode, clipRect, smoothing);
                        };
                        BitmapData.prototype.fillRect = function (rect, uARGB) {
                            this._ensureBitmapData();
                            // TODO: what guarantees this, and why do we even need it?
                            release || assert(this._type === Shumway.ImageType.PremultipliedAlphaARGB);
                            if (this._transparent) {
                                var pARGB = premultiplyARGB(uARGB);
                            } else {
                                var pARGB = uARGB | 4278190080;
                            }
                            var pBGRA = swap32(pARGB);
                            var r = this._getTemporaryRectangleFrom(this._rect).intersectInPlace(rect);
                            if (r.isEmpty()) {
                                return;
                            }
                            // Filling with the same color?
                            if (this._solidFillColorPBGRA === pBGRA) {
                                return;
                            }
                            var view = this._view;
                            // If we are filling the entire buffer, we can do a little better ~ 25% faster.
                            if (r.equals(this._rect)) {
                                var length = view.length | 0;
                                // Unroll 4 iterations, ~ 5% faster.
                                if ((length & 3) === 0) {
                                    for (var i = 0; i < length; i += 4) {
                                        view[i] = pBGRA;
                                        view[i + 1] = pBGRA;
                                        view[i + 2] = pBGRA;
                                        view[i + 3] = pBGRA;
                                    }
                                } else {
                                    for (var i = 0; i < length; i++) {
                                        view[i] = pBGRA;
                                    }
                                }
                                this._solidFillColorPBGRA = pBGRA;
                            } else {
                                var xMin = r.x | 0;
                                var xMax = r.x + r.width | 0;
                                var yMin = r.y | 0;
                                var yMax = r.y + r.height | 0;
                                var width = this._rect.width | 0;
                                for (var y = yMin; y < yMax; y++) {
                                    var offset = y * width | 0;
                                    for (var x = xMin; x < xMax; x++) {
                                        view[offset + x] = pBGRA;
                                    }
                                }
                                this._solidFillColorPBGRA = null;
                            }
                            this._invalidate();
                        };
                        BitmapData.prototype.floodFill = function (x, y, color) {
                            x = x | 0;
                            y = y | 0;
                            color = color >>> 0;
                            release || somewhatImplemented('public flash.display.BitmapData::floodFill');
                            return;
                        };
                        BitmapData.prototype.generateFilterRect = function (sourceRect, filter) {
                            sourceRect = sourceRect;
                            filter = filter;
                            release || somewhatImplemented('public flash.display.BitmapData::generateFilterRect');
                            return;
                        };
                        BitmapData.prototype.getColorBoundsRect = function (mask, color, findColor) {
                            if (findColor === void 0) {
                                findColor = true;
                            }
                            mask = mask >>> 0;
                            color = color >>> 0;
                            findColor = !!findColor;
                            release || somewhatImplemented('public flash.display.BitmapData::getColorBoundsRect');
                            return new this.sec.flash.geom.Rectangle();
                        };
                        BitmapData.prototype.getPixels = function (rect) {
                            var outputByteArray = new this.sec.flash.utils.ByteArray();
                            this.copyPixelsToByteArray(rect, outputByteArray);
                            return outputByteArray;
                        };
                        BitmapData.prototype.copyPixelsToByteArray = function (rect, data) {
                            var pixelData = this._getPixelData(rect);
                            if (!pixelData) {
                                return;
                            }
                            data.writeRawBytes(new Uint8Array(pixelData));
                        };
                        BitmapData.prototype.getVector = function (rect) {
                            var outputVector = new this.sec.Uint32Vector(pixelData.length);
                            var pixelData = this._getPixelData(rect);
                            if (!pixelData) {
                                return outputVector;
                            }
                            outputVector.length = pixelData.length;
                            outputVector._view().set(pixelData);
                            return outputVector;
                        };
                        BitmapData.prototype.hitTest = function (firstPoint, firstAlphaThreshold, secondObject, secondBitmapDataPoint, secondAlphaThreshold) {
                            if (secondBitmapDataPoint === void 0) {
                                secondBitmapDataPoint = null;
                            }
                            if (secondAlphaThreshold === void 0) {
                                secondAlphaThreshold = 1;
                            }
                            firstPoint = firstPoint;
                            firstAlphaThreshold = firstAlphaThreshold >>> 0;
                            secondObject = secondObject;
                            secondBitmapDataPoint = secondBitmapDataPoint;
                            secondAlphaThreshold = secondAlphaThreshold >>> 0;
                            release || somewhatImplemented('public flash.display.BitmapData::hitTest');
                            return true;
                        };
                        BitmapData.prototype.merge = function (sourceBitmapData, sourceRect, destPoint, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier) {
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            redMultiplier = redMultiplier >>> 0;
                            greenMultiplier = greenMultiplier >>> 0;
                            blueMultiplier = blueMultiplier >>> 0;
                            alphaMultiplier = alphaMultiplier >>> 0;
                            release || somewhatImplemented('public flash.display.BitmapData::merge');
                        };
                        BitmapData.prototype.noise = function (randomSeed, low, high, channelOptions, grayScale) {
                            if (low === void 0) {
                                low = 0;
                            }
                            if (high === void 0) {
                                high = 255;
                            }
                            if (channelOptions === void 0) {
                                channelOptions = 7;
                            }
                            if (grayScale === void 0) {
                                grayScale = false;
                            }
                            randomSeed = randomSeed | 0;
                            low = low >>> 0;
                            high = high >>> 0;
                            channelOptions = channelOptions >>> 0;
                            grayScale = !!grayScale;
                            release || somewhatImplemented('public flash.display.BitmapData::noise');
                        };
                        BitmapData.prototype.paletteMap = function (sourceBitmapData, sourceRect, destPoint, redArray, greenArray, blueArray, alphaArray) {
                            if (redArray === void 0) {
                                redArray = null;
                            }
                            if (greenArray === void 0) {
                                greenArray = null;
                            }
                            if (blueArray === void 0) {
                                blueArray = null;
                            }
                            if (alphaArray === void 0) {
                                alphaArray = null;
                            }
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            redArray = redArray;
                            greenArray = greenArray;
                            blueArray = blueArray;
                            alphaArray = alphaArray;
                            release || somewhatImplemented('public flash.display.BitmapData::paletteMap');
                        };
                        BitmapData.prototype.perlinNoise = function (baseX, baseY, numOctaves, randomSeed, stitch, fractalNoise, channelOptions, grayScale, offsets) {
                            if (channelOptions === void 0) {
                                channelOptions = 7;
                            }
                            if (grayScale === void 0) {
                                grayScale = false;
                            }
                            if (offsets === void 0) {
                                offsets = null;
                            }
                            baseX = +baseX;
                            baseY = +baseY;
                            numOctaves = numOctaves >>> 0;
                            randomSeed = randomSeed | 0;
                            stitch = !!stitch;
                            fractalNoise = !!fractalNoise;
                            channelOptions = channelOptions >>> 0;
                            grayScale = !!grayScale;
                            offsets = offsets;
                            release || somewhatImplemented('public flash.display.BitmapData::perlinNoise');
                        };
                        BitmapData.prototype.pixelDissolve = function (sourceBitmapData, sourceRect, destPoint, randomSeed, numPixels, fillColor) {
                            if (randomSeed === void 0) {
                                randomSeed = 0;
                            }
                            if (numPixels === void 0) {
                                numPixels = 0;
                            }
                            if (fillColor === void 0) {
                                fillColor = 0;
                            }
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            randomSeed = randomSeed | 0;
                            numPixels = numPixels | 0;
                            fillColor = fillColor >>> 0;
                            release || somewhatImplemented('public flash.display.BitmapData::pixelDissolve');
                            return;
                        };
                        BitmapData.prototype.scroll = function (x, y) {
                            x = x | 0;
                            y = y | 0;
                            release || somewhatImplemented('public flash.display.BitmapData::scroll');
                            return;
                        };
                        BitmapData.prototype.setPixels = function (rect, inputByteArray) {
                            this._putPixelData(rect, new Int32Array(inputByteArray.readRawBytes()));
                        };
                        BitmapData.prototype.setVector = function (rect, inputVector) {
                            this._putPixelData(rect, inputVector._view());
                        };
                        BitmapData.prototype.threshold = function (sourceBitmapData, sourceRect, destPoint, operation, threshold, color, mask, copySource) {
                            if (color === void 0) {
                                color = 0;
                            }
                            if (mask === void 0) {
                                mask = 4294967295;
                            }
                            if (copySource === void 0) {
                                copySource = false;
                            }
                            sourceBitmapData = sourceBitmapData;
                            sourceRect = sourceRect;
                            destPoint = destPoint;
                            operation = axCoerceString(operation);
                            threshold = threshold >>> 0;
                            color = color >>> 0;
                            mask = mask >>> 0;
                            copySource = !!copySource;
                            release || somewhatImplemented('public flash.display.BitmapData::threshold');
                            return;
                        };
                        BitmapData.prototype.lock = function () {
                            this._locked = true;
                        };
                        BitmapData.prototype.unlock = function (changeRect) {
                            if (changeRect === void 0) {
                                changeRect = null;
                            }
                            //changeRect = changeRect;
                            this._locked = false;
                        };
                        BitmapData.prototype.histogram = function (hRect) {
                            if (hRect === void 0) {
                                hRect = null;
                            }
                            hRect = hRect;
                            release || notImplemented('public flash.display.BitmapData::histogram');
                            return;
                        };
                        BitmapData.prototype.encode = function (rect, compressor, byteArray) {
                            if (byteArray === void 0) {
                                byteArray = null;
                            }
                            rect = rect;
                            compressor = compressor;
                            byteArray = byteArray;
                            release || notImplemented('public flash.display.BitmapData::encode');
                            return;
                        };
                        /**
                         * Ensures that we have the most up-to-date version of the bitmap data. If a call to
                         * |BitmpaData.draw| was made since the last time this method was called, then we need to send
                         * a synchronous message to the GFX remote requesting the latest image data.
                         *
                         * Here we also normalize the image format to |ImageType.StraightAlphaRGBA|. We only need the
                         * normalized pixel data for pixel operations, so we defer image decoding as late as possible.
                         */
                        BitmapData.prototype._ensureBitmapData = function () {
                            if (this._isRemoteDirty) {
                                var data = this.sec.player.requestBitmapData(this);
                                this._setData(data.getBytes(), Shumway.ImageType.StraightAlphaRGBA);
                                this._isRemoteDirty = false;
                                this._isDirty = false;
                                this._solidFillColorPBGRA = null;
                            }
                            release || assert(!(this._type === Shumway.ImageType.JPEG || this._type === Shumway.ImageType.PNG || this._type === Shumway.ImageType.GIF));
                            if (this._type !== Shumway.ImageType.PremultipliedAlphaARGB) {
                                Shumway.ColorUtilities.convertImage(this._type, Shumway.ImageType.PremultipliedAlphaARGB, this._view, this._view);
                                this._type = Shumway.ImageType.PremultipliedAlphaARGB;
                                this._solidFillColorPBGRA = null;
                            }
                            release || assert(this._data);
                            release || assert(this._dataBuffer);
                            release || assert(this._view);
                        };
                        BitmapData.MAXIMUM_WIDTH = 8191;
                        BitmapData.MAXIMUM_HEIGHT = 8191;
                        BitmapData.MAXIMUM_DIMENSION = 16777215;
                        return BitmapData;
                    }(AS.ASObject);
                    display.BitmapData = BitmapData;
                    var BitmapSymbol = function (_super) {
                        __extends(BitmapSymbol, _super);
                        function BitmapSymbol(data, sec) {
                            _super.call(this, data, sec.flash.display.BitmapData.axClass, false);
                            this.ready = false;
                        }
                        BitmapSymbol.FromData = function (data, loaderInfo) {
                            var symbol = new BitmapSymbol(data, loaderInfo.sec);
                            // For non-decoded images, we don't yet have dimensions.
                            symbol.width = data.width || -1;
                            symbol.height = data.height || -1;
                            symbol.syncId = loaderInfo.sec.flash.display.DisplayObject.axClass.getNextSyncID();
                            symbol.data = data.data;
                            switch (data.mimeType) {
                            case 'application/octet-stream':
                                symbol.type = data.dataType;
                                symbol.ready = true;
                                break;
                            case 'image/jpeg':
                                symbol.type = Shumway.ImageType.JPEG;
                                break;
                            case 'image/png':
                                symbol.type = Shumway.ImageType.PNG;
                                break;
                            case 'image/gif':
                                symbol.type = Shumway.ImageType.GIF;
                                break;
                            default:
                                notImplemented(data.mimeType);
                            }
                            return symbol;
                        };
                        BitmapSymbol.prototype.getSharedInstance = function () {
                            return this.sharedInstance || this.createSharedInstance();
                        };
                        BitmapSymbol.prototype.createSharedInstance = function () {
                            release || assert(this.ready);
                            return this.sharedInstance = AS.constructClassFromSymbol(this, this.symbolClass);
                        };
                        Object.defineProperty(BitmapSymbol.prototype, 'resolveAssetCallback', {
                            get: function () {
                                return this._unboundResolveAssetCallback.bind(this);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        BitmapSymbol.prototype._unboundResolveAssetCallback = function (data) {
                            release || assert(!this.ready);
                            this.ready = true;
                            if (!data) {
                                release || Shumway.Debug.error('Error while decoding image');
                                return;
                            }
                            release || assert(data.width);
                            release || assert(data.height);
                            this.width = data.width;
                            this.height = data.height;
                        };
                        return BitmapSymbol;
                    }(Shumway.Timeline.DisplaySymbol);
                    display.BitmapSymbol = BitmapSymbol;
                    var BitmapDataChannel = function (_super) {
                        __extends(BitmapDataChannel, _super);
                        function BitmapDataChannel() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        BitmapDataChannel.classInitializer = null;
                        // List of static symbols to link.
                        BitmapDataChannel.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        BitmapDataChannel.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        BitmapDataChannel.RED = 1;
                        BitmapDataChannel.GREEN = 2;
                        BitmapDataChannel.BLUE = 4;
                        BitmapDataChannel.ALPHA = 8;
                        return BitmapDataChannel;
                    }(AS.ASObject);
                    display.BitmapDataChannel = BitmapDataChannel;
                    var BitmapEncodingColorSpace = function (_super) {
                        __extends(BitmapEncodingColorSpace, _super);
                        function BitmapEncodingColorSpace() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        BitmapEncodingColorSpace.classInitializer = null;
                        // List of static symbols to link.
                        BitmapEncodingColorSpace.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        BitmapEncodingColorSpace.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        BitmapEncodingColorSpace.COLORSPACE_AUTO = 'auto';
                        BitmapEncodingColorSpace.COLORSPACE_4_4_4 = '4:4:4';
                        BitmapEncodingColorSpace.COLORSPACE_4_2_2 = '4:2:2';
                        BitmapEncodingColorSpace.COLORSPACE_4_2_0 = '4:2:0';
                        return BitmapEncodingColorSpace;
                    }(AS.ASObject);
                    display.BitmapEncodingColorSpace = BitmapEncodingColorSpace;
                    var JPEGEncoderOptions = function (_super) {
                        __extends(JPEGEncoderOptions, _super);
                        function JPEGEncoderOptions(quality) {
                            if (quality === void 0) {
                                quality = 80;
                            }
                            _super.call(this);
                            this.quality = quality >>> 0;
                        }
                        // Called whenever the class is initialized.
                        JPEGEncoderOptions.classInitializer = null;
                        // List of static symbols to link.
                        JPEGEncoderOptions.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        JPEGEncoderOptions.instanceSymbols = null;
                        // ["quality"];
                        return JPEGEncoderOptions;
                    }(AS.ASObject);
                    display.JPEGEncoderOptions = JPEGEncoderOptions;
                }(display = flash.display || (flash.display = {})));
                var display;
                (function (display_1) {
                    var assert = Shumway.Debug.assert;
                    var assertUnreachable = Shumway.Debug.assertUnreachable;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var events = flash.events;
                    var FileLoader = Shumway.FileLoader;
                    var SWFFile = Shumway.SWF.SWFFile;
                    var enterTimeline = Shumway.AVMX.enterTimeline;
                    var leaveTimeline = Shumway.AVMX.leaveTimeline;
                    var LoadStatus;
                    (function (LoadStatus) {
                        LoadStatus[LoadStatus['Unloaded'] = 0] = 'Unloaded';
                        LoadStatus[LoadStatus['Opened'] = 1] = 'Opened';
                        LoadStatus[LoadStatus['Initialized'] = 2] = 'Initialized';
                        LoadStatus[LoadStatus['Complete'] = 3] = 'Complete';
                    }(LoadStatus || (LoadStatus = {})));
                    var LoadingType;
                    (function (LoadingType) {
                        LoadingType[LoadingType['External'] = 0] = 'External';
                        LoadingType[LoadingType['Bytes'] = 1] = 'Bytes';
                    }(LoadingType || (LoadingType = {})));
                    var Loader = function (_super) {
                        __extends(Loader, _super);
                        function Loader() {
                            _super.call(this);
                            var displayObjectClass = this.sec.flash.display.DisplayObject.axClass;
                            displayObjectClass._advancableInstances.push(this);
                            this._content = null;
                            if (this.axClass._rootLoader) {
                                // Loader reserves the next instance ID to use for the loaded content.
                                // This isn't needed for the first, root, loader, because that uses "root1" as the name.
                                this._contentID = displayObjectClass._instanceID++;
                            } else {
                                // The root loader gets a default name, but it's not visible and hence
                                // the instance id must not be used up.
                                displayObjectClass._instanceID--;
                            }
                            var loaderInfoCtor = this.sec.flash.display.LoaderInfo;
                            this._contentLoaderInfo = new loaderInfoCtor(loaderInfoCtor.axClass.CtorToken);
                            this._contentLoaderInfo._loader = this;
                            var currentAbc = AVMX.getCurrentABC();
                            if (currentAbc) {
                                this._contentLoaderInfo._loaderUrl = currentAbc.env.url;
                            }
                            this._fileLoader = null;
                            this._loadStatus = LoadStatus.Unloaded;
                        }
                        /**
                         * Creates or returns the root Loader instance. The loader property of that instance's
                         * LoaderInfo object is always null. Also, no OPEN event ever gets dispatched.
                         */
                        Loader.getRootLoader = function () {
                            if (this._rootLoader) {
                                return this._rootLoader;
                            }
                            var loader = new this.sec.flash.display.Loader();
                            // The root loaderInfo's `loader` property is always null.
                            loader._contentLoaderInfo._loader = null;
                            this._rootLoader = loader;
                            return loader;
                        };
                        Loader.reset = function () {
                            this.sec.flash.display.Loader.axClass._loadQueue.forEach(function (loader) {
                                return loader.unload();
                            });
                            Loader.classInitializer();
                        };
                        Loader.classInitializer = function () {
                            this._rootLoader = null;
                            this._loadQueue = [];
                            this.runtimeStartTime = 0;
                            this._embeddedContentLoadCount = 0;
                        };
                        /**
                         * In each turn of the event loop, Loader events are processed in two batches:
                         * first INIT and COMPLETE events are dispatched for all active Loaders, then
                         * OPEN and PROGRESS.
                         *
                         * A slightly weird result of this is that INIT and COMPLETE are dispatched at
                         * least one turn later than the other events: INIT is dispatched after the
                         * content has been created. That, in turn, happens under
                         * `DisplayObject.performFrameNavigation` in reaction to enough data being
                         * marked as available - which happens in the second batch of Loader event
                         * processing.
                         */
                        Loader.processEvents = function () {
                            var loaderClass = this.sec.flash.display.Loader.axClass;
                            loaderClass.processEarlyEvents();
                            loaderClass.processLateEvents();
                        };
                        Loader.processEarlyEvents = function () {
                            var loaderClass = this.sec.flash.display.Loader.axClass;
                            var queue = loaderClass._loadQueue;
                            for (var i = 0; i < queue.length; i++) {
                                var instance = queue[i];
                                release || assert(instance._loadStatus !== LoadStatus.Complete);
                                var loaderInfo = instance._contentLoaderInfo;
                                var imageSymbol = instance._imageSymbol;
                                // For images, only dispatch INIT and COMPLETE once the image has been decoded.
                                if (loaderInfo._file instanceof Shumway.ImageFile) {
                                    if (!imageSymbol || !imageSymbol.ready || instance._queuedLoadUpdate) {
                                        continue;
                                    }
                                    release || assert(loaderInfo.bytesLoaded === loaderInfo.bytesTotal);
                                    instance._applyDecodedImage(imageSymbol);
                                    release || assert(instance._content);
                                }
                                if (instance._loadStatus === LoadStatus.Opened && instance._content) {
                                    enterTimeline('Loader.INIT');
                                    try {
                                        loaderInfo.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.INIT));
                                    } catch (e) {
                                        Shumway.Debug.warning('caught error under loaderInfo INIT event:', e);
                                    }
                                    leaveTimeline();
                                    instance._loadStatus = LoadStatus.Initialized;
                                    // Only for the root loader, progress events for the data loaded up until now are
                                    // dispatched here.
                                    if (instance === this.sec.flash.display.Loader.axClass._rootLoader) {
                                        enterTimeline('Loader.Progress', 'rootLoader');
                                        try {
                                            loaderInfo.dispatchEvent(new this.sec.flash.events.ProgressEvent(events.ProgressEvent.PROGRESS, false, false, loaderInfo.bytesLoaded, loaderInfo.bytesTotal));
                                        } catch (e) {
                                            Shumway.Debug.warning('caught error under loaderInfo PROGRESS event:', e);
                                        }
                                        leaveTimeline();
                                    }
                                }
                                if (instance._loadStatus === LoadStatus.Initialized && loaderInfo.bytesLoaded === loaderInfo.bytesTotal) {
                                    queue.splice(i--, 1);
                                    release || assert(queue.indexOf(instance) === -1);
                                    instance._loadStatus = LoadStatus.Complete;
                                    enterTimeline('Loader.Complete');
                                    try {
                                        loaderInfo.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.COMPLETE));
                                    } catch (e) {
                                        Shumway.Debug.warning('caught error under loaderInfo COMPLETE event: ', e);
                                    }
                                    leaveTimeline();
                                }
                            }
                        };
                        Loader.processLateEvents = function () {
                            var queue = this.sec.flash.display.Loader.axClass._loadQueue;
                            for (var i = 0; i < queue.length; i++) {
                                var instance = queue[i];
                                release || assert(instance._loadStatus !== LoadStatus.Complete);
                                var loaderInfo = instance._contentLoaderInfo;
                                var update = instance._queuedLoadUpdate;
                                var bytesTotal = loaderInfo._bytesTotal;
                                if ((!update || !bytesTotal) && instance._loadStatus !== LoadStatus.Opened) {
                                    continue;
                                }
                                instance._queuedLoadUpdate = null;
                                var progressEventCtor = this.sec.flash.events.ProgressEvent;
                                if (instance._loadStatus === LoadStatus.Unloaded) {
                                    // OPEN is only dispatched when loading external resources, not for loadBytes.
                                    if (instance._loadingType === LoadingType.External) {
                                        enterTimeline('Loader.Open');
                                        try {
                                            loaderInfo.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.OPEN));
                                        } catch (e) {
                                            Shumway.Debug.warning('caught error under loaderInfo OPEN event: ', e);
                                        }
                                        leaveTimeline();
                                    }
                                    // The first time any progress is made at all, a progress event with bytesLoaded = 0
                                    // is dispatched.
                                    enterTimeline('Loader.Progress');
                                    try {
                                        loaderInfo.dispatchEvent(new progressEventCtor(events.ProgressEvent.PROGRESS, false, false, 0, bytesTotal));
                                    } catch (e) {
                                        Shumway.Debug.warning('caught error under loaderInfo PROGRESS event: ', e);
                                    }
                                    leaveTimeline();
                                    instance._loadStatus = LoadStatus.Opened;
                                }
                                // TODO: The Flash player reports progress in 16kb chunks, in a tight loop right here.
                                if (update) {
                                    instance._applyLoadUpdate(update);
                                    enterTimeline('Loader.Progress');
                                    try {
                                        loaderInfo.dispatchEvent(new progressEventCtor(events.ProgressEvent.PROGRESS, false, false, update.bytesLoaded, bytesTotal));
                                    } catch (e) {
                                        Shumway.Debug.warning('caught error under loaderInfo PROGRESS event: ', e);
                                    }
                                    leaveTimeline();
                                }
                            }
                        };
                        Loader.prototype._setStage = function (stage) {
                            release || assert(this === this.sec.flash.display.Loader.axClass.getRootLoader());
                            this._stage = stage;
                        };
                        Loader.prototype._initFrame = function (advance) {
                        };
                        Loader.prototype._constructFrame = function () {
                            if (this === this.sec.flash.display.Loader.axClass.getRootLoader() && this._content) {
                                this.sec.flash.display.DisplayObject.axClass._advancableInstances.remove(this);
                                this._children[0] = this._content;
                                this._constructChildren();
                                this._children.length = 0;
                                return;
                            }
                            this._constructChildren();
                        };
                        Loader.prototype.addChild = function (child) {
                            this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidLoaderMethodError);
                            return null;
                        };
                        Loader.prototype.addChildAt = function (child, index) {
                            this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidLoaderMethodError);
                            return null;
                        };
                        Loader.prototype.removeChild = function (child) {
                            this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidLoaderMethodError);
                            return null;
                        };
                        Loader.prototype.removeChildAt = function (index) {
                            this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidLoaderMethodError);
                            return null;
                        };
                        Loader.prototype.setChildIndex = function (child, index) {
                            this.sec.throwError('IllegalOperationError', AVMX.Errors.InvalidLoaderMethodError);
                        };
                        /**
                         * No way of knowing what's in |data|, so do a best effort to print out some meaninfgul debug
                         * info.
                         */
                        Loader.prototype._describeData = function (data) {
                            var keyValueParis = [];
                            for (var k in data) {
                                keyValueParis.push(k + ':' + Shumway.StringUtilities.toSafeString(data[k]));
                            }
                            return '{' + keyValueParis.join(', ') + '}';
                        };
                        Object.defineProperty(Loader.prototype, 'content', {
                            get: function () {
                                if (this._loadStatus === LoadStatus.Unloaded) {
                                    return null;
                                }
                                return this._content;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Loader.prototype, 'contentLoaderInfo', {
                            get: function () {
                                return this._contentLoaderInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Loader.prototype._getJPEGLoaderContextdeblockingfilter = function (context) {
                            if (this.sec.flash.system.JPEGLoaderContext.axClass.axIsType(context)) {
                                return context.deblockingFilter;
                            }
                            return 0;
                        };
                        Object.defineProperty(Loader.prototype, 'uncaughtErrorEvents', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.Loader::uncaughtErrorEvents');
                                if (!this._uncaughtErrorEvents) {
                                    this._uncaughtErrorEvents = new events.UncaughtErrorEvents();
                                }
                                return this._uncaughtErrorEvents;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Loader.prototype._canLoadSWFFromDomain = function (url) {
                            url = Shumway.FileLoadingService.instance.resolveUrl(url);
                            var whitelist = this.sec.player;
                            return whitelist.checkDomainForSWFLoading(url);
                        };
                        Loader.prototype.load = function (request, context) {
                            this.close();
                            // TODO: clean up contentloaderInfo.
                            var resolvedURL = Shumway.FileLoadingService.instance.resolveUrl(request.url);
                            this._contentLoaderInfo._url = resolvedURL;
                            this._applyLoaderContext(context);
                            this._loadingType = LoadingType.External;
                            var fileLoader = this._fileLoader = new FileLoader(this, this._contentLoaderInfo);
                            if (!release && AS.traceLoaderOption.value) {
                                console.log('Loading url ' + request.url);
                            }
                            fileLoader.loadFile(request._toFileRequest());
                            this._queuedLoadUpdate = null;
                            var loaderClass = this.sec.flash.display.Loader.axClass;
                            release || assert(loaderClass._loadQueue.indexOf(this) === -1);
                            loaderClass._loadQueue.push(this);
                        };
                        Loader.prototype.loadBytes = function (data, context) {
                            this.close();
                            // TODO: properly coerce object arguments to their types.
                            var loaderClass = this.sec.flash.display.Loader.axClass;
                            // In case this is the initial root loader, we won't have a loaderInfo object. That should
                            // only happen in the inspector when a file is loaded from a Blob, though.
                            this._contentLoaderInfo._url = (this.loaderInfo ? this.loaderInfo._url : '') + '/[[DYNAMIC]]/' + ++loaderClass._embeddedContentLoadCount;
                            this._applyLoaderContext(context);
                            this._loadingType = LoadingType.Bytes;
                            this._fileLoader = new FileLoader(this, this._contentLoaderInfo);
                            this._queuedLoadUpdate = null;
                            if (!release && AS.traceLoaderOption.value) {
                                console.log('Loading embedded symbol ' + this._contentLoaderInfo._url);
                            }
                            // Just passing in the bytes won't do, because the buffer can contain slop at the end.
                            this._fileLoader.loadBytes(new Uint8Array(data.bytes, 0, data.length));
                            release || assert(loaderClass._loadQueue.indexOf(this) === -1);
                            loaderClass._loadQueue.push(this);
                        };
                        Loader.prototype.close = function () {
                            var queueIndex = this.sec.flash.display.Loader.axClass._loadQueue.indexOf(this);
                            if (queueIndex > -1) {
                                this.sec.flash.display.Loader.axClass._loadQueue.splice(queueIndex, 1);
                            }
                            this._contentLoaderInfo.reset();
                            if (!this._fileLoader) {
                                return;
                            }
                            this._fileLoader.abortLoad();
                            this._fileLoader = null;
                        };
                        Loader.prototype._unload = function (stopExecution, gc) {
                            if (this._loadStatus < LoadStatus.Initialized) {
                                this._loadStatus = LoadStatus.Unloaded;
                                return;
                            }
                            this.close();
                            this._content = null;
                            this._contentLoaderInfo._loader = null;
                            this._loadStatus = LoadStatus.Unloaded;
                            this.dispatchEvent(this.sec.flash.events.Event.axClass.getInstance(events.Event.UNLOAD));
                        };
                        Loader.prototype.unload = function () {
                            this._unload(false, false);
                        };
                        Loader.prototype.unloadAndStop = function (gc) {
                            // TODO: remove all DisplayObjects originating from the unloaded SWF from all lists and stop
                            // them.
                            this._unload(true, !!gc);
                        };
                        Loader.prototype._applyLoaderContext = function (context) {
                            var parameters = context && context.parameters ? AS.transformASValueToJS(this.sec, context.parameters, false) : {};
                            if (context && context.applicationDomain) {
                                this._contentLoaderInfo._applicationDomain = context.applicationDomain;
                            } else if (this._loaderInfo && this._loaderInfo._applicationDomain) {
                                this._contentLoaderInfo._applicationDomain = this._loaderInfo._applicationDomain;
                            } else {
                                this._contentLoaderInfo._applicationDomain = new this.sec.flash.system.ApplicationDomain();
                            }
                            this._contentLoaderInfo._parameters = parameters;
                            this._contentLoaderInfo._allowCodeImport = context ? context.allowCodeImport : true;
                            this._contentLoaderInfo._checkPolicyFile = context ? context.checkPolicyFile : false;
                            this._contentLoaderInfo._avm1Context = context ? context._avm1Context : null;
                        };
                        Loader.prototype.onLoadOpen = function (file) {
                            if (!file) {
                                this._contentLoaderInfo.dispatchEvent(new this.sec.flash.events.IOErrorEvent(events.IOErrorEvent.IO_ERROR, false, false, AVMX.Errors.UnknownFileTypeError.message, AVMX.Errors.UnknownFileTypeError.code));
                                return;
                            }
                            // For child SWF files, only continue loading and interpreting the loaded data if the
                            // either
                            // - it is loaded from the same origin as the parent, or
                            // - the parent has called `system.Security.allowDomain` with the loadees origin whitelisted
                            // This is a mitigation against the loadee breaking our SecurityDomain sandbox and
                            // reaching into the parent's SecurityDomain, reading data it's not supposed to have
                            // access to.
                            //
                            // We perform this check only once loading has started for two reasons: one is that only
                            // at that point do we know that we're loading a SWF instead of an image (or some invalid
                            // file, in which case none of this matters). The other is that the parent might call
                            // `allowDomain` only after the load has started, in which case we still want to allow the
                            // operation to continue.
                            //
                            // Additionally, all the normal cross-domain checks apply as per usual.
                            if (file._file instanceof SWFFile) {
                                var whitelistResult = this._canLoadSWFFromDomain(this._fileLoader._url);
                                var resultType;
                                switch (whitelistResult) {
                                case 0    /* OwnDomain */:
                                    resultType = 0    /* LoadSource */;
                                    break;
                                case 1    /* Remote */:
                                    resultType = 1    /* LoadWhitelistAllowed */;
                                    break;
                                case 2    /* Failed */:
                                    resultType = 2    /* LoadWhitelistDenied */;
                                    break;
                                default:
                                    assertUnreachable('Invalid whitelistResult');
                                }
                                Shumway.Telemetry.instance.reportTelemetry({
                                    topic: 'loadResource',
                                    resultType: resultType
                                });
                                if (whitelistResult === 2    /* Failed */) {
                                    console.error('Loading of SWF file from ' + this._fileLoader._url + ' was rejected based on allowDomain heuristic.');
                                    this._fileLoader.abortLoad();
                                    var message = 'Security sandbox violation: SWF ' + this._loaderInfo._url + ' cannot load SWF ' + this._fileLoader._url + '. This may be worked' + ' around by calling Security.allowDomain.';
                                    try {
                                        this._contentLoaderInfo.dispatchEvent(new this.sec.flash.events.IOErrorEvent(events.SecurityErrorEvent.SECURITY_ERROR, false, false, message, AVMX.Errors.SecuritySwfNotAllowedError.code));
                                    } catch (_) {
                                    }
                                    return;
                                }
                                if (!this._contentLoaderInfo._allowCodeImport) {
                                    this._fileLoader.abortLoad();
                                    try {
                                        this._contentLoaderInfo.dispatchEvent(new this.sec.flash.events.IOErrorEvent(events.SecurityErrorEvent.SECURITY_ERROR, false, false, AVMX.Errors.AllowCodeImportError.message, AVMX.Errors.AllowCodeImportError.code));
                                    } catch (_) {
                                    }
                                    return;
                                }
                            }
                            this._contentLoaderInfo.setFile(file);
                        };
                        Loader.prototype.onLoadProgress = function (update) {
                            release || assert(update);
                            this._queuedLoadUpdate = update;
                        };
                        Loader.prototype.onNewEagerlyParsedSymbols = function (dictionaryEntries, delta) {
                            var promises = [];
                            for (var i = dictionaryEntries.length - delta; i < dictionaryEntries.length; i++) {
                                var dictionaryEntry = dictionaryEntries[i];
                                var symbol = this._contentLoaderInfo.getSymbolById(dictionaryEntry.id);
                                // JPEGs with alpha channel are parsed with our JS parser for now. They're ready
                                // immediately, so don't need any more work here. We'll change them to using the system
                                // parser, but for now, just skip further processing here.
                                if (symbol.ready) {
                                    continue;
                                }
                                release || assert(symbol.resolveAssetPromise);
                                release || assert(symbol.ready === false);
                                promises.push(symbol.resolveAssetPromise.promise);
                            }
                            return Promise.all(promises);
                        };
                        Loader.prototype.onImageBytesLoaded = function () {
                            var file = this._contentLoaderInfo._file;
                            release || assert(file instanceof Shumway.ImageFile);
                            var data = {
                                id: -1,
                                data: file.data,
                                mimeType: file.mimeType,
                                dataType: file.type,
                                type: 'image'
                            };
                            var symbol = display_1.BitmapSymbol.FromData(data, this._contentLoaderInfo);
                            this._imageSymbol = symbol;
                            this.sec.player.registerImage(symbol, file.type, file.data, null);
                            release || assert(symbol.resolveAssetPromise);
                        };
                        Loader.prototype._applyDecodedImage = function (symbol) {
                            var bitmapData = symbol.createSharedInstance();
                            this._content = new this.sec.flash.display.Bitmap(bitmapData);
                            this._contentLoaderInfo._width = this._content.width * 20;
                            this._contentLoaderInfo._height = this._content.height * 20;
                            this.addTimelineObjectAtDepth(this._content, 0);
                        };
                        Loader.prototype._applyLoadUpdate = function (update) {
                            var loaderInfo = this._contentLoaderInfo;
                            loaderInfo._bytesLoaded = update.bytesLoaded;
                            var file = loaderInfo._file;
                            if (!(file instanceof SWFFile)) {
                                return;
                            }
                            if (file.framesLoaded === 0) {
                                return;
                            }
                            if (loaderInfo._allowCodeExecution) {
                                var app = loaderInfo.app;
                                var abcBlocksLoaded = file.abcBlocks.length;
                                var abcBlocksLoadedDelta = abcBlocksLoaded - loaderInfo._abcBlocksLoaded;
                                if (abcBlocksLoadedDelta > 0) {
                                    for (var i = loaderInfo._abcBlocksLoaded; i < abcBlocksLoaded; i++) {
                                        var abcBlock = file.abcBlocks[i];
                                        var abc = new AVMX.ABCFile(loaderInfo, abcBlock.data);
                                        if (abcBlock.flags) {
                                            // kDoAbcLazyInitializeFlag = 1 Indicates that the ABC block should not be executed
                                            // immediately.
                                            app.loadABC(abc);
                                        } else {
                                            // TODO: probably delay execution until playhead reaches the frame.
                                            app.loadAndExecuteABC(abc);
                                        }
                                    }
                                    loaderInfo._abcBlocksLoaded = abcBlocksLoaded;
                                }
                                var mappedSymbolsLoaded = file.symbolClassesList.length;
                                var mappedSymbolsLoadedDelta = mappedSymbolsLoaded - loaderInfo._mappedSymbolsLoaded;
                                if (mappedSymbolsLoadedDelta > 0) {
                                    for (var i = loaderInfo._mappedSymbolsLoaded; i < mappedSymbolsLoaded; i++) {
                                        var symbolMapping = file.symbolClassesList[i];
                                        var symbolClass = app.getClass(AVMX.Multiname.FromFQNString(symbolMapping.className, 0    /* Public */));
                                        Object.defineProperty(symbolClass.tPrototype, '_symbol', {
                                            get: loaderInfo.getSymbolResolver(symbolClass, symbolMapping.id),
                                            configurable: true
                                        });
                                    }
                                    loaderInfo._mappedSymbolsLoaded = mappedSymbolsLoaded;
                                }
                            }
                            // In browsers that can't synchronously decode fonts, we have already registered all
                            // embedded fonts at this point.
                            if (inFirefox) {
                                var fontsLoaded = file.fonts.length;
                                var fontsLoadedDelta = fontsLoaded - loaderInfo._fontsLoaded;
                                if (fontsLoadedDelta > 0) {
                                    for (var i = loaderInfo._fontsLoaded; i < fontsLoaded; i++) {
                                        this.sec.flash.text.Font.axClass.registerFontSymbol(file.fonts[i], loaderInfo);
                                    }
                                    loaderInfo._fontsLoaded = fontsLoaded;
                                }
                            }
                            var rootSymbol = loaderInfo.getRootSymbol();
                            var framesLoadedDelta = file.framesLoaded - rootSymbol.frames.length;
                            if (framesLoadedDelta === 0) {
                                return;
                            }
                            var root = this._content;
                            if (!root) {
                                root = this.createContentRoot(rootSymbol, file.sceneAndFrameLabelData);
                            }
                            var rootSprite = root;
                            for (var i = 0; i < framesLoadedDelta; i++) {
                                var frameInfo = loaderInfo.getFrame(null, rootSymbol.frames.length);
                                rootSprite._addFrame(frameInfo);
                            }
                        };
                        Loader.prototype.onLoadComplete = function () {
                        };
                        Loader.prototype.onLoadError = function () {
                            release || Shumway.Debug.warning('Not implemented: flash.display.Loader loading-error handling');
                        };
                        Loader.prototype._addScenesToMovieClip = function (mc, sceneData, numFrames) {
                            // Creating scenes so we will always have frames assigned to some scene.
                            if (!sceneData) {
                                mc.addScene('Scene 1', [], 0, numFrames);
                                return;
                            }
                            // Sorting scenes by offset
                            var sceneInfos = [];
                            var scenes = sceneData.scenes;
                            for (var i = 0; i < scenes.length; i++) {
                                sceneInfos.push({
                                    offset: scenes[i].offset,
                                    name: scenes[i].name
                                });
                            }
                            sceneInfos.sort(function (a, b) {
                                return a.offset - b.offset;
                            });
                            var n = sceneInfos.length;
                            var offset, endFrame;
                            if (n > 0 && sceneInfos[0].offset > 0) {
                                // Starting from non-zero frame, we need to create a fake scene.
                                offset = sceneInfos[0].offset;
                                endFrame = Math.min(offset, numFrames);
                                mc.addScene('Scene 0', [], 0, endFrame);
                            }
                            for (var i = 0, n = sceneInfos.length; i < n; i++) {
                                var sceneInfo = sceneInfos[i];
                                offset = sceneInfo.offset;
                                if (offset >= numFrames) {
                                    break;    // out of the movie clip timeline range
                                }
                                endFrame = i < n - 1 ? Math.min(scenes[i + 1].offset, numFrames) : numFrames;
                                mc.addScene(sceneInfo.name, [], offset, endFrame - offset);
                            }
                            var labels = sceneData.labels;
                            for (var i = 0; i < labels.length; i++) {
                                var labelInfo = labels[i];
                                mc.addFrameLabel(labelInfo.name, labelInfo.frame + 1);
                            }
                        };
                        Loader.prototype.createContentRoot = function (symbol, sceneData) {
                            var isAS2LoadedFromAS3 = false;
                            if (symbol.isAVM1Object && !this._contentLoaderInfo._avm1Context) {
                                // For outermost AVM1 SWF we need to create AVM1Context.
                                isAS2LoadedFromAS3 = true;
                                this._createAVM1Context();
                                // Re-sync the AVM1Context for the symbol.
                                symbol.avm1Context = this._contentLoaderInfo._avm1Context;
                            }
                            var root = AS.constructClassFromSymbol(symbol, symbol.symbolClass);
                            // The initial SWF's root object gets a default of 'root1', which doesn't use up a
                            // DisplayObject instance ID. For the others, we have reserved one in `_contentID`.
                            this.sec.flash.display.DisplayObject.axClass._instanceID--;
                            var loaderClass = this.sec.flash.display.Loader.axClass;
                            if (this === loaderClass._rootLoader) {
                                root._name = 'root1';
                            } else {
                                root._name = 'instance' + this._contentID;
                            }
                            if (this.sec.flash.display.MovieClip.axClass.axIsType(root)) {
                                this._addScenesToMovieClip(root, sceneData, symbol.numFrames);
                            }
                            var loaderInfo = this._contentLoaderInfo;
                            root._loaderInfo = loaderInfo;
                            var rootTimeline = root;
                            var isTopLevelMovie = this === loaderClass.getRootLoader();
                            if (isAS2LoadedFromAS3) {
                                root = this._createAVM1Movie(root);
                            } else if (isTopLevelMovie) {
                                var movieClipClass = this.sec.flash.display.MovieClip.axClass;
                                movieClipClass.frameNavigationModel = loaderInfo.swfVersion < 10 ? 9    /* SWF9 */ : 10    /* SWF10 */;
                                root._perspectiveProjectionCenterX = this._stage.stageWidth / 2;
                                root._perspectiveProjectionCenterY = this._stage.stageHeight / 2;
                                root._setFlags(262144    /* HasPerspectiveProjection */);
                            }
                            this._content = root;
                            if (isTopLevelMovie) {
                                this.sec.flash.display.Loader.runtimeStartTime = Date.now();
                                this._stage.setRoot(root);
                            } else {
                                this.addTimelineObjectAtDepth(root, 0);
                            }
                            // Always return the non-wrapped MovieClip instead of AVM1Movie for AVM1 SWFs.
                            return rootTimeline;
                        };
                        Loader.prototype._createAVM1Context = function () {
                            var contentLoaderInfo = this._contentLoaderInfo;
                            var avm1Context = Shumway.AVM1.AVM1Context.create(contentLoaderInfo);
                            var display = this.sec.flash.display;
                            var rootLoader = display.Loader.axClass.getRootLoader();
                            avm1Context.setStage(rootLoader._stage);
                            // FIXME make frameNavigationModel non-global
                            if (this === rootLoader) {
                                display.MovieClip.axClass.frameNavigationModel = 1    /* SWF1 */;
                            }
                            contentLoaderInfo._avm1Context = avm1Context;
                        };
                        /**
                         * Create an AVM1Movie container and wrap the root timeline into it.
                         * This associates the AVM1Context with this AVM1 MovieClip tree,
                         * including potential nested SWFs.
                         */
                        Loader.prototype._createAVM1Movie = function (root) {
                            var contentLoaderInfo = this._contentLoaderInfo;
                            release || Shumway.Debug.assert(contentLoaderInfo);
                            var avm1Context = this._contentLoaderInfo._avm1Context;
                            var avm1MovieClip = Shumway.AVM1.Lib.getAVM1Object(root, avm1Context);
                            var parameters = contentLoaderInfo._parameters;
                            avm1MovieClip.setParameters(parameters);
                            var avm1Movie = new this.sec.flash.display.AVM1Movie(root);
                            release || Shumway.Debug.assert(!avm1Context.levelsContainer, 'One levels container per context');
                            avm1Context.levelsContainer = avm1Movie;
                            return avm1Movie;
                        };
                        Loader.classSymbols = null;
                        Loader.instanceSymbols = null;
                        return Loader;
                    }(flash.display.DisplayObjectContainer);
                    display_1.Loader = Loader;
                }(display = flash.display || (flash.display = {})));
                var display;
                (function (display) {
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var SWFFile = Shumway.SWF.SWFFile;
                    var LoaderInfo = function (_super) {
                        __extends(LoaderInfo, _super);
                        function LoaderInfo(token) {
                            if (token !== LoaderInfo.CtorToken) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.CantInstantiateError, 'LoaderInfo$');
                            }
                            _super.call(this);
                            this._loader = null;
                            this._loaderUrl = '';
                            this.reset();
                        }
                        LoaderInfo.prototype.reset = function () {
                            this._url = '';
                            this._file = null;
                            this._bytesLoaded = 0;
                            this._bytesTotal = 0;
                            this._applicationDomain = null;
                            this._parameters = null;
                            this._allowCodeImport = true;
                            this._checkPolicyFile = false;
                            this._width = 0;
                            this._height = 0;
                            this._sharedEvents = null;
                            this._parentSandboxBridge = null;
                            this._childSandboxBridge = null;
                            this._content = null;
                            this._bytes = null;
                            this._uncaughtErrorEvents = null;
                            this._allowCodeExecution = true;
                            this._dictionary = [];
                            this._abcBlocksLoaded = 0;
                            this._mappedSymbolsLoaded = 0;
                            this._fontsLoaded = 0;
                            this._avm1Context = null;
                        };
                        LoaderInfo.prototype.setFile = function (file) {
                            release || assert(!this._file);
                            this._file = file;
                            this._bytesTotal = file.bytesTotal;
                            if (file instanceof SWFFile) {
                                // TODO: remove these duplicated fields from LoaderInfo.
                                var bbox = file.bounds;
                                this._width = bbox.xMax - bbox.xMin;
                                this._height = bbox.yMax - bbox.yMin;
                            } else {
                                release || assert(file instanceof Shumway.ImageFile);
                            }
                        };
                        LoaderInfo.getLoaderInfoByDefinition = function (object) {
                            object = object;
                            release || notImplemented('public flash.display.LoaderInfo::static getLoaderInfoByDefinition');
                            return;
                        };
                        Object.defineProperty(LoaderInfo.prototype, 'loaderURL', {
                            get: function () {
                                if (!this._loader) {
                                    // For the instance of the main class of the SWF file, this URL is the
                                    // same as the SWF file's own URL.
                                    // The loaderURL value can be changed by player settings.
                                    var service = this.sec.player;
                                    return this._url === service.swfUrl && service.loaderUrl || this._url;
                                }
                                return this._loaderUrl;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'url', {
                            get: function () {
                                if (!this._file) {
                                    return null;
                                }
                                return this._url;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'isURLInaccessible', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.LoaderInfo::get isURLInaccessible');
                                return this._file ? false : true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'bytesLoaded', {
                            get: function () {
                                return this._bytesLoaded;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'bytesTotal', {
                            get: function () {
                                return this._bytesTotal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'applicationDomain', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.LoaderInfo::get applicationDomain');
                                return this._file ? this._applicationDomain : null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'app', {
                            get: function () {
                                return this._applicationDomain.axDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'swfVersion', {
                            get: function () {
                                if (!this._file) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotInitializedError);
                                }
                                if (!(this._file instanceof SWFFile)) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotSWFError);
                                }
                                return this._file.swfVersion;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'actionScriptVersion', {
                            get: function () {
                                if (!this._file) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotInitializedError);
                                }
                                if (!(this._file instanceof SWFFile)) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotSWFError);
                                }
                                return this._file.useAVM1 ? display.ActionScriptVersion.ACTIONSCRIPT2 : display.ActionScriptVersion.ACTIONSCRIPT3;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'frameRate', {
                            get: function () {
                                if (!this._file) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotInitializedError);
                                }
                                if (!(this._file instanceof SWFFile)) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotSWFError);
                                }
                                return this._file.frameRate;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'width', {
                            get: function () {
                                if (!this._file) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotInitializedError);
                                }
                                return this._width / 20 | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'height', {
                            get: function () {
                                if (!this._file) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotInitializedError);
                                }
                                return this._height / 20 | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'contentType', {
                            get: function () {
                                if (!this._file) {
                                    return null;
                                }
                                return this._file instanceof Shumway.ImageFile ? this._file.mimeType : 'application/x-shockwave-flash';
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'sharedEvents', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.LoaderInfo::get sharedEvents');
                                if (!this._sharedEvents) {
                                    this._sharedEvents = new this.sec.flash.events.EventDispatcher();
                                }
                                return this._sharedEvents;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'parentSandboxBridge', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.LoaderInfo::get parentSandboxBridge');
                                return this._parentSandboxBridge;
                            },
                            set: function (door) {
                                release || somewhatImplemented('public flash.display.LoaderInfo::set parentSandboxBridge');
                                this._parentSandboxBridge = door;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'childSandboxBridge', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.LoaderInfo::get childSandboxBridge');
                                return this._childSandboxBridge;
                            },
                            set: function (door) {
                                release || somewhatImplemented('public flash.display.LoaderInfo::set childSandboxBridge');
                                this._childSandboxBridge = door;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'sameDomain', {
                            get: function () {
                                if (!this._file) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotInitializedError);
                                }
                                release || somewhatImplemented('public flash.display.LoaderInfo::get sameDomain');
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'childAllowsParent', {
                            get: function () {
                                if (!this._file) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotInitializedError);
                                }
                                release || somewhatImplemented('public flash.display.LoaderInfo::get childAllowsParent');
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'parentAllowsChild', {
                            get: function () {
                                if (!this._file) {
                                    this.sec.throwError('Error', AVMX.Errors.LoadingObjectNotInitializedError);
                                }
                                release || somewhatImplemented('public flash.display.LoaderInfo::get parentAllowsChild');
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'loader', {
                            get: function () {
                                return this._loader;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'content', {
                            get: function () {
                                return this._loader && this._loader.content;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'bytes', {
                            get: function () {
                                if (!this._file) {
                                    return new this.sec.flash.utils.ByteArray();
                                }
                                release || notImplemented('public flash.display.LoaderInfo::get bytes');
                                return null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'parameters', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.LoaderInfo::get parameters');
                                if (this._parameters) {
                                    return AS.transformJSValueToAS(this.sec, this._parameters, false);
                                }
                                return {};
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderInfo.prototype, 'uncaughtErrorEvents', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.LoaderInfo::_getUncaughtErrorEvents');
                                if (!this._uncaughtErrorEvents) {
                                    this._uncaughtErrorEvents = new this.sec.flash.events.UncaughtErrorEvents();
                                }
                                return this._uncaughtErrorEvents;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // TODO: activate this override while keeping the ability to dispatch events from TS.
                        //dispatchEvent(event: events.Event): boolean {
                        //  // TODO: this should be `IllegalOperationError`, but we don't include that class.
                        //  this.sec.throwError('Error', Errors.InvalidLoaderInfoMethodError);
                        //  return false;
                        //}
                        LoaderInfo.prototype.getSymbolResolver = function (classDefinition, symbolId) {
                            return this.resolveClassSymbol.bind(this, classDefinition, symbolId);
                        };
                        LoaderInfo.prototype.getSymbolById = function (id) {
                            var symbol = this._dictionary[id];
                            if (symbol) {
                                if (symbol.ready === false) {
                                    // We cannot assert this, as content might invalidly access symbols that aren't available
                                    // yet.
                                    release || Shumway.Debug.warning('Accessing symbol that\'s not yet ready.');
                                    return null;
                                }
                                return symbol;
                            }
                            release || assert(this._file instanceof SWFFile);
                            var data = this._file.getSymbol(id);
                            if (!data) {
                                if (id !== 65535) {
                                    // Id 65535 is somehow used invalidly in lots of embedded shapes created by the authoring
                                    // tool.
                                    Shumway.Debug.warning('Unknown symbol requested: ' + id);
                                }
                                // It's entirely valid not to have symbols defined, but might be a sign of us doing
                                // something wrong in parsing.
                                return null;
                            }
                            // TODO: replace this switch with a table lookup.
                            switch (data.type) {
                            case 'shape':
                                symbol = flash.display.ShapeSymbol.FromData(data, this);
                                break;
                            case 'morphshape':
                                symbol = flash.display.MorphShapeSymbol.FromData(data, this);
                                break;
                            case 'image':
                                if (data.definition) {
                                    data = data.definition;
                                }
                                symbol = flash.display.BitmapSymbol.FromData(data, this);
                                if (symbol.ready === false) {
                                    this.sec.player.registerImage(symbol, data.dataType, data.data, data.alphaData);
                                }
                                break;
                            case 'label':
                                symbol = flash.text.TextSymbol.FromLabelData(data, this);
                                break;
                            case 'text':
                                symbol = flash.text.TextSymbol.FromTextData(data, this);
                                this._syncAVM1Attributes(symbol);
                                break;
                            case 'button':
                                symbol = flash.display.ButtonSymbol.FromData(data, this);
                                this._syncAVM1Attributes(symbol);
                                break;
                            case 'sprite':
                                symbol = flash.display.SpriteSymbol.FromData(data, this);
                                break;
                            case 'font':
                                // Fonts are eagerly parsed and have their data in `definition`.
                                if (data.definition) {
                                    data = data.definition;
                                }
                                symbol = flash.text.FontSymbol.FromData(data, this);
                                var font = AS.constructClassFromSymbol(symbol, symbol.symbolClass);
                                if (symbol.ready === false) {
                                    this.sec.player.registerFont(symbol, data.data);
                                }
                                break;
                            case 'sound':
                                symbol = flash.media.SoundSymbol.FromData(data, this);
                                break;
                            case 'video':
                                symbol = flash.media.VideoSymbol.FromData(data, this);
                                break;
                            case 'binary':
                                symbol = Shumway.Timeline.BinarySymbol.FromData(data, this);
                                break;
                            }
                            release || assert(symbol, 'Unknown symbol type ' + data.type);
                            this._dictionary[id] = symbol;
                            return symbol;
                        };
                        LoaderInfo.prototype.getRootSymbol = function () {
                            release || assert(this._file instanceof SWFFile);
                            release || assert(this._file.framesLoaded > 0);
                            var symbol = this._dictionary[0];
                            if (!symbol) {
                                var data = {
                                    id: 0,
                                    className: this._file.symbolClassesMap[0],
                                    env: this
                                };
                                symbol = new flash.display.SpriteSymbol(data, this);
                                symbol.isRoot = true;
                                symbol.numFrames = this._file.frameCount;
                                this._syncAVM1Attributes(symbol);
                                this._dictionary[0] = symbol;
                            }
                            return symbol;
                        };
                        LoaderInfo.prototype._syncAVM1Attributes = function (symbol) {
                            if (this.actionScriptVersion === display.ActionScriptVersion.ACTIONSCRIPT2) {
                                symbol.isAVM1Object = true;
                                symbol.avm1Context = this._avm1Context;
                            }
                        };
                        // TODO: Frames should be parsed lazily when they're first needed, and this removed.
                        // https://bugzilla.mozilla.org/show_bug.cgi?id=1114656
                        LoaderInfo.prototype.getFrame = function (sprite, index) {
                            var file = this._file;
                            release || assert(file instanceof SWFFile);
                            if (!sprite) {
                                sprite = file;
                            }
                            return sprite.frames[index];
                        };
                        // TODO: To prevent leaking LoaderInfo instances, those instances should be stored weakly,
                        // with support for retrieving the instances based on a numeric id, which would be passed here.
                        LoaderInfo.prototype.resolveClassSymbol = function (classDefinition, symbolId) {
                            var symbol = this.getSymbolById(symbolId);
                            if (!symbol) {
                                Shumway.Debug.warning('Attempt to resolve symbol for AVM2 class failed: Symbol ' + symbolId + ' not found.');
                            } else {
                                Object.defineProperty(classDefinition.tPrototype, '_symbol', { value: symbol });
                                return symbol;
                            }
                        };
                        LoaderInfo.classInitializer = null;
                        // Constructing LoaderInfo without providing this token throws, preventing it from AS3.
                        LoaderInfo.CtorToken = {};
                        return LoaderInfo;
                    }(flash.events.EventDispatcher);
                    display.LoaderInfo = LoaderInfo;
                    var assert = Shumway.Debug.assert;
                    var MorphShape = function (_super) {
                        __extends(MorphShape, _super);
                        function MorphShape() {
                            if (this._symbol && !this._fieldsInitialized) {
                                this.applySymbol();
                            }
                            _super.call(this);
                            release || assert(!this._symbol);
                        }
                        MorphShape.prototype.applySymbol = function () {
                            this._initializeFields();
                            release || assert(this._symbol);
                            this._setStaticContentFromSymbol(this._symbol);
                            // TODO: Check what do do if the computed bounds of the graphics object don't
                            // match those given by the symbol.
                            this._setFlags(32768    /* ContainsMorph */);
                        };
                        MorphShape.prototype._canHaveGraphics = function () {
                            return true;
                        };
                        MorphShape.prototype._getGraphics = function () {
                            return this._graphics;
                        };
                        Object.defineProperty(MorphShape.prototype, 'graphics', {
                            get: function () {
                                return this._ensureGraphics();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        MorphShape.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                            var graphics = this._getGraphics();
                            return graphics && graphics._containsPoint(localX, localY, true, this._ratio / 65535);
                        };
                        MorphShape.classSymbols = null;
                        // [];
                        MorphShape.instanceSymbols = null;
                        // [];
                        MorphShape.classInitializer = null;
                        return MorphShape;
                    }(flash.display.DisplayObject);
                    display.MorphShape = MorphShape;
                    var MorphShapeSymbol = function (_super) {
                        __extends(MorphShapeSymbol, _super);
                        function MorphShapeSymbol(data, sec) {
                            _super.call(this, data, sec.flash.display.MorphShape.axClass);
                        }
                        MorphShapeSymbol.FromData = function (data, loaderInfo) {
                            var symbol = new MorphShapeSymbol(data, loaderInfo.sec);
                            symbol._setBoundsFromData(data);
                            symbol.graphics = flash.display.Graphics.FromData(data, loaderInfo);
                            symbol.processRequires(data.require, loaderInfo);
                            symbol.morphFillBounds = data.morphFillBounds;
                            symbol.morphLineBounds = data.morphLineBounds;
                            return symbol;
                        };
                        return MorphShapeSymbol;
                    }(flash.display.ShapeSymbol);
                    display.MorphShapeSymbol = MorphShapeSymbol;
                    var NativeMenu = function (_super) {
                        __extends(NativeMenu, _super);
                        function NativeMenu() {
                            _super.call(this);
                        }
                        NativeMenu.classInitializer = null;
                        NativeMenu.classSymbols = null;
                        // [];
                        NativeMenu.instanceSymbols = null;
                        // [];
                        return NativeMenu;
                    }(flash.events.EventDispatcher);
                    display.NativeMenu = NativeMenu;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var NativeMenuItem = function (_super) {
                        __extends(NativeMenuItem, _super);
                        function NativeMenuItem() {
                            _super.call(this);
                            this._enabled = true;
                        }
                        Object.defineProperty(NativeMenuItem.prototype, 'enabled', {
                            get: function () {
                                release || somewhatImplemented('public flash.display.NativeMenuItem::get enabled');
                                return this._enabled;
                            },
                            set: function (isSeparator) {
                                isSeparator = !!isSeparator;
                                release || somewhatImplemented('public flash.display.NativeMenuItem::set enabled');
                                this._enabled = isSeparator;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // Called whenever the class is initialized.
                        NativeMenuItem.classInitializer = null;
                        // List of static symbols to link.
                        NativeMenuItem.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        NativeMenuItem.instanceSymbols = null;
                        // [];
                        return NativeMenuItem;
                    }(flash.events.EventDispatcher);
                    display.NativeMenuItem = NativeMenuItem;
                    var PNGEncoderOptions = function (_super) {
                        __extends(PNGEncoderOptions, _super);
                        function PNGEncoderOptions(fastCompression) {
                            if (fastCompression === void 0) {
                                fastCompression = false;
                            }
                            _super.call(this);
                            this.fastCompression = !!fastCompression;
                        }
                        // Called whenever the class is initialized.
                        PNGEncoderOptions.classInitializer = null;
                        // List of static symbols to link.
                        PNGEncoderOptions.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        PNGEncoderOptions.instanceSymbols = null;
                        // ["fastCompression"];
                        return PNGEncoderOptions;
                    }(AS.ASObject);
                    display.PNGEncoderOptions = PNGEncoderOptions;
                    var PixelSnapping = function (_super) {
                        __extends(PixelSnapping, _super);
                        function PixelSnapping() {
                            _super.call(this);
                        }
                        PixelSnapping.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return PixelSnapping.NEVER;
                            case 1:
                                return PixelSnapping.ALWAYS;
                            case 2:
                                return PixelSnapping.AUTO;
                            default:
                                return null;
                            }
                        };
                        PixelSnapping.toNumber = function (value) {
                            switch (value) {
                            case PixelSnapping.NEVER:
                                return 0;
                            case PixelSnapping.ALWAYS:
                                return 1;
                            case PixelSnapping.AUTO:
                                return 2;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        PixelSnapping.classInitializer = null;
                        // List of static symbols to link.
                        PixelSnapping.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        PixelSnapping.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        PixelSnapping.NEVER = 'never';
                        PixelSnapping.ALWAYS = 'always';
                        PixelSnapping.AUTO = 'auto';
                        return PixelSnapping;
                    }(AS.ASObject);
                    display.PixelSnapping = PixelSnapping;
                    var SWFVersion = function (_super) {
                        __extends(SWFVersion, _super);
                        function SWFVersion() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        SWFVersion.classInitializer = null;
                        // List of static symbols to link.
                        SWFVersion.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        SWFVersion.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        SWFVersion.FLASH1 = 1;
                        SWFVersion.FLASH2 = 2;
                        SWFVersion.FLASH3 = 3;
                        SWFVersion.FLASH4 = 4;
                        SWFVersion.FLASH5 = 5;
                        SWFVersion.FLASH6 = 6;
                        SWFVersion.FLASH7 = 7;
                        SWFVersion.FLASH8 = 8;
                        SWFVersion.FLASH9 = 9;
                        SWFVersion.FLASH10 = 10;
                        SWFVersion.FLASH11 = 11;
                        SWFVersion.FLASH12 = 12;
                        return SWFVersion;
                    }(AS.ASObject);
                    display.SWFVersion = SWFVersion;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var Scene = function (_super) {
                        __extends(Scene, _super);
                        function Scene(name, labels, offset, numFrames) {
                            _super.call(this);
                            this._name = axCoerceString(name);
                            // Note: creating Scene objects in ActionScript, while possible, is undocumented and entirely
                            // useless. Luckily, that also means that they're not very carefully implemented.
                            // Specifically, the `labels` array isn't cloned during construction or when returned from
                            // the getter. I.e., it can be modified freely.
                            this._labels = labels;
                            this.offset = offset;
                            this._numFrames = numFrames | 0;
                        }
                        Object.defineProperty(Scene.prototype, 'name', {
                            get: function () {
                                return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Scene.prototype, 'labels', {
                            get: function () {
                                return this._labels;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Scene.prototype, 'numFrames', {
                            get: function () {
                                return this._numFrames;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Scene.prototype.clone = function () {
                            var labels_ = this._labels.value.map(function (label) {
                                return label.clone();
                            });
                            return new this.sec.flash.display.Scene(this._name, this.sec.createArrayUnsafe(labels_), this.offset, this._numFrames);
                        };
                        Scene.prototype.getLabelByName = function (name, ignoreCase) {
                            if (ignoreCase) {
                                name = name.toLowerCase();
                            }
                            var labels = this._labels.value;
                            for (var i = 0; i < labels.length; i++) {
                                var label = labels[i];
                                if (ignoreCase ? label.name.toLowerCase() === name : label.name === name) {
                                    return label;
                                }
                            }
                            return null;
                        };
                        Scene.prototype.getLabelByFrame = function (frame) {
                            var labels = this._labels.value;
                            for (var i = 0; i < labels.length; i++) {
                                var label = labels[i];
                                if (label.frame === frame) {
                                    return label;
                                }
                            }
                            return null;
                        };
                        Scene.classInitializer = null;
                        Scene.classSymbols = null;
                        // [];
                        Scene.instanceSymbols = null;
                        return Scene;
                    }(AS.ASObject);
                    display.Scene = Scene;
                    var StageAlign = function (_super) {
                        __extends(StageAlign, _super);
                        function StageAlign() {
                            _super.call(this);
                        }
                        StageAlign.fromNumber = function (n) {
                            if (n === 0) {
                                return '';
                            }
                            var s = '';
                            if (n & 1    /* Top */) {
                                s += 'T';
                            }
                            if (n & 2    /* Bottom */) {
                                s += 'B';
                            }
                            if (n & 4    /* Left */) {
                                s += 'L';
                            }
                            if (n & 8    /* Right */) {
                                s += 'R';
                            }
                            return s;
                        };
                        /**
                         * Looks like the Flash player just searches for the "T", "B", "L", "R" characters and
                         * maintains an internal bit field for alignment, for instance it's possible to set the
                         * alignment value "TBLR" even though there is no enum for it.
                         */
                        StageAlign.toNumber = function (value) {
                            var n = 0;
                            value = value.toUpperCase();
                            if (value.indexOf('T') >= 0) {
                                n |= 1    /* Top */;
                            }
                            if (value.indexOf('B') >= 0) {
                                n |= 2    /* Bottom */;
                            }
                            if (value.indexOf('L') >= 0) {
                                n |= 4    /* Left */;
                            }
                            if (value.indexOf('R') >= 0) {
                                n |= 8    /* Right */;
                            }
                            return n;
                        };
                        StageAlign.classInitializer = null;
                        StageAlign.classSymbols = null;
                        // [];
                        StageAlign.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        StageAlign.TOP = 'T';
                        StageAlign.LEFT = 'L';
                        StageAlign.BOTTOM = 'B';
                        StageAlign.RIGHT = 'R';
                        StageAlign.TOP_LEFT = 'TL';
                        StageAlign.TOP_RIGHT = 'TR';
                        StageAlign.BOTTOM_LEFT = 'BL';
                        StageAlign.BOTTOM_RIGHT = 'BR';
                        return StageAlign;
                    }(AS.ASObject);
                    display.StageAlign = StageAlign;
                    var StageDisplayState = function (_super) {
                        __extends(StageDisplayState, _super);
                        function StageDisplayState() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        StageDisplayState.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return StageDisplayState.FULL_SCREEN;
                            case 1:
                                return StageDisplayState.FULL_SCREEN_INTERACTIVE;
                            case 2:
                                return StageDisplayState.NORMAL;
                            default:
                                return null;
                            }
                        };
                        StageDisplayState.toNumber = function (value) {
                            switch (value) {
                            case StageDisplayState.FULL_SCREEN:
                                return 0;
                            case StageDisplayState.FULL_SCREEN_INTERACTIVE:
                                return 1;
                            case StageDisplayState.NORMAL:
                                return 2;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        StageDisplayState.classInitializer = null;
                        // List of static symbols to link.
                        StageDisplayState.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        StageDisplayState.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        StageDisplayState.FULL_SCREEN = 'fullScreen';
                        StageDisplayState.FULL_SCREEN_INTERACTIVE = 'fullScreenInteractive';
                        StageDisplayState.NORMAL = 'normal';
                        return StageDisplayState;
                    }(AS.ASObject);
                    display.StageDisplayState = StageDisplayState;
                    var StageQuality = function (_super) {
                        __extends(StageQuality, _super);
                        function StageQuality() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        StageQuality.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return StageQuality.LOW;
                            case 1:
                                return StageQuality.MEDIUM;
                            case 2:
                                return StageQuality.HIGH;
                            case 3:
                                return StageQuality.BEST;
                            case 4:
                                return StageQuality.HIGH_8X8;
                            case 5:
                                return StageQuality.HIGH_8X8_LINEAR;
                            case 6:
                                return StageQuality.HIGH_16X16;
                            case 7:
                                return StageQuality.HIGH_16X16_LINEAR;
                            default:
                                return null;
                            }
                        };
                        StageQuality.toNumber = function (value) {
                            switch (value) {
                            case StageQuality.LOW:
                                return 0;
                            case StageQuality.MEDIUM:
                                return 1;
                            case StageQuality.HIGH:
                                return 2;
                            case StageQuality.BEST:
                                return 3;
                            case StageQuality.HIGH_8X8:
                                return 4;
                            case StageQuality.HIGH_8X8_LINEAR:
                                return 5;
                            case StageQuality.HIGH_16X16:
                                return 6;
                            case StageQuality.HIGH_16X16_LINEAR:
                                return 7;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        StageQuality.classInitializer = null;
                        // List of static symbols to link.
                        StageQuality.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        StageQuality.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        StageQuality.LOW = 'low';
                        StageQuality.MEDIUM = 'medium';
                        StageQuality.HIGH = 'high';
                        StageQuality.BEST = 'best';
                        StageQuality.HIGH_8X8 = '8x8';
                        StageQuality.HIGH_8X8_LINEAR = '8x8linear';
                        StageQuality.HIGH_16X16 = '16x16';
                        StageQuality.HIGH_16X16_LINEAR = '16x16linear';
                        return StageQuality;
                    }(AS.ASObject);
                    display.StageQuality = StageQuality;
                    var StageScaleMode = function (_super) {
                        __extends(StageScaleMode, _super);
                        function StageScaleMode() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        StageScaleMode.fromNumber = function (n) {
                            switch (n) {
                            case 0    /* ShowAll */:
                                return StageScaleMode.SHOW_ALL;
                            case 1    /* ExactFit */:
                                return StageScaleMode.EXACT_FIT;
                            case 2    /* NoBorder */:
                                return StageScaleMode.NO_BORDER;
                            case 4    /* NoScale */:
                                return StageScaleMode.NO_SCALE;
                            default:
                                return null;
                            }
                        };
                        StageScaleMode.toNumber = function (value) {
                            switch (value.toLowerCase()) {
                            case StageScaleMode.SHOW_ALL_LOWERCASE:
                                return 0    /* ShowAll */;
                            case StageScaleMode.EXACT_FIT_LOWERCASE:
                                return 1    /* ExactFit */;
                            case StageScaleMode.NO_BORDER_LOWERCASE:
                                return 2    /* NoBorder */;
                            case StageScaleMode.NO_SCALE_LOWERCASE:
                                return 4    /* NoScale */;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        StageScaleMode.classInitializer = null;
                        // List of static symbols to link.
                        StageScaleMode.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        StageScaleMode.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        StageScaleMode.SHOW_ALL = 'showAll';
                        StageScaleMode.EXACT_FIT = 'exactFit';
                        StageScaleMode.NO_BORDER = 'noBorder';
                        StageScaleMode.NO_SCALE = 'noScale';
                        StageScaleMode.SHOW_ALL_LOWERCASE = 'showall';
                        StageScaleMode.EXACT_FIT_LOWERCASE = 'exactfit';
                        StageScaleMode.NO_BORDER_LOWERCASE = 'noborder';
                        StageScaleMode.NO_SCALE_LOWERCASE = 'noscale';
                        return StageScaleMode;
                    }(AS.ASObject);
                    display.StageScaleMode = StageScaleMode;
                    var TriangleCulling = function (_super) {
                        __extends(TriangleCulling, _super);
                        function TriangleCulling() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        TriangleCulling.classInitializer = null;
                        // List of static symbols to link.
                        TriangleCulling.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        TriangleCulling.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        TriangleCulling.NONE = 'none';
                        TriangleCulling.POSITIVE = 'positive';
                        TriangleCulling.NEGATIVE = 'negative';
                        return TriangleCulling;
                    }(AS.ASObject);
                    display.TriangleCulling = TriangleCulling;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var AVM1Movie = function (_super) {
                        __extends(AVM1Movie, _super);
                        function AVM1Movie(level0) {
                            _super.call(this);
                            this._content = this.sec.flash.display.Sprite.axClass.axConstruct();
                            this._children = [];
                            this._children[0] = this._content;
                            // Pretend we're a DisplayObjectContainer and can have children. See comment at the top.
                            this._content._setParent(this, 0);
                            this._setDirtyFlags(2    /* DirtyChildren */);
                            this._invalidateFillAndLineBounds(true, true);
                            this.sec.flash.display.DisplayObject.axClass._advancableInstances.push(this);
                            this._constructed = false;
                            // Setting _level0 root.
                            this._content.addTimelineObjectAtDepth(level0, 0);
                        }
                        AVM1Movie.prototype.call = function (functionName) {
                            notImplemented('AVM1Movie#call');
                        };
                        AVM1Movie.prototype.addCallback = function (functionName, closure) {
                            notImplemented('AVM1Movie#call');
                        };
                        AVM1Movie.prototype._addFrame = function (frame) {
                            this._content._children[0]._addFrame(frame);
                        };
                        AVM1Movie.prototype._initFrame = function (advance) {
                        };
                        AVM1Movie.prototype._constructFrame = function () {
                            // On custructFrame we need to fully construct the roots container.
                            // Once constructed, its children (which are IAdvancable type) will be
                            // receiving their own _constructFrame events.
                            if (!this._constructed) {
                                this._constructed = true;
                                this._content._constructChildren();
                            }
                        };
                        AVM1Movie.prototype._enqueueFrameScripts = function () {
                            this._removeFlags(16384    /* ContainsFrameScriptPendingChildren */);
                            this._content._enqueueFrameScripts();
                        };
                        AVM1Movie.prototype._propagateFlagsDown = function (flags) {
                            if (this._hasFlags(flags)) {
                                return;
                            }
                            this._setFlags(flags);
                            this._content._propagateFlagsDown(flags);
                        };
                        /**
                         * AVM1Movie only takes the AVM1 content into consideration when testing points against
                         * bounding boxes, not otherwise.
                         */
                        AVM1Movie.prototype._containsPoint = function (globalX, globalY, localX, localY, testingType, objects) {
                            if (testingType === 3    /* Mouse */) {
                                return this._content._containsPoint(globalX, globalY, localX, localY, testingType, objects);
                            }
                            if (testingType !== 0    /* HitTestBounds */ || !this._getContentBounds().contains(localX, localY)) {
                                return 0    /* None */;
                            }
                            return 1    /* Bounds */;
                        };
                        /**
                         * Override of DisplayObject#_getChildBounds that retrieves the AVM1 content's bounds.
                         */
                        AVM1Movie.prototype._getChildBounds = function (bounds, includeStrokes) {
                            var childBounds = this._content._getContentBounds(includeStrokes).clone();
                            // Always apply the SimpleButton's matrix.
                            this._getConcatenatedMatrix().transformBounds(childBounds);
                            bounds.unionInPlace(childBounds);
                        };
                        AVM1Movie.prototype._getLevelForRoot = function (root) {
                            release || Shumway.Debug.assert(root.parent === this._content);
                            return root._depth;
                        };
                        AVM1Movie.prototype._getRootForLevel = function (level) {
                            return this._content.getTimelineObjectAtDepth(level);
                        };
                        AVM1Movie.prototype._addRoot = function (level, root) {
                            release || Shumway.Debug.assert(this.sec.flash.display.MovieClip.axClass.axIsType(root));
                            this._removeRoot(level);
                            release || Shumway.Debug.assert(!this._content.getTimelineObjectAtDepth(level));
                            this._content.addTimelineObjectAtDepth(root, level);
                        };
                        AVM1Movie.prototype._removeRoot = function (level) {
                            var root = this._content.getTimelineObjectAtDepth(level);
                            if (!root) {
                                return false;
                            }
                            this._content.removeChild(root);
                            return true;
                        };
                        AVM1Movie.classInitializer = null;
                        AVM1Movie.classSymbols = null;
                        AVM1Movie.instanceSymbols = null;
                        return AVM1Movie;
                    }(flash.display.DisplayObject);
                    display.AVM1Movie = AVM1Movie;
                }(display = flash.display || (flash.display = {})));
                var errors;
                (function (errors) {
                    var IllegalOperationError = function (_super) {
                        __extends(IllegalOperationError, _super);
                        function IllegalOperationError(message, id) {
                            if (message === void 0) {
                                message = '';
                            }
                            if (id === void 0) {
                                id = 0;
                            }
                            _super.call(this, message, id);
                        }
                        // Called whenever the class is initialized.
                        IllegalOperationError.classInitializer = null;
                        // List of static symbols to link.
                        IllegalOperationError.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        IllegalOperationError.instanceSymbols = null;
                        // [];
                        return IllegalOperationError;
                    }(AS.ASError);
                    errors.IllegalOperationError = IllegalOperationError;
                }(errors = flash.errors || (flash.errors = {})));
                var external;
                (function (external) {
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var Telemetry = Shumway.Telemetry;
                    var ExternalInterfaceService = Shumway.ExternalInterfaceService;
                    var ExternalInterface = function (_super) {
                        __extends(ExternalInterface, _super);
                        function ExternalInterface() {
                            _super.call(this);
                        }
                        ExternalInterface.ensureInitialized = function () {
                            if (!this.available) {
                                this.sec.throwError('Error', AVMX.Errors.ExternalInterfaceNotAvailableError);
                            }
                            if (this.initialized) {
                                return;
                            }
                            Telemetry.instance.reportTelemetry({
                                topic: 'feature',
                                feature: 1    /* EXTERNAL_INTERFACE_FEATURE */
                            });
                            this.initialized = true;
                            ExternalInterfaceService.instance.initJS(this._callIn);
                        };
                        ExternalInterface.call = function (functionName) {
                            this.ensureInitialized();
                            var argsExpr = '';
                            if (arguments.length > 1) {
                                var args = [];
                                for (var i = 1; i < arguments.length; i++) {
                                    args.push(this.convertToJSString(arguments[i]));
                                }
                                argsExpr = args.join(',');
                            }
                            var catchExpr = this.$BgmarshallExceptions ? '"<exception>" + e + "</exception>";' : '"<undefined/>";';
                            var evalExpr = 'try {' + '__flash__toXML(' + functionName + '(' + argsExpr + '));' + '} catch (e) {' + catchExpr + '}';
                            var result = this._evalJS(evalExpr);
                            if (result == null) {
                                return null;
                            }
                            return this.convertFromXML(this.convertToXML(result));
                        };
                        ExternalInterface.addCallback = function (functionName, closure) {
                            this.ensureInitialized();
                            if (!closure) {
                                this._removeCallback(functionName);
                                return;
                            }
                            var self = this;
                            this._addCallback(functionName, function (request, args) {
                                var returnAsJS = true;
                                if (args) {
                                    var wrappedArgs = [];
                                    for (var i = 0; i < args.length; i++) {
                                        var arg = args[i];
                                        // Objects have to be converted into proper AS objects in the current security domain.
                                        if (typeof arg === 'object' && arg) {
                                            wrappedArgs.push(self.sec.createObjectFromJS(arg, true));
                                        } else {
                                            wrappedArgs.push(arg);
                                        }
                                    }
                                    args = wrappedArgs;
                                } else {
                                    var xml = this.convertToXML(request);
                                    var returnTypeAttr = xml.attribute('returntype');
                                    returnAsJS = returnTypeAttr && returnTypeAttr._value == 'javascript';
                                    args = [];
                                    for (var i = 0; i < xml._children.length; i++) {
                                        var x = xml._children[i];
                                        args.push(this.convertFromXML(x));
                                    }
                                }
                                var result;
                                try {
                                    result = closure.axApply(null, args);
                                } catch (e) {
                                    if (this.$BgmarshallExceptions) {
                                        result = e;
                                    } else {
                                        throw e;
                                    }
                                }
                                return returnAsJS ? self.convertToJSString(result) : self.convertToXMLString(result);
                            });
                        };
                        Object.defineProperty(ExternalInterface, 'available', {
                            get: function () {
                                return ExternalInterfaceService.instance.enabled;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ExternalInterface, 'objectID', {
                            get: function () {
                                return ExternalInterfaceService.instance.getId();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ExternalInterface._addCallback = function (functionName, closure) {
                            ExternalInterfaceService.instance.registerCallback(functionName);
                            ExternalInterface.registeredCallbacks[functionName] = closure;
                        };
                        ExternalInterface._removeCallback = function (functionName) {
                            ExternalInterfaceService.instance.unregisterCallback(functionName);
                            delete ExternalInterface.registeredCallbacks[functionName];
                        };
                        ExternalInterface._evalJS = function (expression) {
                            expression = axCoerceString(expression);
                            return ExternalInterfaceService.instance.eval(expression);
                        };
                        ExternalInterface._callIn = function (functionName, args) {
                            var callback = ExternalInterface.registeredCallbacks[functionName];
                            if (!callback) {
                                return;
                            }
                            return callback(functionName, args);
                        };
                        ExternalInterface._callOut = function (request) {
                            request = axCoerceString(request);
                            return ExternalInterfaceService.instance.call(request);
                        };
                        ExternalInterface.convertToXML = function (s) {
                            var xmlClass = this.sec.system.getClass(AVMX.Multiname.FromSimpleName('XML'));
                            var savedIgnoreWhitespace = xmlClass.ignoreWhitespace;
                            xmlClass.ignoreWhitespace = false;
                            var xml = xmlClass.Create(s);
                            xmlClass.ignoreWhitespace = savedIgnoreWhitespace;
                            return xml;
                        };
                        ExternalInterface.convertToXMLString = function (obj) {
                            switch (typeof obj) {
                            case 'boolean':
                                return obj ? '<true/>' : '<false/>';
                            case 'number':
                                return '<number>' + obj + '</number>';
                            case 'string':
                                return '<string>' + obj.split('&').join('&amp;').split('<').join('&lt;').split('>').join('&gt;') + '</string>';
                            case 'object':
                                if (obj === null) {
                                    return '<null/>';
                                }
                                if (this.sec.AXDate.axIsInstanceOf(obj)) {
                                    return '<date>' + obj.time + '</date>';
                                }
                                if (this.sec.AXError.axIsInstanceOf(obj)) {
                                    if (this.$BgmarshallExceptions) {
                                        return '<exception>' + obj + '</exception>';
                                    } else {
                                        return '<null/>';    // not sure?
                                    }
                                }
                                var result = [];
                                // Looks like length is used to detect array. (obj is Array) is better?
                                if (obj.hasOwnProperty('$Bglength')) {
                                    var len = obj.$Bglength;
                                    for (var i = 0; i < len; i++) {
                                        var entry = this.convertToXMLString(obj.axGetNumericProperty(i));
                                        result.push('<property id="' + i + '">' + entry + '</property>');
                                    }
                                    return '<array>' + result.join('') + '</array>';
                                }
                                var keys = obj.axGetEnumerableKeys();
                                for (var i = 0; i < keys.length; i++) {
                                    var key = keys[i];
                                    var entry = this.convertToXMLString(obj.axGetPublicProperty(key));
                                    result.push('<property id="' + key + '">' + entry + '</property>');
                                }
                                return '<object>' + result.join('') + '</object>';
                            default:
                                return '<undefined/>';
                            }
                        };
                        ExternalInterface.convertFromXML = function (xml) {
                            switch (xml._name.name) {
                            case 'true':
                                return true;
                            case 'false':
                                return false;
                            case 'number':
                                return Number(String(xml.children()));
                            case 'string':
                                return String(xml.children());
                            case 'null':
                                return null;
                            case 'date':
                                return this.sec.AXDate.axConstruct([Number(String(xml.children()))]);
                            case 'exception':
                                if (this.$BgmarshallExceptions) {
                                    throw this.sec.AXError.axConstruct([String(xml.children())]);
                                }
                                return undefined;
                            case 'array':
                            case 'object':
                                var obj = xml._name.name === 'object' ? this.sec.createObject() : this.sec.createArrayUnsafe([]);
                                for (var i = 0; i < xml._children.length; i++) {
                                    var x = xml._children[i];
                                    obj.axSetPublicProperty(extractId(x), this.convertFromXML(x._children[0]));
                                }
                                return obj;
                            case 'class':
                                var className = AVMX.Multiname.FromFQNString(String(xml.children()), 0    /* Public */);
                                return this.sec.application.getClass(className);
                            default:
                                return undefined;
                            }
                        };
                        ExternalInterface.convertToJSString = function (obj) {
                            if (typeof obj == 'string') {
                                return '"' + obj.split('\r').join('\\r').split('\n').join('\\n').split('"').join('\\"') + '"';
                            }
                            if (this.sec.AXArray.axIsInstanceOf(obj)) {
                                var parts = [];
                                var arr = obj.value;
                                for (var i = 0; i < arr.length; i++) {
                                    parts.push(this.convertToJSString(arr[i]));
                                }
                                return '[' + parts.join(',') + ']';
                            }
                            if (this.sec.AXDate.axIsInstanceOf(obj)) {
                                return 'new Date(' + obj.value + ')';
                            }
                            if (this.$BgmarshallExceptions && this.sec.AXError.axIsInstanceOf(obj)) {
                                return 'throw "' + obj + '"';
                            }
                            if (typeof obj === 'object' && obj !== null) {
                                var parts = [];
                                var keys = obj.axGetEnumerableKeys();
                                for (var i = 0; i < keys.length; i++) {
                                    var key = keys[i];
                                    parts.push(key + ':' + this.convertToJSString(obj.axGetPublicProperty(key)));
                                }
                                return '({' + parts.join(',') + '})';
                            }
                            return String(obj);
                        };
                        ExternalInterface.classInitializer = null;
                        ExternalInterface.initialized = false;
                        ExternalInterface.registeredCallbacks = Object.create(null);
                        return ExternalInterface;
                    }(AS.ASObject);
                    external.ExternalInterface = ExternalInterface;
                    function extractId(node) {
                        for (var i = 0; i < node._attributes.length; i++) {
                            var attribute = node._attributes[i];
                            if (attribute._name.name === 'id') {
                                return attribute._value;
                            }
                        }    // TODO: throw if no `id` attribute was found.
                    }
                }(external = flash.external || (flash.external = {})));
                var filters;
                (function (filters) {
                    var BitmapFilterQuality = function (_super) {
                        __extends(BitmapFilterQuality, _super);
                        function BitmapFilterQuality() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        BitmapFilterQuality.classInitializer = null;
                        // List of static symbols to link.
                        BitmapFilterQuality.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        BitmapFilterQuality.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        BitmapFilterQuality.LOW = 1;
                        BitmapFilterQuality.MEDIUM = 2;
                        BitmapFilterQuality.HIGH = 3;
                        return BitmapFilterQuality;
                    }(AS.ASObject);
                    filters.BitmapFilterQuality = BitmapFilterQuality;
                    var BitmapFilterType = function (_super) {
                        __extends(BitmapFilterType, _super);
                        function BitmapFilterType() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        BitmapFilterType.classInitializer = null;
                        // List of static symbols to link.
                        BitmapFilterType.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        BitmapFilterType.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        BitmapFilterType.INNER = 'inner';
                        BitmapFilterType.OUTER = 'outer';
                        BitmapFilterType.FULL = 'full';
                        return BitmapFilterType;
                    }(AS.ASObject);
                    filters.BitmapFilterType = BitmapFilterType;
                    var BitmapFilter = function (_super) {
                        __extends(BitmapFilter, _super);
                        function BitmapFilter() {
                            _super.call(this);
                        }
                        BitmapFilter._updateBlurBounds = function (bounds, blurX, blurY, quality, isBlurFilter) {
                            if (isBlurFilter === void 0) {
                                isBlurFilter = false;
                            }
                            // Approximation of BitmapData.generateFilterRect()
                            var stepWidth = BitmapFilter.blurFilterStepWidths[quality - 1];
                            if (isBlurFilter) {
                                // BlurFilter behaves slightly different from other blur based filters:
                                // Given ascending blurX/blurY values, generateFilterRect with BlurFilter
                                // expands the source rect later than with i.e. GlowFilter. The difference
                                // appears to be stepWidth / 4 for all quality values.
                                var stepWidth4 = stepWidth / 4;
                                blurX -= stepWidth4;
                                blurY -= stepWidth4;
                            }
                            // Calculate horizontal and vertical borders:
                            // blurX/blurY values <= 1 are always rounded up to 1,
                            // which means that generateFilterRect always expands the source rect,
                            // even when blurX/blurY is 0.
                            var bh = Math.ceil((blurX < 1 ? 1 : blurX) * stepWidth);
                            var bv = Math.ceil((blurY < 1 ? 1 : blurY) * stepWidth);
                            bounds.inflate(bh, bv);
                        };
                        BitmapFilter.prototype._updateFilterBounds = function (bounds) {
                        };
                        BitmapFilter.prototype._serialize = function (message) {
                            // Overridden by subclasses
                            // -1: Filter not supported, no further serialization
                            // 0-7: Filter IDs according to SWF spec
                            message.writeInt(-1);
                        };
                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        BitmapFilter.prototype.clone = function () {
                            return null;
                        };
                        // Called whenever the class is initialized.
                        BitmapFilter.classInitializer = null;
                        BitmapFilter.EPS = 1e-9;
                        // Step widths for blur based filters, for quality values 1..15:
                        // If we plot the border width added by generateFilterRect for each
                        // blurX (or blurY) value, the step width is the amount of blurX
                        // that adds one pixel to the border width. I.e. for quality = 1,
                        // the border width increments at blurX = 2, 4, 6, ...
                        BitmapFilter.blurFilterStepWidths = [
                            0.5,
                            1.05,
                            1.35,
                            1.55,
                            1.75,
                            1.9,
                            2,
                            2.1,
                            2.2,
                            2.3,
                            2.5,
                            3,
                            3,
                            3.5,
                            3.5
                        ];
                        return BitmapFilter;
                    }(AS.ASObject);
                    filters.BitmapFilter = BitmapFilter;
                    var GradientArrays = function () {
                        function GradientArrays() {
                        }
                        // colors null or empty - all empty
                        // ratios empty - all empty
                        // ratios null and alphas null - length: colors, alphas set to 0, ratios set to 0
                        // ratios null and alphas != null - length: colors, alphas filled with 1, ratios set to 0
                        // ratios not empty and alphas null - length: min(colors,ratios), alphas set to 0
                        // ratios not empty and alphas != null - length: min(colors,ratios), alphas filled with 1
                        GradientArrays.sanitize = function (colors, alphas, ratios) {
                            if (Shumway.isNullOrUndefined(colors) || colors.length === 0) {
                                this.colors = [];
                                this.alphas = [];
                                this.ratios = [];
                            } else {
                                var len;
                                if (Shumway.isNullOrUndefined(ratios)) {
                                    this.colors = this.sanitizeColors(colors);
                                    len = this.colors.length;
                                    this.ratios = this.initArray(len);
                                    if (Shumway.isNullOrUndefined(alphas)) {
                                        this.alphas = this.initArray(len);
                                    } else {
                                        this.alphas = this.sanitizeAlphas(alphas, len, len, 1);
                                    }
                                } else {
                                    if (ratios.length === 0) {
                                        this.colors = [];
                                        this.alphas = [];
                                        this.ratios = [];
                                    } else {
                                        len = Math.min(colors.length, ratios.length, 16);
                                        this.colors = this.sanitizeColors(colors, len);
                                        this.ratios = this.sanitizeRatios(ratios, len);
                                        if (Shumway.isNullOrUndefined(alphas)) {
                                            this.alphas = this.initArray(len);
                                        } else {
                                            this.alphas = this.sanitizeAlphas(alphas, len, len, 1);
                                        }
                                    }
                                }
                            }
                        };
                        GradientArrays.sanitizeColors = function (colors, maxLen) {
                            if (maxLen === void 0) {
                                maxLen = 16;
                            }
                            var arr = [];
                            for (var i = 0, n = Math.min(colors.length, maxLen); i < n; i++) {
                                arr[i] = colors[i] >>> 0 & 16777215;
                            }
                            return arr;
                        };
                        GradientArrays.sanitizeAlphas = function (alphas, maxLen, minLen, value) {
                            if (maxLen === void 0) {
                                maxLen = 16;
                            }
                            if (minLen === void 0) {
                                minLen = 0;
                            }
                            if (value === void 0) {
                                value = 0;
                            }
                            var arr = [];
                            for (var i = 0, n = Math.min(alphas.length, maxLen); i < n; i++) {
                                arr[i] = Shumway.NumberUtilities.clamp(+alphas[i], 0, 1);
                            }
                            while (i < minLen) {
                                arr[i++] = value;
                            }
                            return arr;
                        };
                        GradientArrays.sanitizeRatios = function (ratios, maxLen, minLen, value) {
                            if (maxLen === void 0) {
                                maxLen = 16;
                            }
                            if (minLen === void 0) {
                                minLen = 0;
                            }
                            if (value === void 0) {
                                value = 0;
                            }
                            var arr = [];
                            for (var i = 0, n = Math.min(ratios.length, maxLen); i < n; i++) {
                                arr[i] = Shumway.NumberUtilities.clamp(+ratios[i], 0, 255);
                            }
                            while (i < minLen) {
                                arr[i++] = value;
                            }
                            return arr;
                        };
                        GradientArrays.initArray = function (len, value) {
                            if (value === void 0) {
                                value = 0;
                            }
                            var arr = Array(len);
                            for (var i = 0; i < len; i++) {
                                arr[i] = value;
                            }
                            return arr;
                        };
                        return GradientArrays;
                    }();
                    filters.GradientArrays = GradientArrays;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var assert = Shumway.Debug.assert;
                    var BevelFilter = function (_super) {
                        __extends(BevelFilter, _super);
                        function BevelFilter(distance, angle, highlightColor, highlightAlpha, shadowColor, shadowAlpha, blurX, blurY, strength, quality, type, knockout) {
                            if (distance === void 0) {
                                distance = 4;
                            }
                            if (angle === void 0) {
                                angle = 45;
                            }
                            if (highlightColor === void 0) {
                                highlightColor = 16777215;
                            }
                            if (highlightAlpha === void 0) {
                                highlightAlpha = 1;
                            }
                            if (shadowColor === void 0) {
                                shadowColor = 0;
                            }
                            if (shadowAlpha === void 0) {
                                shadowAlpha = 1;
                            }
                            if (blurX === void 0) {
                                blurX = 4;
                            }
                            if (blurY === void 0) {
                                blurY = 4;
                            }
                            if (strength === void 0) {
                                strength = 1;
                            }
                            if (quality === void 0) {
                                quality = 1;
                            }
                            if (type === void 0) {
                                type = 'inner';
                            }
                            if (knockout === void 0) {
                                knockout = false;
                            }
                            _super.call(this);
                            this.distance = distance;
                            this.angle = angle;
                            this.highlightColor = highlightColor;
                            this.highlightAlpha = highlightAlpha;
                            this.shadowColor = shadowColor;
                            this.shadowAlpha = shadowAlpha;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.type = type;
                            this.knockout = knockout;
                        }
                        BevelFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // Here it contains exactly two color objects (spec might state it differently):
                            //  - first maps to highlightColor and highlightAlpha;
                            //  - second maps to shadowColor and shadowAlpha;
                            release || assert(obj.colors && obj.colors.length === 2, 'colors must be Array of length 2');
                            var highlightColor = obj.colors[0] >>> 8;
                            var highlightAlpha = (obj.colors[0] & 255) / 255;
                            var shadowColor = obj.colors[1] >>> 8;
                            var shadowAlpha = (obj.colors[1] & 255) / 255;
                            // type is derived from obj.onTop and obj.innerShadow
                            // obj.onTop true: type is FULL
                            // obj.inner true: type is INNER
                            // neither true: type is OUTER
                            var type = flash.filters.BitmapFilterType.OUTER;
                            if (!!obj.onTop) {
                                type = flash.filters.BitmapFilterType.FULL;
                            } else if (!!obj.inner) {
                                type = flash.filters.BitmapFilterType.INNER;
                            }
                            // obj.angle is represented in radians, the api needs degrees
                            var angle = obj.angle * 180 / Math.PI;
                            return new this.sec.flash.filters.BevelFilter(obj.distance, angle, highlightColor, highlightAlpha, shadowColor, shadowAlpha, obj.blurX, obj.blurY, obj.strength, obj.quality, type, obj.knockout);
                        };
                        BevelFilter.prototype._updateFilterBounds = function (bounds) {
                            if (this.type !== filters.BitmapFilterType.INNER) {
                                filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                                if (this._distance !== 0) {
                                    var a = this._angle * Math.PI / 180;
                                    bounds.x += Math.floor(Math.cos(a) * this._distance);
                                    bounds.y += Math.floor(Math.sin(a) * this._distance);
                                    if (bounds.left > 0) {
                                        bounds.left = 0;
                                    }
                                    if (bounds.top > 0) {
                                        bounds.top = 0;
                                    }
                                }
                            }
                        };
                        Object.defineProperty(BevelFilter.prototype, 'distance', {
                            get: function () {
                                return this._distance;
                            },
                            set: function (value) {
                                this._distance = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'angle', {
                            get: function () {
                                return this._angle;
                            },
                            set: function (value) {
                                this._angle = +value % 360;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'highlightColor', {
                            get: function () {
                                return this._highlightColor;
                            },
                            set: function (value) {
                                this._highlightColor = value >>> 0 & 16777215;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'highlightAlpha', {
                            get: function () {
                                return this._highlightAlpha;
                            },
                            set: function (value) {
                                this._highlightAlpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'shadowColor', {
                            get: function () {
                                return this._shadowColor;
                            },
                            set: function (value) {
                                this._shadowColor = value >>> 0 & 16777215;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'shadowAlpha', {
                            get: function () {
                                return this._shadowAlpha;
                            },
                            set: function (value) {
                                this._shadowAlpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'blurX', {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'blurY', {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'knockout', {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'quality', {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'strength', {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BevelFilter.prototype, 'type', {
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                if (value === null) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'type');
                                } else {
                                    if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                        this._type = value;
                                    } else {
                                        this._type = filters.BitmapFilterType.FULL;
                                    }
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        BevelFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.BevelFilter(this._distance, this._angle, this._highlightColor, this._highlightAlpha, this._shadowColor, this._shadowAlpha, this._blurX, this._blurY, this._strength, this._quality, this._type, this._knockout);
                        };
                        // Called whenever the class is initialized.
                        BevelFilter.classInitializer = null;
                        // List of static symbols to link.
                        BevelFilter.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        BevelFilter.instanceSymbols = null;
                        return BevelFilter;
                    }(flash.filters.BitmapFilter);
                    filters.BevelFilter = BevelFilter;
                    var BlurFilter = function (_super) {
                        __extends(BlurFilter, _super);
                        function BlurFilter(blurX, blurY, quality) {
                            if (blurX === void 0) {
                                blurX = 4;
                            }
                            if (blurY === void 0) {
                                blurY = 4;
                            }
                            if (quality === void 0) {
                                quality = 1;
                            }
                            _super.call(this);
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.quality = quality;
                        }
                        BlurFilter.FromUntyped = function (obj) {
                            return new this.sec.flash.filters.BlurFilter(obj.blurX, obj.blurY, obj.quality);
                        };
                        BlurFilter.prototype._updateFilterBounds = function (bounds) {
                            filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality, true);
                        };
                        BlurFilter.prototype._serialize = function (message) {
                            message.ensureAdditionalCapacity(16);
                            message.writeIntUnsafe(1);
                            message.writeFloatUnsafe(this._blurX);
                            message.writeFloatUnsafe(this._blurY);
                            message.writeIntUnsafe(this._quality);
                        };
                        Object.defineProperty(BlurFilter.prototype, 'blurX', {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BlurFilter.prototype, 'blurY', {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(BlurFilter.prototype, 'quality', {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        BlurFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.BlurFilter(this._blurX, this._blurY, this._quality);
                        };
                        // Called whenever the class is initialized.
                        BlurFilter.classInitializer = null;
                        // List of static symbols to link.
                        BlurFilter.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        BlurFilter.instanceSymbols = null;
                        return BlurFilter;
                    }(flash.filters.BitmapFilter);
                    filters.BlurFilter = BlurFilter;
                    var ColorMatrixFilter = function (_super) {
                        __extends(ColorMatrixFilter, _super);
                        function ColorMatrixFilter(matrix) {
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            _super.call(this);
                            if (matrix) {
                                this.matrix = matrix;
                            } else {
                                this._matrix = [
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    1,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    1,
                                    0
                                ];
                            }
                        }
                        ColorMatrixFilter.FromUntyped = function (obj) {
                            var filter = Object.create(this.sec.flash.filters.ColorMatrixFilter.axClass.tPrototype);
                            filter._matrix = obj.matrix;
                            return filter;
                        };
                        ColorMatrixFilter.prototype._serialize = function (message) {
                            var matrix = this._matrix;
                            message.ensureAdditionalCapacity((matrix.length + 1) * 4);
                            message.writeIntUnsafe(6);
                            for (var i = 0; i < matrix.length; i++) {
                                message.writeFloatUnsafe(matrix[i]);
                            }
                        };
                        Object.defineProperty(ColorMatrixFilter.prototype, 'matrix', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._matrix.concat());
                            },
                            set: function (value_) {
                                if (Shumway.isNullOrUndefined(value_)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'matrix');
                                }
                                var matrix = [
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0,
                                    0
                                ];
                                var value = value_.value;
                                for (var i = 0, n = Math.min(value.length, 20); i < n; i++) {
                                    matrix[i] = Shumway.toNumber(value[i]);
                                }
                                this._matrix = matrix;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ColorMatrixFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.ColorMatrixFilter(this.matrix);
                        };
                        ColorMatrixFilter.classInitializer = null;
                        return ColorMatrixFilter;
                    }(flash.filters.BitmapFilter);
                    filters.ColorMatrixFilter = ColorMatrixFilter;
                    var ConvolutionFilter = function (_super) {
                        __extends(ConvolutionFilter, _super);
                        function ConvolutionFilter(matrixX, matrixY, matrix, divisor, bias, preserveAlpha, clamp, color, alpha) {
                            if (matrixX === void 0) {
                                matrixX = 0;
                            }
                            if (matrixY === void 0) {
                                matrixY = 0;
                            }
                            if (matrix === void 0) {
                                matrix = null;
                            }
                            if (divisor === void 0) {
                                divisor = 1;
                            }
                            if (bias === void 0) {
                                bias = 0;
                            }
                            if (preserveAlpha === void 0) {
                                preserveAlpha = true;
                            }
                            if (clamp === void 0) {
                                clamp = true;
                            }
                            if (color === void 0) {
                                color = 0;
                            }
                            if (alpha === void 0) {
                                alpha = 0;
                            }
                            _super.call(this);
                            this.matrixX = matrixX;
                            this.matrixY = matrixY;
                            if (matrix) {
                                this.matrix = matrix;
                            } else {
                                this._matrix = this._expandArray([], this._matrixX * this._matrixY);
                            }
                            this.divisor = divisor;
                            this.bias = bias;
                            this.preserveAlpha = preserveAlpha;
                            this.clamp = clamp;
                            this.color = color;
                            this.alpha = alpha;
                        }
                        ConvolutionFilter.FromUntyped = function (obj) {
                            return new this.sec.flash.filters.ConvolutionFilter(obj.matrixX, obj.matrixY, obj.matrix, obj.divisor, obj.bias, obj.preserveAlpha, obj.clamp, // obj.color is an RGBA color.
                            obj.color >>> 8, (obj.color & 255) / 255);
                        };
                        ConvolutionFilter.prototype._expandArray = function (a, newLen, value) {
                            if (value === void 0) {
                                value = 0;
                            }
                            if (a) {
                                var i = a.length;
                                while (i < newLen) {
                                    a[i++] = 0;
                                }
                            }
                            return a;
                        };
                        Object.defineProperty(ConvolutionFilter.prototype, 'matrix', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._matrix.slice(0, this._matrixX * this._matrixY));
                            },
                            set: function (value_) {
                                if (Shumway.isNullOrUndefined(value_)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'matrix');
                                }
                                var value = value_.value;
                                var actualLen = this._matrixX * this._matrixY;
                                var minLen = Math.min(value.length, actualLen);
                                var matrix = Array(minLen);
                                for (var i = 0; i < minLen; i++) {
                                    matrix[i] = Shumway.toNumber(value[i]);
                                }
                                this._expandArray(matrix, actualLen);
                                this._matrix = matrix;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, 'matrixX', {
                            get: function () {
                                return this._matrixX;
                            },
                            set: function (value) {
                                var mx = Shumway.NumberUtilities.clamp(+value, 0, 15) | 0;
                                if (this._matrixX !== mx) {
                                    this._matrixX = mx;
                                    this._expandArray(this._matrix, mx * this._matrixY);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, 'matrixY', {
                            get: function () {
                                return this._matrixY;
                            },
                            set: function (value) {
                                var my = Shumway.NumberUtilities.clamp(+value, 0, 15) | 0;
                                if (this._matrixY !== my) {
                                    this._matrixY = my;
                                    this._expandArray(this._matrix, my * this._matrixX);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, 'divisor', {
                            get: function () {
                                return this._divisor;
                            },
                            set: function (value) {
                                this._divisor = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, 'bias', {
                            get: function () {
                                return this._bias;
                            },
                            set: function (value) {
                                this._bias = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, 'preserveAlpha', {
                            get: function () {
                                return this._preserveAlpha;
                            },
                            set: function (value) {
                                this._preserveAlpha = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, 'clamp', {
                            get: function () {
                                return this._clamp;
                            },
                            set: function (value) {
                                this._clamp = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, 'color', {
                            get: function () {
                                return this._color;
                            },
                            set: function (value) {
                                this._color = value >>> 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ConvolutionFilter.prototype, 'alpha', {
                            get: function () {
                                return this._alpha;
                            },
                            set: function (value) {
                                this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ConvolutionFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.ConvolutionFilter(this._matrixX, this._matrixY, this.matrix, this._divisor, this._bias, this._preserveAlpha, this._clamp, this._color, this._alpha);
                        };
                        ConvolutionFilter.classInitializer = null;
                        return ConvolutionFilter;
                    }(flash.filters.BitmapFilter);
                    filters.ConvolutionFilter = ConvolutionFilter;
                    var DisplacementMapFilterMode = function (_super) {
                        __extends(DisplacementMapFilterMode, _super);
                        function DisplacementMapFilterMode() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        DisplacementMapFilterMode.classInitializer = null;
                        // List of static symbols to link.
                        DisplacementMapFilterMode.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        DisplacementMapFilterMode.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        DisplacementMapFilterMode.WRAP = 'wrap';
                        DisplacementMapFilterMode.CLAMP = 'clamp';
                        DisplacementMapFilterMode.IGNORE = 'ignore';
                        DisplacementMapFilterMode.COLOR = 'color';
                        return DisplacementMapFilterMode;
                    }(AS.ASObject);
                    filters.DisplacementMapFilterMode = DisplacementMapFilterMode;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var DisplacementMapFilter = function (_super) {
                        __extends(DisplacementMapFilter, _super);
                        function DisplacementMapFilter(mapBitmap, mapPoint, componentX, componentY, scaleX, scaleY, mode, color, alpha) {
                            if (mapBitmap === void 0) {
                                mapBitmap = null;
                            }
                            if (mapPoint === void 0) {
                                mapPoint = null;
                            }
                            if (componentX === void 0) {
                                componentX = 0;
                            }
                            if (componentY === void 0) {
                                componentY = 0;
                            }
                            if (scaleX === void 0) {
                                scaleX = 0;
                            }
                            if (scaleY === void 0) {
                                scaleY = 0;
                            }
                            if (mode === void 0) {
                                mode = 'wrap';
                            }
                            if (color === void 0) {
                                color = 0;
                            }
                            if (alpha === void 0) {
                                alpha = 0;
                            }
                            _super.call(this);
                            this.mapBitmap = mapBitmap;
                            this.mapPoint = mapPoint;
                            this.componentX = componentX;
                            this.componentY = componentY;
                            this.scaleX = scaleX;
                            this.scaleY = scaleY;
                            this.mode = mode;
                            this.color = color;
                            this.alpha = alpha;
                        }
                        DisplacementMapFilter.FromUntyped = function (obj) {
                            return new this.sec.flash.filters.DisplacementMapFilter(obj.mapBitmap, obj.mapPoint, obj.componentX, obj.componentY, obj.scaleX, obj.scaleY, obj.mode, obj.color, obj.alpha);
                        };
                        Object.defineProperty(DisplacementMapFilter.prototype, 'mapBitmap', {
                            get: function () {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::get mapBitmap');
                                return this._mapBitmap;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set mapBitmap');
                                this._mapBitmap = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplacementMapFilter.prototype, 'mapPoint', {
                            get: function () {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::get mapPoint');
                                return this._mapPoint;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set mapPoint');
                                this._mapPoint = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplacementMapFilter.prototype, 'componentX', {
                            get: function () {
                                return this._componentX;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set componentX');
                                this._componentX = value >>> 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplacementMapFilter.prototype, 'componentY', {
                            get: function () {
                                return this._componentY;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set componentY');
                                this._componentY = value >>> 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplacementMapFilter.prototype, 'scaleX', {
                            get: function () {
                                return this._scaleX;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set scaleX');
                                this._scaleX = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplacementMapFilter.prototype, 'scaleY', {
                            get: function () {
                                return this._scaleY;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set scaleY');
                                this._scaleY = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplacementMapFilter.prototype, 'mode', {
                            get: function () {
                                return this._mode;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set mode');
                                this._mode = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplacementMapFilter.prototype, 'color', {
                            get: function () {
                                return this._color;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set color');
                                this._color = value >>> 0 & 16777215;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DisplacementMapFilter.prototype, 'alpha', {
                            get: function () {
                                return this._alpha;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.filters.DisplacementMapFilter::set alpha');
                                this._alpha = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DisplacementMapFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.DisplacementMapFilter(this._mapBitmap, this._mapPoint, this._componentX, this._componentY, this._scaleX, this._scaleY, this._mode, this._color, this._alpha);
                        };
                        // Called whenever the class is initialized.
                        DisplacementMapFilter.classInitializer = null;
                        // List of static symbols to link.
                        DisplacementMapFilter.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        DisplacementMapFilter.instanceSymbols = null;
                        return DisplacementMapFilter;
                    }(flash.filters.BitmapFilter);
                    filters.DisplacementMapFilter = DisplacementMapFilter;
                    var assert = Shumway.Debug.assert;
                    var DropShadowFilter = function (_super) {
                        __extends(DropShadowFilter, _super);
                        function DropShadowFilter(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject) {
                            if (distance === void 0) {
                                distance = 4;
                            }
                            if (angle === void 0) {
                                angle = 45;
                            }
                            if (color === void 0) {
                                color = 0;
                            }
                            if (alpha === void 0) {
                                alpha = 1;
                            }
                            if (blurX === void 0) {
                                blurX = 4;
                            }
                            if (blurY === void 0) {
                                blurY = 4;
                            }
                            if (strength === void 0) {
                                strength = 1;
                            }
                            if (quality === void 0) {
                                quality = 1;
                            }
                            if (inner === void 0) {
                                inner = false;
                            }
                            if (knockout === void 0) {
                                knockout = false;
                            }
                            if (hideObject === void 0) {
                                hideObject = false;
                            }
                            _super.call(this);
                            this.distance = distance;
                            this.angle = angle;
                            this.color = color;
                            this.alpha = alpha;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.inner = inner;
                            this.knockout = knockout;
                            this.hideObject = hideObject;
                        }
                        DropShadowFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // Here it contains exactly one color object, which maps to color and alpha.
                            release || assert(obj.colors && obj.colors.length === 1, 'colors must be Array of length 1');
                            var color = obj.colors[0] >>> 8;
                            var alpha = (obj.colors[0] & 255) / 255;
                            // obj.angle is represented in radians, the api needs degrees
                            var angle = obj.angle * 180 / Math.PI;
                            // obj.compositeSource maps to !hideObject
                            var hideObject = !obj.compositeSource;
                            return new this.sec.flash.filters.DropShadowFilter(obj.distance, angle, color, alpha, obj.blurX, obj.blurY, obj.strength, obj.quality, obj.inner, obj.knockout, hideObject);
                        };
                        DropShadowFilter.prototype._updateFilterBounds = function (bounds) {
                            if (!this.inner) {
                                filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                                if (this._distance !== 0) {
                                    var a = this._angle * Math.PI / 180;
                                    bounds.x += Math.floor(Math.cos(a) * this._distance);
                                    bounds.y += Math.floor(Math.sin(a) * this._distance);
                                    if (bounds.left > 0) {
                                        bounds.left = 0;
                                    }
                                    if (bounds.top > 0) {
                                        bounds.top = 0;
                                    }
                                }
                            }
                        };
                        Object.defineProperty(DropShadowFilter.prototype, 'distance', {
                            get: function () {
                                return this._distance;
                            },
                            set: function (value) {
                                this._distance = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'angle', {
                            get: function () {
                                return this._angle;
                            },
                            set: function (value) {
                                this._angle = +value % 360;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'color', {
                            get: function () {
                                return this._color;
                            },
                            set: function (value) {
                                this._color = value >>> 0 & 16777215;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'alpha', {
                            get: function () {
                                return this._alpha;
                            },
                            set: function (value) {
                                this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'blurX', {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'blurY', {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'hideObject', {
                            get: function () {
                                return this._hideObject;
                            },
                            set: function (value) {
                                this._hideObject = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'inner', {
                            get: function () {
                                return this._inner;
                            },
                            set: function (value) {
                                this._inner = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'knockout', {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'quality', {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(DropShadowFilter.prototype, 'strength', {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        DropShadowFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.DropShadowFilter(this._distance, this._angle, this._color, this._alpha, this._blurX, this._blurY, this._strength, this._quality, this._inner, this._knockout, this._hideObject);
                        };
                        // Called whenever the class is initialized.
                        DropShadowFilter.classInitializer = null;
                        // List of static symbols to link.
                        DropShadowFilter.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        DropShadowFilter.instanceSymbols = null;
                        return DropShadowFilter;
                    }(flash.filters.BitmapFilter);
                    filters.DropShadowFilter = DropShadowFilter;
                    var assert = Shumway.Debug.assert;
                    var GlowFilter = function (_super) {
                        __extends(GlowFilter, _super);
                        function GlowFilter(color, alpha, blurX, blurY, strength, quality, inner, knockout) {
                            if (color === void 0) {
                                color = 16711680;
                            }
                            if (alpha === void 0) {
                                alpha = 1;
                            }
                            if (blurX === void 0) {
                                blurX = 6;
                            }
                            if (blurY === void 0) {
                                blurY = 6;
                            }
                            if (strength === void 0) {
                                strength = 2;
                            }
                            if (quality === void 0) {
                                quality = 1;
                            }
                            if (inner === void 0) {
                                inner = false;
                            }
                            if (knockout === void 0) {
                                knockout = false;
                            }
                            _super.call(this);
                            this.color = color;
                            this.alpha = alpha;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.inner = inner;
                            this.knockout = knockout;
                        }
                        GlowFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // Here it contains exactly one color object, which maps to color and alpha.
                            release || assert(obj.colors && obj.colors.length === 1, 'colors must be Array of length 1');
                            var color = obj.colors[0] >>> 8;
                            var alpha = (obj.colors[0] & 255) / 255;
                            return new this.sec.flash.filters.GlowFilter(color, alpha, obj.blurX, obj.blurY, obj.strength, obj.quality, obj.inner, obj.knockout);
                        };
                        GlowFilter.prototype._updateFilterBounds = function (bounds) {
                            filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                        };
                        Object.defineProperty(GlowFilter.prototype, 'color', {
                            get: function () {
                                return this._color;
                            },
                            set: function (value) {
                                this._color = value >>> 0 & 16777215;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GlowFilter.prototype, 'alpha', {
                            get: function () {
                                return this._alpha;
                            },
                            set: function (value) {
                                this._alpha = Shumway.NumberUtilities.clamp(+value, 0, 1);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GlowFilter.prototype, 'blurX', {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GlowFilter.prototype, 'blurY', {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GlowFilter.prototype, 'inner', {
                            get: function () {
                                return this._inner;
                            },
                            set: function (value) {
                                this._inner = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GlowFilter.prototype, 'knockout', {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GlowFilter.prototype, 'quality', {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GlowFilter.prototype, 'strength', {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GlowFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.GlowFilter(this._color, this._alpha, this._blurX, this._blurY, this._strength, this._quality, this._inner, this._knockout);
                        };
                        // Called whenever the class is initialized.
                        GlowFilter.classInitializer = null;
                        // List of static symbols to link.
                        GlowFilter.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GlowFilter.instanceSymbols = null;
                        return GlowFilter;
                    }(flash.filters.BitmapFilter);
                    filters.GlowFilter = GlowFilter;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var GradientBevelFilter = function (_super) {
                        __extends(GradientBevelFilter, _super);
                        function GradientBevelFilter(distance, angle, colors, alphas, ratios, blurX, blurY, strength, quality, type, knockout) {
                            if (distance === void 0) {
                                distance = 4;
                            }
                            if (angle === void 0) {
                                angle = 45;
                            }
                            if (colors === void 0) {
                                colors = null;
                            }
                            if (alphas === void 0) {
                                alphas = null;
                            }
                            if (ratios === void 0) {
                                ratios = null;
                            }
                            if (blurX === void 0) {
                                blurX = 4;
                            }
                            if (blurY === void 0) {
                                blurY = 4;
                            }
                            if (strength === void 0) {
                                strength = 1;
                            }
                            if (quality === void 0) {
                                quality = 1;
                            }
                            if (type === void 0) {
                                type = 'inner';
                            }
                            if (knockout === void 0) {
                                knockout = false;
                            }
                            _super.call(this);
                            this.distance = distance;
                            this.angle = angle;
                            filters.GradientArrays.sanitize(colors ? colors.value : null, alphas ? alphas.value : null, ratios ? ratios.value : null);
                            this._colors = filters.GradientArrays.colors;
                            this._alphas = filters.GradientArrays.alphas;
                            this._ratios = filters.GradientArrays.ratios;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.type = type;
                            this.knockout = knockout;
                        }
                        GradientBevelFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // The RGB and alpha parts must be separated into colors and alphas arrays.
                            var colors = [];
                            var alphas = [];
                            for (var i = 0; i < obj.colors.length; i++) {
                                var color = obj.colors[i];
                                colors.push(color >>> 8);
                                alphas.push(color & 255) / 255;
                            }
                            // type is derived from obj.onTop and obj.innerShadow
                            // obj.onTop true: type is FULL
                            // obj.inner true: type is INNER
                            // neither true: type is OUTER
                            var type = flash.filters.BitmapFilterType.OUTER;
                            if (!!obj.onTop) {
                                type = flash.filters.BitmapFilterType.FULL;
                            } else if (!!obj.inner) {
                                type = flash.filters.BitmapFilterType.INNER;
                            }
                            // obj.angle is represented in radians, the api needs degrees
                            var angle = obj.angle * 180 / Math.PI;
                            return new this.sec.flash.filters.GradientBevelFilter(obj.distance, angle, // Boxing these is obviously not ideal, but everything else is just annoying.
                            this.sec.createArrayUnsafe(colors), this.sec.createArrayUnsafe(alphas), this.sec.createArrayUnsafe(obj.ratios), obj.blurX, obj.blurY, obj.strength, obj.quality, type, obj.knockout);
                        };
                        GradientBevelFilter.prototype._updateFilterBounds = function (bounds) {
                            if (this.type !== filters.BitmapFilterType.INNER) {
                                filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                                if (this._distance !== 0) {
                                    var a = this._angle * Math.PI / 180;
                                    bounds.x += Math.floor(Math.cos(a) * this._distance);
                                    bounds.y += Math.floor(Math.sin(a) * this._distance);
                                    if (bounds.left > 0) {
                                        bounds.left = 0;
                                    }
                                    if (bounds.top > 0) {
                                        bounds.top = 0;
                                    }
                                }
                            }
                        };
                        Object.defineProperty(GradientBevelFilter.prototype, 'distance', {
                            get: function () {
                                return this._distance;
                            },
                            set: function (value) {
                                this._distance = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'angle', {
                            get: function () {
                                return this._angle;
                            },
                            set: function (value) {
                                this._angle = +value % 360;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'colors', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._colors.concat());
                            },
                            set: function (value) {
                                if (Shumway.isNullOrUndefined(value)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'colors');
                                }
                                this._colors = filters.GradientArrays.sanitizeColors(value.value);
                                var len = this._colors.length;
                                this._alphas = filters.GradientArrays.sanitizeAlphas(this._alphas, len, len);
                                this._ratios = filters.GradientArrays.sanitizeRatios(this._ratios, len, len);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'alphas', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._alphas.concat());
                            },
                            set: function (value) {
                                if (Shumway.isNullOrUndefined(value)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'alphas');
                                }
                                filters.GradientArrays.sanitize(this._colors, value.value, this._ratios);
                                this._colors = filters.GradientArrays.colors;
                                this._alphas = filters.GradientArrays.alphas;
                                this._ratios = filters.GradientArrays.ratios;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'ratios', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._ratios.concat());
                            },
                            set: function (value_) {
                                if (Shumway.isNullOrUndefined(value_)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'ratios');
                                }
                                filters.GradientArrays.sanitize(this._colors, this._alphas, value_.value);
                                this._colors = filters.GradientArrays.colors;
                                this._alphas = filters.GradientArrays.alphas;
                                this._ratios = filters.GradientArrays.ratios;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'blurX', {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'blurY', {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'knockout', {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'quality', {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'strength', {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientBevelFilter.prototype, 'type', {
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                if (value === null) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'type');
                                } else {
                                    if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                        this._type = value;
                                    } else {
                                        this._type = filters.BitmapFilterType.FULL;
                                    }
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GradientBevelFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.GradientBevelFilter(this._distance, this._angle, this.colors, this.alphas, this.ratios, this._blurX, this._blurY, this._strength, this._quality, this._type, this._knockout);
                        };
                        // Called whenever the class is initialized.
                        GradientBevelFilter.classInitializer = null;
                        // List of static symbols to link.
                        GradientBevelFilter.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GradientBevelFilter.instanceSymbols = null;
                        return GradientBevelFilter;
                    }(flash.filters.BitmapFilter);
                    filters.GradientBevelFilter = GradientBevelFilter;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var GradientGlowFilter = function (_super) {
                        __extends(GradientGlowFilter, _super);
                        function GradientGlowFilter(distance, angle, colors, alphas, ratios, blurX, blurY, strength, quality, type, knockout) {
                            if (distance === void 0) {
                                distance = 4;
                            }
                            if (angle === void 0) {
                                angle = 45;
                            }
                            if (colors === void 0) {
                                colors = null;
                            }
                            if (alphas === void 0) {
                                alphas = null;
                            }
                            if (ratios === void 0) {
                                ratios = null;
                            }
                            if (blurX === void 0) {
                                blurX = 4;
                            }
                            if (blurY === void 0) {
                                blurY = 4;
                            }
                            if (strength === void 0) {
                                strength = 1;
                            }
                            if (quality === void 0) {
                                quality = 1;
                            }
                            if (type === void 0) {
                                type = 'inner';
                            }
                            if (knockout === void 0) {
                                knockout = false;
                            }
                            _super.call(this);
                            this.distance = distance;
                            this.angle = angle;
                            filters.GradientArrays.sanitize(colors ? colors.value : null, alphas ? alphas.value : null, ratios ? ratios.value : null);
                            this._colors = filters.GradientArrays.colors;
                            this._alphas = filters.GradientArrays.alphas;
                            this._ratios = filters.GradientArrays.ratios;
                            this.blurX = blurX;
                            this.blurY = blurY;
                            this.strength = strength;
                            this.quality = quality;
                            this.type = type;
                            this.knockout = knockout;
                        }
                        GradientGlowFilter.FromUntyped = function (obj) {
                            // obj.colors is an array of RGBA colors.
                            // The RGB and alpha parts must be separated into colors and alphas arrays.
                            var colors = [];
                            var alphas = [];
                            for (var i = 0; i < obj.colors.length; i++) {
                                var color = obj.colors[i];
                                colors.push(color >>> 8);
                                alphas.push(color & 255) / 255;
                            }
                            // type is derived from obj.onTop and obj.innerShadow
                            // obj.onTop true: type is FULL
                            // obj.inner true: type is INNER
                            // neither true: type is OUTER
                            var type = flash.filters.BitmapFilterType.OUTER;
                            if (!!obj.onTop) {
                                type = flash.filters.BitmapFilterType.FULL;
                            } else if (!!obj.inner) {
                                type = flash.filters.BitmapFilterType.INNER;
                            }
                            // obj.angle is represented in radians, the api needs degrees
                            var angle = obj.angle * 180 / Math.PI;
                            return new this.sec.flash.filters.GradientGlowFilter(obj.distance, angle, // Boxing these is obviously not ideal, but everything else is just annoying.
                            this.sec.createArrayUnsafe(colors), this.sec.createArrayUnsafe(alphas), this.sec.createArrayUnsafe(obj.ratios), obj.blurX, obj.blurY, obj.strength, obj.quality, type, obj.knockout);
                        };
                        GradientGlowFilter.prototype._updateFilterBounds = function (bounds) {
                            if (this.type !== filters.BitmapFilterType.INNER) {
                                filters.BitmapFilter._updateBlurBounds(bounds, this._blurX, this._blurY, this._quality);
                                if (this._distance !== 0) {
                                    var a = this._angle * Math.PI / 180;
                                    bounds.x += Math.floor(Math.cos(a) * this._distance);
                                    bounds.y += Math.floor(Math.sin(a) * this._distance);
                                    if (bounds.left > 0) {
                                        bounds.left = 0;
                                    }
                                    if (bounds.top > 0) {
                                        bounds.top = 0;
                                    }
                                }
                            }
                        };
                        Object.defineProperty(GradientGlowFilter.prototype, 'distance', {
                            get: function () {
                                return this._distance;
                            },
                            set: function (value) {
                                this._distance = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'angle', {
                            get: function () {
                                return this._angle;
                            },
                            set: function (value) {
                                this._angle = +value % 360;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'colors', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._colors.concat());
                            },
                            set: function (value) {
                                if (Shumway.isNullOrUndefined(value)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'colors');
                                }
                                this._colors = filters.GradientArrays.sanitizeColors(value.value);
                                var len = this._colors.length;
                                this._alphas = filters.GradientArrays.sanitizeAlphas(this._alphas, len, len);
                                this._ratios = filters.GradientArrays.sanitizeRatios(this._ratios, len, len);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'alphas', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._alphas.concat());
                            },
                            set: function (value) {
                                if (Shumway.isNullOrUndefined(value)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'alphas');
                                }
                                filters.GradientArrays.sanitize(this._colors, value.value, this._ratios);
                                this._colors = filters.GradientArrays.colors;
                                this._alphas = filters.GradientArrays.alphas;
                                this._ratios = filters.GradientArrays.ratios;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'ratios', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._ratios.concat());
                            },
                            set: function (value_) {
                                if (Shumway.isNullOrUndefined(value_)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'ratios');
                                }
                                filters.GradientArrays.sanitize(this._colors, this._alphas, value_.value);
                                this._colors = filters.GradientArrays.colors;
                                this._alphas = filters.GradientArrays.alphas;
                                this._ratios = filters.GradientArrays.ratios;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'blurX', {
                            get: function () {
                                return this._blurX;
                            },
                            set: function (value) {
                                this._blurX = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'blurY', {
                            get: function () {
                                return this._blurY;
                            },
                            set: function (value) {
                                this._blurY = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'knockout', {
                            get: function () {
                                return this._knockout;
                            },
                            set: function (value) {
                                this._knockout = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'quality', {
                            get: function () {
                                return this._quality;
                            },
                            set: function (value) {
                                this._quality = Shumway.NumberUtilities.clamp(value | 0, 0, 15);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'strength', {
                            get: function () {
                                return this._strength;
                            },
                            set: function (value) {
                                this._strength = Shumway.NumberUtilities.clamp(+value, 0, 255);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GradientGlowFilter.prototype, 'type', {
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                if (value === null) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'type');
                                } else {
                                    if (value === filters.BitmapFilterType.INNER || value === filters.BitmapFilterType.OUTER) {
                                        this._type = value;
                                    } else {
                                        this._type = filters.BitmapFilterType.FULL;
                                    }
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GradientGlowFilter.prototype.clone = function () {
                            return new this.sec.flash.filters.GradientGlowFilter(this._distance, this._angle, this.colors, this.alphas, this.ratios, this._blurX, this._blurY, this._strength, this._quality, this._type, this._knockout);
                        };
                        GradientGlowFilter.classInitializer = null;
                        return GradientGlowFilter;
                    }(flash.filters.BitmapFilter);
                    filters.GradientGlowFilter = GradientGlowFilter;
                }(filters = flash.filters || (flash.filters = {})));
                var geom;
                (function (geom) {
                    var toS16 = Shumway.IntegerUtilities.toS16;
                    var clampS8U8 = Shumway.IntegerUtilities.clampS8U8;
                    var ColorTransform = function (_super) {
                        __extends(ColorTransform, _super);
                        // "blueMultiplier", "alphaMultiplier", "redOffset",
                        // "greenOffset", "blueOffset", "alphaOffset",
                        // "color", "color", "concat", "toString"];
                        function ColorTransform(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                            if (redMultiplier === void 0) {
                                redMultiplier = 1;
                            }
                            if (greenMultiplier === void 0) {
                                greenMultiplier = 1;
                            }
                            if (blueMultiplier === void 0) {
                                blueMultiplier = 1;
                            }
                            if (alphaMultiplier === void 0) {
                                alphaMultiplier = 1;
                            }
                            if (redOffset === void 0) {
                                redOffset = 0;
                            }
                            if (greenOffset === void 0) {
                                greenOffset = 0;
                            }
                            if (blueOffset === void 0) {
                                blueOffset = 0;
                            }
                            if (alphaOffset === void 0) {
                                alphaOffset = 0;
                            }
                            _super.call(this);
                            this.redMultiplier = +redMultiplier;
                            this.greenMultiplier = +greenMultiplier;
                            this.blueMultiplier = +blueMultiplier;
                            this.alphaMultiplier = +alphaMultiplier;
                            this.redOffset = +redOffset;
                            this.greenOffset = +greenOffset;
                            this.blueOffset = +blueOffset;
                            this.alphaOffset = +alphaOffset;
                        }
                        ColorTransform.classInitializer = function () {
                            this.FROZEN_IDENTITY_COLOR_TRANSFORM = Object.freeze(this.axConstruct([]));
                            this.TEMP_COLOR_TRANSFORM = this.axConstruct([]);
                        };
                        Object.defineProperty(ColorTransform.prototype, 'native_redMultiplier', {
                            get: function () {
                                return this.redMultiplier;
                            },
                            set: function (redMultiplier) {
                                this.redMultiplier = +redMultiplier;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ColorTransform.prototype, 'native_greenMultiplier', {
                            get: function () {
                                return this.greenMultiplier;
                            },
                            set: function (greenMultiplier) {
                                this.greenMultiplier = +greenMultiplier;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ColorTransform.prototype, 'native_blueMultiplier', {
                            get: function () {
                                return this.blueMultiplier;
                            },
                            set: function (blueMultiplier) {
                                this.blueMultiplier = +blueMultiplier;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ColorTransform.prototype, 'native_alphaMultiplier', {
                            get: function () {
                                return this.alphaMultiplier;
                            },
                            set: function (alphaMultiplier) {
                                this.alphaMultiplier = +alphaMultiplier;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ColorTransform.prototype, 'native_redOffset', {
                            get: function () {
                                return this.redOffset;
                            },
                            set: function (redOffset) {
                                this.redOffset = +redOffset;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ColorTransform.prototype, 'native_greenOffset', {
                            get: function () {
                                return this.greenOffset;
                            },
                            set: function (greenOffset) {
                                this.greenOffset = +greenOffset;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ColorTransform.prototype, 'native_blueOffset', {
                            get: function () {
                                return this.blueOffset;
                            },
                            set: function (blueOffset) {
                                this.blueOffset = +blueOffset;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ColorTransform.prototype, 'native_alphaOffset', {
                            get: function () {
                                return this.alphaOffset;
                            },
                            set: function (alphaOffset) {
                                this.alphaOffset = +alphaOffset;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ColorTransform.prototype.ColorTransform = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                            if (redMultiplier === void 0) {
                                redMultiplier = 1;
                            }
                            if (greenMultiplier === void 0) {
                                greenMultiplier = 1;
                            }
                            if (blueMultiplier === void 0) {
                                blueMultiplier = 1;
                            }
                            if (alphaMultiplier === void 0) {
                                alphaMultiplier = 1;
                            }
                            if (redOffset === void 0) {
                                redOffset = 0;
                            }
                            if (greenOffset === void 0) {
                                greenOffset = 0;
                            }
                            if (blueOffset === void 0) {
                                blueOffset = 0;
                            }
                            if (alphaOffset === void 0) {
                                alphaOffset = 0;
                            }
                            this.redMultiplier = redMultiplier;
                            this.greenMultiplier = greenMultiplier;
                            this.blueMultiplier = blueMultiplier;
                            this.alphaMultiplier = alphaMultiplier;
                            this.redOffset = redOffset;
                            this.greenOffset = greenOffset;
                            this.blueOffset = blueOffset;
                            this.alphaOffset = alphaOffset;
                        };
                        Object.defineProperty(ColorTransform.prototype, 'color', {
                            get: function () {
                                return this.redOffset << 16 | this.greenOffset << 8 | this.blueOffset;
                            },
                            set: function (newColor) {
                                this.redOffset = newColor >> 16 & 255;
                                this.greenOffset = newColor >> 8 & 255;
                                this.blueOffset = newColor & 255;
                                this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 1;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ColorTransform.prototype.concat = function (second) {
                            this.redMultiplier *= second.redMultiplier;
                            this.greenMultiplier *= second.greenMultiplier;
                            this.blueMultiplier *= second.blueMultiplier;
                            this.alphaMultiplier *= second.alphaMultiplier;
                            this.redOffset += second.redOffset;
                            this.greenOffset += second.greenOffset;
                            this.blueOffset += second.blueOffset;
                            this.alphaOffset += second.alphaOffset;
                        };
                        ColorTransform.prototype.preMultiply = function (second) {
                            this.redOffset += second.redOffset * this.redMultiplier;
                            this.greenOffset += second.greenOffset * this.greenMultiplier;
                            this.blueOffset += second.blueOffset * this.blueMultiplier;
                            this.alphaOffset += second.alphaOffset * this.alphaMultiplier;
                            this.redMultiplier *= second.redMultiplier;
                            this.greenMultiplier *= second.greenMultiplier;
                            this.blueMultiplier *= second.blueMultiplier;
                            this.alphaMultiplier *= second.alphaMultiplier;
                        };
                        ColorTransform.prototype.copyFrom = function (sourceColorTransform) {
                            this.redMultiplier = sourceColorTransform.redMultiplier;
                            this.greenMultiplier = sourceColorTransform.greenMultiplier;
                            this.blueMultiplier = sourceColorTransform.blueMultiplier;
                            this.alphaMultiplier = sourceColorTransform.alphaMultiplier;
                            this.redOffset = sourceColorTransform.redOffset;
                            this.greenOffset = sourceColorTransform.greenOffset;
                            this.blueOffset = sourceColorTransform.blueOffset;
                            this.alphaOffset = sourceColorTransform.alphaOffset;
                        };
                        ColorTransform.prototype.copyFromUntyped = function (object) {
                            this.redMultiplier = object.redMultiplier / 256;
                            this.greenMultiplier = object.greenMultiplier / 256;
                            this.blueMultiplier = object.blueMultiplier / 256;
                            this.alphaMultiplier = object.alphaMultiplier / 256;
                            this.redOffset = object.redOffset;
                            this.greenOffset = object.greenOffset;
                            this.blueOffset = object.blueOffset;
                            this.alphaOffset = object.alphaOffset;
                        };
                        ColorTransform.prototype.setTo = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                            this.redMultiplier = redMultiplier;
                            this.greenMultiplier = greenMultiplier;
                            this.blueMultiplier = blueMultiplier;
                            this.alphaMultiplier = alphaMultiplier;
                            this.redOffset = redOffset;
                            this.greenOffset = greenOffset;
                            this.blueOffset = blueOffset;
                            this.alphaOffset = alphaOffset;
                        };
                        ColorTransform.prototype.clone = function () {
                            return new this.sec.flash.geom.ColorTransform(this.redMultiplier, this.greenMultiplier, this.blueMultiplier, this.alphaMultiplier, this.redOffset, this.greenOffset, this.blueOffset, this.alphaOffset);
                        };
                        ColorTransform.prototype.convertToFixedPoint = function () {
                            this.redMultiplier = clampS8U8(this.redMultiplier);
                            this.greenMultiplier = clampS8U8(this.greenMultiplier);
                            this.blueMultiplier = clampS8U8(this.blueMultiplier);
                            this.alphaMultiplier = clampS8U8(this.alphaMultiplier);
                            this.redOffset = toS16(this.redOffset);
                            this.greenOffset = toS16(this.greenOffset);
                            this.blueOffset = toS16(this.blueOffset);
                            this.alphaOffset = toS16(this.alphaOffset);
                            return this;
                        };
                        ColorTransform.prototype.equals = function (other) {
                            if (this === other) {
                                return true;
                            }
                            return this.redMultiplier === other.redMultiplier && this.greenMultiplier === other.greenMultiplier && this.blueMultiplier === other.blueMultiplier && this.alphaMultiplier === other.alphaMultiplier && this.redOffset === other.redOffset && this.greenOffset === other.greenOffset && this.blueOffset === other.blueOffset && this.alphaOffset === other.alphaOffset;
                        };
                        ColorTransform.prototype.toString = function () {
                            return '(redMultiplier=' + this.redMultiplier + ', greenMultiplier=' + this.greenMultiplier + ', blueMultiplier=' + this.blueMultiplier + ', alphaMultiplier=' + this.alphaMultiplier + ', redOffset=' + this.redOffset + ', greenOffset=' + this.greenOffset + ', blueOffset=' + this.blueOffset + ', alphaOffset=' + this.alphaOffset + ')';
                        };
                        ColorTransform.classSymbols = null;
                        // [];
                        ColorTransform.instanceSymbols = null;
                        // ["redMultiplier", "greenMultiplier",
                        return ColorTransform;
                    }(AS.ASObject);
                    geom.ColorTransform = ColorTransform;
                }(geom = flash.geom || (flash.geom = {})));
                var media;
                (function (media) {
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var Camera = function (_super) {
                        __extends(Camera, _super);
                        function Camera() {
                            _super.call(this);
                        }
                        Object.defineProperty(Camera, 'names', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get names');
                                return this.sec.createArrayUnsafe([]);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera, 'isSupported', {
                            get: function () {
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Camera.getCamera = function (name) {
                            if (name === void 0) {
                                name = null;
                            }
                            name = axCoerceString(name);
                            release || somewhatImplemented('public flash.media.Camera::static getCamera');
                            return null;
                        };
                        Camera._scanHardware = function () {
                            release || somewhatImplemented('public flash.media.Camera::static _scanHardware');
                        };
                        Object.defineProperty(Camera.prototype, 'activityLevel', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get activityLevel');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'bandwidth', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get bandwidth');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'currentFPS', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get currentFPS');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'fps', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get fps');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'height', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get height');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'index', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get index');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'keyFrameInterval', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get keyFrameInterval');
                                return 1;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'loopback', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get loopback');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'motionLevel', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get motionLevel');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'motionTimeout', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get motionTimeout');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'muted', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get muted');
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'name', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get name');
                                return '';
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'quality', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get quality');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Camera.prototype, 'width', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Camera::get width');
                                return 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Camera.prototype.setCursor = function (value) {
                            value = !!value;
                            release || somewhatImplemented('public flash.media.Camera::setCursor');
                        };
                        Camera.prototype.setKeyFrameInterval = function (keyFrameInterval) {
                            keyFrameInterval = keyFrameInterval | 0;
                            release || somewhatImplemented('public flash.media.Camera::setKeyFrameInterval');
                        };
                        Camera.prototype.setLoopback = function (compress) {
                            if (compress === void 0) {
                                compress = false;
                            }
                            compress = !!compress;
                            release || somewhatImplemented('public flash.media.Camera::setLoopback');
                        };
                        Camera.prototype.setMode = function (width, height, fps, favorArea) {
                            if (favorArea === void 0) {
                                favorArea = true;
                            }
                            width = width | 0;
                            height = height | 0;
                            fps = +fps;
                            favorArea = !!favorArea;
                            release || somewhatImplemented('public flash.media.Camera::setMode');
                        };
                        Camera.prototype.setMotionLevel = function (motionLevel, timeout) {
                            if (timeout === void 0) {
                                timeout = 2000;
                            }
                            motionLevel = motionLevel | 0;
                            timeout = timeout | 0;
                            release || somewhatImplemented('public flash.media.Camera::setMotionLevel');
                        };
                        Camera.prototype.setQuality = function (bandwidth, quality) {
                            bandwidth = bandwidth | 0;
                            quality = quality | 0;
                            release || somewhatImplemented('public flash.media.Camera::setQuality');
                        };
                        Camera.prototype.drawToBitmapData = function (destination) {
                            destination = destination;
                            release || somewhatImplemented('public flash.media.Camera::drawToBitmapData');
                        };
                        Camera.prototype.copyToByteArray = function (rect, destination) {
                            rect = rect;
                            destination = destination;
                            release || somewhatImplemented('public flash.media.Camera::copyToByteArray');
                        };
                        Camera.prototype.copyToVector = function (rect, destination) {
                            rect = rect;
                            destination = destination;
                            release || somewhatImplemented('public flash.media.Camera::copyToVector');
                        };
                        Camera.classInitializer = null;
                        return Camera;
                    }(flash.events.EventDispatcher);
                    media.Camera = Camera;
                    var ID3Info = function (_super) {
                        __extends(ID3Info, _super);
                        function ID3Info() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        ID3Info.classInitializer = null;
                        // List of static symbols to link.
                        ID3Info.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        ID3Info.instanceSymbols = [
                            'songName',
                            'artist',
                            'album',
                            'year',
                            'comment',
                            'genre',
                            'track'
                        ];
                        return ID3Info;
                    }(AS.ASObject);
                    media.ID3Info = ID3Info;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var Microphone = function (_super) {
                        __extends(Microphone, _super);
                        function Microphone() {
                            _super.call(this);
                        }
                        Object.defineProperty(Microphone, 'names', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Microphone::get names');
                                return this.sec.createArrayUnsafe([]);    // return this._names;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone, 'isSupported', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Microphone::get isSupported');
                                return false;    // return this._isSupported;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Microphone.getMicrophone = function (index) {
                            if (index === void 0) {
                                index = -1;
                            }
                            index = index | 0;
                            release || notImplemented('public flash.media.Microphone::static getMicrophone');
                            return;
                        };
                        Microphone.getEnhancedMicrophone = function (index) {
                            if (index === void 0) {
                                index = -1;
                            }
                            index = index | 0;
                            release || notImplemented('public flash.media.Microphone::static getEnhancedMicrophone');
                            return;
                        };
                        Object.defineProperty(Microphone.prototype, 'rate', {
                            // _rate: number /*int*/;
                            // _codec: string;
                            // _framesPerPacket: number /*int*/;
                            // _encodeQuality: number /*int*/;
                            // _noiseSuppressionLevel: number /*int*/;
                            // _enableVAD: boolean;
                            // _activityLevel: number;
                            // _gain: number;
                            // _index: number /*int*/;
                            // _muted: boolean;
                            // _name: string;
                            // _silenceLevel: number;
                            // _silenceTimeout: number /*int*/;
                            // _useEchoSuppression: boolean;
                            // _soundTransform: flash.media.SoundTransform;
                            // _enhancedOptions: flash.media.MicrophoneEnhancedOptions;
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get rate');
                                return;    // return this._rate;
                            },
                            set: function (rate) {
                                rate = rate | 0;
                                release || notImplemented('public flash.media.Microphone::set rate');
                                return;    // this._rate = rate;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'codec', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get codec');
                                return;    // return this._codec;
                            },
                            set: function (codec) {
                                codec = axCoerceString(codec);
                                release || notImplemented('public flash.media.Microphone::set codec');
                                return;    // this._codec = codec;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'framesPerPacket', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get framesPerPacket');
                                return;    // return this._framesPerPacket;
                            },
                            set: function (frames) {
                                frames = frames | 0;
                                release || notImplemented('public flash.media.Microphone::set framesPerPacket');
                                return;    // this._framesPerPacket = frames;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'encodeQuality', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get encodeQuality');
                                return;    // return this._encodeQuality;
                            },
                            set: function (quality) {
                                quality = quality | 0;
                                release || notImplemented('public flash.media.Microphone::set encodeQuality');
                                return;    // this._encodeQuality = quality;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'noiseSuppressionLevel', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get noiseSuppressionLevel');
                                return;    // return this._noiseSuppressionLevel;
                            },
                            set: function (level) {
                                level = level | 0;
                                release || notImplemented('public flash.media.Microphone::set noiseSuppressionLevel');
                                return;    // this._noiseSuppressionLevel = level;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'enableVAD', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get enableVAD');
                                return;    // return this._enableVAD;
                            },
                            set: function (enable) {
                                enable = !!enable;
                                release || notImplemented('public flash.media.Microphone::set enableVAD');
                                return;    // this._enableVAD = enable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'activityLevel', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get activityLevel');
                                return;    // return this._activityLevel;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'gain', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get gain');
                                return;    // return this._gain;
                            },
                            set: function (gain) {
                                gain = +gain;
                                release || notImplemented('public flash.media.Microphone::set gain');
                                return;    // this._gain = gain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'index', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get index');
                                return;    // return this._index;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'muted', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get muted');
                                return;    // return this._muted;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'name', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get name');
                                return;    // return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'silenceLevel', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get silenceLevel');
                                return;    // return this._silenceLevel;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'silenceTimeout', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get silenceTimeout');
                                return;    // return this._silenceTimeout;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'useEchoSuppression', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get useEchoSuppression');
                                return;    // return this._useEchoSuppression;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'soundTransform', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get soundTransform');
                                return;    // return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                sndTransform = sndTransform;
                                release || notImplemented('public flash.media.Microphone::set soundTransform');
                                return;    // this._soundTransform = sndTransform;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Microphone.prototype, 'enhancedOptions', {
                            get: function () {
                                release || notImplemented('public flash.media.Microphone::get enhancedOptions');
                                return;    // return this._enhancedOptions;
                            },
                            set: function (options) {
                                options = options;
                                release || notImplemented('public flash.media.Microphone::set enhancedOptions');
                                return;    // this._enhancedOptions = options;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Microphone.prototype.setSilenceLevel = function (silenceLevel, timeout) {
                            if (timeout === void 0) {
                                timeout = -1;
                            }
                            silenceLevel = +silenceLevel;
                            timeout = timeout | 0;
                            release || notImplemented('public flash.media.Microphone::setSilenceLevel');
                            return;
                        };
                        Microphone.prototype.setUseEchoSuppression = function (useEchoSuppression) {
                            useEchoSuppression = !!useEchoSuppression;
                            release || notImplemented('public flash.media.Microphone::setUseEchoSuppression');
                            return;
                        };
                        Microphone.prototype.setLoopBack = function (state) {
                            if (state === void 0) {
                                state = true;
                            }
                            state = !!state;
                            release || notImplemented('public flash.media.Microphone::setLoopBack');
                            return;
                        };
                        Microphone.classInitializer = null;
                        return Microphone;
                    }(flash.events.EventDispatcher);
                    media.Microphone = Microphone;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var assert = Shumway.Debug.assert;
                    var Telemetry = Shumway.Telemetry;
                    function getAudioDescription(soundData, onComplete) {
                        var audioElement = document.createElement('audio');
                        if (!audioElement.canPlayType(soundData.mimeType)) {
                            onComplete({ duration: 0 });
                            return;
                        }
                        audioElement.preload = 'metadata';
                        // for mobile devices
                        var blob = new Blob([soundData.data], { type: soundData.mimeType });
                        audioElement.src = URL.createObjectURL(blob);
                        audioElement.load();
                        audioElement.addEventListener('loadedmetadata', function () {
                            onComplete({ duration: this.duration * 1000 });
                        });
                    }
                    var SoundData = function () {
                        function SoundData() {
                        }
                        return SoundData;
                    }();
                    var Sound = function (_super) {
                        __extends(Sound, _super);
                        function Sound(stream, context) {
                            if (this._symbol) {
                                this.applySymbol();
                            }
                            _super.call(this);
                            Telemetry.instance.reportTelemetry({
                                topic: 'feature',
                                feature: 5    /* SOUND_FEATURE */
                            });
                            this._playQueue = [];
                            this._url = null;
                            this._length = 0;
                            this._bytesTotal = 0;
                            this._bytesLoaded = 0;
                            this._id3 = new this.sec.flash.media.ID3Info();
                            this._isURLInaccessible = false;
                            this._isBuffering = false;
                            this.load(stream, context);
                        }
                        Sound.prototype.applySymbol = function () {
                            release || assert(this._symbol);
                            this._playQueue = [];
                            this._url = null;
                            this._length = 0;
                            this._bytesTotal = 0;
                            this._bytesLoaded = 0;
                            this._id3 = new this.sec.flash.media.ID3Info();
                            this._isURLInaccessible = false;
                            this._isBuffering = false;
                            var symbol = this._symbol;
                            if (symbol) {
                                var soundData = new SoundData();
                                soundData.sampleRate = symbol.sampleRate;
                                soundData.channels = symbol.channels;
                                soundData.completed = true;
                                if (symbol.pcm) {
                                    soundData.pcm = symbol.pcm;
                                    soundData.end = symbol.pcm.length;
                                }
                                if (symbol.packaged) {
                                    soundData.data = symbol.packaged.data.buffer;
                                    soundData.mimeType = symbol.packaged.mimeType;
                                }
                                var self = this;
                                getAudioDescription(soundData, function (description) {
                                    self._length = description.duration;
                                });
                                this._soundData = soundData;
                            }
                        };
                        Sound.initializeFromPCMData = function (sec, data) {
                            var sound = new sec.flash.media.Sound();
                            sound._symbol = data;
                            sound.applySymbol();
                            return sound;
                        };
                        Object.defineProperty(Sound.prototype, 'url', {
                            get: function () {
                                return this._url;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, 'isURLInaccessible', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Sound::get isURLInaccessible');
                                return this._isURLInaccessible;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, 'length', {
                            get: function () {
                                return this._length;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, 'isBuffering', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.Sound::get isBuffering');
                                return this._isBuffering;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, 'bytesLoaded', {
                            get: function () {
                                return this._bytesLoaded;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, 'bytesTotal', {
                            get: function () {
                                return this._bytesTotal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Sound.prototype, 'id3', {
                            get: function () {
                                return this._id3;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Sound.prototype.loadCompressedDataFromByteArray = function (bytes, bytesLength) {
                            bytes = bytes;
                            bytesLength = bytesLength >>> 0;
                            release || notImplemented('public flash.media.Sound::loadCompressedDataFromByteArray');
                            return;
                        };
                        Sound.prototype.loadPCMFromByteArray = function (bytes, samples, format, stereo, sampleRate) {
                            if (format === void 0) {
                                format = 'float';
                            }
                            if (stereo === void 0) {
                                stereo = true;
                            }
                            if (sampleRate === void 0) {
                                sampleRate = 44100;
                            }
                            bytes = bytes;
                            samples = samples >>> 0;
                            format = axCoerceString(format);
                            stereo = !!stereo;
                            sampleRate = +sampleRate;
                            release || notImplemented('public flash.media.Sound::loadPCMFromByteArray');
                            return;
                        };
                        Sound.prototype.play = function (startTime, loops, sndTransform) {
                            if (startTime === void 0) {
                                startTime = 0;
                            }
                            if (loops === void 0) {
                                loops = 0;
                            }
                            if (sndTransform === void 0) {
                                sndTransform = null;
                            }
                            startTime = +startTime;
                            loops = loops | 0;
                            var channel = new this.sec.flash.media.SoundChannel();
                            channel._sound = this;
                            channel._soundTransform = Shumway.isNullOrUndefined(sndTransform) ? new this.sec.flash.media.SoundTransform() : sndTransform;
                            this._playQueue.push({
                                channel: channel,
                                startTime: startTime
                            });
                            if (AS.disableAudioOption.value) {
                                return channel;
                            }
                            if (this._soundData) {
                                if (!AS.webAudioOption.value && !AS.webAudioMP3Option.value) {
                                    channel._playSoundDataViaAudio(this._soundData, startTime, loops);
                                } else if (!this._soundData.pcm) {
                                    if (this._soundData.mimeType === 'audio/mpeg' && AS.webAudioMP3Option.value) {
                                        Shumway.SWF.MP3DecoderSession.processAll(new Uint8Array(this._soundData.data)).then(function (result) {
                                            this._soundData.pcm = result.data;
                                            this._soundData.end = result.data.length;
                                            channel._playSoundDataViaChannel(this._soundData, startTime, loops);
                                        }.bind(this), function (reason) {
                                            Shumway.Debug.warning('Unable to decode MP3 data: ' + reason);
                                        });
                                    } else {
                                        Shumway.Debug.warning('Unable to decode packaged sound data of type: ' + this._soundData.mimeType);
                                    }
                                } else {
                                    channel._playSoundDataViaChannel(this._soundData, startTime, loops);
                                }
                            }
                            return channel;
                        };
                        Sound.prototype.close = function () {
                            release || somewhatImplemented('public flash.media.Sound::close');
                        };
                        Sound.prototype.extract = function (target, length, startPosition) {
                            if (startPosition === void 0) {
                                startPosition = -1;
                            }
                            target = target;
                            length = +length;
                            startPosition = +startPosition;
                            release || notImplemented('public flash.media.Sound::extract');
                            return;
                        };
                        Sound.prototype.load = function (request, context) {
                            if (!request) {
                                return;
                            }
                            var checkPolicyFile = context ? context.checkPolicyFile : false;
                            var bufferTime = context ? context.bufferTime : 1000;
                            var _this = this;
                            var stream = this._stream = new this.sec.flash.net.URLStream();
                            var data = new this.sec.flash.utils.ByteArray();
                            var dataPosition = 0;
                            var playUsingWebAudio = AS.webAudioOption.value;
                            var mp3DecodingSession = null;
                            var soundData = new SoundData();
                            soundData.completed = false;
                            stream.addEventListener('progress', function (event) {
                                _this._bytesLoaded = event.axGetPublicProperty('bytesLoaded');
                                _this._bytesTotal = event.axGetPublicProperty('bytesTotal');
                                if (playUsingWebAudio && !mp3DecodingSession) {
                                    // initialize MP3 decoding
                                    mp3DecodingSession = decodeMP3(soundData, function (duration, final) {
                                        if (_this._length === 0) {
                                            // once we have some data, trying to play it
                                            _this._soundData = soundData;
                                            _this._playQueue.forEach(function (item) {
                                                item.channel._playSoundDataViaChannel(soundData, item.startTime);
                                            });
                                        }
                                        // estimate duration based on bytesTotal and current loaded data time
                                        _this._length = final ? duration * 1000 : Math.max(duration, mp3DecodingSession.estimateDuration(_this._bytesTotal)) * 1000;
                                    });
                                }
                                var bytesAvailable = stream.bytesAvailable;
                                stream.readBytes(data, dataPosition, bytesAvailable);
                                if (mp3DecodingSession) {
                                    mp3DecodingSession.pushData(new Uint8Array(data._buffer, dataPosition, bytesAvailable));
                                }
                                dataPosition += bytesAvailable;
                                _this.dispatchEvent(event);
                            });
                            stream.addEventListener('complete', function (event) {
                                _this.dispatchEvent(event);
                                soundData.data = data._buffer;
                                soundData.mimeType = 'audio/mpeg';
                                soundData.completed = true;
                                if (!playUsingWebAudio) {
                                    _this._soundData = soundData;
                                    getAudioDescription(soundData, function (description) {
                                        _this._length = description.duration;
                                    });
                                    _this._playQueue.forEach(function (item) {
                                        item.channel._playSoundDataViaAudio(soundData, item.startTime);
                                    });
                                }
                                if (mp3DecodingSession) {
                                    mp3DecodingSession.close();
                                }
                            });
                            stream.load(request);
                        };
                        // Called whenever the class is initialized.
                        Sound.classInitializer = null;
                        // List of static symbols to link.
                        Sound.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Sound.instanceSymbols = null;
                        // ["load"];
                        return Sound;
                    }(flash.events.EventDispatcher);
                    media.Sound = Sound;
                    var SoundSymbol = function (_super) {
                        __extends(SoundSymbol, _super);
                        function SoundSymbol(data, sec) {
                            _super.call(this, data, sec.flash.media.Sound.axClass);
                        }
                        SoundSymbol.FromData = function (data, loaderInfo) {
                            var symbol = new SoundSymbol(data, loaderInfo.sec);
                            symbol.channels = data.channels;
                            symbol.sampleRate = data.sampleRate;
                            symbol.pcm = data.pcm;
                            symbol.packaged = data.packaged;
                            return symbol;
                        };
                        return SoundSymbol;
                    }(Shumway.Timeline.Symbol);
                    media.SoundSymbol = SoundSymbol;
                    var assert = Shumway.Debug.assert;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var error = Shumway.Debug.error;
                    function createAudioChannel(sampleRate, channels) {
                        if (WebAudioChannel.isSupported) {
                            return new WebAudioChannel(sampleRate, channels);
                        } else {
                            error('PCM data playback is not supported by the browser');
                        }
                    }
                    var AudioResampler = function () {
                        function AudioResampler(sourceRate, targetRate) {
                            this._sourceRate = sourceRate;
                            this._targetRate = targetRate;
                            this._tail = [];
                            this._sourceOffset = 0;
                        }
                        AudioResampler.prototype.getData = function (channelsData, count) {
                            var k = this._sourceRate / this._targetRate;
                            var offset = this._sourceOffset;
                            var needed = Math.ceil((count - 1) * k + offset) + 1;
                            var sourceData = [];
                            for (var channel = 0; channel < channelsData.length; channel++) {
                                sourceData.push(new Float32Array(needed));
                            }
                            var e = {
                                data: sourceData,
                                count: needed
                            };
                            this.ondatarequested(e);
                            for (var channel = 0; channel < channelsData.length; channel++) {
                                var data = channelsData[channel];
                                var source = sourceData[channel];
                                for (var j = 0; j < count; j++) {
                                    var i = j * k + offset;
                                    var i1 = i | 0, i2 = Math.ceil(i) | 0;
                                    var source_i1 = i1 < 0 ? this._tail[channel] : source[i1];
                                    if (i1 === i2) {
                                        data[j] = source_i1;
                                    } else {
                                        var alpha = i - i1;
                                        data[j] = source_i1 * (1 - alpha) + source[i2] * alpha;
                                    }
                                }
                                this._tail[channel] = source[needed - 1];
                            }
                            this._sourceOffset = (count - 1) * k + offset - (needed - 1);
                        };
                        return AudioResampler;
                    }();
                    var WebAudioChannel = function () {
                        function WebAudioChannel(sampleRate, channels) {
                            var context = WebAudioChannel._cachedContext;
                            if (!context) {
                                context = new AudioContext();
                                WebAudioChannel._cachedContext = context;
                            }
                            this._context = context;
                            this._contextSampleRate = context.sampleRate || 44100;
                            this._channels = channels;
                            this._sampleRate = sampleRate;
                            if (this._contextSampleRate !== sampleRate) {
                                this._resampler = new AudioResampler(sampleRate, this._contextSampleRate);
                                this._resampler.ondatarequested = function (e) {
                                    this.requestData(e.data, e.count);
                                }.bind(this);
                            }
                        }
                        WebAudioChannel.prototype.setVolume = function (value) {
                        };
                        WebAudioChannel.prototype.start = function () {
                            var source = this._context.createScriptProcessor(2048, 0, this._channels);
                            var self = this;
                            source.onaudioprocess = function (e) {
                                var channelsData = [];
                                for (var i = 0; i < self._channels; i++) {
                                    channelsData.push(e.outputBuffer.getChannelData(i));
                                }
                                var count = channelsData[0].length;
                                if (self._resampler) {
                                    self._resampler.getData(channelsData, count);
                                } else {
                                    self.requestData(channelsData, count);
                                }
                            };
                            source.connect(this._context.destination);
                            this._source = source;
                        };
                        WebAudioChannel.prototype.stop = function () {
                            this._source.disconnect(this._context.destination);
                        };
                        WebAudioChannel.prototype.requestData = function (channelsData, count) {
                            var channels = this._channels;
                            var buffer = new Float32Array(count * channels);
                            var e = {
                                data: buffer,
                                count: buffer.length
                            };
                            this.ondatarequested(e);
                            for (var j = 0, p = 0; j < count; j++) {
                                for (var i = 0; i < channels; i++) {
                                    channelsData[i][j] = buffer[p++];
                                }
                            }
                        };
                        WebAudioChannel.isSupported = function () {
                            return typeof AudioContext !== 'undefined';
                        };
                        return WebAudioChannel;
                    }();
                    var SoundChannel = function (_super) {
                        __extends(SoundChannel, _super);
                        function SoundChannel() {
                            _super.call(this);
                            this._element = null;
                            this._position = 0;
                            this._leftPeak = 0;
                            this._rightPeak = 0;
                            this._pcmData = null;
                            this._soundTransform = new this.sec.flash.media.SoundTransform();
                            this._playing = false;
                            this._element = null;
                        }
                        SoundChannel.initializeFromAudioElement = function (sec, element) {
                            var channel = new sec.flash.media.SoundChannel();
                            channel._element = element;
                            media.SoundMixer._registerSoundSource(channel);
                            return channel;
                        };
                        Object.defineProperty(SoundChannel.prototype, 'position', {
                            get: function () {
                                return this._position;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundChannel.prototype, 'soundTransform', {
                            get: function () {
                                return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                release || somewhatImplemented('public flash.media.SoundChannel::set soundTransform');
                                this._soundTransform = Shumway.isNullOrUndefined(sndTransform) ? new this.sec.flash.media.SoundTransform() : sndTransform;
                                media.SoundMixer._updateSoundSource(this);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundChannel.prototype, 'leftPeak', {
                            get: function () {
                                return this._leftPeak;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundChannel.prototype, 'rightPeak', {
                            get: function () {
                                return this._rightPeak;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundChannel.prototype, 'playing', {
                            get: function () {
                                return this._playing;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SoundChannel.prototype.stop = function () {
                            if (this._element) {
                                media.SoundMixer._unregisterSoundSource(this);
                                this._element.loop = false;
                                this._element.pause();
                                this._element.removeAttribute('src');
                                this._playing = false;
                            }
                            if (this._audioChannel) {
                                media.SoundMixer._unregisterSoundSource(this);
                                this._audioChannel.stop();
                                this._playing = false;
                            }
                        };
                        SoundChannel.prototype._playSoundDataViaAudio = function (soundData, startTime, loops) {
                            if (!soundData.mimeType) {
                                return;
                            }
                            media.SoundMixer._registerSoundSource(this);
                            this._position = startTime;
                            var self = this;
                            var lastCurrentTime = 0;
                            var element = document.createElement('audio');
                            if (!element.canPlayType(soundData.mimeType)) {
                                console.error('ERROR: "' + soundData.mimeType + '" ' + 'type playback is not supported by the browser');
                                return;
                            }
                            element.preload = 'metadata';
                            // for mobile devices
                            element.loop = loops > 0;
                            // starts loop played if at least one is specified
                            var blob = new Blob([soundData.data], { type: soundData.mimeType });
                            element.src = URL.createObjectURL(blob);
                            element.addEventListener('loadeddata', function loaded() {
                                element.currentTime = startTime / 1000;
                                element.play();
                            });
                            element.addEventListener('timeupdate', function timeupdate() {
                                var currentTime = element.currentTime;
                                if (loops && lastCurrentTime > currentTime) {
                                    --loops;
                                    if (!loops) {
                                        element.loop = false;
                                    }
                                    if (currentTime < startTime / 1000) {
                                        element.currentTime = startTime / 1000;
                                    }
                                }
                                self._position = (lastCurrentTime = currentTime) * 1000;
                            });
                            element.addEventListener('ended', function ended() {
                                media.SoundMixer._unregisterSoundSource(self);
                                self._element = null;
                                self._playing = false;
                                self.dispatchEvent(new self.sec.flash.events.Event('soundComplete', false, false));
                            });
                            this._element = element;
                            this._playing = true;
                            media.SoundMixer._updateSoundSource(this);
                        };
                        SoundChannel.prototype._playSoundDataViaChannel = function (soundData, startTime, loops) {
                            release || assert(soundData.pcm, 'no pcm data found');
                            media.SoundMixer._registerSoundSource(this);
                            var self = this;
                            var startPosition = Math.round(startTime / 1000 * soundData.sampleRate) * soundData.channels;
                            var position = startPosition;
                            this._position = startTime;
                            this._audioChannel = createAudioChannel(soundData.sampleRate, soundData.channels);
                            this._audioChannel.ondatarequested = function (e) {
                                var end = soundData.end;
                                if (position >= end && soundData.completed) {
                                    // end of buffer
                                    media.SoundMixer._unregisterSoundSource(this);
                                    self._audioChannel.stop();
                                    self._playing = false;
                                    self.dispatchEvent(new self.sec.flash.events.Event('soundComplete', false, false));
                                    return;
                                }
                                var left = e.count;
                                var data = e.data;
                                var source = soundData.pcm;
                                do {
                                    var count = Math.min(end - position, left);
                                    for (var j = 0; j < count; j++) {
                                        data[j] = source[position++];
                                    }
                                    left -= count;
                                    if (position >= end) {
                                        if (!loops) {
                                            break;
                                        }
                                        loops--;
                                        position = startPosition;
                                    }
                                } while (left > 0);
                                self._position = position / soundData.sampleRate / soundData.channels * 1000;
                            };
                            this._audioChannel.start();
                            this._playing = true;
                            media.SoundMixer._updateSoundSource(this);
                        };
                        SoundChannel.prototype.stopSound = function () {
                            this.stop();
                        };
                        SoundChannel.prototype.updateSoundLevels = function (volume) {
                            if (this._element) {
                                this._element.volume = volume <= 0 ? 0 : volume >= 1 ? 1 : volume;
                            }
                            if (this._audioChannel) {
                                this._audioChannel.setVolume(volume);
                            }
                        };
                        SoundChannel.classInitializer = null;
                        return SoundChannel;
                    }(flash.events.EventDispatcher);
                    media.SoundChannel = SoundChannel;
                    var SoundLoaderContext = function (_super) {
                        __extends(SoundLoaderContext, _super);
                        function SoundLoaderContext(bufferTime, checkPolicyFile) {
                            if (bufferTime === void 0) {
                                bufferTime = 1000;
                            }
                            if (checkPolicyFile === void 0) {
                                checkPolicyFile = false;
                            }
                            _super.call(this);
                            this.bufferTime = +bufferTime;
                            this.checkPolicyFile = !!checkPolicyFile;
                        }
                        // Called whenever the class is initialized.
                        SoundLoaderContext.classInitializer = null;
                        // List of static symbols to link.
                        SoundLoaderContext.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        SoundLoaderContext.instanceSymbols = null;
                        // ["bufferTime", "checkPolicyFile"];
                        return SoundLoaderContext;
                    }(AS.ASObject);
                    media.SoundLoaderContext = SoundLoaderContext;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var SoundMixer = function (_super) {
                        __extends(SoundMixer, _super);
                        function SoundMixer() {
                            _super.call(this);
                        }
                        Object.defineProperty(SoundMixer, 'bufferTime', {
                            // static _audioPlaybackMode: string;
                            // static _useSpeakerphoneForVoice: boolean;
                            get: function () {
                                release || notImplemented('public flash.media.SoundMixer::get bufferTime');
                                return SoundMixer._bufferTime;
                            },
                            set: function (bufferTime) {
                                release || somewhatImplemented('public flash.media.SoundMixer::set bufferTime');
                                SoundMixer._bufferTime = bufferTime | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundMixer, 'soundTransform', {
                            get: function () {
                                release || somewhatImplemented('public flash.media.SoundMixer::get soundTransform');
                                return Shumway.isNullOrUndefined(SoundMixer._soundTransform) ? new this.sec.flash.media.SoundTransform() : new this.sec.flash.media.SoundTransform(SoundMixer._soundTransform.volume, SoundMixer._soundTransform.pan);
                            },
                            set: function (sndTransform) {
                                release || somewhatImplemented('public flash.media.SoundMixer::set soundTransform');
                                SoundMixer._soundTransform = Shumway.isNullOrUndefined(sndTransform) ? new this.sec.flash.media.SoundTransform() : sndTransform;
                                SoundMixer._updateAllSoundSources();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundMixer, 'audioPlaybackMode', {
                            get: function () {
                                release || notImplemented('public flash.media.SoundMixer::get audioPlaybackMode');
                                return;    // return SoundMixer._audioPlaybackMode;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                release || notImplemented('public flash.media.SoundMixer::set audioPlaybackMode');
                                return;    // SoundMixer._audioPlaybackMode = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundMixer, 'useSpeakerphoneForVoice', {
                            get: function () {
                                release || notImplemented('public flash.media.SoundMixer::get useSpeakerphoneForVoice');
                                return;    // return SoundMixer._useSpeakerphoneForVoice;
                            },
                            set: function (value) {
                                value = !!value;
                                release || notImplemented('public flash.media.SoundMixer::set useSpeakerphoneForVoice');
                                return;    // SoundMixer._useSpeakerphoneForVoice = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SoundMixer.stopAll = function () {
                            SoundMixer._registeredSoundSources.forEach(function (channel) {
                                channel.stopSound();
                            });
                            SoundMixer._registeredSoundSources = [];
                        };
                        SoundMixer.computeSpectrum = function (outputArray, FFTMode, stretchFactor) {
                            if (FFTMode === void 0) {
                                FFTMode = false;
                            }
                            if (stretchFactor === void 0) {
                                stretchFactor = 0;
                            }
                            FFTMode = !!FFTMode;
                            stretchFactor = stretchFactor | 0;
                            release || somewhatImplemented('public flash.media.SoundMixer::static computeSpectrum');
                            var data = new Float32Array(1024);
                            for (var i = 0; i < 1024; i++) {
                                data[i] = Math.random();
                            }
                            outputArray.writeRawBytes(data);
                            outputArray.position = 0;
                        };
                        SoundMixer.areSoundsInaccessible = function () {
                            release || notImplemented('public flash.media.SoundMixer::static areSoundsInaccessible');
                            return;
                        };
                        SoundMixer._getMasterVolume = function () {
                            return SoundMixer._masterVolume;
                        };
                        SoundMixer._setMasterVolume = function (volume) {
                            volume = +volume;
                            SoundMixer._masterVolume = volume;
                            SoundMixer._updateAllSoundSources();
                        };
                        SoundMixer._registerSoundSource = function (source) {
                            SoundMixer._registeredSoundSources.push(source);
                        };
                        SoundMixer._unregisterSoundSource = function (source) {
                            var index = SoundMixer._registeredSoundSources.indexOf(source);
                            if (index >= 0) {
                                SoundMixer._registeredSoundSources.splice(index, 1);
                            }
                        };
                        SoundMixer._updateSoundSource = function (source) {
                            var volume = source.soundTransform.volume;
                            if (SoundMixer._soundTransform) {
                                volume *= SoundMixer._soundTransform.volume;
                            }
                            volume *= SoundMixer._getMasterVolume();
                            source.updateSoundLevels(volume);
                        };
                        SoundMixer._updateAllSoundSources = function () {
                            SoundMixer._registeredSoundSources.forEach(SoundMixer._updateSoundSource);
                        };
                        // Called whenever the class is initialized.
                        SoundMixer.classInitializer = null;
                        // List of static symbols to link.
                        SoundMixer.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        SoundMixer.instanceSymbols = null;
                        // [];
                        SoundMixer._masterVolume = 1;
                        SoundMixer._registeredSoundSources = [];
                        SoundMixer._bufferTime = 0;
                        return SoundMixer;
                    }(AS.ASObject);
                    media.SoundMixer = SoundMixer;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var SoundTransform = function (_super) {
                        __extends(SoundTransform, _super);
                        function SoundTransform(vol, panning) {
                            if (vol === void 0) {
                                vol = 1;
                            }
                            if (panning === void 0) {
                                panning = 0;
                            }
                            _super.call(this);
                            this.volume = +vol;
                            this.pan = +panning;
                        }
                        Object.defineProperty(SoundTransform.prototype, 'volume', {
                            get: function () {
                                return this._volume;
                            },
                            set: function (volume) {
                                volume = +volume;
                                this._volume = volume;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, 'leftToLeft', {
                            get: function () {
                                return this._leftToLeft;
                            },
                            set: function (leftToLeft) {
                                leftToLeft = +leftToLeft;
                                this._leftToLeft = leftToLeft;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, 'leftToRight', {
                            get: function () {
                                return this._leftToRight;
                            },
                            set: function (leftToRight) {
                                leftToRight = +leftToRight;
                                this._leftToRight = leftToRight;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, 'rightToRight', {
                            get: function () {
                                return this._rightToRight;
                            },
                            set: function (rightToRight) {
                                rightToRight = +rightToRight;
                                this._rightToRight = rightToRight;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, 'rightToLeft', {
                            get: function () {
                                return this._rightToLeft;
                            },
                            set: function (rightToLeft) {
                                rightToLeft = +rightToLeft;
                                this._rightToLeft = rightToLeft;
                                this._updateTransform();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SoundTransform.prototype, 'pan', {
                            get: function () {
                                if (this._leftToRight === 0 && this._rightToLeft === 0) {
                                    return 1 - this._leftToLeft * this._leftToLeft;
                                }
                                return 0;
                            },
                            set: function (panning) {
                                this.leftToLeft = Math.sqrt(1 - panning);
                                this.leftToRight = 0;
                                this.rightToRight = Math.sqrt(1 + panning);
                                this.rightToLeft = 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SoundTransform.prototype._updateTransform = function () {
                            release || somewhatImplemented('public flash.media.SoundTransform::_updateTransform');    // TODO dispatch updates to the current audio destinations?
                        };
                        // Called whenever the class is initialized.
                        SoundTransform.classInitializer = null;
                        // List of static symbols to link.
                        SoundTransform.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        SoundTransform.instanceSymbols = null;
                        // [];
                        return SoundTransform;
                    }(AS.ASObject);
                    media.SoundTransform = SoundTransform;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var StageVideo = function (_super) {
                        __extends(StageVideo, _super);
                        function StageVideo() {
                            _super.call(this);
                        }
                        Object.defineProperty(StageVideo.prototype, 'viewPort', {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // _viewPort: flash.geom.Rectangle;
                            // _pan: flash.geom.Point;
                            // _zoom: flash.geom.Point;
                            // _depth: number /*int*/;
                            // _videoWidth: number /*int*/;
                            // _videoHeight: number /*int*/;
                            // _colorSpaces: ASVector<any>;
                            get: function () {
                                release || notImplemented('public flash.media.StageVideo::get viewPort');
                                return;    // return this._viewPort;
                            },
                            set: function (rect) {
                                rect = rect;
                                release || notImplemented('public flash.media.StageVideo::set viewPort');
                                return;    // this._viewPort = rect;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(StageVideo.prototype, 'pan', {
                            get: function () {
                                release || notImplemented('public flash.media.StageVideo::get pan');
                                return;    // return this._pan;
                            },
                            set: function (point) {
                                point = point;
                                release || notImplemented('public flash.media.StageVideo::set pan');
                                return;    // this._pan = point;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(StageVideo.prototype, 'zoom', {
                            get: function () {
                                release || notImplemented('public flash.media.StageVideo::get zoom');
                                return;    // return this._zoom;
                            },
                            set: function (point) {
                                point = point;
                                release || notImplemented('public flash.media.StageVideo::set zoom');
                                return;    // this._zoom = point;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(StageVideo.prototype, 'depth', {
                            get: function () {
                                release || notImplemented('public flash.media.StageVideo::get depth');
                                return;    // return this._depth;
                            },
                            set: function (depth) {
                                depth = depth | 0;
                                release || notImplemented('public flash.media.StageVideo::set depth');
                                return;    // this._depth = depth;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(StageVideo.prototype, 'videoWidth', {
                            get: function () {
                                release || notImplemented('public flash.media.StageVideo::get videoWidth');
                                return;    // return this._videoWidth;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(StageVideo.prototype, 'videoHeight', {
                            get: function () {
                                release || notImplemented('public flash.media.StageVideo::get videoHeight');
                                return;    // return this._videoHeight;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(StageVideo.prototype, 'colorSpaces', {
                            get: function () {
                                release || notImplemented('public flash.media.StageVideo::get colorSpaces');
                                return;    // return this._colorSpaces;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        StageVideo.prototype.attachNetStream = function (netStream) {
                            netStream = netStream;
                            release || notImplemented('public flash.media.StageVideo::attachNetStream');
                            return;
                        };
                        StageVideo.prototype.attachCamera = function (theCamera) {
                            theCamera = theCamera;
                            release || notImplemented('public flash.media.StageVideo::attachCamera');
                            return;
                        };
                        // Called whenever the class is initialized.
                        StageVideo.classInitializer = null;
                        // List of static symbols to link.
                        StageVideo.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        StageVideo.instanceSymbols = null;
                        // [];
                        return StageVideo;
                    }(flash.events.EventDispatcher);
                    media.StageVideo = StageVideo;
                    var StageVideoAvailability = function (_super) {
                        __extends(StageVideoAvailability, _super);
                        function StageVideoAvailability() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        StageVideoAvailability.classInitializer = null;
                        // List of static symbols to link.
                        StageVideoAvailability.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        StageVideoAvailability.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        StageVideoAvailability.AVAILABLE = 'available';
                        StageVideoAvailability.UNAVAILABLE = 'unavailable';
                        return StageVideoAvailability;
                    }(AS.ASObject);
                    media.StageVideoAvailability = StageVideoAvailability;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var assert = Shumway.Debug.assert;
                    var Video = function (_super) {
                        __extends(Video, _super);
                        function Video(width, height) {
                            if (width === void 0) {
                                width = 320;
                            }
                            if (height === void 0) {
                                height = 240;
                            }
                            width |= 0;
                            height |= 0;
                            if (this._symbol && !this._fieldsInitialized) {
                                this.applySymbol();
                            }
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                            if (!this._symbol) {
                                width = width || 320;
                                height = height || 240;
                                this._setFillAndLineBoundsFromWidthAndHeight(width * 20, height * 20);
                            }
                        }
                        Video.prototype.applySymbol = function () {
                            this._initializeFields();
                            var symbol = this._symbol;
                            this._deblocking = symbol.deblocking;
                            this._smoothing = symbol.smoothing;
                            this._setFillAndLineBoundsFromWidthAndHeight(symbol.width * 20, symbol.height * 20);
                        };
                        Video.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this);
                            this._deblocking = 0;
                            this._smoothing = false;
                            this._videoWidth = 0;
                            this._videoHeight = 0;
                        };
                        Object.defineProperty(Video.prototype, 'deblocking', {
                            get: function () {
                                return this._deblocking;
                            },
                            set: function (value) {
                                this._deblocking = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Video.prototype, 'smoothing', {
                            get: function () {
                                return this._smoothing;
                            },
                            set: function (value) {
                                this._smoothing = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Video.prototype, 'videoWidth', {
                            get: function () {
                                return this._videoWidth;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Video.prototype, 'videoHeight', {
                            get: function () {
                                return this._videoHeight;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Video.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                            // If this override is reached, the content bounds have already been checked, which is all
                            // we need to do.
                            release || assert(this._getContentBounds().contains(localX, localY));
                            return true;
                        };
                        Video.prototype.clear = function () {
                            release || somewhatImplemented('public flash.media.Video::clear');
                            return;
                        };
                        Video.prototype.attachNetStream = function (netStream) {
                            if (this._netStream === netStream) {
                                return;
                            }
                            if (this._netStream) {
                                this._netStream._videoReferrer = null;
                            }
                            this._netStream = netStream;
                            if (this._netStream) {
                                netStream._videoReferrer = this;
                            }
                            this._setDirtyFlags(32    /* DirtyNetStream */);
                        };
                        Video.prototype.attachCamera = function (camera) {
                            release || notImplemented('public flash.media.Video::attachCamera');
                            return;
                        };
                        Video.classInitializer = null;
                        Video.classSymbols = null;
                        Video.instanceSymbols = null;
                        return Video;
                    }(flash.display.DisplayObject);
                    media.Video = Video;
                    var VideoSymbol = function (_super) {
                        __extends(VideoSymbol, _super);
                        function VideoSymbol(data, sec) {
                            _super.call(this, data, sec.flash.media.Video.axClass, true);
                        }
                        VideoSymbol.FromData = function (data, loaderInfo) {
                            var symbol = new VideoSymbol(data, loaderInfo.sec);
                            symbol.width = data.width;
                            symbol.height = data.height;
                            symbol.deblocking = data.deblocking;
                            symbol.smoothing = data.smoothing;
                            symbol.codec = data.codec;
                            return symbol;
                        };
                        return VideoSymbol;
                    }(Shumway.Timeline.DisplaySymbol);
                    media.VideoSymbol = VideoSymbol;
                    var VideoStreamSettings = function (_super) {
                        __extends(VideoStreamSettings, _super);
                        function VideoStreamSettings() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        VideoStreamSettings.classInitializer = null;
                        // List of static symbols to link.
                        VideoStreamSettings.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        VideoStreamSettings.instanceSymbols = null;
                        // ["width", "height", "fps", "quality", "bandwidth", "keyFrameInterval", "codec", "setMode", "setQuality", "setKeyFrameInterval"];
                        return VideoStreamSettings;
                    }(AS.ASObject);
                    media.VideoStreamSettings = VideoStreamSettings;
                }(media = flash.media || (flash.media = {})));
                var net;
                (function (net) {
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var FileFilter = function (_super) {
                        __extends(FileFilter, _super);
                        function FileFilter(description, extension, macType) {
                            if (macType === void 0) {
                                macType = null;
                            }
                            _super.call(this);
                        }
                        Object.defineProperty(FileFilter.prototype, 'description', {
                            get: function () {
                                return this._description;
                            },
                            set: function (value) {
                                this._description = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileFilter.prototype, 'extension', {
                            get: function () {
                                return this._extension;
                            },
                            set: function (value) {
                                this._extension = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileFilter.prototype, 'macType', {
                            get: function () {
                                return this._macType;
                            },
                            set: function (value) {
                                this._macType = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // Called whenever the class is initialized.
                        FileFilter.classInitializer = null;
                        // List of static symbols to link.
                        FileFilter.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        FileFilter.instanceSymbols = null;
                        // [];
                        return FileFilter;
                    }(AS.ASObject);
                    net.FileFilter = FileFilter;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var FileReference = function (_super) {
                        __extends(FileReference, _super);
                        function FileReference() {
                            _super.call(this);
                        }
                        Object.defineProperty(FileReference.prototype, 'creationDate', {
                            // _creationDate: ASDate;
                            // _creator: string;
                            // _modificationDate: ASDate;
                            // _name: string;
                            // _size: number;
                            // _type: string;
                            // _data: flash.utils.ByteArray;
                            get: function () {
                                release || notImplemented('public flash.net.FileReference::get creationDate');
                                return;    // return this._creationDate;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileReference.prototype, 'creator', {
                            get: function () {
                                release || notImplemented('public flash.net.FileReference::get creator');
                                return;    // return this._creator;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileReference.prototype, 'modificationDate', {
                            get: function () {
                                release || notImplemented('public flash.net.FileReference::get modificationDate');
                                return;    // return this._modificationDate;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileReference.prototype, 'name', {
                            get: function () {
                                release || notImplemented('public flash.net.FileReference::get name');
                                return;    // return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileReference.prototype, 'size', {
                            get: function () {
                                release || notImplemented('public flash.net.FileReference::get size');
                                return;    // return this._size;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(FileReference.prototype, 'type', {
                            get: function () {
                                release || notImplemented('public flash.net.FileReference::get type');
                                return;    // return this._type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        FileReference.prototype.cancel = function () {
                            release || notImplemented('public flash.net.FileReference::cancel');
                            return;
                        };
                        FileReference.prototype.download = function (request, defaultFileName) {
                            if (defaultFileName === void 0) {
                                defaultFileName = null;
                            }
                            request = request;
                            defaultFileName = axCoerceString(defaultFileName);
                            release || notImplemented('public flash.net.FileReference::download');
                            return;
                        };
                        FileReference.prototype.upload = function (request, uploadDataFieldName, testUpload) {
                            if (uploadDataFieldName === void 0) {
                                uploadDataFieldName = 'Filedata';
                            }
                            if (testUpload === void 0) {
                                testUpload = false;
                            }
                            request = request;
                            uploadDataFieldName = axCoerceString(uploadDataFieldName);
                            testUpload = !!testUpload;
                            release || notImplemented('public flash.net.FileReference::upload');
                            return;
                        };
                        Object.defineProperty(FileReference.prototype, 'data', {
                            get: function () {
                                release || notImplemented('public flash.net.FileReference::get data');
                                return;    // return this._data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        FileReference.prototype.browse = function (typeFilter) {
                            if (typeFilter === void 0) {
                                typeFilter = null;
                            }
                            typeFilter = typeFilter;
                            release || notImplemented('public flash.net.FileReference::browse');
                            return;
                        };
                        FileReference.classInitializer = null;
                        return FileReference;
                    }(flash.events.EventDispatcher);
                    net.FileReference = FileReference;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var FileReferenceList = function (_super) {
                        __extends(FileReferenceList, _super);
                        function FileReferenceList() {
                            _super.call(this);
                        }
                        Object.defineProperty(FileReferenceList.prototype, 'fileList', {
                            // _fileList: any [];
                            get: function () {
                                release || notImplemented('public flash.net.FileReferenceList::get fileList');
                                return;    // return this._fileList;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        FileReferenceList.prototype.browse = function (typeFilter) {
                            if (typeFilter === void 0) {
                                typeFilter = null;
                            }
                            typeFilter = typeFilter;
                            release || notImplemented('public flash.net.FileReferenceList::browse');
                            return;
                        };
                        FileReferenceList.classInitializer = null;
                        return FileReferenceList;
                    }(flash.events.EventDispatcher);
                    net.FileReferenceList = FileReferenceList;
                    var assert = Shumway.Debug.assert;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var forbiddenNames = [
                        'send',
                        'connect',
                        'close',
                        'allowDomain',
                        'allowInsecureDomain',
                        'client',
                        'domain'
                    ];
                    Object.freeze(forbiddenNames);
                    var LocalConnection = function (_super) {
                        __extends(LocalConnection, _super);
                        function LocalConnection() {
                            _super.call(this);
                            this._client = this;
                            this._connectionName = null;
                            this._allowedInsecureDomains = [];
                            this._allowedSecureDomains = [];
                            // tsc contains a definition for URL that's non-constructible.
                            var url = new URL(Shumway.AVMX.getCurrentABC().env.url);
                            this._domain = url.hostname;
                            this._secure = url.protocol === 'https:';
                        }
                        Object.defineProperty(LocalConnection, 'isSupported', {
                            get: function () {
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        LocalConnection.prototype.close = function () {
                            var connectionName = this._connectionName;
                            if (!connectionName) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.CloseNotConnectedError);
                            }
                            release || assert(typeof connectionName === 'string' && connectionName.length > 0);
                            this._connectionName = null;
                            // TODO: verify that these really are reset. For now, we aim to err on the safe side.
                            this._allowedInsecureDomains = [];
                            this._allowedSecureDomains = [];
                            Shumway.LocalConnectionService.instance.closeConnection(connectionName, this);
                        };
                        LocalConnection.prototype.connect = function (connectionName) {
                            connectionName = axCoerceString(connectionName);
                            if (connectionName === null) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'connectionName');
                            }
                            if (connectionName === '') {
                                this.sec.throwError('TypeError', AVMX.Errors.EmptyStringError, 'connectionName');
                            }
                            // The only disallowed character for the connection name is ":".
                            if (connectionName.indexOf(':') > -1) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.InvalidParamError);
                            }
                            if (this._connectionName) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.AlreadyConnectedError);
                            }
                            var result = Shumway.LocalConnectionService.instance.createConnection(connectionName, this);
                            if (result === -2    /* AlreadyTaken */) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.AlreadyConnectedError);
                            }
                            this._connectionName = connectionName;
                            release || assert(result === 0    /* Success */);
                            if (this._allowedInsecureDomains.length) {
                                Shumway.LocalConnectionService.instance.allowDomains(connectionName, this, this._allowedInsecureDomains, false);
                            }
                            if (this._allowedSecureDomains.length) {
                                Shumway.LocalConnectionService.instance.allowDomains(connectionName, this, this._allowedSecureDomains, true);
                            }
                        };
                        LocalConnection.prototype.send = function (connectionName, methodName) {
                            var args = [];
                            for (var _i = 2; _i < arguments.length; _i++) {
                                args[_i - 2] = arguments[_i];
                            }
                            connectionName = axCoerceString(connectionName);
                            methodName = axCoerceString(methodName);
                            if (connectionName === null) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'connectionName');
                            }
                            if (connectionName === '') {
                                this.sec.throwError('TypeError', AVMX.Errors.EmptyStringError, 'connectionName');
                            }
                            if (methodName === null) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'methodName');
                            }
                            if (methodName === '') {
                                this.sec.throwError('TypeError', AVMX.Errors.EmptyStringError, 'methodName');
                            }
                            if (forbiddenNames.indexOf(methodName) > -1) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.InvalidParamError);
                            }
                            var serializedArgs = new this.sec.flash.utils.ByteArray();
                            serializedArgs.writeObject(this.sec.createArrayUnsafe(args));
                            if (serializedArgs.length > 40 * 1024) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.ArgumentSizeError);
                            }
                            var argsBuffer = serializedArgs.getBytes().buffer;
                            try {
                                Shumway.LocalConnectionService.instance.send(connectionName, methodName, argsBuffer, this, this._domain, this._secure);
                            } catch (e) {
                                // Not sure what to do here, this shouldn't happen. We'll just ignore it with a warning.
                                Shumway.Debug.warning('Unknown error occurred in LocalConnection#send', e);
                            }
                        };
                        Object.defineProperty(LocalConnection.prototype, 'client', {
                            get: function () {
                                return this._client;
                            },
                            set: function (client) {
                                if (!this.sec.AXObject.axIsType(client)) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidParamError);
                                }
                                this._client = client;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        LocalConnection.prototype.allowDomain = function () {
                            var domains = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                domains[_i - 0] = arguments[_i];
                            }
                            this._allowDomains(domains, true);
                        };
                        LocalConnection.prototype.allowInsecureDomain = function () {
                            var domains = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                domains[_i - 0] = arguments[_i];
                            }
                            // allowInsecureDomain also allows secure domains.
                            this._allowDomains(domains, true);
                            this._allowDomains(domains, false);
                        };
                        LocalConnection.prototype._allowDomains = function (domains, secure) {
                            var result = [];
                            // If no connection has been made yet, store the domains for later retrieval.
                            if (!this._connectionName) {
                                result = secure ? this._allowedSecureDomains : this._allowedInsecureDomains;
                            }
                            for (var i = 0; i < domains.length; i++) {
                                var domain = domains[i];
                                if (!AVMX.axIsTypeString(domain)) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.AllowDomainArgumentError);
                                }
                                if (result.indexOf(domain) === -1) {
                                    result.push(domain);
                                }
                            }
                            if (this._connectionName) {
                                Shumway.LocalConnectionService.instance.allowDomains(this._connectionName, this, domains, secure);
                            }
                        };
                        LocalConnection.prototype.handleMessage = function (methodName, argsBuffer) {
                            var client = this._client;
                            var error;
                            if (!client.axHasPublicProperty(methodName) || forbiddenNames.indexOf(methodName) > -1) {
                                // Forbidden names really shouldn't reach this point, but should everything else fail,
                                // we just pretend not to have found them here.
                                error = this.sec.createError('ReferenceError', AVMX.Errors.ReadSealedError, methodName, client.axClass.name.name);
                            } else {
                                var handler = client.axGetPublicProperty(methodName);
                                if (!AVMX.axIsCallable(handler)) {
                                    // Non-callable handlers are just ignored.
                                    return;
                                }
                                var ba = new this.sec.flash.utils.ByteArray(argsBuffer);
                                var args = ba.readObject();
                                if (!this.sec.AXArray.axIsType(args)) {
                                    error = this.sec.createError('TypeError', AVMX.Errors.CheckTypeFailedError, args, 'Array');
                                } else {
                                    try {
                                        handler.apply(client, args.value);
                                    } catch (e) {
                                        error = e;
                                    }
                                }
                            }
                            if (!error) {
                                return;
                            }
                            var asyncErrorEventCtor = this.sec.flash.events.AsyncErrorEvent;
                            var errorEvent = new asyncErrorEventCtor('asyncError', false, false, 'Error #2095: flash.net.LocalConnection was' + ' unable to invoke' + ' callback ' + methodName + '.', error);
                            if (this.hasEventListener('asyncError')) {
                                try {
                                    this.dispatchEvent(errorEvent);
                                } catch (e) {
                                    console.warn('Exception encountered during asyncErrorEvent handling in ' + 'LocalConnection sender.');
                                }
                            } else {
                                // TODO: add the error to the LoaderInfo#uncaughtErrorEvents list.
                                console.warn('No handler for asyncError on LocalConnection sender, not sending event', errorEvent);
                            }
                        };
                        Object.defineProperty(LocalConnection.prototype, 'domain', {
                            get: function () {
                                return this._domain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LocalConnection.prototype, 'isPerUser', {
                            get: function () {
                                // We always return true, because everything else would be a lie.
                                return true;
                            },
                            set: function (newValue) {
                                !!newValue;    // Ignored. See
                                               // https://blogs.adobe.com/simplicity/2009/08/localconnectionisperuser_in_ai.html for an
                                               // explanation.
                            },
                            enumerable: true,
                            configurable: true
                        });
                        LocalConnection.classInitializer = null;
                        return LocalConnection;
                    }(flash.events.EventDispatcher);
                    net.LocalConnection = LocalConnection;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var Telemetry = Shumway.Telemetry;
                    var NetConnection = function (_super) {
                        __extends(NetConnection, _super);
                        function NetConnection() {
                            _super.call(this);
                            this._uri = null;
                            this._connected = false;
                            this._client = null;
                            this._proxyType = 'none';
                            this._objectEncoding = NetConnection.defaultObjectEncoding;
                            this._usingTLS = false;
                            this._protocol = null;
                            Telemetry.instance.reportTelemetry({
                                topic: 'feature',
                                feature: 6    /* NETCONNECTION_FEATURE */
                            });
                        }
                        // JS -> AS Bindings
                        NetConnection.prototype.close = function () {
                            this.invoke(1);
                        };
                        NetConnection.prototype.addHeader = function (operation, mustUnderstand, param) {
                            if (mustUnderstand === void 0) {
                                mustUnderstand = false;
                            }
                            if (param === void 0) {
                                param = null;
                            }
                            this._invoke(3, [
                                AVMX.axCoerceString(operation),
                                !!mustUnderstand,
                                param
                            ]);
                        };
                        NetConnection.prototype.call = function (command, responder) {
                            arguments[0] = AVMX.axCoerceString(command);
                            this._invoke(2, arguments);
                        };
                        Object.defineProperty(NetConnection, 'defaultObjectEncoding', {
                            get: function () {
                                return NetConnection._defaultObjectEncoding;
                            },
                            set: function (version) {
                                version = version >>> 0;
                                NetConnection._defaultObjectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'connected', {
                            get: function () {
                                return this._connected;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'uri', {
                            get: function () {
                                return this._uri;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetConnection.prototype.connect = function (command) {
                            command = AVMX.axCoerceString(command);
                            release || somewhatImplemented('public flash.net.NetConnection::connect');
                            this._uri = command;
                            var netStatusEventCtor = this.sec.flash.events.NetStatusEvent;
                            if (!command) {
                                this._connected = true;
                                this.dispatchEvent(new netStatusEventCtor(flash.events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    level: 'status',
                                    code: 'NetConnection.Connect.Success'
                                })));
                            } else {
                                var parsedURL = RtmpJs.parseConnectionString(command);
                                if (!parsedURL || !parsedURL.host || parsedURL.protocol !== 'rtmp' && parsedURL.protocol !== 'rtmpt' && parsedURL.protocol !== 'rtmps') {
                                    this.dispatchEvent(new netStatusEventCtor(flash.events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                        level: 'status',
                                        code: 'NetConnection.Connect.Failed'
                                    })));
                                    return;
                                }
                                var service = this.sec.player;
                                var rtmpProps = this.sec.createObjectFromJS({
                                    app: parsedURL.app,
                                    flashver: flash.system.Capabilities.version,
                                    swfUrl: service.swfUrl,
                                    tcUrl: command,
                                    fpad: false,
                                    audioCodecs: 4095,
                                    videoCodecs: 255,
                                    videoFunction: 1,
                                    pageUrl: service.pageUrl || service.swfUrl,
                                    objectEncoding: 0
                                });
                                this._protocol = parsedURL.protocol;
                                var secured = parsedURL.protocol === 'rtmps' || parsedURL.protocol === 'rtmpt' && (parsedURL.port === 443 || parsedURL.port === 8443);
                                this._usingTLS = secured;
                                var rtmpConnection = parsedURL.protocol === 'rtmp' || parsedURL.protocol === 'rtmps' ? new RtmpJs.Browser.RtmpTransport({
                                    host: parsedURL.host,
                                    port: parsedURL.port || 1935,
                                    ssl: secured
                                }) : new RtmpJs.Browser.RtmptTransport({
                                    host: parsedURL.host,
                                    port: parsedURL.port || 80,
                                    ssl: secured
                                });
                                this._rtmpConnection = rtmpConnection;
                                this._rtmpCreateStreamCallbacks = [
                                    null,
                                    null
                                ];
                                // reserve first two
                                rtmpConnection.onresponse = function (e) {
                                };
                                rtmpConnection.onevent = function (e) {
                                };
                                rtmpConnection.onconnected = function (e) {
                                    this._connected = true;
                                    this.dispatchEvent(new this.sec.flash.events.NetStatusEvent(flash.events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                        level: 'status',
                                        code: 'NetConnection.Connect.Success'
                                    })));
                                }.bind(this);
                                rtmpConnection.onstreamcreated = function (e) {
                                    console.log('#streamcreated: ' + e.streamId);
                                    var callback = this._rtmpCreateStreamCallbacks[e.transactionId];
                                    delete this._rtmpCreateStreamCallbacks[e.transactionId];
                                    callback(e.stream, e.streamId);
                                }.bind(this);
                                rtmpConnection.connect(rtmpProps);
                            }
                        };
                        NetConnection.prototype._createRtmpStream = function (callback) {
                            var transactionId = this._rtmpCreateStreamCallbacks.length;
                            this._rtmpCreateStreamCallbacks[transactionId] = callback;
                            this._rtmpConnection.createStream(transactionId, null);
                        };
                        Object.defineProperty(NetConnection.prototype, 'client', {
                            get: function () {
                                return this._client;
                            },
                            set: function (object) {
                                this._client = object;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'objectEncoding', {
                            get: function () {
                                return this._objectEncoding;
                            },
                            set: function (version) {
                                version = version >>> 0;
                                release || somewhatImplemented('public flash.net.NetConnection::set objectEncoding');
                                this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'proxyType', {
                            get: function () {
                                return this._proxyType;
                            },
                            set: function (ptype) {
                                ptype = AVMX.axCoerceString(ptype);
                                release || somewhatImplemented('public flash.net.NetConnection::set proxyType');
                                this._proxyType = ptype;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'connectedProxyType', {
                            get: function () {
                                release || notImplemented('public flash.net.NetConnection::get connectedProxyType');
                                return;    // return this._connectedProxyType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'usingTLS', {
                            get: function () {
                                return this._usingTLS;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'protocol', {
                            get: function () {
                                return this._protocol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'maxPeerConnections', {
                            get: function () {
                                release || notImplemented('public flash.net.NetConnection::get maxPeerConnections');
                                return;    // return this._maxPeerConnections;
                            },
                            set: function (maxPeers) {
                                maxPeers = maxPeers >>> 0;
                                release || notImplemented('public flash.net.NetConnection::set maxPeerConnections');
                                return;    // this._maxPeerConnections = maxPeers;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'nearID', {
                            get: function () {
                                release || notImplemented('public flash.net.NetConnection::get nearID');
                                return;    // return this._nearID;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'farID', {
                            get: function () {
                                release || notImplemented('public flash.net.NetConnection::get farID');
                                return;    // return this._farID;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'nearNonce', {
                            get: function () {
                                release || notImplemented('public flash.net.NetConnection::get nearNonce');
                                return;    // return this._nearNonce;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'farNonce', {
                            get: function () {
                                release || notImplemented('public flash.net.NetConnection::get farNonce');
                                return;    // return this._farNonce;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetConnection.prototype, 'unconnectedPeerStreams', {
                            get: function () {
                                release || notImplemented('public flash.net.NetConnection::get unconnectedPeerStreams');
                                return;    // return this._unconnectedPeerStreams;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetConnection.prototype.invoke = function (index) {
                            index = index >>> 0;
                            return this._invoke(index, Array.prototype.slice.call(arguments, 1));
                        };
                        NetConnection.prototype._invoke = function (index, args) {
                            var simulated = false;
                            var result;
                            switch (index) {
                            case 1:
                            // close
                            case 2:
                                simulated = true;
                                break;
                            }
                            (simulated ? somewhatImplemented : notImplemented)('private flash.net.NetConnection::_invoke (' + index + ')');
                            return result;
                        };
                        // Called whenever the class is initialized.
                        NetConnection.classInitializer = null;
                        // AS -> JS Bindings
                        NetConnection._defaultObjectEncoding = 3    /* AMF3 */;
                        return NetConnection;
                    }(flash.events.EventDispatcher);
                    net.NetConnection = NetConnection;
                }(net = flash.net || (flash.net = {})));
                var net;
                (function (net_1) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var assert = Shumway.Debug.assert;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var events = Shumway.AVMX.AS.flash.events;
                    var FileLoadingService = Shumway.FileLoadingService;
                    var NetStream = function (_super) {
                        __extends(NetStream, _super);
                        function NetStream(connection, peerID) {
                            if (peerID === void 0) {
                                peerID = 'connectToFMS';
                            }
                            _super.call(this);
                            this._connection = connection;
                            this._peerID = axCoerceString(peerID);
                            this._id = flash.display.DisplayObject.getNextSyncID();
                            this._isDirty = true;
                            this._soundTransform = new this.sec.flash.media.SoundTransform();
                            this._contentTypeHint = null;
                            this._checkPolicyFile = true;
                            this._videoStream = new VideoStream(this);
                            this._videoStream._onEnsurePlay = function () {
                                this._notifyVideoControl(9    /* EnsurePlaying */, null);
                            }.bind(this);
                            this._resourceName = null;
                            this._metaData = null;
                        }
                        // _multicastPushNeighborLimit: number;
                        // _multicastWindowDuration: number;
                        // _multicastRelayMarginDuration: number;
                        // _multicastAvailabilityUpdatePeriod: number;
                        // _multicastFetchPeriod: number;
                        // _multicastAvailabilitySendToAll: boolean;
                        // _farID: string;
                        // _nearNonce: string;
                        // _farNonce: string;
                        // _peerStreams: any [];
                        // _audioReliable: boolean;
                        // _videoReliable: boolean;
                        // _dataReliable: boolean;
                        // _audioSampleAccess: boolean;
                        // _videoSampleAccess: boolean;
                        // _useHardwareDecoder: boolean;
                        // _useJitterBuffer: boolean;
                        // _videoStreamSettings: flash.media.VideoStreamSettings;
                        NetStream.prototype.dispose = function () {
                            release || notImplemented('public flash.net.NetStream::dispose');
                            return;
                        };
                        NetStream.prototype._getVideoStreamURL = function () {
                            return this._videoStream.url;
                        };
                        NetStream.prototype.play = function (url) {
                            flash.media.SoundMixer._registerSoundSource(this);
                            // (void) -> void ???
                            url = axCoerceString(url);
                            var service = this.sec.player;
                            service.registerEventListener(this._id, this.processVideoEvent.bind(this));
                            if (this._connection && this._connection.uri) {
                                this._videoStream.playInConnection(this._connection, url);
                            } else if (url === null) {
                                this._videoStream.openInDataGenerationMode();
                            } else {
                                this._videoStream.play(url, this.checkPolicyFile);
                            }
                            this._notifyVideoControl(1    /* Init */, { url: this._videoStream.url });
                        };
                        NetStream.prototype.play2 = function (param) {
                            param = param;
                            release || notImplemented('public flash.net.NetStream::play2');
                            return;
                        };
                        Object.defineProperty(NetStream.prototype, 'info', {
                            get: function () {
                                release || somewhatImplemented('public flash.net.NetStream::get info');
                                var bufferSeconds = 1;
                                var playedSeconds = Math.ceil(this._invoke(304, null));
                                var audioBytesPerSecond = 32;
                                var videoBytesPerSecond = 200;
                                var dataBytesPerSecond = 1;
                                return new this.sec.flash.net.NetStreamInfo(audioBytesPerSecond + videoBytesPerSecond, (audioBytesPerSecond + videoBytesPerSecond + dataBytesPerSecond) * (bufferSeconds + playedSeconds), audioBytesPerSecond + videoBytesPerSecond, audioBytesPerSecond, audioBytesPerSecond * (bufferSeconds + playedSeconds), videoBytesPerSecond, videoBytesPerSecond * (bufferSeconds + playedSeconds), dataBytesPerSecond, dataBytesPerSecond * (bufferSeconds + playedSeconds), (audioBytesPerSecond + videoBytesPerSecond + dataBytesPerSecond) * playedSeconds, 0, audioBytesPerSecond * bufferSeconds, videoBytesPerSecond * bufferSeconds, dataBytesPerSecond * bufferSeconds, bufferSeconds, bufferSeconds, bufferSeconds, 0, 0, 0, this._metaData, null, this._connection.uri, this._resourceName, false);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'multicastInfo', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get multicastInfo');
                                return;    // return this._multicastInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'soundTransform', {
                            get: function () {
                                return this._soundTransform;
                            },
                            set: function (sndTransform) {
                                this._soundTransform = sndTransform;
                                flash.media.SoundMixer._updateSoundSource(this);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'checkPolicyFile', {
                            get: function () {
                                return this._checkPolicyFile;
                            },
                            set: function (state) {
                                state = !!state;
                                this._checkPolicyFile = state;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'client', {
                            get: function () {
                                return this._client;
                            },
                            set: function (object) {
                                release || somewhatImplemented('public flash.net.NetStream::set client');
                                this._client = object;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'objectEncoding', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get objectEncoding');
                                return;    // return this._objectEncoding;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'multicastPushNeighborLimit', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get multicastPushNeighborLimit');
                                return;    // return this._multicastPushNeighborLimit;
                            },
                            set: function (neighbors) {
                                neighbors = +neighbors;
                                release || notImplemented('public flash.net.NetStream::set multicastPushNeighborLimit');
                                return;    // this._multicastPushNeighborLimit = neighbors;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'multicastWindowDuration', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get multicastWindowDuration');
                                return;    // return this._multicastWindowDuration;
                            },
                            set: function (seconds) {
                                seconds = +seconds;
                                release || notImplemented('public flash.net.NetStream::set multicastWindowDuration');
                                return;    // this._multicastWindowDuration = seconds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'multicastRelayMarginDuration', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get multicastRelayMarginDuration');
                                return;    // return this._multicastRelayMarginDuration;
                            },
                            set: function (seconds) {
                                seconds = +seconds;
                                release || notImplemented('public flash.net.NetStream::set multicastRelayMarginDuration');
                                return;    // this._multicastRelayMarginDuration = seconds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'multicastAvailabilityUpdatePeriod', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get multicastAvailabilityUpdatePeriod');
                                return;    // return this._multicastAvailabilityUpdatePeriod;
                            },
                            set: function (seconds) {
                                seconds = +seconds;
                                release || notImplemented('public flash.net.NetStream::set multicastAvailabilityUpdatePeriod');
                                return;    // this._multicastAvailabilityUpdatePeriod = seconds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'multicastFetchPeriod', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get multicastFetchPeriod');
                                return;    // return this._multicastFetchPeriod;
                            },
                            set: function (seconds) {
                                seconds = +seconds;
                                release || notImplemented('public flash.net.NetStream::set multicastFetchPeriod');
                                return;    // this._multicastFetchPeriod = seconds;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'multicastAvailabilitySendToAll', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get multicastAvailabilitySendToAll');
                                return;    // return this._multicastAvailabilitySendToAll;
                            },
                            set: function (value) {
                                value = !!value;
                                release || notImplemented('public flash.net.NetStream::set multicastAvailabilitySendToAll');
                                return;    // this._multicastAvailabilitySendToAll = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'farID', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get farID');
                                return;    // return this._farID;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'nearNonce', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get nearNonce');
                                return;    // return this._nearNonce;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'farNonce', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get farNonce');
                                return;    // return this._farNonce;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'peerStreams', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get peerStreams');
                                return;    // return this._peerStreams;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'audioReliable', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get audioReliable');
                                return;    // return this._audioReliable;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                release || notImplemented('public flash.net.NetStream::set audioReliable');
                                return;    // this._audioReliable = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'videoReliable', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get videoReliable');
                                return;    // return this._videoReliable;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                release || notImplemented('public flash.net.NetStream::set videoReliable');
                                return;    // this._videoReliable = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'dataReliable', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get dataReliable');
                                return;    // return this._dataReliable;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                release || notImplemented('public flash.net.NetStream::set dataReliable');
                                return;    // this._dataReliable = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'audioSampleAccess', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get audioSampleAccess');
                                return;    // return this._audioSampleAccess;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                release || notImplemented('public flash.net.NetStream::set audioSampleAccess');
                                return;    // this._audioSampleAccess = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'videoSampleAccess', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get videoSampleAccess');
                                return;    // return this._videoSampleAccess;
                            },
                            set: function (reliable) {
                                reliable = !!reliable;
                                release || notImplemented('public flash.net.NetStream::set videoSampleAccess');
                                return;    // this._videoSampleAccess = reliable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetStream.prototype.appendBytes = function (bytes) {
                            var chunk = new Uint8Array(bytes._buffer, 0, bytes.length);
                            // We need to pass cloned data, since the bytes can be reused and
                            // VideoStream.appendBytes can hold data for some time.
                            this._videoStream.appendBytes(chunk);
                        };
                        NetStream.prototype.appendBytesAction = function (netStreamAppendBytesAction) {
                            this._videoStream.appendBytesAction(netStreamAppendBytesAction);
                        };
                        Object.defineProperty(NetStream.prototype, 'useHardwareDecoder', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get useHardwareDecoder');
                                return;    // return this._useHardwareDecoder;
                            },
                            set: function (v) {
                                v = !!v;
                                release || notImplemented('public flash.net.NetStream::set useHardwareDecoder');
                                return;    // this._useHardwareDecoder = v;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'useJitterBuffer', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get useJitterBuffer');
                                return;    // return this._useJitterBuffer;
                            },
                            set: function (value) {
                                value = !!value;
                                release || notImplemented('public flash.net.NetStream::set useJitterBuffer');
                                return;    // this._useJitterBuffer = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(NetStream.prototype, 'videoStreamSettings', {
                            get: function () {
                                release || notImplemented('public flash.net.NetStream::get videoStreamSettings');
                                return;    // return this._videoStreamSettings;
                            },
                            set: function (settings) {
                                settings = settings;
                                release || notImplemented('public flash.net.NetStream::set videoStreamSettings');
                                return;    // this._videoStreamSettings = settings;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetStream.prototype.invoke = function (index) {
                            index = index >>> 0;
                            return this._invoke(index, Array.prototype.slice.call(arguments, 1));
                        };
                        NetStream.prototype.invokeWithArgsArray = function (index, p_arguments) {
                            index = index >>> 0;
                            p_arguments = p_arguments;
                            return this._invoke.call(this, index, p_arguments.value);
                        };
                        Object.defineProperty(NetStream.prototype, 'inBufferSeek', {
                            get: function () {
                                return this._inBufferSeek;
                            },
                            set: function (value) {
                                this._inBufferSeek = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        NetStream.prototype._invoke = function (index, args) {
                            var simulated = false, result;
                            switch (index) {
                            case 4:
                                this._videoStream.bufferTime = args[0];
                                simulated = true;
                                break;
                            case 202:
                                switch (args[1]) {
                                case 'pause':
                                    simulated = true;
                                    this._notifyVideoControl(2    /* Pause */, {
                                        paused: !!args[3],
                                        time: args[4] / 1000
                                    });
                                    break;
                                case 'seek':
                                    simulated = true;
                                    this._notifyVideoControl(3    /* Seek */, { time: args[3] / 1000 });
                                    break;
                                }
                                break;
                            case 300:
                                result = this._notifyVideoControl(4    /* GetTime */, null);
                                simulated = true;
                                break;
                            case 302:
                                result = this._videoStream.bufferTime;
                                simulated = true;
                                break;
                            case 303:
                                result = this._notifyVideoControl(5    /* GetBufferLength */, null);
                                simulated = true;
                                break;
                            case 305:
                                result = this._notifyVideoControl(7    /* GetBytesLoaded */, null);
                                simulated = true;
                                break;
                            case 306:
                                result = this._notifyVideoControl(8    /* GetBytesTotal */, null);
                                simulated = true;
                                break;
                            }
                            // (index:uint) -> any
                            (simulated ? somewhatImplemented : notImplemented)('NetStream._invoke (' + index + ')');
                            return result;
                        };
                        NetStream.prototype._notifyVideoControl = function (eventType, data) {
                            var service = this.sec.player;
                            return service.notifyVideoControl(this._id, eventType, data);
                        };
                        NetStream.prototype.processVideoEvent = function (eventType, data) {
                            this._videoStream.processVideoPlaybackEvent(eventType, data);
                            var netStatusEventCtor = this.sec.flash.events.NetStatusEvent;
                            switch (eventType) {
                            case 0    /* Initialized */:
                                flash.media.SoundMixer._updateSoundSource(this);
                                break;
                            case 2    /* PlayStart */:
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Play.Start',
                                    level: 'status'
                                })));
                                break;
                            case 3    /* PlayStop */:
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Buffer.Flush',
                                    level: 'status'
                                })));
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Play.Stop',
                                    level: 'status'
                                })));
                                flash.media.SoundMixer._unregisterSoundSource(this);
                                break;
                            case 5    /* BufferFull */:
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Buffer.Full',
                                    level: 'status'
                                })));
                                break;
                            case 4    /* BufferEmpty */:
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Buffer.Empty',
                                    level: 'status'
                                })));
                                break;
                            case 11    /* Error */:
                                var code = data.code === 4 ? 'NetStream.Play.NoSupportedTrackFound' : data.code === 3 ? 'NetStream.Play.FileStructureInvalid' : 'NetStream.Play.StreamNotFound';
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: code,
                                    level: 'error'
                                })));
                                break;
                            case 6    /* Pause */:
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Pause.Notify',
                                    level: 'status'
                                })));
                                break;
                            case 7    /* Unpause */:
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Unpause.Notify',
                                    level: 'status'
                                })));
                                break;
                            case 8    /* Seeking */:
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Seek.Notify',
                                    level: 'status'
                                })));
                                break;
                            case 9    /* Seeked */:
                                this.dispatchEvent(new netStatusEventCtor(events.NetStatusEvent.NET_STATUS, false, false, this.sec.createObjectFromJS({
                                    code: 'NetStream.Seek.Complete',
                                    level: 'status'
                                })));
                                break;
                            case 1    /* Metadata */:
                                if (this._client) {
                                    var metadata = this.sec.createObject();
                                    metadata.axSetPublicProperty('width', data.videoWidth);
                                    metadata.axSetPublicProperty('height', data.videoHeight);
                                    metadata.axSetPublicProperty('duration', data.duration);
                                    this._client.axCallPublicProperty('onMetaData', [metadata]);
                                }
                                break;
                            }
                        };
                        NetStream.prototype.stopSound = function () {
                            this.pause();
                        };
                        NetStream.prototype.updateSoundLevels = function (volume) {
                            this._notifyVideoControl(6    /* SetSoundLevels */, { volume: volume });
                        };
                        // Called whenever the class is initialized.
                        NetStream.classInitializer = null;
                        // List of static symbols to link.
                        NetStream.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        NetStream.instanceSymbols = null;
                        // ["attach", "close", "attachAudio", "attachCamera", "send", "bufferTime", "bufferTime", "maxPauseBufferTime", "maxPauseBufferTime", "backBufferTime", "backBufferTime", "backBufferLength", "step", "bufferTimeMax", "bufferTimeMax", "receiveAudio", "receiveVideo", "receiveVideoFPS", "pause", "resume", "togglePause", "seek", "publish", "time", "currentFPS", "bufferLength", "liveDelay", "bytesLoaded", "bytesTotal", "decodedFrames", "videoCodec", "audioCodec", "onPeerConnect", "call"];
                        // JS -> AS Bindings
                        NetStream.DIRECT_CONNECTIONS = 'directConnections';
                        NetStream.CONNECT_TO_FMS = 'connectToFMS';
                        return NetStream;
                    }(flash.events.EventDispatcher);
                    net_1.NetStream = NetStream;
                    var FLV_MIME_TYPE = 'video/x-flv';
                    var MP4_MIME_TYPE = 'video/mp4';
                    var MP3_MIME_TYPE = 'audio/mpeg';
                    function buildMimeType(baseType, codecs) {
                        var mimeType = baseType;
                        if (codecs) {
                            mimeType += ';codecs="' + codecs.join(',') + '"';
                        }
                        return mimeType;
                    }
                    var VideoStreamState;
                    (function (VideoStreamState) {
                        VideoStreamState[VideoStreamState['CLOSED'] = 0] = 'CLOSED';
                        VideoStreamState[VideoStreamState['OPENED'] = 1] = 'OPENED';
                        VideoStreamState[VideoStreamState['ENDED'] = 2] = 'ENDED';
                        VideoStreamState[VideoStreamState['OPENED_DATA_GENERATION'] = 3] = 'OPENED_DATA_GENERATION';
                        VideoStreamState[VideoStreamState['ERROR'] = 4] = 'ERROR';
                    }(VideoStreamState || (VideoStreamState = {})));
                    /**
                     * Helper class that encapsulates VIDEO/MediaSource operations and
                     * buffers data before passing to the MSE.
                     */
                    var VideoStream = function () {
                        function VideoStream(netStream) {
                            this.sec = netStream.sec;
                            this._domReady = new Shumway.PromiseWrapper();
                            this._metadataReady = new Shumway.PromiseWrapper();
                            this._started = false;
                            this._buffer = 'empty';
                            this._bufferTime = 0.1;
                            this._url = null;
                            this._mediaSource = null;
                            this._mediaSourceBuffer = null;
                            this._mediaSourceBufferLock = null;
                            this._contentTypeHint = null;
                            this._state = VideoStreamState.CLOSED;
                            this._head = null;
                            this._netStream = netStream;
                        }
                        Object.defineProperty(VideoStream.prototype, 'state', {
                            get: function () {
                                return this._state;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(VideoStream.prototype, 'bufferTime', {
                            get: function () {
                                return this._bufferTime;
                            },
                            set: function (value) {
                                this._bufferTime = +value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(VideoStream.prototype, 'url', {
                            get: function () {
                                return this._url;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        VideoStream.prototype.play = function (url, checkPolicyFile) {
                            var _this = this;
                            release || assert(this._state === VideoStreamState.CLOSED);
                            var isMediaSourceEnabled = AS.mediaSourceOption.value;
                            if (isMediaSourceEnabled && typeof MediaSource === 'undefined') {
                                Shumway.Debug.warning('MediaSource API is not enabled, falling back to regular playback');
                                isMediaSourceEnabled = false;
                            }
                            var forceMediaSource = false;
                            if (/\.flv($|\?)/i.test(url)) {
                                if (AS.flvOption.value === 'supported') {
                                    forceMediaSource = true;
                                } else if (AS.flvOption.value === 'mock') {
                                    url = 'resource://shumway/web/noflv.mp4';
                                } else {
                                    setTimeout(function () {
                                        _this._netStream.dispatchEvent(new _this.sec.flash.events.NetStatusEvent(events.NetStatusEvent.NET_STATUS, false, false, _this.sec.createObjectFromJS({
                                            code: 'NetStream.Play.NoSupportedTrackFound',
                                            level: 'error'
                                        })));
                                    });
                                    return;
                                }
                            }
                            if (!forceMediaSource && !isMediaSourceEnabled) {
                                release || somewhatImplemented('public flash.net.NetStream::play');
                                this._state = VideoStreamState.OPENED;
                                this._url = FileLoadingService.instance.resolveUrl(url);
                                return;
                            }
                            this.openInDataGenerationMode();
                            var request = new this.sec.flash.net.URLRequest(url);
                            request._checkPolicyFile = checkPolicyFile;
                            var stream = new this.sec.flash.net.URLStream();
                            stream.addEventListener('httpStatus', function (e) {
                                var responseHeaders = e.axGetPublicProperty('responseHeaders');
                                var contentTypeHeader = responseHeaders.filter(function (h) {
                                    return h.axGetPublicProperty('name') === 'Content-Type';
                                })[0];
                                if (contentTypeHeader) {
                                    var hint = contentTypeHeader.axGetPublicProperty('value');
                                    if (hint !== 'application/octet-stream') {
                                    }
                                }
                            }.bind(this));
                            stream.addEventListener('progress', function (e) {
                                var available = stream.bytesAvailable;
                                var bytes = new request.sec.flash.utils.ByteArray();
                                stream.readBytes(bytes, 0, available);
                                var chunk = new Uint8Array(bytes._buffer, 0, bytes.length);
                                this.appendBytes(chunk);
                            }.bind(this));
                            stream.addEventListener('complete', function (e) {
                                this.appendBytesAction('endSequence');    // NetStreamAppendBytesAction.END_SEQUENCE
                            }.bind(this));
                            stream.load(request);
                        };
                        VideoStream.prototype.playInConnection = function (connection, streamPath) {
                            this.openInDataGenerationMode();
                            var self = this;
                            var mux;
                            var mp4 = {
                                packets: 0,
                                init: function (metadata) {
                                    if (!metadata.axGetPublicProperty('audiocodecid') && !metadata.axGetPublicProperty('videocodecid')) {
                                        return;    // useless metadata?
                                    }
                                    var parsedMetadata = RtmpJs.MP4.parseFLVMetadata(metadata);
                                    mux = new RtmpJs.MP4.MP4Mux(parsedMetadata);
                                    mux.oncodecinfo = function (mediaCodecs) {
                                        this._contentTypeHint = buildMimeType(MP4_MIME_TYPE, mediaCodecs);
                                    };
                                    mux.ondata = function (data) {
                                        self.appendBytes(new Uint8Array(data));
                                    }.bind(this);
                                },
                                packet: function (type, data, timestamp) {
                                    mux.pushPacket(type, new Uint8Array(data), timestamp);
                                },
                                generate: function () {
                                    mux.flush();
                                }
                            };
                            connection._createRtmpStream(function (ns, streamId) {
                                ns.ondata = function (message) {
                                    console.log('#packet (' + message.typeId + '): @' + message.timestamp);
                                    if (message.data.length > 0) {
                                        mp4.packet(message.typeId, message.data, message.timestamp);
                                    }
                                };
                                ns.oncallback = function () {
                                    console.log('#callback');
                                };
                                ns.onscriptdata = function (type, data) {
                                    console.log('#object: ' + type);
                                    if (type === 'onMetaData') {
                                        mp4.init(data);
                                    }
                                };
                                ns.play(streamPath);
                            });
                        };
                        VideoStream.prototype.openInDataGenerationMode = function () {
                            release || assert(this._state === VideoStreamState.CLOSED);
                            this._state = VideoStreamState.OPENED_DATA_GENERATION;
                            var mediaSource = new MediaSource();
                            mediaSource.addEventListener('sourceopen', function (e) {
                                this._ensurePlaying();
                            }.bind(this));
                            mediaSource.addEventListener('sourceend', function (e) {
                                this._mediaSource = null;
                            }.bind(this));
                            this._mediaSource = mediaSource;
                            this._url = URL.createObjectURL(mediaSource);
                        };
                        VideoStream.prototype.appendBytes = function (bytes) {
                            release || assert(this._state === VideoStreamState.OPENED_DATA_GENERATION || this._state === VideoStreamState.OPENED);
                            release || assert(this._mediaSource);
                            if (this._decoder) {
                                this._decoder.push(bytes);
                                return;
                            }
                            // First we need to parse some content to find out mime type and codecs
                            // for MediaSource. Caching some data at the beginning until we can tell
                            // the type of the content.
                            var cached;
                            var buffer;
                            if (this._head !== null) {
                                cached = this._head.length;
                                buffer = new Uint8Array(cached + bytes.length);
                                buffer.set(bytes, cached);
                            } else {
                                cached = 0;
                                buffer = bytes;
                            }
                            if (!this._decoder) {
                                // Trying to create a data decoder.
                                var contentType = this._detectContentType(buffer);
                                if (contentType === FLV_MIME_TYPE) {
                                    // FLV data needs to be parsed and wrapped with MP4 tags.
                                    var flvDecoder = new FlvMp4Decoder(this.sec);
                                    flvDecoder.onHeader = function (contentType) {
                                        this._mediaSourceBuffer = this._mediaSource.addSourceBuffer(contentType);
                                        this._mediaSourceBufferLock = Promise.resolve(undefined);
                                    }.bind(this);
                                    flvDecoder.onData = this._queueData.bind(this);
                                    this._decoder = flvDecoder;
                                } else if (contentType) {
                                    // Let's use identity decoder for reset of the types.
                                    this._decoder = {
                                        onData: this._queueData.bind(this),
                                        onError: function (e) {
                                        },
                                        push: function (bytes) {
                                            this.onData(bytes);
                                        },
                                        close: function () {
                                        }
                                    };
                                    this._mediaSourceBuffer = this._mediaSource.addSourceBuffer(contentType);
                                    this._mediaSourceBufferLock = Promise.resolve(undefined);
                                }
                            }
                            if (this._decoder) {
                                // The decoder exists, doing first data push, see also above.
                                this._decoder.push(buffer);
                                if (cached > 0) {
                                    this._head = null;
                                }
                            } else {
                                // Caching header more header data.
                                if (cached === 0) {
                                    this._head = new Uint8Array(bytes);
                                } else {
                                    this._head = buffer;
                                }
                            }
                        };
                        VideoStream.prototype._queueData = function (bytes) {
                            // We need to chain all appendBuffer operations using 'update' event.
                            var buffer = this._mediaSourceBuffer;
                            this._mediaSourceBufferLock = this._mediaSourceBufferLock.then(function () {
                                buffer.appendBuffer(bytes);
                                return new Promise(function (resolve) {
                                    buffer.addEventListener('update', function updateHandler() {
                                        buffer.removeEventListener('update', updateHandler);
                                        resolve();
                                    });
                                });
                            });
                        };
                        VideoStream.prototype.appendBytesAction = function (netStreamAppendBytesAction) {
                            release || assert(this._state === VideoStreamState.OPENED_DATA_GENERATION || this._state === VideoStreamState.OPENED);
                            netStreamAppendBytesAction = axCoerceString(netStreamAppendBytesAction);
                            // TODO Ignoring reset actions for now.
                            if (netStreamAppendBytesAction === 'endSequence') {
                                if (!this._decoder) {
                                    // REDUX: throw a proper internal error. Or something.
                                    throw new Error('Internal appendBytes error');
                                }
                                this._decoder.close();
                                this._mediaSourceBufferLock.then(function () {
                                    if (this._mediaSource) {
                                        this._mediaSource.endOfStream();
                                    }
                                    this.close();
                                }.bind(this));
                            }
                            release || somewhatImplemented('public flash.net.NetStream::appendBytesAction');
                        };
                        VideoStream.prototype.close = function () {
                            this._state = VideoStreamState.CLOSED;
                        };
                        VideoStream.prototype._ensurePlaying = function () {
                            if (!this._onEnsurePlay) {
                                return;
                            }
                            this._onEnsurePlay();
                        };
                        VideoStream.prototype._detectContentType = function (bytes) {
                            if (bytes.length < 16) {
                                return null;    // Need more bytes.
                            }
                            if (bytes[0] === 70    /* F */ && bytes[1] === 76    /* L */ && bytes[2] === 86    /* V */ && bytes[3] === 1    /* version 1 */) {
                                // Likely FLV.
                                return FLV_MIME_TYPE;
                            }
                            if (bytes[4] === 102    /* f */ && bytes[5] === 116    /* t */ && bytes[6] === 121    /* y */ && bytes[7] === 112    /* p */) {
                                if (this._contentTypeHint && /^video\/mp4;\s*codecs=/.test(this._contentTypeHint)) {
                                    return this._contentTypeHint;
                                }
                                // TODO check bytes for content type
                                return 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
                            }
                            if (bytes[0] === 73    /* I */ && bytes[1] === 68    /* D */ && bytes[2] === 51    /* 3 */ || bytes[0] === 255 && (bytes[1] & 224) === 224 && (bytes[1] & 30) !== 8) {
                                // Maybe MP3.
                                return MP3_MIME_TYPE;
                            }
                            // Just a wild (and wrong) guess
                            return this._contentTypeHint || MP4_MIME_TYPE;
                        };
                        VideoStream.prototype.processVideoPlaybackEvent = function (eventType, data) {
                            switch (eventType) {
                            case 0    /* Initialized */:
                                this._domReady.resolve(undefined);
                                break;
                            case 2    /* PlayStart */:
                                if (this._started) {
                                    break;
                                }
                                this._started = true;
                                break;
                            case 3    /* PlayStop */:
                                this._started = false;
                                break;
                            case 5    /* BufferFull */:
                                this._buffer = 'full';
                                break;
                            case 10    /* Progress */:
                                this._buffer = 'progress';
                                break;
                            case 4    /* BufferEmpty */:
                                this._buffer = 'empty';
                                break;
                            case 1    /* Metadata */:
                                this._metadataReady.resolve({
                                    videoWidth: data.videoWidth,
                                    videoHeight: data.videoHeight
                                });
                                break;
                            }
                        };
                        return VideoStream;
                    }();
                    // FLV-to-MP4 data transformation.
                    var FlvMp4Decoder = function () {
                        function FlvMp4Decoder(sec) {
                            this.sec = sec;
                            this._flvParser = new RtmpJs.FLV.FLVParser();
                            this._flvParser.onHeader = this._onFlvHeader.bind(this);
                            this._flvParser.onTag = this._onFlvTag.bind(this);
                            this._flvParser.onClose = this._onFlvClose.bind(this);
                            this._flvParser.onError = this._onFlvError.bind(this);
                            this._mp4Mux = null;
                        }
                        FlvMp4Decoder.prototype._onFlvHeader = function (header) {
                        };
                        FlvMp4Decoder.prototype._onFlvTag = function (tag) {
                            if (tag.type === 18) {
                                var ba = new this.sec.flash.utils.ByteArray();
                                ba.writeRawBytes(tag.data);
                                ba.position = 0;
                                var name = AVMX.AMF0.read(ba);
                                var value = AVMX.AMF0.read(ba);
                                if (name === 'onMetaData') {
                                    var metadata = RtmpJs.MP4.parseFLVMetadata(value);
                                    var mp4Mux = new RtmpJs.MP4.MP4Mux(metadata);
                                    mp4Mux.oncodecinfo = function (codecs) {
                                        this.onHeader(buildMimeType(MP4_MIME_TYPE, codecs));
                                    }.bind(this);
                                    mp4Mux.ondata = function (data) {
                                        this.onData.call(null, data);
                                    }.bind(this);
                                    this._mp4Mux = mp4Mux;
                                }
                                return;
                            }
                            this._mp4Mux.pushPacket(tag.type, new Uint8Array(tag.data), tag.timestamp);
                        };
                        FlvMp4Decoder.prototype._onFlvClose = function () {
                            this._mp4Mux.flush();
                        };
                        FlvMp4Decoder.prototype._onFlvError = function (e) {
                            if (this.onError) {
                                this.onError(e);
                            }
                        };
                        FlvMp4Decoder.prototype.push = function (bytes) {
                            try {
                                this._flvParser.push(bytes);
                            } catch (e) {
                                if (this.onError) {
                                    this.onError(e);
                                }
                            }
                        };
                        FlvMp4Decoder.prototype.close = function () {
                            try {
                                this._flvParser.close();
                            } catch (e) {
                                if (this.onError) {
                                    this.onError(e);
                                }
                            }
                        };
                        return FlvMp4Decoder;
                    }();
                }(net = flash.net || (flash.net = {})));
                var net;
                (function (net) {
                    var NetStreamInfo = function (_super) {
                        __extends(NetStreamInfo, _super);
                        function NetStreamInfo(curBPS, byteCount, maxBPS, audioBPS, audioByteCount, videoBPS, videoByteCount, dataBPS, dataByteCount, playbackBPS, droppedFrames, audioBufferByteLength, videoBufferByteLength, dataBufferByteLength, audioBufferLength, videoBufferLength, dataBufferLength, srtt, audioLossRate, videoLossRate, metaData, xmpData, uri, resourceName, isLive) {
                            if (metaData === void 0) {
                                metaData = null;
                            }
                            if (xmpData === void 0) {
                                xmpData = null;
                            }
                            if (uri === void 0) {
                                uri = null;
                            }
                            if (resourceName === void 0) {
                                resourceName = null;
                            }
                            if (isLive === void 0) {
                                isLive = true;
                            }
                            _super.call(this);
                            this.currentBytesPerSecond = +curBPS;
                            this.byteCount = +byteCount;
                            this.maxBytesPerSecond = +maxBPS;
                            this.audioBytesPerSecond = +audioBPS;
                            this.audioByteCount = +audioByteCount;
                            this.videoBytesPerSecond = +videoBPS;
                            this.videoByteCount = +videoByteCount;
                            this.dataBytesPerSecond = +dataBPS;
                            this.dataByteCount = +dataByteCount;
                            this.playbackBytesPerSecond = +playbackBPS;
                            this.droppedFrames = +droppedFrames;
                            this.audioBufferByteLength = +audioBufferByteLength;
                            this.videoBufferByteLength = +videoBufferByteLength;
                            this.dataBufferByteLength = +dataBufferByteLength;
                            this.audioBufferLength = +audioBufferLength;
                            this.videoBufferLength = +videoBufferLength;
                            this.dataBufferLength = +dataBufferLength;
                            this._srtt = +srtt;
                            this.audioLossRate = +audioLossRate;
                            this.videoLossRate = +videoLossRate;
                            this.metaData = metaData;
                            this.xmpData = xmpData;
                            this.uri = AVMX.axCoerceString(uri);
                            this.resourceName = AVMX.axCoerceString(resourceName);
                            this.isLive = !!isLive;
                        }
                        // Called whenever the class is initialized.
                        NetStreamInfo.classInitializer = null;
                        // List of static symbols to link.
                        NetStreamInfo.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        NetStreamInfo.instanceSymbols = null;
                        return NetStreamInfo;
                    }(AS.ASObject);
                    net.NetStreamInfo = NetStreamInfo;
                    var NetStreamMulticastInfo = function (_super) {
                        __extends(NetStreamMulticastInfo, _super);
                        function NetStreamMulticastInfo(sendDataBytesPerSecond, sendControlBytesPerSecond, receiveDataBytesPerSecond, receiveControlBytesPerSecond, bytesPushedToPeers, fragmentsPushedToPeers, bytesRequestedByPeers, fragmentsRequestedByPeers, bytesPushedFromPeers, fragmentsPushedFromPeers, bytesRequestedFromPeers, fragmentsRequestedFromPeers, sendControlBytesPerSecondToServer, receiveDataBytesPerSecondFromServer, bytesReceivedFromServer, fragmentsReceivedFromServer, receiveDataBytesPerSecondFromIPMulticast, bytesReceivedFromIPMulticast, fragmentsReceivedFromIPMulticast) {
                            this.sendDataBytesPerSecond = +sendDataBytesPerSecond;
                            this.sendControlBytesPerSecond = +sendControlBytesPerSecond;
                            this.receiveDataBytesPerSecond = +receiveDataBytesPerSecond;
                            this.receiveControlBytesPerSecond = +receiveControlBytesPerSecond;
                            this.bytesPushedToPeers = +bytesPushedToPeers;
                            this.fragmentsPushedToPeers = +fragmentsPushedToPeers;
                            this.bytesRequestedByPeers = +bytesRequestedByPeers;
                            this.fragmentsRequestedByPeers = +fragmentsRequestedByPeers;
                            this.bytesPushedFromPeers = +bytesPushedFromPeers;
                            this.fragmentsPushedFromPeers = +fragmentsPushedFromPeers;
                            this.bytesRequestedFromPeers = +bytesRequestedFromPeers;
                            this.fragmentsRequestedFromPeers = +fragmentsRequestedFromPeers;
                            this.sendControlBytesPerSecondToServer = +sendControlBytesPerSecondToServer;
                            this.receiveDataBytesPerSecondFromServer = +receiveDataBytesPerSecondFromServer;
                            this.bytesReceivedFromServer = +bytesReceivedFromServer;
                            this.fragmentsReceivedFromServer = +fragmentsReceivedFromServer;
                            this.receiveDataBytesPerSecondFromIPMulticast = +receiveDataBytesPerSecondFromIPMulticast;
                            this.bytesReceivedFromIPMulticast = +bytesReceivedFromIPMulticast;
                            this.fragmentsReceivedFromIPMulticast = +fragmentsReceivedFromIPMulticast;
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        NetStreamMulticastInfo.classInitializer = null;
                        // List of static symbols to link.
                        NetStreamMulticastInfo.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        NetStreamMulticastInfo.instanceSymbols = null;
                        return NetStreamMulticastInfo;
                    }(AS.ASObject);
                    net.NetStreamMulticastInfo = NetStreamMulticastInfo;
                    var NetStreamPlayOptions = function (_super) {
                        __extends(NetStreamPlayOptions, _super);
                        function NetStreamPlayOptions() {
                            _super.call(this, undefined);
                        }
                        // Called whenever the class is initialized.
                        NetStreamPlayOptions.classInitializer = null;
                        // List of static symbols to link.
                        NetStreamPlayOptions.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        NetStreamPlayOptions.instanceSymbols = null;
                        // ["streamName", "oldStreamName", "start", "len", "offset", "transition"];
                        return NetStreamPlayOptions;
                    }(flash.events.EventDispatcher);
                    net.NetStreamPlayOptions = NetStreamPlayOptions;
                    var Responder = function (_super) {
                        __extends(Responder, _super);
                        function Responder(result, status) {
                            if (status === void 0) {
                                status = null;
                            }
                            _super.call(this);
                        }
                        // JS -> AS Bindings
                        // AS -> JS Bindings
                        Responder.prototype.ctor = function (result, status) {
                            this._result = result;
                            this._status = status;
                        };
                        // Called whenever the class is initialized.
                        Responder.classInitializer = null;
                        // List of static symbols to link.
                        Responder.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Responder.instanceSymbols = null;
                        // [];
                        return Responder;
                    }(AS.ASObject);
                    net.Responder = Responder;
                    var assert = Shumway.Debug.assert;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var _sharedObjectStorage;
                    function getSharedObjectStorage() {
                        if (!_sharedObjectStorage) {
                            if (typeof ShumwayCom !== 'undefined' && ShumwayCom.createSpecialStorage) {
                                _sharedObjectStorage = ShumwayCom.createSpecialStorage();
                            } else {
                                _sharedObjectStorage = window.sessionStorage;
                            }
                        }
                        release || assert(_sharedObjectStorage, 'SharedObjectStorage is not available.');
                        return _sharedObjectStorage;
                    }
                    var SharedObject = function (_super) {
                        __extends(SharedObject, _super);
                        function SharedObject() {
                            _super.call(this);
                            this._data = this.sec.createObject();
                        }
                        SharedObject.deleteAll = function (url) {
                            url = axCoerceString(url);
                            release || notImplemented('public flash.net.SharedObject::static deleteAll');
                            return;
                        };
                        SharedObject.getDiskUsage = function (url) {
                            url = axCoerceString(url);
                            release || somewhatImplemented('public flash.net.SharedObject::static getDiskUsage');
                            return 0;
                        };
                        SharedObject._create = function (path, data, encoding) {
                            var obj = new this.sec.flash.net.SharedObject();
                            obj._path = path;
                            obj._data = data;
                            obj._objectEncoding = encoding;
                            Shumway.Telemetry.instance.reportTelemetry({
                                topic: 'feature',
                                feature: 3    /* SHAREDOBJECT_FEATURE */
                            });
                            return obj;
                        };
                        SharedObject.getLocal = function (name, localPath, secure) {
                            if (localPath === void 0) {
                                localPath = null;
                            }
                            if (secure === void 0) {
                                secure = false;
                            }
                            name = axCoerceString(name);
                            localPath = axCoerceString(localPath);
                            secure = !!secure;
                            var path = (localPath || '') + '/' + name;
                            if (this._sharedObjects[path]) {
                                return this._sharedObjects[path];
                            }
                            var encodedData = getSharedObjectStorage().getItem(path);
                            var data;
                            var encoding = this._defaultObjectEncoding;
                            if (encodedData) {
                                try {
                                    var bytes = Shumway.StringUtilities.decodeRestrictedBase64ToBytes(encodedData);
                                    var serializedData = new this.sec.flash.utils.ByteArray(bytes);
                                    data = serializedData.readObject();
                                    encoding = serializedData.objectEncoding;
                                } catch (e) {
                                    Shumway.Debug.warning('Error encountered while decoding LocalStorage entry. Resetting data.');
                                }
                                if (!data || typeof data !== 'object') {
                                    data = this.sec.createObject();
                                }
                            } else {
                                data = this.sec.createObject();
                            }
                            var so = this._create(path, data, encoding);
                            so._objectEncoding = encoding;
                            this._sharedObjects[path] = so;
                            return so;
                        };
                        SharedObject.getRemote = function (name, remotePath, persistence, secure) {
                            if (remotePath === void 0) {
                                remotePath = null;
                            }
                            if (persistence === void 0) {
                                persistence = false;
                            }
                            if (secure === void 0) {
                                secure = false;
                            }
                            name = axCoerceString(name);
                            remotePath = axCoerceString(remotePath);
                            secure = !!secure;
                            release || notImplemented('public flash.net.SharedObject::static getRemote');
                            return;
                        };
                        Object.defineProperty(SharedObject, 'defaultObjectEncoding', {
                            get: function () {
                                return this._defaultObjectEncoding;
                            },
                            set: function (version) {
                                version = version >>> 0;
                                this._defaultObjectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SharedObject.prototype, 'data', {
                            // _client: ASObject;
                            get: function () {
                                // Make sure that any changes made to the object get stored.
                                // This isn't how Flash does it, and not as efficient as it could be, but it'll
                                // do for now.
                                this.queueFlush();
                                return this._data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SharedObject.prototype, 'objectEncoding', {
                            get: function () {
                                return this._objectEncoding;
                            },
                            set: function (version) {
                                version = version >>> 0;
                                this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SharedObject.prototype, 'client', {
                            get: function () {
                                release || notImplemented('public flash.net.SharedObject::get client');
                                return;    // return this._client;
                            },
                            set: function (object) {
                                object = object;
                                release || notImplemented('public flash.net.SharedObject::set client');
                                return;    // this._client = object;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SharedObject.prototype.setDirty = function (propertyName) {
                            propertyName = axCoerceString(propertyName);
                            this.queueFlush();
                        };
                        SharedObject.prototype.connect = function (myConnection, params) {
                            if (params === void 0) {
                                params = null;
                            }
                            release || notImplemented('public flash.net.SharedObject::connect');
                        };
                        SharedObject.prototype.send = function () {
                            release || notImplemented('public flash.net.SharedObject::send');
                        };
                        SharedObject.prototype.close = function () {
                            release || somewhatImplemented('public flash.net.SharedObject::close');
                        };
                        SharedObject.prototype.flush = function (minDiskSpace) {
                            minDiskSpace = minDiskSpace | 0;
                            release || somewhatImplemented('public flash.net.SharedObject::flush');
                            if (!this._pendingFlushId) {
                                return 'flushed';
                            }
                            clearTimeout(this._pendingFlushId);
                            this._pendingFlushId = 0;
                            // Check if the object is empty. If it is, don't create a stored object if one doesn't exist.
                            var isEmpty = true;
                            for (var key in this._data) {
                                if (this._data.hasOwnProperty(key)) {
                                    isEmpty = false;
                                    break;
                                }
                            }
                            if (isEmpty && !getSharedObjectStorage().getItem(this._path)) {
                                return;
                            }
                            var serializedData = new this.sec.flash.utils.ByteArray();
                            serializedData.objectEncoding = this._objectEncoding;
                            serializedData.writeObject(this._data);
                            var bytes = serializedData.getBytes();
                            var encodedData = Shumway.StringUtilities.base64EncodeBytes(bytes);
                            if (!release) {
                                var decoded = Shumway.StringUtilities.decodeRestrictedBase64ToBytes(encodedData);
                                Shumway.Debug.assert(decoded.byteLength === bytes.byteLength);
                                for (var i = 0; i < decoded.byteLength; i++) {
                                    Shumway.Debug.assert(decoded[i] === bytes[i]);
                                }
                            }
                            getSharedObjectStorage().setItem(this._path, encodedData);
                            return 'flushed';
                        };
                        SharedObject.prototype.clear = function () {
                            release || somewhatImplemented('public flash.net.SharedObject::clear');
                            this._data = this.sec.createObject();
                            getSharedObjectStorage().removeItem(this._path);
                        };
                        Object.defineProperty(SharedObject.prototype, 'size', {
                            get: function () {
                                release || somewhatImplemented('public flash.net.SharedObject::get size');
                                this.flush(0);
                                var storedData = getSharedObjectStorage().getItem(this._path);
                                return storedData ? storedData.length : 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(SharedObject.prototype, 'fps', {
                            set: function (updatesPerSecond) {
                                release || somewhatImplemented('fps');
                                this._fps = updatesPerSecond;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SharedObject.prototype.setProperty = function (propertyName, value) {
                            if (value === void 0) {
                                value = null;
                            }
                            propertyName = '$Bg' + axCoerceString(propertyName);
                            if (value === this._data[propertyName]) {
                                return;
                            }
                            this._data[propertyName] = value;
                            this.queueFlush();
                        };
                        SharedObject.prototype.queueFlush = function () {
                            if (this._pendingFlushId) {
                                clearTimeout(this._pendingFlushId);
                            }
                            this._pendingFlushId = setTimeout(this.flush.bind(this), 100);
                        };
                        // Called whenever the class is initialized.
                        SharedObject.classInitializer = null;
                        SharedObject._sharedObjects = Object.create(null);
                        SharedObject._defaultObjectEncoding = flash.net.ObjectEncoding.DEFAULT;
                        return SharedObject;
                    }(flash.events.EventDispatcher);
                    net.SharedObject = SharedObject;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var Socket = function (_super) {
                        __extends(Socket, _super);
                        function Socket(host, port) {
                            if (host === void 0) {
                                host = null;
                            }
                            if (port === void 0) {
                                port = 0;
                            }
                            _super.call(this, undefined);
                            host = axCoerceString(host);
                            port = port | 0;
                        }
                        Object.defineProperty(Socket.prototype, 'bytesAvailable', {
                            // AS -> JS Bindings
                            // _timeout: number /*uint*/;
                            // _bytesAvailable: number /*uint*/;
                            // _connected: boolean;
                            // _objectEncoding: number /*uint*/;
                            // _endian: string;
                            // _bytesPending: number /*uint*/;
                            get: function () {
                                release || notImplemented('public flash.net.Socket::get bytesAvailable');
                                return;    // return this._bytesAvailable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Socket.prototype, 'connected', {
                            get: function () {
                                release || notImplemented('public flash.net.Socket::get connected');
                                return;    // return this._connected;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Socket.prototype, 'objectEncoding', {
                            get: function () {
                                release || notImplemented('public flash.net.Socket::get objectEncoding');
                                return;    // return this._objectEncoding;
                            },
                            set: function (version) {
                                version = version >>> 0;
                                release || notImplemented('public flash.net.Socket::set objectEncoding');
                                return;    // this._objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Socket.prototype, 'endian', {
                            get: function () {
                                release || notImplemented('public flash.net.Socket::get endian');
                                return;    // return this._endian;
                            },
                            set: function (type) {
                                type = axCoerceString(type);
                                release || notImplemented('public flash.net.Socket::set endian');
                                return;    // this._endian = type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Socket.prototype, 'bytesPending', {
                            get: function () {
                                release || notImplemented('public flash.net.Socket::get bytesPending');
                                return;    // return this._bytesPending;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Socket.prototype.readBytes = function (bytes, offset, length) {
                            if (offset === void 0) {
                                offset = 0;
                            }
                            if (length === void 0) {
                                length = 0;
                            }
                            bytes = bytes;
                            offset = offset >>> 0;
                            length = length >>> 0;
                            release || notImplemented('public flash.net.Socket::readBytes');
                            return;
                        };
                        Socket.prototype.writeBytes = function (bytes, offset, length) {
                            if (offset === void 0) {
                                offset = 0;
                            }
                            if (length === void 0) {
                                length = 0;
                            }
                            bytes = bytes;
                            offset = offset >>> 0;
                            length = length >>> 0;
                            release || notImplemented('public flash.net.Socket::writeBytes');
                            return;
                        };
                        Socket.prototype.writeBoolean = function (value) {
                            value = !!value;
                            release || notImplemented('public flash.net.Socket::writeBoolean');
                            return;
                        };
                        Socket.prototype.writeByte = function (value) {
                            value = value | 0;
                            release || notImplemented('public flash.net.Socket::writeByte');
                            return;
                        };
                        Socket.prototype.writeShort = function (value) {
                            value = value | 0;
                            release || notImplemented('public flash.net.Socket::writeShort');
                            return;
                        };
                        Socket.prototype.writeInt = function (value) {
                            value = value | 0;
                            release || notImplemented('public flash.net.Socket::writeInt');
                            return;
                        };
                        Socket.prototype.writeUnsignedInt = function (value) {
                            value = value >>> 0;
                            release || notImplemented('public flash.net.Socket::writeUnsignedInt');
                            return;
                        };
                        Socket.prototype.writeFloat = function (value) {
                            value = +value;
                            release || notImplemented('public flash.net.Socket::writeFloat');
                            return;
                        };
                        Socket.prototype.writeDouble = function (value) {
                            value = +value;
                            release || notImplemented('public flash.net.Socket::writeDouble');
                            return;
                        };
                        Socket.prototype.writeMultiByte = function (value, charSet) {
                            value = axCoerceString(value);
                            charSet = axCoerceString(charSet);
                            release || notImplemented('public flash.net.Socket::writeMultiByte');
                            return;
                        };
                        Socket.prototype.writeUTF = function (value) {
                            value = axCoerceString(value);
                            release || notImplemented('public flash.net.Socket::writeUTF');
                            return;
                        };
                        Socket.prototype.writeUTFBytes = function (value) {
                            value = axCoerceString(value);
                            release || notImplemented('public flash.net.Socket::writeUTFBytes');
                            return;
                        };
                        Socket.prototype.readBoolean = function () {
                            release || notImplemented('public flash.net.Socket::readBoolean');
                            return;
                        };
                        Socket.prototype.readByte = function () {
                            release || notImplemented('public flash.net.Socket::readByte');
                            return;
                        };
                        Socket.prototype.readUnsignedByte = function () {
                            release || notImplemented('public flash.net.Socket::readUnsignedByte');
                            return;
                        };
                        Socket.prototype.readShort = function () {
                            release || notImplemented('public flash.net.Socket::readShort');
                            return;
                        };
                        Socket.prototype.readUnsignedShort = function () {
                            release || notImplemented('public flash.net.Socket::readUnsignedShort');
                            return;
                        };
                        Socket.prototype.readInt = function () {
                            release || notImplemented('public flash.net.Socket::readInt');
                            return;
                        };
                        Socket.prototype.readUnsignedInt = function () {
                            release || notImplemented('public flash.net.Socket::readUnsignedInt');
                            return;
                        };
                        Socket.prototype.readFloat = function () {
                            release || notImplemented('public flash.net.Socket::readFloat');
                            return;
                        };
                        Socket.prototype.readDouble = function () {
                            release || notImplemented('public flash.net.Socket::readDouble');
                            return;
                        };
                        Socket.prototype.readMultiByte = function (length, charSet) {
                            length = length >>> 0;
                            charSet = axCoerceString(charSet);
                            release || notImplemented('public flash.net.Socket::readMultiByte');
                            return;
                        };
                        Socket.prototype.readUTF = function () {
                            release || notImplemented('public flash.net.Socket::readUTF');
                            return;
                        };
                        Socket.prototype.readUTFBytes = function (length) {
                            length = length >>> 0;
                            release || notImplemented('public flash.net.Socket::readUTFBytes');
                            return;
                        };
                        Socket.prototype.flush = function () {
                            release || notImplemented('public flash.net.Socket::flush');
                            return;
                        };
                        Socket.prototype.writeObject = function (object) {
                            release || notImplemented('public flash.net.Socket::writeObject');
                            return;
                        };
                        Socket.prototype.readObject = function () {
                            release || notImplemented('public flash.net.Socket::readObject');
                            return;
                        };
                        Socket.prototype.internalGetSecurityErrorMessage = function (host, port) {
                            host = axCoerceString(host);
                            port |= 0;
                            release || somewhatImplemented('flash.net.Socket::internalGetSecurityErrorMessage');
                            return 'SecurityErrorEvent';
                        };
                        Socket.prototype.internalConnect = function (host, port) {
                            host = axCoerceString(host);
                            port |= 0;
                            release || somewhatImplemented('flash.net.Socket::internalConnect');
                            this.sec.throwError('SecurityError', AVMX.Errors.SocketConnectError, host, port);
                        };
                        Socket.prototype.didFailureOccur = function () {
                            release || somewhatImplemented('flash.net.Socket::didFailureOccur');
                            return true;
                        };
                        // Called whenever the class is initialized.
                        Socket.classInitializer = null;
                        // List of static symbols to link.
                        Socket.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Socket.instanceSymbols = null;
                        // ["timeout", "timeout", "connect", "close"];
                        return Socket;
                    }(flash.events.EventDispatcher);
                    net.Socket = Socket;
                    var Event = flash.events.Event;
                    var IOErrorEvent = flash.events.IOErrorEvent;
                    var ProgressEvent = flash.events.ProgressEvent;
                    var HTTPStatusEvent = flash.events.HTTPStatusEvent;
                    var SecurityErrorEvent = flash.events.SecurityErrorEvent;
                    var URLLoader = function (_super) {
                        __extends(URLLoader, _super);
                        function URLLoader(request) {
                            _super.call(this);
                            var stream = this._stream = new this.sec.flash.net.URLStream();
                            stream.addEventListener(Event.OPEN, this.onStreamOpen.bind(this));
                            stream.addEventListener(Event.COMPLETE, this.onStreamComplete.bind(this));
                            stream.addEventListener(ProgressEvent.PROGRESS, this.onStreamProgress.bind(this));
                            stream.addEventListener(IOErrorEvent.IO_ERROR, this.onStreamIOError.bind(this));
                            stream.addEventListener(HTTPStatusEvent.HTTP_STATUS, this.onStreamHTTPStatus.bind(this));
                            stream.addEventListener(HTTPStatusEvent.HTTP_RESPONSE_STATUS, this.onStreamHTTPResponseStatus.bind(this));
                            stream.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onStreamSecurityError.bind(this));
                            this.$BgdataFormat = 'text';
                            if (request) {
                                this.load(request);
                            }
                        }
                        Object.defineProperty(URLLoader.prototype, 'data', {
                            get: function () {
                                return this.$Bgdata;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLLoader.prototype, 'dataFormat', {
                            get: function () {
                                return this.$BgdataFormat;
                            },
                            set: function (format) {
                                release || Shumway.Debug.assert(typeof format === 'string');
                                this.$BgdataFormat = format;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLLoader.prototype, 'bytesLoaded', {
                            get: function () {
                                return this.$BgbytesLoaded;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLLoader.prototype, 'bytesTotal', {
                            get: function () {
                                return this.$BgbytesTotal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        URLLoader.prototype.load = function (request) {
                            this._stream.load(request);
                        };
                        URLLoader.prototype.close = function () {
                            this._stream.close();
                        };
                        URLLoader.prototype.complete = function () {
                            var response = new this.sec.flash.utils.ByteArray();
                            this._stream.readBytes(response);
                            if (this.$BgdataFormat === 'binary') {
                                this.$Bgdata = response;
                                return;
                            }
                            var data = response.toString();
                            if (response.length > 0 && this.$BgdataFormat === 'variables') {
                                var variable = new this.sec.flash.net.URLVariables();
                                if (this._ignoreDecodeErrors) {
                                    variable._ignoreDecodingErrors = true;
                                }
                                variable.decode(String(data));
                                this.$Bgdata = variable;
                            } else {
                                this.$Bgdata = data;
                            }
                        };
                        URLLoader.prototype.addEventListener = function (type, listener, useCapture, priority, useWeakReference) {
                            _super.prototype.addEventListener.call(this, type, listener, useCapture, priority, useWeakReference);
                            // Looks like there is some bug related to the HTTP_RESPONSE_STATUS
                            if (type === HTTPStatusEvent.HTTP_RESPONSE_STATUS) {
                                this._httpResponseEventBound = true;
                            }
                        };
                        URLLoader.prototype.onStreamOpen = function (e) {
                            this.dispatchEvent(e);
                        };
                        URLLoader.prototype.onStreamComplete = function (e) {
                            this.complete();
                            this.dispatchEvent(e);
                        };
                        URLLoader.prototype.onStreamProgress = function (e) {
                            this.$BgbytesLoaded = e.bytesLoaded;
                            this.$BgbytesTotal = e.bytesTotal;
                            this.dispatchEvent(e);
                        };
                        URLLoader.prototype.onStreamIOError = function (e) {
                            this.complete();
                            this.dispatchEvent(e);
                        };
                        URLLoader.prototype.onStreamHTTPStatus = function (e) {
                            this.dispatchEvent(e);
                        };
                        URLLoader.prototype.onStreamHTTPResponseStatus = function (e) {
                            if (!this._httpResponseEventBound) {
                                return;
                            }
                            this.dispatchEvent(e);
                        };
                        URLLoader.prototype.onStreamSecurityError = function (e) {
                            this.dispatchEvent(e);
                        };
                        URLLoader.classInitializer = null;
                        URLLoader.classSymbols = null;
                        // [];
                        URLLoader.instanceSymbols = null;
                        return URLLoader;
                    }(flash.events.EventDispatcher);
                    net.URLLoader = URLLoader;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var URLRequest = function (_super) {
                        __extends(URLRequest, _super);
                        function URLRequest(url) {
                            if (url === void 0) {
                                url = null;
                            }
                            _super.call(this);
                            this._url = axCoerceString(url);
                            this._method = 'GET';
                            this._data = null;
                            this._digest = null;
                            this._contentType = 'application/x-www-form-urlencoded';
                            this._requestHeaders = [];
                            this._checkPolicyFile = true;
                        }
                        Object.defineProperty(URLRequest.prototype, 'url', {
                            get: function () {
                                return this._url;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                this._url = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, 'data', {
                            get: function () {
                                return this._data;
                            },
                            set: function (value) {
                                this._data = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, 'method', {
                            get: function () {
                                return this._method;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                if (value !== 'get' && value !== 'GET' && value !== 'post' && value !== 'POST') {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidArgumentError);
                                }
                                this._method = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, 'contentType', {
                            get: function () {
                                return this._contentType;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                this._contentType = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, 'requestHeaders', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._requestHeaders);
                            },
                            set: function (value) {
                                if (!this.sec.AXArray.axIsType(value)) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidArgumentError, 'value');
                                }
                                this._requestHeaders = value.value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLRequest.prototype, 'digest', {
                            get: function () {
                                return this._digest;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                this._digest = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        URLRequest.prototype._toFileRequest = function () {
                            var obj = {};
                            obj.url = this._url;
                            obj.method = this._method;
                            obj.checkPolicyFile = this._checkPolicyFile;
                            var data = this._data;
                            if (data) {
                                obj.mimeType = this._contentType;
                                if (this.sec.flash.utils.ByteArray.axClass.axIsType(data)) {
                                    obj.data = new Uint8Array(data._buffer, 0, data.length);
                                } else {
                                    var dataStr = data.toString();
                                    if (this._method === 'GET') {
                                        var i = obj.url.lastIndexOf('?');
                                        obj.url = (i < 0 ? obj.url : obj.url.substring(0, i)) + '?' + dataStr;
                                    } else {
                                        obj.data = dataStr;
                                    }
                                }
                            }
                            return obj;
                        };
                        // Called whenever the class is initialized.
                        URLRequest.classInitializer = null;
                        // List of static symbols to link.
                        URLRequest.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        URLRequest.bindings = null;
                        return URLRequest;
                    }(AS.ASObject);
                    net.URLRequest = URLRequest;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var URLRequestHeader = function (_super) {
                        __extends(URLRequestHeader, _super);
                        function URLRequestHeader(name, value) {
                            if (name === void 0) {
                                name = '';
                            }
                            if (value === void 0) {
                                value = '';
                            }
                            _super.call(this);
                            this.name = axCoerceString(name);
                            this.value = axCoerceString(value);
                        }
                        // Called whenever the class is initialized.
                        URLRequestHeader.classInitializer = null;
                        // List of static symbols to link.
                        URLRequestHeader.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        URLRequestHeader.instanceSymbols = [
                            'name!',
                            'value!'
                        ];
                        return URLRequestHeader;
                    }(AS.ASObject);
                    net.URLRequestHeader = URLRequestHeader;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var FileLoadingService = Shumway.FileLoadingService;
                    var URLStream = function (_super) {
                        __extends(URLStream, _super);
                        function URLStream() {
                            _super.call(this);
                            this._buffer = new this.sec.flash.utils.ByteArray();
                            this._writePosition = 0;
                            this._connected = false;
                        }
                        Object.defineProperty(URLStream.prototype, 'connected', {
                            // _diskCacheEnabled: boolean;
                            get: function () {
                                return this._connected;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, 'bytesAvailable', {
                            get: function () {
                                return this._buffer.length - this._buffer.position;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, 'objectEncoding', {
                            get: function () {
                                return this._buffer.objectEncoding;
                            },
                            set: function (version) {
                                version = version >>> 0;
                                this._buffer.objectEncoding = version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, 'endian', {
                            get: function () {
                                return this._buffer.endian;
                            },
                            set: function (type) {
                                type = axCoerceString(type);
                                this._buffer.endian = type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, 'diskCacheEnabled', {
                            get: function () {
                                release || notImplemented('public flash.net.URLStream::get diskCacheEnabled');
                                return;    // return this._diskCacheEnabled;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, 'position', {
                            get: function () {
                                return this._buffer.position;
                            },
                            set: function (offset) {
                                offset = +offset;
                                this._buffer.position = offset;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(URLStream.prototype, 'length', {
                            get: function () {
                                return this._buffer.length;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        URLStream.prototype.load = function (request) {
                            var Event = flash.events.Event;
                            var IOErrorEvent = flash.events.IOErrorEvent;
                            var ProgressEvent = flash.events.ProgressEvent;
                            var HTTPStatusEvent = flash.events.HTTPStatusEvent;
                            var session = FileLoadingService.instance.createSession();
                            var self = this;
                            var initStream = true;
                            var eventsPackage = this.sec.flash.events;
                            session.onprogress = function (data, progressState) {
                                var readPosition = self._buffer.position;
                                self._buffer.position = self._writePosition;
                                self._buffer.writeRawBytes(data);
                                self._writePosition = self._buffer.position;
                                self._buffer.position = readPosition;
                                self.dispatchEvent(new eventsPackage.ProgressEvent(ProgressEvent.PROGRESS, false, false, progressState.bytesLoaded, progressState.bytesTotal));
                            };
                            session.onerror = function (error) {
                                self._connected = false;
                                self.dispatchEvent(new eventsPackage.IOErrorEvent(IOErrorEvent.IO_ERROR, false, false, error));
                                var isXDomainError = typeof error === 'string' && error.indexOf('XDOMAIN') >= 0;
                                Shumway.Telemetry.instance.reportTelemetry({
                                    topic: 'loadResource',
                                    resultType: isXDomainError ? 5    /* StreamCrossdomain */ : 4    /* StreamDenied */
                                });
                            };
                            session.onopen = function () {
                                self._connected = true;
                                self.dispatchEvent(new eventsPackage.Event(Event.OPEN, false, false));
                                Shumway.Telemetry.instance.reportTelemetry({
                                    topic: 'loadResource',
                                    resultType: 3    /* StreamAllowed */
                                });
                            };
                            session.onhttpstatus = function (location, httpStatus, httpHeaders) {
                                var httpStatusEvent = new eventsPackage.HTTPStatusEvent(HTTPStatusEvent.HTTP_STATUS, false, false, httpStatus);
                                var headers = [];
                                httpHeaders.split(/(?:\n|\r?\n)/g).forEach(function (h) {
                                    var m = /^([^:]+): (.*)$/.exec(h);
                                    if (m) {
                                        headers.push(new self.sec.flash.net.URLRequestHeader(m[1], m[2]));
                                        if (m[1] === 'Location') {
                                            location = m[2];
                                        }
                                    }
                                });
                                var boxedHeaders = self.sec.createArray(headers);
                                httpStatusEvent.axSetPublicProperty('responseHeaders', boxedHeaders);
                                httpStatusEvent.axSetPublicProperty('responseURL', location);
                                self.dispatchEvent(httpStatusEvent);
                            };
                            session.onclose = function () {
                                self._connected = false;
                                self.dispatchEvent(new eventsPackage.Event(Event.COMPLETE, false, false));
                            };
                            session.open(request._toFileRequest());
                            this._session = session;
                        };
                        URLStream.prototype.readBytes = function (bytes, offset, length) {
                            if (offset === void 0) {
                                offset = 0;
                            }
                            if (length === void 0) {
                                length = 0;
                            }
                            offset = offset >>> 0;
                            length = length >>> 0;
                            if (length < 0) {
                                this.sec.throwError('ArgumentError', AVMX.Errors.InvalidArgumentError, 'length');
                            }
                            this._buffer.readBytes(bytes, offset, length);
                        };
                        URLStream.prototype.readBoolean = function () {
                            release || notImplemented('public flash.net.URLStream::readBoolean');
                            return;
                        };
                        URLStream.prototype.readByte = function () {
                            return this._buffer.readByte();
                        };
                        URLStream.prototype.readUnsignedByte = function () {
                            release || notImplemented('public flash.net.URLStream::readUnsignedByte');
                            return;
                        };
                        URLStream.prototype.readShort = function () {
                            release || notImplemented('public flash.net.URLStream::readShort');
                            return;
                        };
                        URLStream.prototype.readUnsignedShort = function () {
                            return this._buffer.readUnsignedShort();
                        };
                        URLStream.prototype.readUnsignedInt = function () {
                            release || notImplemented('public flash.net.URLStream::readUnsignedInt');
                            return;
                        };
                        URLStream.prototype.readInt = function () {
                            release || notImplemented('public flash.net.URLStream::readInt');
                            return;
                        };
                        URLStream.prototype.readFloat = function () {
                            release || notImplemented('public flash.net.URLStream::readFloat');
                            return;
                        };
                        URLStream.prototype.readDouble = function () {
                            release || notImplemented('public flash.net.URLStream::readDouble');
                            return;
                        };
                        URLStream.prototype.readMultiByte = function (length, charSet) {
                            length = length >>> 0;
                            charSet = axCoerceString(charSet);
                            release || notImplemented('public flash.net.URLStream::readMultiByte');
                            return;
                        };
                        URLStream.prototype.readUTF = function () {
                            return this._buffer.readUTF();
                        };
                        URLStream.prototype.readUTFBytes = function (length) {
                            return this._buffer.readUTFBytes(length);
                        };
                        URLStream.prototype.close = function () {
                            if (this._session) {
                                this._session.close();
                            }
                        };
                        URLStream.prototype.readObject = function () {
                            release || notImplemented('public flash.net.URLStream::readObject');
                            return;
                        };
                        URLStream.prototype.stop = function () {
                            release || notImplemented('public flash.net.URLStream::stop');
                            return;
                        };
                        // Called whenever the class is initialized.
                        URLStream.classInitializer = null;
                        // List of static symbols to link.
                        URLStream.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        URLStream.instanceSymbols = null;
                        // [];
                        return URLStream;
                    }(flash.events.EventDispatcher);
                    net.URLStream = URLStream;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var URLVariables = function (_super) {
                        __extends(URLVariables, _super);
                        function URLVariables(source) {
                            if (source === void 0) {
                                source = null;
                            }
                            _super.call(this);
                            this._ignoreDecodingErrors = false;
                            source && this.decode(source);
                        }
                        URLVariables.prototype.decode = function (source) {
                            source = axCoerceString(source);
                            var variables = source.split('&');
                            for (var i = 0; i < variables.length; i++) {
                                var p = variables[i];
                                var j = p.indexOf('=');
                                if (j < 0) {
                                    if (this._ignoreDecodingErrors) {
                                        j = p.length;
                                    } else {
                                        this.sec.throwError('Error', AVMX.Errors.DecodeParamError);
                                    }
                                }
                                var name = unescape(p.substring(0, j).split('+').join(' '));
                                var value = unescape(p.substring(j + 1).split('+').join(' '));
                                var currentValue = this.axGetPublicProperty(name);
                                if (typeof currentValue === 'undefined') {
                                    this.axSetPublicProperty(name, value);
                                } else if (Array.isArray(currentValue)) {
                                    currentValue.push(value);
                                } else {
                                    this.axSetPublicProperty(name, [
                                        currentValue,
                                        value
                                    ]);
                                }
                            }
                        };
                        URLVariables.prototype.toString = function () {
                            var pairs = [];
                            var keys = this.axGetEnumerableKeys();
                            for (var i = 0; i < keys.length; i++) {
                                var name = keys[i].split(' ').join('+');
                                var value = this.axGetPublicProperty(name);
                                name = escape(name).split(' ').join('+');
                                if (Array.isArray(value)) {
                                    for (var j = 0; j < value.length; j++) {
                                        pairs.push(name + '=' + escape(value[j]));
                                    }
                                } else {
                                    pairs.push(name + '=' + escape(value));
                                }
                            }
                            return pairs.join('&');
                        };
                        URLVariables.classInitializer = null;
                        URLVariables.classSymbols = null;
                        // [];
                        URLVariables.instanceSymbols = null;
                        return URLVariables;
                    }(AS.ASObject);
                    net.URLVariables = URLVariables;
                }(net = flash.net || (flash.net = {})));
                var sensors;
                (function (sensors) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var Accelerometer = function (_super) {
                        __extends(Accelerometer, _super);
                        function Accelerometer() {
                            _super.call(this);
                        }
                        Object.defineProperty(Accelerometer.prototype, 'isSupported', {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _isSupported: boolean;
                            get: function () {
                                release || notImplemented('public flash.sensors.Accelerometer::get isSupported');
                                return;    // return this._isSupported;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Accelerometer.prototype, 'muted', {
                            // _muted: boolean;
                            get: function () {
                                release || notImplemented('public flash.sensors.Accelerometer::get muted');
                                return;    // return this._muted;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Accelerometer.prototype.setRequestedUpdateInterval = function (interval) {
                            interval = +interval;
                            release || notImplemented('public flash.sensors.Accelerometer::setRequestedUpdateInterval');
                            return;
                        };
                        // Called whenever the class is initialized.
                        Accelerometer.classInitializer = null;
                        // List of static symbols to link.
                        Accelerometer.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Accelerometer.instanceSymbols = null;
                        // [];
                        return Accelerometer;
                    }(flash.events.EventDispatcher);
                    sensors.Accelerometer = Accelerometer;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var Geolocation = function (_super) {
                        __extends(Geolocation, _super);
                        function Geolocation() {
                            _super.call(this);
                        }
                        Object.defineProperty(Geolocation.prototype, 'isSupported', {
                            // static _isSupported: boolean;
                            get: function () {
                                release || notImplemented('public flash.sensors.Geolocation::get isSupported');
                                return;    // return this._isSupported;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Geolocation.prototype, 'muted', {
                            // _muted: boolean;
                            get: function () {
                                release || notImplemented('public flash.sensors.Geolocation::get muted');
                                return;    // return this._muted;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Geolocation.prototype.setRequestedUpdateInterval = function (interval) {
                            interval = +interval;
                            release || notImplemented('public flash.sensors.Geolocation::setRequestedUpdateInterval');
                            return;
                        };
                        // Called whenever the class is initialized.
                        Geolocation.classInitializer = null;
                        // List of static symbols to link.
                        Geolocation.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Geolocation.instanceSymbols = null;
                        // [];
                        return Geolocation;
                    }(flash.events.EventDispatcher);
                    sensors.Geolocation = Geolocation;
                }(sensors = flash.sensors || (flash.sensors = {})));
                var system;
                (function (system) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var AXApplicationDomain = Shumway.AVMX.AXApplicationDomain;
                    var ApplicationDomain = function (_super) {
                        __extends(ApplicationDomain, _super);
                        function ApplicationDomain(parentDomainOrAXDomain) {
                            if (parentDomainOrAXDomain === void 0) {
                                parentDomainOrAXDomain = null;
                            }
                            _super.call(this);
                            release || Shumway.Debug.assert(!(this instanceof ApplicationDomain));
                            if (parentDomainOrAXDomain instanceof AXApplicationDomain) {
                                this.axDomain = parentDomainOrAXDomain;
                                return;
                            }
                            var parentRuntimeDomain = null;
                            if (this.sec.flash.system.ApplicationDomain.axIsType(parentDomainOrAXDomain)) {
                                parentRuntimeDomain = parentDomainOrAXDomain.axDomain;
                            } else {
                                parentRuntimeDomain = this.sec.application;
                            }
                            this.axDomain = new AXApplicationDomain(this.sec, parentRuntimeDomain);
                        }
                        Object.defineProperty(ApplicationDomain, 'currentDomain', {
                            // This must return a new object each time.
                            get: function () {
                                var currentABC = AVMX.getCurrentABC();
                                var app = currentABC ? currentABC.env.app : this.sec.application;
                                return new this.sec.flash.system.ApplicationDomain(app);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ApplicationDomain, 'MIN_DOMAIN_MEMORY_LENGTH', {
                            get: function () {
                                release || notImplemented('public flash.system.ApplicationDomain::get MIN_DOMAIN_MEMORY_LENGTH');
                                return;    // return this._MIN_DOMAIN_MEMORY_LENGTH;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ApplicationDomain.prototype, 'parentDomain', {
                            get: function () {
                                var currentABC = AVMX.getCurrentABC();
                                var app = currentABC ? currentABC.env.app : this.sec.application;
                                release || Shumway.Debug.assert(app.parent !== undefined);
                                return new this.sec.flash.system.ApplicationDomain(app.parent);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ApplicationDomain.prototype, 'domainMemory', {
                            get: function () {
                                release || notImplemented('public flash.system.ApplicationDomain::get domainMemory');
                                return;    // return this._domainMemory;
                            },
                            set: function (mem) {
                                mem = mem;
                                release || notImplemented('public flash.system.ApplicationDomain::set domainMemory');
                                return;    // this._domainMemory = mem;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ApplicationDomain.prototype.getDefinition = function (name) {
                            var definition = this.getDefinitionImpl(name);
                            if (!definition) {
                                this.sec.throwError('ReferenceError', AVMX.Errors.UndefinedVarError, name);
                            }
                            return definition;
                        };
                        ApplicationDomain.prototype.hasDefinition = function (name) {
                            return !!this.getDefinitionImpl(name);
                        };
                        ApplicationDomain.prototype.getDefinitionImpl = function (name) {
                            name = axCoerceString(name);
                            if (!name) {
                                this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'definitionName');
                            }
                            var simpleName = name.replace('::', '.');
                            var mn = AVMX.Multiname.FromFQNString(simpleName, 0    /* Public */);
                            return this.axDomain.getProperty(mn, false, false);
                        };
                        ApplicationDomain.prototype.getQualifiedDefinitionNames = function () {
                            release || notImplemented('public flash.system.ApplicationDomain::getQualifiedDefinitionNames');
                            return;
                        };
                        return ApplicationDomain;
                    }(AS.ASObject);
                    system.ApplicationDomain = ApplicationDomain;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var toKeyValueArray = Shumway.ObjectUtilities.toKeyValueArray;
                    var Capabilities = function (_super) {
                        __extends(Capabilities, _super);
                        function Capabilities() {
                            _super.call(this);
                        }
                        Object.defineProperty(Capabilities, 'isEmbeddedInAcrobat', {
                            // static _touchscreenType: string;
                            // static _hasIME: boolean;
                            // static _hasTLS: boolean;
                            // static _maxLevelIDC: string;
                            // static _supports32BitProcesses: boolean;
                            // static _supports64BitProcesses: boolean;
                            // static __internal: number /*uint*/;
                            get: function () {
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasEmbeddedVideo', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get hasEmbeddedVideo');
                                return;    // return Capabilities._hasEmbeddedVideo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasAudio', {
                            get: function () {
                                // The documentation says "this property is always true".
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'avHardwareDisable', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get avHardwareDisable');
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasAccessibility', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get hasAccessibility');
                                return Capabilities._hasAccessibility;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasAudioEncoder', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get hasAudioEncoder');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasMP3', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get hasMP3');
                                return;    // return Capabilities._hasMP3;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasPrinting', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get hasPrinting');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasScreenBroadcast', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get hasScreenBroadcast');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasScreenPlayback', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get hasScreenPlayback');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasStreamingAudio', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get hasStreamingAudio');
                                return;    // return Capabilities._hasStreamingAudio;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasStreamingVideo', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get hasStreamingVideo');
                                return;    // return Capabilities._hasStreamingVideo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasVideoEncoder', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get hasVideoEncoder');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'isDebugger', {
                            get: function () {
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'localFileReadDisable', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get localFileReadDisable');
                                return;    // return Capabilities._localFileReadDisable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'language', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get language');
                                return Capabilities._language;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'manufacturer', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get manufacturer');
                                return Capabilities._manufacturer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'os', {
                            get: function () {
                                if (Capabilities._os === null) {
                                    var os;
                                    var userAgent = window.navigator.userAgent;
                                    if (userAgent.indexOf('Macintosh') > 0) {
                                        if (userAgent.indexOf('Mac OS X ') === -1) {
                                            os = 'Mac OS 10.6';
                                        } else {
                                            var versionStr = userAgent.split('Mac OS X ')[1];
                                            os = versionStr.substr(0, versionStr.indexOf(';'));
                                        }
                                    } else if (userAgent.indexOf('Windows') > 0) {
                                        os = 'Windows XP';
                                    } else if (userAgent.indexOf('Linux') > 0) {
                                        os = 'Linux';
                                    } else if (/(iPad|iPhone|iPod|Android)/.test(userAgent)) {
                                        os = 'iPhone3,1';
                                    } else {
                                        release || somewhatImplemented('public flash.system.Capabilities::get os');
                                        os = 'Generic OS';
                                    }
                                    Capabilities._os = os;
                                }
                                return Capabilities._os;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'cpuArchitecture', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get cpuArchitecture');
                                return 'x86';
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'playerType', {
                            get: function () {
                                return Capabilities._playerType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'serverString', {
                            get: function () {
                                var str = toKeyValueArray({ OS: Capabilities.os }).map(function (pair) {
                                    return pair[0] + '=' + encodeURIComponent(pair[1]);
                                }).join('&');
                                release || somewhatImplemented('Capabilities.serverString: ' + str);
                                return str;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'version', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get version');
                                return Capabilities._version;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'screenColor', {
                            /**
                             * This can be "color", "gray" or "bw" for black and white. I don't know when you'd have anything
                             * other than "color".
                             */
                            get: function () {
                                return 'color';
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'pixelAspectRatio', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get pixelAspectRatio');
                                return 1;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'screenDPI', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get screenDPI');
                                return Capabilities._screenDPI;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'screenResolutionX', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get screenResolutionX');
                                return window.screen.width;    // TODO check
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'screenResolutionY', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Capabilities::get screenResolutionY');
                                return window.screen.height;    // TODO check
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'touchscreenType', {
                            get: function () {
                                return system.TouchscreenType.NONE;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasIME', {
                            get: function () {
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'hasTLS', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get hasTLS');
                                return;    // return Capabilities._hasTLS;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'maxLevelIDC', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get maxLevelIDC');
                                return;    // return Capabilities._maxLevelIDC;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'supports32BitProcesses', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get supports32BitProcesses');
                                return;    // return Capabilities._supports32BitProcesses;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, 'supports64BitProcesses', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get supports64BitProcesses');
                                return;    // return Capabilities._supports64BitProcesses;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Capabilities, '_internal', {
                            get: function () {
                                release || notImplemented('public flash.system.Capabilities::get _internal');
                                return;    // return Capabilities.__internal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Capabilities.hasMultiChannelAudio = function (type) {
                            release || somewhatImplemented('public flash.system.Capabilities::static hasMultiChannelAudio');
                            return false;
                        };
                        Capabilities.classInitializer = null;
                        // static _hasEmbeddedVideo: boolean;
                        // static _hasAudio: boolean;
                        // static _avHardwareDisable: boolean;
                        Capabilities._hasAccessibility = false;
                        // static _hasAudioEncoder: boolean;
                        // static _hasMP3: boolean;
                        // static _hasPrinting: boolean;
                        // static _hasScreenBroadcast: boolean;
                        // static _hasScreenPlayback: boolean;
                        // static _hasStreamingAudio: boolean;
                        // static _hasStreamingVideo: boolean;
                        // static _hasVideoEncoder: boolean;
                        // static _localFileReadDisable: boolean;
                        Capabilities._language = 'en';
                        Capabilities._manufacturer = 'Mozilla Research';
                        Capabilities._os = null;
                        // static _cpuArchitecture: string;
                        Capabilities._playerType = 'PlugIn';
                        Capabilities._version = 'SHUMWAY 10,0,0,0';
                        // static _screenColor: string;
                        // static _pixelAspectRatio: number;
                        Capabilities._screenDPI = 96;
                        // Using standard CSS DPI for now.
                        return Capabilities;
                    }(AS.ASObject);
                    system.Capabilities = Capabilities;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    function fscommand(sec, command, args) {
                        command = axCoerceString(command);
                        args = axCoerceString(args);
                        console.log('FSCommand: ' + command + '; ' + args);
                        command = command.toLowerCase();
                        if (command === 'debugger') {
                            /* tslint:disable */
                            debugger;
                            /* tslint:enable */
                            return;
                        }
                        sec.player.executeFSCommand(command, args);
                    }
                    system.fscommand = fscommand;
                    var ImageDecodingPolicy = function (_super) {
                        __extends(ImageDecodingPolicy, _super);
                        function ImageDecodingPolicy() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        ImageDecodingPolicy.classInitializer = null;
                        // List of static symbols to link.
                        ImageDecodingPolicy.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        ImageDecodingPolicy.instanceSymbols = null;
                        // [];
                        ImageDecodingPolicy.ON_DEMAND = 'onDemand';
                        ImageDecodingPolicy.ON_LOAD = 'onLoad';
                        return ImageDecodingPolicy;
                    }(AS.ASObject);
                    system.ImageDecodingPolicy = ImageDecodingPolicy;
                    var LoaderContext = function (_super) {
                        __extends(LoaderContext, _super);
                        function LoaderContext(checkPolicyFile, applicationDomain, securityDomain) {
                            if (checkPolicyFile === void 0) {
                                checkPolicyFile = false;
                            }
                            if (applicationDomain === void 0) {
                                applicationDomain = null;
                            }
                            if (securityDomain === void 0) {
                                securityDomain = null;
                            }
                            _super.call(this);
                            this.$BgcheckPolicyFile = !!checkPolicyFile;
                            this.$BgapplicationDomain = applicationDomain;
                            this.$BgsecurityDomain = securityDomain;
                            this.$BgimageDecodingPolicy = flash.system.ImageDecodingPolicy.ON_DEMAND;
                            this._avm1Context = null;
                        }
                        Object.defineProperty(LoaderContext.prototype, 'imageDecodingPolicy', {
                            get: function () {
                                return this.$BgimageDecodingPolicy;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderContext.prototype, 'parameters', {
                            get: function () {
                                return this.$Bgparameters;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderContext.prototype, 'requestedContentParent', {
                            get: function () {
                                return this.$BgrequestedContentParent;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderContext.prototype, 'allowCodeImport', {
                            get: function () {
                                return this.$BgallowCodeImport;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderContext.prototype, 'securityDomain', {
                            get: function () {
                                return this.$BgsecurityDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderContext.prototype, 'applicationDomain', {
                            get: function () {
                                return this.$BgapplicationDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(LoaderContext.prototype, 'checkPolicyFile', {
                            get: function () {
                                return this.$BgcheckPolicyFile;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        LoaderContext.classInitializer = null;
                        LoaderContext.instanceSymbols = [
                            'checkPolicyFile!',
                            'applicationDomain!',
                            'sec!',
                            'allowCodeImport!',
                            'requestedContentParent!',
                            'parameters!',
                            'imageDecodingPolicy!'
                        ];
                        return LoaderContext;
                    }(AS.ASObject);
                    system.LoaderContext = LoaderContext;
                    var JPEGLoaderContext = function (_super) {
                        __extends(JPEGLoaderContext, _super);
                        function JPEGLoaderContext(deblockingFilter, checkPolicyFile, applicationDomain, securityDomain) {
                            if (deblockingFilter === void 0) {
                                deblockingFilter = 0;
                            }
                            if (checkPolicyFile === void 0) {
                                checkPolicyFile = false;
                            }
                            if (applicationDomain === void 0) {
                                applicationDomain = null;
                            }
                            if (securityDomain === void 0) {
                                securityDomain = null;
                            }
                            _super.call(this, checkPolicyFile, applicationDomain, securityDomain);
                            this.deblockingFilter = +deblockingFilter;
                        }
                        // Called whenever the class is initialized.
                        JPEGLoaderContext.classInitializer = null;
                        // List of static symbols to link.
                        JPEGLoaderContext.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        JPEGLoaderContext.instanceSymbols = null;
                        // ["deblockingFilter"];
                        return JPEGLoaderContext;
                    }(flash.system.LoaderContext);
                    system.JPEGLoaderContext = JPEGLoaderContext;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var MessageChannel = function (_super) {
                        __extends(MessageChannel, _super);
                        function MessageChannel() {
                            _super.call(this);
                        }
                        Object.defineProperty(MessageChannel.prototype, 'messageAvailable', {
                            // addEventListener: (type: string, listener: ASFunction, useCapture: boolean = false, priority: number /*int*/ = 0, useWeakReference: boolean = false) => void;
                            // removeEventListener: (type: string, listener: ASFunction, useCapture: boolean = false) => void;
                            // AS -> JS Bindings
                            // _messageAvailable: boolean;
                            // _state: string;
                            get: function () {
                                release || notImplemented('public flash.system.MessageChannel::get messageAvailable');
                                return;    // return this._messageAvailable;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MessageChannel.prototype, 'state', {
                            get: function () {
                                release || notImplemented('public flash.system.MessageChannel::get state');
                                return;    // return this._state;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        MessageChannel.prototype.send = function (arg, queueLimit) {
                            if (queueLimit === void 0) {
                                queueLimit = -1;
                            }
                            queueLimit = queueLimit | 0;
                            release || notImplemented('public flash.system.MessageChannel::send');
                            return;
                        };
                        MessageChannel.prototype.receive = function (blockUntilReceived) {
                            if (blockUntilReceived === void 0) {
                                blockUntilReceived = false;
                            }
                            blockUntilReceived = !!blockUntilReceived;
                            release || notImplemented('public flash.system.MessageChannel::receive');
                            return;
                        };
                        MessageChannel.prototype.close = function () {
                            release || notImplemented('public flash.system.MessageChannel::close');
                            return;
                        };
                        // Called whenever the class is initialized.
                        MessageChannel.classInitializer = null;
                        // List of static symbols to link.
                        MessageChannel.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        MessageChannel.instanceSymbols = null;
                        // ["addEventListener", "removeEventListener", "toString"];
                        return MessageChannel;
                    }(flash.events.EventDispatcher);
                    system.MessageChannel = MessageChannel;
                    var MessageChannelState = function (_super) {
                        __extends(MessageChannelState, _super);
                        function MessageChannelState() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        MessageChannelState.classInitializer = null;
                        // List of static symbols to link.
                        MessageChannelState.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        MessageChannelState.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        MessageChannelState.OPEN = 'open';
                        MessageChannelState.CLOSING = 'closing';
                        MessageChannelState.CLOSED = 'closed';
                        return MessageChannelState;
                    }(AS.ASObject);
                    system.MessageChannelState = MessageChannelState;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var Security = function (_super) {
                        __extends(Security, _super);
                        function Security() {
                            _super.call(this);
                        }
                        Object.defineProperty(Security, 'exactSettings', {
                            // static _pageDomain: string;
                            get: function () {
                                return Security._exactSettings;
                            },
                            set: function (value) {
                                value = !!value;
                                Security._exactSettings = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Security, 'disableAVM1Loading', {
                            get: function () {
                                release || notImplemented('public flash.system.Security::get disableAVM1Loading');
                                return;    // return Security._disableAVM1Loading;
                            },
                            set: function (value) {
                                value = !!value;
                                release || notImplemented('public flash.system.Security::set disableAVM1Loading');
                                return;    // Security._disableAVM1Loading = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Security, 'sandboxType', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Security::get sandboxType');
                                return Security._sandboxType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Security, 'pageDomain', {
                            get: function () {
                                release || somewhatImplemented('public flash.system.Security::get pageDomain');
                                // TODO: convert this to proper URI parsing.
                                var pageHost = Shumway.FileLoadingService.instance.resolveUrl('/');
                                var parts = pageHost.split('/');
                                parts.pop();
                                return parts.pop();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Security.allowDomain = function () {
                            release || somewhatImplemented('public flash.system.Security::static allowDomain ["' + Array.prototype.join.call(arguments, '", "') + '"]');
                            var whitelist = this.sec.player;
                            for (var i = 0; i < arguments.length; i++) {
                                whitelist.addToSWFLoadingWhitelist(axCoerceString(arguments[i]) || '', false, false);
                            }
                        };
                        Security.allowInsecureDomain = function () {
                            release || somewhatImplemented('public flash.system.Security::static allowInsecureDomain');
                            var whitelist = this.sec.player;
                            for (var i = 0; i < arguments.length; i++) {
                                whitelist.addToSWFLoadingWhitelist(axCoerceString(arguments[i]) || '', true, false);
                            }
                        };
                        Security.loadPolicyFile = function (url) {
                            url = axCoerceString(url);
                            release || somewhatImplemented('public flash.system.Security::static loadPolicyFile');
                        };
                        Security.showSettings = function (panel) {
                            if (panel === void 0) {
                                panel = 'default';
                            }
                            panel = axCoerceString(panel);
                            release || notImplemented('public flash.system.Security::static showSettings');
                            return;
                        };
                        Security.duplicateSandboxBridgeInputArguments = function (toplevel, args) {
                            toplevel = toplevel;
                            args = args;
                            release || notImplemented('public flash.system.Security::static duplicateSandboxBridgeInputArguments');
                            return;
                        };
                        Security.duplicateSandboxBridgeOutputArgument = function (toplevel, arg) {
                            toplevel = toplevel;
                            release || notImplemented('public flash.system.Security::static duplicateSandboxBridgeOutputArgument');
                            return;
                        };
                        // Called whenever the class is initialized.
                        Security.classInitializer = null;
                        // List of static symbols to link.
                        Security.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Security.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        Security.REMOTE = 'remote';
                        Security.LOCAL_WITH_FILE = 'localWithFile';
                        Security.LOCAL_WITH_NETWORK = 'localWithNetwork';
                        Security.LOCAL_TRUSTED = 'localTrusted';
                        Security.APPLICATION = 'application';
                        // AS -> JS Bindings
                        Security._exactSettings = false;
                        // static _disableAVM1Loading: boolean;
                        Security._sandboxType = 'remote';
                        return Security;
                    }(AS.ASObject);
                    system.Security = Security;
                    var SecurityDomain = function (_super) {
                        __extends(SecurityDomain, _super);
                        function SecurityDomain() {
                            _super.call(this);
                            this.sec.throwError('ArgumentError', AVMX.Errors.CantInstantiateError, 'SecurityDomain');
                        }
                        Object.defineProperty(SecurityDomain, 'currentDomain', {
                            get: function () {
                                var currentABC = AVMX.getCurrentABC();
                                var sec = currentABC ? currentABC.env.app.sec : this.sec;
                                // TODO: memoize the flash.system.SecurityDomain instance
                                return Object.create(sec.flash.system.SecurityDomain.axClass.tPrototype);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        SecurityDomain.classInitializer = null;
                        return SecurityDomain;
                    }(AS.ASObject);
                    system.SecurityDomain = SecurityDomain;
                    var SecurityPanel = function (_super) {
                        __extends(SecurityPanel, _super);
                        function SecurityPanel() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        SecurityPanel.classInitializer = null;
                        // List of static symbols to link.
                        SecurityPanel.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        SecurityPanel.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        SecurityPanel.DEFAULT = 'default';
                        SecurityPanel.PRIVACY = 'privacy';
                        SecurityPanel.LOCAL_STORAGE = 'localStorage';
                        SecurityPanel.MICROPHONE = 'microphone';
                        SecurityPanel.CAMERA = 'camera';
                        SecurityPanel.DISPLAY = 'display';
                        SecurityPanel.SETTINGS_MANAGER = 'settingsManager';
                        return SecurityPanel;
                    }(AS.ASObject);
                    system.SecurityPanel = SecurityPanel;
                    var TouchscreenType = function (_super) {
                        __extends(TouchscreenType, _super);
                        function TouchscreenType() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        TouchscreenType.classInitializer = null;
                        // List of static symbols to link.
                        TouchscreenType.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        TouchscreenType.instanceSymbols = null;
                        // [];
                        TouchscreenType.FINGER = 'finger';
                        TouchscreenType.STYLUS = 'stylus';
                        TouchscreenType.NONE = 'none';
                        return TouchscreenType;
                    }(AS.ASObject);
                    system.TouchscreenType = TouchscreenType;
                }(system = flash.system || (flash.system = {})));
                var text;
                (function (text) {
                    var AntiAliasType = function (_super) {
                        __extends(AntiAliasType, _super);
                        function AntiAliasType() {
                            _super.call(this);
                        }
                        AntiAliasType.fromNumber = function (n) {
                            switch (n) {
                            case 1:
                                return AntiAliasType.NORMAL;
                            case 2:
                                return AntiAliasType.ADVANCED;
                            default:
                                return null;
                            }
                        };
                        AntiAliasType.toNumber = function (value) {
                            switch (value) {
                            case AntiAliasType.NORMAL:
                                return 1;
                            case AntiAliasType.ADVANCED:
                                return 2;
                            default:
                                return -1;
                            }
                        };
                        AntiAliasType.classInitializer = null;
                        AntiAliasType.classSymbols = null;
                        AntiAliasType.instanceSymbols = null;
                        // JS -> AS Bindings
                        AntiAliasType.NORMAL = 'normal';
                        AntiAliasType.ADVANCED = 'advanced';
                        return AntiAliasType;
                    }(AS.ASObject);
                    text.AntiAliasType = AntiAliasType;
                    var FontStyle = function (_super) {
                        __extends(FontStyle, _super);
                        function FontStyle() {
                            _super.call(this);
                        }
                        FontStyle.classInitializer = null;
                        FontStyle.classSymbols = null;
                        FontStyle.instanceSymbols = null;
                        // JS -> AS Bindings
                        FontStyle.REGULAR = 'regular';
                        FontStyle.BOLD = 'bold';
                        FontStyle.ITALIC = 'italic';
                        FontStyle.BOLD_ITALIC = 'boldItalic';
                        return FontStyle;
                    }(AS.ASObject);
                    text.FontStyle = FontStyle;
                    var FontType = function (_super) {
                        __extends(FontType, _super);
                        function FontType() {
                            _super.call(this);
                        }
                        FontType.classInitializer = null;
                        FontType.classSymbols = null;
                        FontType.instanceSymbols = null;
                        // JS -> AS Bindings
                        FontType.EMBEDDED = 'embedded';
                        FontType.EMBEDDED_CFF = 'embeddedCFF';
                        FontType.DEVICE = 'device';
                        return FontType;
                    }(AS.ASObject);
                    text.FontType = FontType;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var assert = Shumway.Debug.assert;
                    var FontStyle = flash.text.FontStyle;
                    var FontType = flash.text.FontType;
                    var Font = function (_super) {
                        __extends(Font, _super);
                        function Font() {
                            _super.call(this);
                            if (!this._symbol) {
                                this._initializeFields();
                            }
                        }
                        Font.prototype._initializeFields = function () {
                            this._fontName = null;
                            this._fontFamily = null;
                            this._fontStyle = null;
                            this._fontType = null;
                            this.ascent = 0;
                            this.descent = 0;
                            this.leading = 0;
                            this.advances = null;
                            this._id = flash.display.DisplayObject.getNextSyncID();
                        };
                        Font._getFontMetrics = function (name, style) {
                            return this._deviceFontMetrics[name + style] || this._deviceFontMetrics[name];
                        };
                        Font.resolveFontName = function (name) {
                            if (name === '_sans') {
                                return this.DEFAULT_FONT_SANS;
                            } else if (name === '_serif') {
                                return this.DEFAULT_FONT_SERIF;
                            } else if (name === '_typewriter') {
                                return this.DEFAULT_FONT_TYPEWRITER;
                            }
                            return name;
                        };
                        Font.prototype.applySymbol = function () {
                            release || Shumway.Debug.assert(this._symbol);
                            var symbol = this._symbol;
                            release || Shumway.Debug.assert(symbol.syncId);
                            this._initializeFields();
                            this._id = symbol.syncId;
                            this._fontName = symbol.name;
                            var fontClass = this.sec.flash.text.Font.axClass;
                            this._fontFamily = fontClass.resolveFontName(symbol.name);
                            if (symbol.bold) {
                                if (symbol.italic) {
                                    this._fontStyle = FontStyle.BOLD_ITALIC;
                                } else {
                                    this._fontStyle = FontStyle.BOLD;
                                }
                            } else if (symbol.italic) {
                                this._fontStyle = FontStyle.ITALIC;
                            } else {
                                this._fontStyle = FontStyle.REGULAR;
                            }
                            var metrics = symbol.metrics;
                            if (metrics) {
                                this.ascent = metrics.ascent;
                                this.descent = metrics.descent;
                                this.leading = metrics.leading;
                                this.advances = metrics.advances;
                            }
                            // Font symbols without any glyphs describe device fonts.
                            this._fontType = metrics ? FontType.EMBEDDED : FontType.DEVICE;
                            // Keeping fontProp.configurable === true, some old movies have fonts with non-unique
                            // names.
                            var fontProp = {
                                value: this,
                                configurable: true
                            };
                            Object.defineProperty(fontClass._fontsBySymbolId, symbol.id + '', fontProp);
                            Object.defineProperty(fontClass._fontsByName, symbol.name.toLowerCase() + this._fontStyle, fontProp);
                            if (this._fontType === FontType.EMBEDDED) {
                                Object.defineProperty(fontClass._fontsByName, 'swffont' + symbol.syncId + this._fontStyle, fontProp);
                            }
                        };
                        Font.getBySymbolId = function (id) {
                            return this._fontsBySymbolId[id];
                        };
                        Font.getByNameAndStyle = function (name, style) {
                            var key;
                            var font;
                            // The name argument can be a string specifying a list of comma-delimited font names in which
                            // case the first available font should be used.
                            var names = name.split(',');
                            for (var i = 0; i < names.length && !font; i++) {
                                key = names[i].toLowerCase() + style;
                                font = this._fontsByName[key];
                            }
                            if (!font) {
                                var font = new this.sec.flash.text.Font();
                                font._fontName = names[0];
                                font._fontFamily = this.resolveFontName(names[0].toLowerCase());
                                font._fontStyle = style;
                                font._fontType = FontType.DEVICE;
                                this._fontsByName[key] = font;
                            }
                            if (font._fontType === FontType.DEVICE) {
                                var metrics = this._getFontMetrics(font._fontName, font._fontStyle);
                                if (!metrics) {
                                    Shumway.Debug.warning('Font metrics for "' + font._fontName + '" unknown. Fallback to default.');
                                    metrics = this._getFontMetrics(this.DEFAULT_FONT_SANS, font._fontStyle);
                                    font._fontFamily = this.DEFAULT_FONT_SANS;
                                }
                                font.ascent = metrics[0];
                                font.descent = metrics[1];
                                font.leading = metrics[2] || 0;
                            }
                            return font;
                        };
                        Font.getDefaultFont = function () {
                            return this.getByNameAndStyle(this.DEFAULT_FONT_SANS, FontStyle.REGULAR);
                        };
                        // AS -> JS Bindings
                        Font.enumerateFonts = function (enumerateDeviceFonts) {
                            if (enumerateDeviceFonts === void 0) {
                                enumerateDeviceFonts = false;
                            }
                            //TODO: support iterating device fonts, perhaps?
                            release || somewhatImplemented('public flash.text.Font::static enumerateFonts');
                            return this.sec.createArrayUnsafe(this._fonts.slice());
                        };
                        Font.registerFont = function (font) {
                            somewhatImplemented('Font.registerFont');
                        };
                        /**
                         * Registers a font symbol as available in the system.
                         *
                         * Firefox decodes fonts synchronously, allowing us to do the decoding upon first actual use.
                         * All we need to do here is let the system know about the family name and ID, so that both
                         * TextFields/Labels referring to the font's symbol ID as well as HTML text specifying a font
                         * face can resolve the font.
                         *
                         * For all other browsers, the decoding has been triggered by the Loader at this point.
                         */
                        Font.registerFontSymbol = function (fontMapping, loaderInfo) {
                            var syncId = this.sec.flash.display.DisplayObject.axClass.getNextSyncID();
                            var key = fontMapping.name.toLowerCase() + fontMapping.style;
                            var resolverProp = {
                                get: this.resolveFontSymbol.bind(this, loaderInfo, fontMapping.id, syncId, key),
                                configurable: true
                            };
                            Object.defineProperty(this._fontsByName, key, resolverProp);
                            Object.defineProperty(this._fontsByName, 'swffont' + syncId + fontMapping.style, resolverProp);
                            Object.defineProperty(this._fontsBySymbolId, fontMapping.id + '', resolverProp);
                        };
                        Font.resolveFontSymbol = function (loaderInfo, id, syncId, key) {
                            // Force font resolution and installation in _fontsByName and _fontsBySymbolId.
                            release || assert('get' in Object.getOwnPropertyDescriptor(this._fontsBySymbolId, id + ''));
                            var symbol = loaderInfo.getSymbolById(id);
                            symbol.syncId = syncId;
                            release || assert('value' in Object.getOwnPropertyDescriptor(this._fontsBySymbolId, id + ''));
                            release || assert('value' in Object.getOwnPropertyDescriptor(this._fontsByName, key));
                            return this._fontsByName[key];
                        };
                        Object.defineProperty(Font.prototype, 'fontName', {
                            get: function () {
                                return this._fontName;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Font.prototype, 'fontStyle', {
                            get: function () {
                                return this._fontStyle;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Font.prototype, 'fontType', {
                            get: function () {
                                return this._fontType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Font.prototype.hasGlyphs = function (str) {
                            str = axCoerceString(str);
                            somewhatImplemented('Font#hasGlyphs');
                            return true;
                        };
                        Font.DEFAULT_FONT_SANS = 'Arial';
                        Font.DEFAULT_FONT_SERIF = 'Times New Roman';
                        Font.DEFAULT_FONT_TYPEWRITER = 'Courier New';
                        Font.classInitializer = function () {
                            this._fonts = [];
                            this._fontsBySymbolId = Shumway.ObjectUtilities.createMap();
                            this._fontsByName = Shumway.ObjectUtilities.createMap();
                            this.DEVICE_FONT_METRICS_BUILTIN = {
                                '_sans': [
                                    0.9,
                                    0.22,
                                    0.08
                                ],
                                '_serif': [
                                    0.88,
                                    0.26,
                                    0.08
                                ],
                                '_typewriter': [
                                    0.86,
                                    0.24,
                                    0.08
                                ]
                            };
                            // Measurements taken on a freshly installed Windows 7 (Ultimate).
                            this.DEVICE_FONT_METRICS_WIN = {
                                __proto__: this.DEVICE_FONT_METRICS_BUILTIN,
                                'Arial': [
                                    1,
                                    0.25
                                ],
                                'Arial Baltic': [
                                    1,
                                    0.25
                                ],
                                'Arial Black': [
                                    1.0833,
                                    0.3333
                                ],
                                'Arial CE': [
                                    1,
                                    0.25
                                ],
                                'Arial CYR': [
                                    1,
                                    0.25
                                ],
                                'Arial Greek': [
                                    1,
                                    0.25
                                ],
                                'Arial TUR': [
                                    1,
                                    0.25
                                ],
                                'Comic Sans MS': [
                                    1.0833,
                                    0.3333
                                ],
                                'Courier New': [
                                    1,
                                    0.25
                                ],
                                'Courier New Baltic': [
                                    1,
                                    0.25
                                ],
                                'Courier New CE': [
                                    1,
                                    0.25
                                ],
                                'Courier New CYR': [
                                    1,
                                    0.25
                                ],
                                'Courier New Greek': [
                                    1,
                                    0.25
                                ],
                                'Courier New TUR': [
                                    1,
                                    0.25
                                ],
                                'Estrangelo Edessa': [
                                    0.75,
                                    0.3333
                                ],
                                'Franklin Gothic Medium': [
                                    1,
                                    0.3333
                                ],
                                'Gautami': [
                                    0.9167,
                                    0.8333
                                ],
                                'Georgia': [
                                    1,
                                    0.25
                                ],
                                'Impact': [
                                    1.0833,
                                    0.25
                                ],
                                'Latha': [
                                    1.0833,
                                    0.25
                                ],
                                'Lucida Console': [
                                    0.75,
                                    0.25
                                ],
                                'Lucida Sans Unicode': [
                                    1.0833,
                                    0.25
                                ],
                                'Mangal': [
                                    1.0833,
                                    0.25
                                ],
                                'Marlett': [
                                    1,
                                    0
                                ],
                                'Microsoft Sans Serif': [
                                    1.0833,
                                    0.1667
                                ],
                                'MV Boli': [
                                    0.9167,
                                    0.25
                                ],
                                'Palatino Linotype': [
                                    1.0833,
                                    0.3333
                                ],
                                'Raavi': [
                                    1.0833,
                                    0.6667
                                ],
                                'Shruti': [
                                    1,
                                    0.5
                                ],
                                'Sylfaen': [
                                    1,
                                    0.3333
                                ],
                                'Symbol': [
                                    1,
                                    0.25
                                ],
                                'Tahoma': [
                                    1,
                                    0.1667
                                ],
                                'Times New Roman': [
                                    1,
                                    0.25
                                ],
                                'Times New Roman Baltic': [
                                    1,
                                    0.25
                                ],
                                'Times New Roman CE': [
                                    1,
                                    0.25
                                ],
                                'Times New Roman CYR': [
                                    1,
                                    0.25
                                ],
                                'Times New Roman Greek': [
                                    1,
                                    0.25
                                ],
                                'Times New Roman TUR': [
                                    1,
                                    0.25
                                ],
                                'Trebuchet MS': [
                                    1.0833,
                                    0.4167
                                ],
                                'Tunga': [
                                    1,
                                    0.75
                                ],
                                'Verdana': [
                                    1,
                                    0.1667
                                ],
                                'Webdings': [
                                    1.0833,
                                    0.5
                                ],
                                'Wingdings': [
                                    0.9167,
                                    0.25
                                ]
                            };
                            // Measurements taken on a freshly installed Mac OS X 10.10 (Yosemite).
                            this.DEVICE_FONT_METRICS_MAC = {
                                __proto__: this.DEVICE_FONT_METRICS_BUILTIN,
                                'Al Bayan Bold': [
                                    1,
                                    0.5833
                                ],
                                'Al Bayan Plain': [
                                    1,
                                    0.5
                                ],
                                'Al Nile': [
                                    0.8333,
                                    0.5
                                ],
                                'Al Nile Bold': [
                                    0.8333,
                                    0.5
                                ],
                                'Al Tarikh Regular': [
                                    0.5833,
                                    0.4167
                                ],
                                'American Typewriter': [
                                    0.9167,
                                    0.25
                                ],
                                'American Typewriter Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'American Typewriter Condensed': [
                                    0.9167,
                                    0.25
                                ],
                                'American Typewriter Condensed Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'American Typewriter Condensed Light': [
                                    0.8333,
                                    0.25
                                ],
                                'American Typewriter Light': [
                                    0.9167,
                                    0.25
                                ],
                                'Andale Mono': [
                                    0.9167,
                                    0.25
                                ],
                                'Apple Braille': [
                                    0.75,
                                    0.25
                                ],
                                'Apple Braille Outline 6 Dot': [
                                    0.75,
                                    0.25
                                ],
                                'Apple Braille Outline 8 Dot': [
                                    0.75,
                                    0.25
                                ],
                                'Apple Braille Pinpoint 6 Dot': [
                                    0.75,
                                    0.25
                                ],
                                'Apple Braille Pinpoint 8 Dot': [
                                    0.75,
                                    0.25
                                ],
                                'Apple Chancery': [
                                    1.0833,
                                    0.5
                                ],
                                'Apple Color Emoji': [
                                    1.25,
                                    0.4167
                                ],
                                'Apple SD Gothic Neo Bold': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple SD Gothic Neo Heavy': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple SD Gothic Neo Light': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple SD Gothic Neo Medium': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple SD Gothic Neo Regular': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple SD Gothic Neo SemiBold': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple SD Gothic Neo Thin': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple SD Gothic Neo UltraLight': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple SD GothicNeo ExtraBold': [
                                    0.9167,
                                    0.3333
                                ],
                                'Apple Symbols': [
                                    0.6667,
                                    0.25
                                ],
                                'AppleGothic Regular': [
                                    0.9167,
                                    0.3333
                                ],
                                'AppleMyungjo Regular': [
                                    0.8333,
                                    0.3333
                                ],
                                'Arial': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Black': [
                                    1.0833,
                                    0.3333
                                ],
                                'Arial Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Hebrew': [
                                    0.75,
                                    0.3333
                                ],
                                'Arial Hebrew Bold': [
                                    0.75,
                                    0.3333
                                ],
                                'Arial Hebrew Light': [
                                    0.75,
                                    0.3333
                                ],
                                'Arial Hebrew Scholar': [
                                    0.75,
                                    0.3333
                                ],
                                'Arial Hebrew Scholar Bold': [
                                    0.75,
                                    0.3333
                                ],
                                'Arial Hebrew Scholar Light': [
                                    0.75,
                                    0.3333
                                ],
                                'Arial Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Narrow': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Narrow Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Narrow Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Narrow Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Rounded MT Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Arial Unicode MS': [
                                    1.0833,
                                    0.25
                                ],
                                'Athelas Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Athelas Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Athelas Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Athelas Regular': [
                                    0.9167,
                                    0.25
                                ],
                                'Avenir Black': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Black Oblique': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Book': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Book Oblique': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Heavy': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Heavy Oblique': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Light': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Light Oblique': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Medium': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Medium Oblique': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Bold': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Bold Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Bold': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Bold Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Demi Bold': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Demi Bold Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Heavy': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Heavy Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Medium': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Medium Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Regular': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Ultra Light': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Condensed Ultra Light Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Demi Bold': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Demi Bold Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Heavy': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Heavy Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Medium': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Medium Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Regular': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Ultra Light': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Next Ultra Light Italic': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Oblique': [
                                    1,
                                    0.3333
                                ],
                                'Avenir Roman': [
                                    1,
                                    0.3333
                                ],
                                'Ayuthaya': [
                                    1.0833,
                                    0.3333
                                ],
                                'Baghdad Regular': [
                                    0.9167,
                                    0.4167
                                ],
                                'Bangla MN': [
                                    1.0833,
                                    0.75
                                ],
                                'Bangla MN Bold': [
                                    1.0833,
                                    0.75
                                ],
                                'Bangla Sangam MN': [
                                    0.9167,
                                    0.4167
                                ],
                                'Bangla Sangam MN Bold': [
                                    0.9167,
                                    0.4167
                                ],
                                'Baoli SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Baskerville': [
                                    0.9167,
                                    0.25
                                ],
                                'Baskerville Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Baskerville Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Baskerville Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Baskerville SemiBold': [
                                    0.9167,
                                    0.25
                                ],
                                'Baskerville SemiBold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Beirut Regular': [
                                    0.75,
                                    0.25
                                ],
                                'Big Caslon Medium': [
                                    0.9167,
                                    0.25
                                ],
                                'Bodoni 72 Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Bodoni 72 Book': [
                                    0.9167,
                                    0.25
                                ],
                                'Bodoni 72 Book Italic': [
                                    0.9167,
                                    0.3333
                                ],
                                'Bodoni 72 Oldstyle Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Bodoni 72 Oldstyle Book': [
                                    0.9167,
                                    0.25
                                ],
                                'Bodoni 72 Oldstyle Book Italic': [
                                    0.9167,
                                    0.3333
                                ],
                                'Bodoni 72 Smallcaps Book': [
                                    0.9167,
                                    0.25
                                ],
                                'Bodoni Ornaments': [
                                    0.8333,
                                    0.1667
                                ],
                                'Bradley Hand Bold': [
                                    0.8333,
                                    0.4167
                                ],
                                'Brush Script MT Italic': [
                                    0.9167,
                                    0.3333
                                ],
                                'Chalkboard': [
                                    1,
                                    0.25
                                ],
                                'Chalkboard Bold': [
                                    1,
                                    0.25
                                ],
                                'Chalkboard SE Bold': [
                                    1.1667,
                                    0.25
                                ],
                                'Chalkboard SE Light': [
                                    1.1667,
                                    0.25
                                ],
                                'Chalkboard SE Regular': [
                                    1.1667,
                                    0.25
                                ],
                                'Chalkduster': [
                                    1,
                                    0.25
                                ],
                                'Charter Black': [
                                    1,
                                    0.25
                                ],
                                'Charter Black Italic': [
                                    1,
                                    0.25
                                ],
                                'Charter Bold': [
                                    1,
                                    0.25
                                ],
                                'Charter Bold Italic': [
                                    1,
                                    0.25
                                ],
                                'Charter Italic': [
                                    1,
                                    0.25
                                ],
                                'Charter Roman': [
                                    1,
                                    0.25
                                ],
                                'Cochin': [
                                    0.9167,
                                    0.25
                                ],
                                'Cochin Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Cochin Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Cochin Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Comic Sans MS': [
                                    1.0833,
                                    0.25
                                ],
                                'Comic Sans MS Bold': [
                                    1.0833,
                                    0.25
                                ],
                                'Copperplate': [
                                    0.75,
                                    0.25
                                ],
                                'Copperplate Bold': [
                                    0.75,
                                    0.25
                                ],
                                'Copperplate Light': [
                                    0.75,
                                    0.25
                                ],
                                'Corsiva Hebrew': [
                                    0.6667,
                                    0.3333
                                ],
                                'Corsiva Hebrew Bold': [
                                    0.6667,
                                    0.3333
                                ],
                                'Courier': [
                                    0.75,
                                    0.25
                                ],
                                'Courier Bold': [
                                    0.75,
                                    0.25
                                ],
                                'Courier Bold Oblique': [
                                    0.75,
                                    0.25
                                ],
                                'Courier New': [
                                    0.8333,
                                    0.3333
                                ],
                                'Courier New Bold': [
                                    0.8333,
                                    0.3333
                                ],
                                'Courier New Bold Italic': [
                                    0.8333,
                                    0.3333
                                ],
                                'Courier New Italic': [
                                    0.8333,
                                    0.3333
                                ],
                                'Courier Oblique': [
                                    0.75,
                                    0.25
                                ],
                                'Damascus Bold': [
                                    0.5833,
                                    0.4167
                                ],
                                'Damascus Light': [
                                    0.5833,
                                    0.4167
                                ],
                                'Damascus Medium': [
                                    0.5833,
                                    0.4167
                                ],
                                'Damascus Regular': [
                                    0.5833,
                                    0.4167
                                ],
                                'Damascus Semi Bold': [
                                    0.5833,
                                    0.4167
                                ],
                                'DecoType Naskh Regular': [
                                    1.1667,
                                    0.6667
                                ],
                                'Devanagari MT': [
                                    0.9167,
                                    0.6667
                                ],
                                'Devanagari MT Bold': [
                                    0.9167,
                                    0.6667
                                ],
                                'Devanagari Sangam MN': [
                                    0.9167,
                                    0.4167
                                ],
                                'Devanagari Sangam MN Bold': [
                                    0.9167,
                                    0.4167
                                ],
                                'Didot': [
                                    0.9167,
                                    0.3333
                                ],
                                'Didot Bold': [
                                    1,
                                    0.3333
                                ],
                                'Didot Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'DIN Alternate Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'DIN Condensed Bold': [
                                    0.75,
                                    0.25
                                ],
                                'Diwan Kufi Regular': [
                                    1.4167,
                                    0.5
                                ],
                                'Diwan Thuluth Regular': [
                                    1,
                                    0.6667
                                ],
                                'Euphemia UCAS': [
                                    1.0833,
                                    0.25
                                ],
                                'Euphemia UCAS Bold': [
                                    1.0833,
                                    0.25
                                ],
                                'Euphemia UCAS Italic': [
                                    1.0833,
                                    0.25
                                ],
                                'Farah Regular': [
                                    0.75,
                                    0.25
                                ],
                                'Farisi Regular': [
                                    1.0833,
                                    1
                                ],
                                'Futura Condensed ExtraBold': [
                                    1,
                                    0.25
                                ],
                                'Futura Condensed Medium': [
                                    1,
                                    0.25
                                ],
                                'Futura Medium': [
                                    1,
                                    0.25
                                ],
                                'Futura Medium Italic': [
                                    1,
                                    0.25
                                ],
                                'GB18030 Bitmap': [
                                    1.1667,
                                    0.1667
                                ],
                                'Geeza Pro Bold': [
                                    0.9167,
                                    0.3333
                                ],
                                'Geeza Pro Regular': [
                                    0.9167,
                                    0.3333
                                ],
                                'Geneva': [
                                    1,
                                    0.25
                                ],
                                'Georgia': [
                                    0.9167,
                                    0.25
                                ],
                                'Georgia Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Georgia Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Georgia Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans Light': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans Light Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans SemiBold': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans SemiBold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Gill Sans UltraBold': [
                                    1,
                                    0.25
                                ],
                                'Gujarati MT': [
                                    0.9167,
                                    0.6667
                                ],
                                'Gujarati MT Bold': [
                                    0.9167,
                                    0.6667
                                ],
                                'Gujarati Sangam MN': [
                                    0.8333,
                                    0.4167
                                ],
                                'Gujarati Sangam MN Bold': [
                                    0.8333,
                                    0.4167
                                ],
                                'GungSeo Regular': [
                                    0.8333,
                                    0.25
                                ],
                                'Gurmukhi MN': [
                                    0.9167,
                                    0.25
                                ],
                                'Gurmukhi MN Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Gurmukhi MT': [
                                    0.8333,
                                    0.4167
                                ],
                                'Gurmukhi Sangam MN': [
                                    0.9167,
                                    0.3333
                                ],
                                'Gurmukhi Sangam MN Bold': [
                                    0.9167,
                                    0.3333
                                ],
                                'Hannotate SC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Hannotate SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Hannotate TC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Hannotate TC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'HanziPen SC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'HanziPen SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'HanziPen TC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'HanziPen TC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'HeadLineA Regular': [
                                    0.8333,
                                    0.1667
                                ],
                                'Heiti SC Light': [
                                    0.8333,
                                    0.1667
                                ],
                                'Heiti SC Medium': [
                                    0.8333,
                                    0.1667
                                ],
                                'Heiti TC Light': [
                                    0.8333,
                                    0.1667
                                ],
                                'Heiti TC Medium': [
                                    0.8333,
                                    0.1667
                                ],
                                'Helvetica': [
                                    0.75,
                                    0.25
                                ],
                                'Helvetica Bold': [
                                    0.75,
                                    0.25
                                ],
                                'Helvetica Bold Oblique': [
                                    0.75,
                                    0.25
                                ],
                                'Helvetica Light': [
                                    0.75,
                                    0.25
                                ],
                                'Helvetica Light Oblique': [
                                    0.75,
                                    0.25
                                ],
                                'Helvetica Neue': [
                                    0.9167,
                                    0.25
                                ],
                                'Helvetica Neue Bold': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue Bold Italic': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue Condensed Black': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue Condensed Bold': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Helvetica Neue Light': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue Light Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Helvetica Neue Medium': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue Medium Italic': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue Thin': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue Thin Italic': [
                                    1,
                                    0.25
                                ],
                                'Helvetica Neue UltraLight': [
                                    0.9167,
                                    0.25
                                ],
                                'Helvetica Neue UltraLight Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Helvetica Oblique': [
                                    0.75,
                                    0.25
                                ],
                                'Herculanum': [
                                    0.8333,
                                    0.1667
                                ],
                                'Hiragino Kaku Gothic Pro W3': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Kaku Gothic Pro W6': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Kaku Gothic ProN W3': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Kaku Gothic ProN W6': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Kaku Gothic Std W8': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Kaku Gothic StdN W8': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Maru Gothic Pro W4': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Maru Gothic ProN W4': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Mincho Pro W3': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Mincho Pro W6': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Mincho ProN W3': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Mincho ProN W6': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Sans GB W3': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hiragino Sans GB W6': [
                                    0.9167,
                                    0.0833
                                ],
                                'Hoefler Text': [
                                    0.75,
                                    0.25
                                ],
                                'Hoefler Text Black': [
                                    0.75,
                                    0.25
                                ],
                                'Hoefler Text Black Italic': [
                                    0.75,
                                    0.25
                                ],
                                'Hoefler Text Italic': [
                                    0.75,
                                    0.25
                                ],
                                'Hoefler Text Ornaments': [
                                    0.8333,
                                    0.1667
                                ],
                                'Impact': [
                                    1,
                                    0.25
                                ],
                                'InaiMathi': [
                                    0.8333,
                                    0.4167
                                ],
                                'Iowan Old Style Black': [
                                    1,
                                    0.3333
                                ],
                                'Iowan Old Style Black Italic': [
                                    1,
                                    0.3333
                                ],
                                'Iowan Old Style Bold': [
                                    1,
                                    0.3333
                                ],
                                'Iowan Old Style Bold Italic': [
                                    1,
                                    0.3333
                                ],
                                'Iowan Old Style Italic': [
                                    1,
                                    0.3333
                                ],
                                'Iowan Old Style Roman': [
                                    1,
                                    0.3333
                                ],
                                'Iowan Old Style Titling': [
                                    1,
                                    0.3333
                                ],
                                'ITF Devanagari Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'ITF Devanagari Book': [
                                    1.0833,
                                    0.3333
                                ],
                                'ITF Devanagari Demi': [
                                    1.0833,
                                    0.3333
                                ],
                                'ITF Devanagari Light': [
                                    1.0833,
                                    0.3333
                                ],
                                'ITF Devanagari Medium': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kailasa Regular': [
                                    1.0833,
                                    0.5833
                                ],
                                'Kaiti SC Black': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kaiti SC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kaiti SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kaiti TC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kaiti TC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kannada MN': [
                                    0.9167,
                                    0.25
                                ],
                                'Kannada MN Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Kannada Sangam MN': [
                                    1,
                                    0.5833
                                ],
                                'Kannada Sangam MN Bold': [
                                    1,
                                    0.5833
                                ],
                                'Kefa Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Kefa Regular': [
                                    0.9167,
                                    0.25
                                ],
                                'Khmer MN': [
                                    1,
                                    0.8333
                                ],
                                'Khmer MN Bold': [
                                    1,
                                    0.8333
                                ],
                                'Khmer Sangam MN': [
                                    1.0833,
                                    0.8333
                                ],
                                'Kohinoor Devanagari Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kohinoor Devanagari Book': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kohinoor Devanagari Demi': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kohinoor Devanagari Light': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kohinoor Devanagari Medium': [
                                    1.0833,
                                    0.3333
                                ],
                                'Kokonor Regular': [
                                    1.0833,
                                    0.5833
                                ],
                                'Krungthep': [
                                    1,
                                    0.25
                                ],
                                'KufiStandardGK Regular': [
                                    0.9167,
                                    0.5
                                ],
                                'Lantinghei SC Demibold': [
                                    1,
                                    0.3333
                                ],
                                'Lantinghei SC Extralight': [
                                    1,
                                    0.3333
                                ],
                                'Lantinghei SC Heavy': [
                                    1,
                                    0.3333
                                ],
                                'Lantinghei TC Demibold': [
                                    1,
                                    0.3333
                                ],
                                'Lantinghei TC Extralight': [
                                    1,
                                    0.3333
                                ],
                                'Lantinghei TC Heavy': [
                                    1,
                                    0.3333
                                ],
                                'Lao MN': [
                                    0.9167,
                                    0.4167
                                ],
                                'Lao MN Bold': [
                                    0.9167,
                                    0.4167
                                ],
                                'Lao Sangam MN': [
                                    1,
                                    0.3333
                                ],
                                'Libian SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'LiHei Pro': [
                                    0.8333,
                                    0.1667
                                ],
                                'LiSong Pro': [
                                    0.8333,
                                    0.1667
                                ],
                                'Lucida Grande': [
                                    1,
                                    0.25
                                ],
                                'Lucida Grande Bold': [
                                    1,
                                    0.25
                                ],
                                'Luminari': [
                                    1,
                                    0.3333
                                ],
                                'Malayalam MN': [
                                    1,
                                    0.4167
                                ],
                                'Malayalam MN Bold': [
                                    1,
                                    0.4167
                                ],
                                'Malayalam Sangam MN': [
                                    0.8333,
                                    0.4167
                                ],
                                'Malayalam Sangam MN Bold': [
                                    0.8333,
                                    0.4167
                                ],
                                'Marion Bold': [
                                    0.6667,
                                    0.3333
                                ],
                                'Marion Italic': [
                                    0.6667,
                                    0.3333
                                ],
                                'Marion Regular': [
                                    0.6667,
                                    0.3333
                                ],
                                'Marker Felt Thin': [
                                    0.8333,
                                    0.25
                                ],
                                'Marker Felt Wide': [
                                    0.9167,
                                    0.25
                                ],
                                'Menlo Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Menlo Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Menlo Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Menlo Regular': [
                                    0.9167,
                                    0.25
                                ],
                                'Microsoft Sans Serif': [
                                    0.9167,
                                    0.25
                                ],
                                'Mishafi Gold Regular': [
                                    0.75,
                                    0.6667
                                ],
                                'Mishafi Regular': [
                                    0.75,
                                    0.6667
                                ],
                                'Monaco': [
                                    1,
                                    0.25
                                ],
                                'Mshtakan': [
                                    0.9167,
                                    0.25
                                ],
                                'Mshtakan Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Mshtakan BoldOblique': [
                                    0.9167,
                                    0.25
                                ],
                                'Mshtakan Oblique': [
                                    0.9167,
                                    0.25
                                ],
                                'Muna Black': [
                                    0.75,
                                    0.3333
                                ],
                                'Muna Bold': [
                                    0.75,
                                    0.3333
                                ],
                                'Muna Regular': [
                                    0.75,
                                    0.3333
                                ],
                                'Myanmar MN': [
                                    1,
                                    0.4167
                                ],
                                'Myanmar MN Bold': [
                                    1,
                                    0.4167
                                ],
                                'Myanmar Sangam MN': [
                                    0.9167,
                                    0.4167
                                ],
                                'Nadeem Regular': [
                                    0.9167,
                                    0.4167
                                ],
                                'Nanum Brush Script': [
                                    0.9167,
                                    0.25
                                ],
                                'Nanum Pen Script': [
                                    0.9167,
                                    0.25
                                ],
                                'NanumGothic': [
                                    0.9167,
                                    0.25
                                ],
                                'NanumGothic Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'NanumGothic ExtraBold': [
                                    0.9167,
                                    0.25
                                ],
                                'NanumMyeongjo': [
                                    0.9167,
                                    0.25
                                ],
                                'NanumMyeongjo Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'NanumMyeongjo ExtraBold': [
                                    0.9167,
                                    0.25
                                ],
                                'New Peninim MT': [
                                    0.75,
                                    0.3333
                                ],
                                'New Peninim MT Bold': [
                                    0.75,
                                    0.3333
                                ],
                                'New Peninim MT Bold Inclined': [
                                    0.75,
                                    0.3333
                                ],
                                'New Peninim MT Inclined': [
                                    0.75,
                                    0.3333
                                ],
                                'Noteworthy Bold': [
                                    1.25,
                                    0.3333
                                ],
                                'Noteworthy Light': [
                                    1.25,
                                    0.3333
                                ],
                                'Optima Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Optima Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Optima ExtraBlack': [
                                    1,
                                    0.25
                                ],
                                'Optima Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Optima Regular': [
                                    0.9167,
                                    0.25
                                ],
                                'Oriya MN': [
                                    0.9167,
                                    0.25
                                ],
                                'Oriya MN Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Oriya Sangam MN': [
                                    0.8333,
                                    0.4167
                                ],
                                'Oriya Sangam MN Bold': [
                                    0.8333,
                                    0.4167
                                ],
                                'Osaka': [
                                    1,
                                    0.25
                                ],
                                'Osaka-Mono': [
                                    0.8333,
                                    0.1667
                                ],
                                'Palatino': [
                                    0.8333,
                                    0.25
                                ],
                                'Palatino Bold': [
                                    0.8333,
                                    0.25
                                ],
                                'Palatino Bold Italic': [
                                    0.8333,
                                    0.25
                                ],
                                'Palatino Italic': [
                                    0.8333,
                                    0.25
                                ],
                                'Papyrus': [
                                    0.9167,
                                    0.5833
                                ],
                                'Papyrus Condensed': [
                                    0.9167,
                                    0.5833
                                ],
                                'PCMyungjo Regular': [
                                    0.8333,
                                    0.25
                                ],
                                'Phosphate Inline': [
                                    0.9167,
                                    0.25
                                ],
                                'Phosphate Solid': [
                                    0.9167,
                                    0.25
                                ],
                                'PilGi Regular': [
                                    0.8333,
                                    0.25
                                ],
                                'Plantagenet Cherokee': [
                                    0.6667,
                                    0.25
                                ],
                                'PT Mono': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Mono Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Sans': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Sans Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Sans Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Sans Caption': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Sans Caption Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Sans Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Sans Narrow': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Sans Narrow Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'PT Serif': [
                                    1,
                                    0.25
                                ],
                                'PT Serif Bold': [
                                    1,
                                    0.25
                                ],
                                'PT Serif Bold Italic': [
                                    1,
                                    0.25
                                ],
                                'PT Serif Caption': [
                                    1,
                                    0.25
                                ],
                                'PT Serif Caption Italic': [
                                    1,
                                    0.25
                                ],
                                'PT Serif Italic': [
                                    1,
                                    0.25
                                ],
                                'Raanana': [
                                    0.75,
                                    0.25
                                ],
                                'Raanana Bold': [
                                    0.75,
                                    0.25
                                ],
                                'Sana Regular': [
                                    0.75,
                                    0.25
                                ],
                                'Sathu': [
                                    0.9167,
                                    0.3333
                                ],
                                'Savoye LET Plain CC.:1.0': [
                                    1.0833,
                                    0.75
                                ],
                                'Savoye LET Plain:1.0': [
                                    0.6667,
                                    0.5
                                ],
                                'Seravek': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek Bold': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek Bold Italic': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek ExtraLight': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek ExtraLight Italic': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek Italic': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek Light': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek Light Italic': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek Medium': [
                                    0.9167,
                                    0.3333
                                ],
                                'Seravek Medium Italic': [
                                    0.9167,
                                    0.3333
                                ],
                                'Shree Devanagari 714': [
                                    0.9167,
                                    0.4167
                                ],
                                'Shree Devanagari 714 Bold': [
                                    0.9167,
                                    0.4167
                                ],
                                'Shree Devanagari 714 Bold Italic': [
                                    0.9167,
                                    0.4167
                                ],
                                'Shree Devanagari 714 Italic': [
                                    0.9167,
                                    0.4167
                                ],
                                'SignPainter-HouseScript': [
                                    0.6667,
                                    0.1667
                                ],
                                'Silom': [
                                    1,
                                    0.3333
                                ],
                                'Sinhala MN': [
                                    0.9167,
                                    0.25
                                ],
                                'Sinhala MN Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Sinhala Sangam MN': [
                                    1.1667,
                                    0.3333
                                ],
                                'Sinhala Sangam MN Bold': [
                                    1.1667,
                                    0.3333
                                ],
                                'Skia Black': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Black Condensed': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Black Extended': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Bold': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Condensed': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Extended': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Light': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Light Condensed': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Light Extended': [
                                    0.75,
                                    0.25
                                ],
                                'Skia Regular': [
                                    0.75,
                                    0.25
                                ],
                                'Snell Roundhand': [
                                    0.9167,
                                    0.3333
                                ],
                                'Snell Roundhand Black': [
                                    0.9167,
                                    0.3333
                                ],
                                'Snell Roundhand Bold': [
                                    0.9167,
                                    0.3333
                                ],
                                'Songti SC Black': [
                                    1.0833,
                                    0.3333
                                ],
                                'Songti SC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Songti SC Light': [
                                    1.0833,
                                    0.3333
                                ],
                                'Songti SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Songti TC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Songti TC Light': [
                                    1.0833,
                                    0.3333
                                ],
                                'Songti TC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'STFangsong': [
                                    0.8333,
                                    0.1667
                                ],
                                'STHeiti': [
                                    0.8333,
                                    0.1667
                                ],
                                'STIXGeneral-Bold': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXGeneral-BoldItalic': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXGeneral-Italic': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXGeneral-Regular': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXIntegralsD-Bold': [
                                    2.1667,
                                    0.4167
                                ],
                                'STIXIntegralsD-Regular': [
                                    2.1667,
                                    0.4167
                                ],
                                'STIXIntegralsSm-Bold': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXIntegralsSm-Regular': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXIntegralsUp-Bold': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXIntegralsUp-Regular': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXIntegralsUpD-Bold': [
                                    2.1667,
                                    0.4167
                                ],
                                'STIXIntegralsUpD-Regular': [
                                    2.1667,
                                    0.4167
                                ],
                                'STIXIntegralsUpSm-Bold': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXIntegralsUpSm-Regular': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXNonUnicode-Bold': [
                                    1.4167,
                                    0.5833
                                ],
                                'STIXNonUnicode-BoldItalic': [
                                    1.4167,
                                    0.5833
                                ],
                                'STIXNonUnicode-Italic': [
                                    1.4167,
                                    0.5833
                                ],
                                'STIXNonUnicode-Regular': [
                                    1.4167,
                                    0.5833
                                ],
                                'STIXSizeFiveSym-Regular': [
                                    1,
                                    0.4167
                                ],
                                'STIXSizeFourSym-Bold': [
                                    2.5833,
                                    0.5
                                ],
                                'STIXSizeFourSym-Regular': [
                                    2.5833,
                                    0.5
                                ],
                                'STIXSizeOneSym-Bold': [
                                    1.5833,
                                    0.3333
                                ],
                                'STIXSizeOneSym-Regular': [
                                    1.5833,
                                    0.3333
                                ],
                                'STIXSizeThreeSym-Bold': [
                                    2.5833,
                                    0.5
                                ],
                                'STIXSizeThreeSym-Regular': [
                                    2.5833,
                                    0.5
                                ],
                                'STIXSizeTwoSym-Bold': [
                                    2.0833,
                                    0.4167
                                ],
                                'STIXSizeTwoSym-Regular': [
                                    2.0833,
                                    0.4167
                                ],
                                'STIXVariants-Bold': [
                                    1.0833,
                                    0.4167
                                ],
                                'STIXVariants-Regular': [
                                    1.0833,
                                    0.4167
                                ],
                                'STKaiti': [
                                    0.8333,
                                    0.1667
                                ],
                                'STSong': [
                                    0.8333,
                                    0.1667
                                ],
                                'STXihei': [
                                    0.8333,
                                    0.1667
                                ],
                                'Sukhumvit Set Bold': [
                                    1.0833,
                                    0.5
                                ],
                                'Sukhumvit Set Light': [
                                    1.0833,
                                    0.5
                                ],
                                'Sukhumvit Set Medium': [
                                    1.0833,
                                    0.5
                                ],
                                'Sukhumvit Set Semi Bold': [
                                    1.0833,
                                    0.5
                                ],
                                'Sukhumvit Set Text': [
                                    1.0833,
                                    0.5
                                ],
                                'Sukhumvit Set Thin': [
                                    1.0833,
                                    0.5
                                ],
                                'Superclarendon Black': [
                                    1,
                                    0.25
                                ],
                                'Superclarendon Black Italic': [
                                    1,
                                    0.25
                                ],
                                'Superclarendon Bold': [
                                    1,
                                    0.25
                                ],
                                'Superclarendon Bold Italic': [
                                    1,
                                    0.25
                                ],
                                'Superclarendon Italic': [
                                    1,
                                    0.25
                                ],
                                'Superclarendon Light': [
                                    1,
                                    0.25
                                ],
                                'Superclarendon Light Italic': [
                                    1,
                                    0.25
                                ],
                                'Superclarendon Regular': [
                                    1,
                                    0.25
                                ],
                                'Symbol': [
                                    0.6667,
                                    0.3333
                                ],
                                'System Font Bold': [
                                    1,
                                    0.25
                                ],
                                'System Font Bold Italic': [
                                    1,
                                    0.25
                                ],
                                'System Font Heavy': [
                                    1,
                                    0.25
                                ],
                                'System Font Italic': [
                                    1,
                                    0.25
                                ],
                                'System Font Light': [
                                    1,
                                    0.25
                                ],
                                'System Font Medium Italic P4': [
                                    1,
                                    0.25
                                ],
                                'System Font Medium P4': [
                                    1,
                                    0.25
                                ],
                                'System Font Regular': [
                                    1,
                                    0.25
                                ],
                                'System Font Thin': [
                                    1,
                                    0.25
                                ],
                                'System Font UltraLight': [
                                    1,
                                    0.25
                                ],
                                'Tahoma': [
                                    1,
                                    0.1667
                                ],
                                'Tahoma Negreta': [
                                    1,
                                    0.1667
                                ],
                                'Tamil MN': [
                                    0.9167,
                                    0.25
                                ],
                                'Tamil MN Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Tamil Sangam MN': [
                                    0.75,
                                    0.25
                                ],
                                'Tamil Sangam MN Bold': [
                                    0.75,
                                    0.25
                                ],
                                'Telugu MN': [
                                    0.9167,
                                    0.25
                                ],
                                'Telugu MN Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Telugu Sangam MN': [
                                    1,
                                    0.5833
                                ],
                                'Telugu Sangam MN Bold': [
                                    1,
                                    0.5833
                                ],
                                'Thonburi': [
                                    1.0833,
                                    0.25
                                ],
                                'Thonburi Bold': [
                                    1.0833,
                                    0.25
                                ],
                                'Thonburi Light': [
                                    1.0833,
                                    0.25
                                ],
                                'Times Bold': [
                                    0.75,
                                    0.25
                                ],
                                'Times Bold Italic': [
                                    0.75,
                                    0.25
                                ],
                                'Times Italic': [
                                    0.75,
                                    0.25
                                ],
                                'Times New Roman': [
                                    0.9167,
                                    0.25
                                ],
                                'Times New Roman Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Times New Roman Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Times New Roman Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Times Roman': [
                                    0.75,
                                    0.25
                                ],
                                'Trattatello': [
                                    1.1667,
                                    0.6667
                                ],
                                'Trebuchet MS': [
                                    0.9167,
                                    0.25
                                ],
                                'Trebuchet MS Bold': [
                                    0.9167,
                                    0.25
                                ],
                                'Trebuchet MS Bold Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Trebuchet MS Italic': [
                                    0.9167,
                                    0.25
                                ],
                                'Verdana': [
                                    1,
                                    0.25
                                ],
                                'Verdana Bold': [
                                    1,
                                    0.25
                                ],
                                'Verdana Bold Italic': [
                                    1,
                                    0.25
                                ],
                                'Verdana Italic': [
                                    1,
                                    0.25
                                ],
                                'Waseem Light': [
                                    0.9167,
                                    0.5833
                                ],
                                'Waseem Regular': [
                                    0.9167,
                                    0.5833
                                ],
                                'Wawati SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Wawati TC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Webdings': [
                                    0.8333,
                                    0.1667
                                ],
                                'Weibei SC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Weibei TC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Wingdings': [
                                    0.9167,
                                    0.25
                                ],
                                'Wingdings 2': [
                                    0.8333,
                                    0.25
                                ],
                                'Wingdings 3': [
                                    0.9167,
                                    0.25
                                ],
                                'Xingkai SC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Xingkai SC Light': [
                                    1.0833,
                                    0.3333
                                ],
                                'Yuanti SC Bold': [
                                    1.0833,
                                    0.3333
                                ],
                                'Yuanti SC Light': [
                                    1.0833,
                                    0.3333
                                ],
                                'Yuanti SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'YuGothic Bold': [
                                    0.9167,
                                    0.0833
                                ],
                                'YuGothic Medium': [
                                    0.9167,
                                    0.0833
                                ],
                                'YuMincho Demibold': [
                                    0.9167,
                                    0.0833
                                ],
                                'YuMincho Medium': [
                                    0.9167,
                                    0.0833
                                ],
                                'Yuppy SC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Yuppy TC Regular': [
                                    1.0833,
                                    0.3333
                                ],
                                'Zapf Dingbats': [
                                    0.8333,
                                    0.1667
                                ],
                                'Zapfino': [
                                    1.9167,
                                    1.5
                                ]
                            };
                            // Measurements taken on a freshly installed Ubuntu Linux 12.04.5 (Precise Pangolin).
                            this.DEVICE_FONT_METRICS_LINUX = {
                                __proto__: this.DEVICE_FONT_METRICS_BUILTIN,
                                'KacstFarsi': [
                                    1.0417,
                                    0.5208
                                ],
                                'Meera': [
                                    0.651,
                                    0.4557
                                ],
                                'FreeMono': [
                                    0.7812,
                                    0.1953
                                ],
                                'Loma': [
                                    1.1719,
                                    0.4557
                                ],
                                'Century Schoolbook L': [
                                    0.9766,
                                    0.3255
                                ],
                                'KacstTitleL': [
                                    1.0417,
                                    0.5208
                                ],
                                'Garuda': [
                                    1.3021,
                                    0.5859
                                ],
                                'Rekha': [
                                    1.1068,
                                    0.2604
                                ],
                                'Purisa': [
                                    1.1068,
                                    0.5208
                                ],
                                'DejaVu Sans Mono': [
                                    0.9115,
                                    0.2604
                                ],
                                'Vemana2000': [
                                    0.9115,
                                    0.8464
                                ],
                                'KacstOffice': [
                                    1.0417,
                                    0.5208
                                ],
                                'Umpush': [
                                    1.237,
                                    0.651
                                ],
                                'OpenSymbol': [
                                    0.7812,
                                    0.1953
                                ],
                                'Sawasdee': [
                                    1.1068,
                                    0.4557
                                ],
                                'URW Palladio L': [
                                    0.9766,
                                    0.3255
                                ],
                                'FreeSerif': [
                                    0.9115,
                                    0.3255
                                ],
                                'KacstDigital': [
                                    1.0417,
                                    0.5208
                                ],
                                'Ubuntu Condensed': [
                                    0.9115,
                                    0.1953
                                ],
                                'mry_KacstQurn': [
                                    1.4323,
                                    0.7161
                                ],
                                'URW Gothic L': [
                                    0.9766,
                                    0.2604
                                ],
                                'Dingbats': [
                                    0.8464,
                                    0.1953
                                ],
                                'URW Chancery L': [
                                    0.9766,
                                    0.3255
                                ],
                                'Phetsarath OT': [
                                    1.1068,
                                    0.5208
                                ],
                                'Tlwg Typist': [
                                    0.9115,
                                    0.3906
                                ],
                                'KacstLetter': [
                                    1.0417,
                                    0.5208
                                ],
                                'utkal': [
                                    1.1719,
                                    0.651
                                ],
                                'Norasi': [
                                    1.237,
                                    0.5208
                                ],
                                'KacstOne': [
                                    1.237,
                                    0.651
                                ],
                                'Liberation Sans Narrow': [
                                    0.9115,
                                    0.2604
                                ],
                                'Symbol': [
                                    1.0417,
                                    0.3255
                                ],
                                'NanumMyeongjo': [
                                    0.9115,
                                    0.2604
                                ],
                                'Untitled1': [
                                    0.651,
                                    0.5859
                                ],
                                'Lohit Gujarati': [
                                    0.9115,
                                    0.3906
                                ],
                                'Liberation Mono': [
                                    0.8464,
                                    0.3255
                                ],
                                'KacstArt': [
                                    1.0417,
                                    0.5208
                                ],
                                'Mallige': [
                                    0.9766,
                                    0.651
                                ],
                                'Bitstream Charter': [
                                    0.9766,
                                    0.2604
                                ],
                                'NanumGothic': [
                                    0.9115,
                                    0.2604
                                ],
                                'Liberation Serif': [
                                    0.9115,
                                    0.2604
                                ],
                                'Ubuntu': [
                                    0.9115,
                                    0.1953
                                ],
                                'Courier 10 Pitch': [
                                    0.8464,
                                    0.3255
                                ],
                                'Nimbus Sans L': [
                                    0.9766,
                                    0.3255
                                ],
                                'TakaoPGothic': [
                                    0.9115,
                                    0.1953
                                ],
                                'WenQuanYi Micro Hei Mono': [
                                    0.9766,
                                    0.2604
                                ],
                                'DejaVu Sans': [
                                    0.9115,
                                    0.2604
                                ],
                                'Kedage': [
                                    0.9766,
                                    0.651
                                ],
                                'Kinnari': [
                                    1.3021,
                                    0.5208
                                ],
                                'TlwgMono': [
                                    0.8464,
                                    0.3906
                                ],
                                'Standard Symbols L': [
                                    1.0417,
                                    0.3255
                                ],
                                'Lohit Punjabi': [
                                    1.1719,
                                    0.651
                                ],
                                'Nimbus Mono L': [
                                    0.8464,
                                    0.3255
                                ],
                                'Rachana': [
                                    0.651,
                                    0.5859
                                ],
                                'Waree': [
                                    1.237,
                                    0.4557
                                ],
                                'KacstPoster': [
                                    1.0417,
                                    0.5208
                                ],
                                'Khmer OS': [
                                    1.3021,
                                    0.7161
                                ],
                                'FreeSans': [
                                    0.9766,
                                    0.3255
                                ],
                                'gargi': [
                                    0.9115,
                                    0.3255
                                ],
                                'Nimbus Roman No9 L': [
                                    0.9115,
                                    0.3255
                                ],
                                'DejaVu Serif': [
                                    0.9115,
                                    0.2604
                                ],
                                'WenQuanYi Micro Hei': [
                                    0.9766,
                                    0.2604
                                ],
                                'Ubuntu Light': [
                                    0.9115,
                                    0.1953
                                ],
                                'TlwgTypewriter': [
                                    0.9115,
                                    0.3906
                                ],
                                'KacstPen': [
                                    1.0417,
                                    0.5208
                                ],
                                'Tlwg Typo': [
                                    0.9115,
                                    0.3906
                                ],
                                'Mukti Narrow': [
                                    1.237,
                                    0.4557
                                ],
                                'Ubuntu Mono': [
                                    0.8464,
                                    0.1953
                                ],
                                'Lohit Bengali': [
                                    0.9766,
                                    0.4557
                                ],
                                'Liberation Sans': [
                                    0.9115,
                                    0.2604
                                ],
                                'KacstDecorative': [
                                    1.1068,
                                    0.5208
                                ],
                                'Khmer OS System': [
                                    1.237,
                                    0.5859
                                ],
                                'Saab': [
                                    0.9766,
                                    0.651
                                ],
                                'KacstTitle': [
                                    1.0417,
                                    0.5208
                                ],
                                'Mukti Narrow Bold': [
                                    1.237,
                                    0.4557
                                ],
                                'Lohit Hindi': [
                                    0.9766,
                                    0.5208
                                ],
                                'KacstQurn': [
                                    1.0417,
                                    0.5208
                                ],
                                'URW Bookman L': [
                                    0.9766,
                                    0.3255
                                ],
                                'KacstNaskh': [
                                    1.0417,
                                    0.5208
                                ],
                                'KacstScreen': [
                                    1.0417,
                                    0.5208
                                ],
                                'Pothana2000': [
                                    0.9115,
                                    0.8464
                                ],
                                'Lohit Tamil': [
                                    0.8464,
                                    0.3906
                                ],
                                'KacstBook': [
                                    1.0417,
                                    0.5208
                                ],
                                'Sans': [
                                    0.9115,
                                    0.2604
                                ],
                                'Times': [
                                    0.9115,
                                    0.3255
                                ],
                                'Monospace': [
                                    0.9115,
                                    0.2604
                                ]
                            };
                            var userAgent = self.navigator.userAgent;
                            if (userAgent.indexOf('Windows') > -1) {
                                this._deviceFontMetrics = this.DEVICE_FONT_METRICS_WIN;
                            } else if (/(Macintosh|iPad|iPhone|iPod|Android)/.test(userAgent)) {
                                this._deviceFontMetrics = this.DEVICE_FONT_METRICS_MAC;
                                this.DEFAULT_FONT_SANS = 'Helvetica';
                                this.DEFAULT_FONT_SERIF = 'Times Roman';
                                this.DEFAULT_FONT_TYPEWRITER = 'Courier';
                            } else {
                                this._deviceFontMetrics = this.DEVICE_FONT_METRICS_LINUX;
                                this.DEFAULT_FONT_SANS = 'Sans';
                                this.DEFAULT_FONT_SERIF = 'Times';
                                this.DEFAULT_FONT_TYPEWRITER = 'Monospace';
                            }
                            var metrics = this._deviceFontMetrics;
                            for (var fontName in metrics) {
                                metrics[fontName.toLowerCase()] = metrics[fontName];
                            }
                        };
                        Font.classSymbols = null;
                        Font.instanceSymbols = null;
                        return Font;
                    }(AS.ASObject);
                    text.Font = Font;
                    var FontSymbol = function (_super) {
                        __extends(FontSymbol, _super);
                        function FontSymbol(data, sec) {
                            _super.call(this, data, sec.flash.text.Font.axClass);
                        }
                        FontSymbol.FromData = function (data, loaderInfo) {
                            var symbol = new FontSymbol(data, loaderInfo.sec);
                            // Immediately mark glyph-less fonts as ready.
                            symbol.ready = !data.metrics;
                            symbol.name = data.name;
                            // No need to keep the original data baggage around.
                            symbol.data = { id: data.id };
                            symbol.bold = data.bold;
                            symbol.italic = data.italic;
                            symbol.originalSize = data.originalSize;
                            symbol.codes = data.codes;
                            symbol.metrics = data.metrics;
                            symbol.syncId = flash.display.DisplayObject.getNextSyncID();
                            return symbol;
                        };
                        Object.defineProperty(FontSymbol.prototype, 'resolveAssetCallback', {
                            get: function () {
                                return this._unboundResolveAssetCallback.bind(this);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        FontSymbol.prototype._unboundResolveAssetCallback = function (data) {
                            release || Shumway.Debug.assert(!this.ready);
                            this.ready = true;
                        };
                        return FontSymbol;
                    }(Shumway.Timeline.Symbol);
                    text.FontSymbol = FontSymbol;
                    var GridFitType = function (_super) {
                        __extends(GridFitType, _super);
                        function GridFitType() {
                            _super.call(this);
                        }
                        GridFitType.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return GridFitType.NONE;
                            case 1:
                                return GridFitType.PIXEL;
                            case 2:
                                return GridFitType.SUBPIXEL;
                            default:
                                return null;
                            }
                        };
                        GridFitType.toNumber = function (value) {
                            switch (value) {
                            case GridFitType.NONE:
                                return 0;
                            case GridFitType.PIXEL:
                                return 1;
                            case GridFitType.SUBPIXEL:
                                return 2;
                            default:
                                return -1;
                            }
                        };
                        GridFitType.classInitializer = null;
                        GridFitType.classSymbols = null;
                        GridFitType.instanceSymbols = null;
                        // JS -> AS Bindings
                        GridFitType.NONE = 'none';
                        GridFitType.PIXEL = 'pixel';
                        GridFitType.SUBPIXEL = 'subpixel';
                        return GridFitType;
                    }(AS.ASObject);
                    text.GridFitType = GridFitType;
                    var assert = Shumway.Debug.assert;
                    var StaticText = function (_super) {
                        __extends(StaticText, _super);
                        function StaticText() {
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                        }
                        StaticText.prototype.applySymbol = function () {
                            release || assert(this._symbol);
                            this._initializeFields();
                            this._setStaticContentFromSymbol(this._symbol);
                        };
                        StaticText.prototype._canHaveTextContent = function () {
                            return true;
                        };
                        StaticText.prototype._getTextContent = function () {
                            return this._textContent;
                        };
                        Object.defineProperty(StaticText.prototype, 'text', {
                            get: function () {
                                return this._textContent.plainText;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        StaticText.classInitializer = null;
                        StaticText.classSymbols = null;
                        StaticText.instanceSymbols = null;
                        return StaticText;
                    }(flash.display.DisplayObject);
                    text.StaticText = StaticText;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var assert = Shumway.Debug.assert;
                    var StyleSheet = function (_super) {
                        __extends(StyleSheet, _super);
                        function StyleSheet() {
                            _super.call(this);
                            this.clear();
                        }
                        Object.defineProperty(StyleSheet.prototype, 'styleNames', {
                            get: function () {
                                var styles = this._rules;
                                var names = [];
                                for (var name in styles) {
                                    if (styles[name]) {
                                        names.push(name);
                                    }
                                }
                                return this.sec.createArrayUnsafe(names);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        StyleSheet.prototype.getStyle = function (styleName) {
                            styleName = axCoerceString(styleName);
                            var style = this._rules[styleName.toLowerCase()];
                            if (!style) {
                                return this.sec.createObject();    // note that documentation is lying about `null`;
                            }
                            return AS.transformJSValueToAS(this.sec, style, false);
                        };
                        StyleSheet.prototype.applyStyle = function (textFormat, styleName) {
                            styleName = axCoerceString(styleName);
                            var style = this._rules[styleName.toLowerCase()];
                            if (style) {
                                return textFormat.transform(style);
                            }
                            return textFormat;
                        };
                        StyleSheet.prototype.setStyle = function (styleName, styleObject) {
                            if (typeof styleObject !== 'object') {
                                return;
                            }
                            styleName = axCoerceString(styleName);
                            this._rules[styleName.toLowerCase()] = AS.transformASValueToJS(this.sec, styleObject, false);
                        };
                        StyleSheet.prototype.hasStyle = function (styleName) {
                            return !!this._rules[styleName.toLowerCase()];
                        };
                        StyleSheet.prototype.clear = function () {
                            this._rules = Object.create(null);
                        };
                        StyleSheet.prototype.transform = function (formatObject) {
                            if (typeof formatObject !== 'object') {
                                return null;
                            }
                            formatObject = AS.transformASValueToJS(this.sec, formatObject, false);
                            var textFormat = new this.sec.flash.text.TextFormat();
                            textFormat.transform(formatObject);
                            return textFormat;
                        };
                        StyleSheet.prototype.parseCSS = function (css) {
                            css = axCoerceString(css) + '';
                            var length = css.length;
                            var index = skipWhitespace(css, 0, length);
                            // Styles are only added once parsing completed successfully. Invalid syntax anywhere discards all new styles.
                            var newStyles = {};
                            var currentNames = [];
                            var sawWhitespace = false;
                            var name = '';
                            while (index < length) {
                                var char = css[index++];
                                // Everything except whitespace, command, and '{' is valid in names.
                                // Note: if no name is given, the empty string is used.
                                switch (char) {
                                case '{':
                                    sawWhitespace = false;
                                    currentNames.push(name);
                                    // parse style.
                                    index = parseStyle(css, index, length, currentNames, newStyles);
                                    if (index === -1) {
                                        // Syntax error encountered in style parsing.
                                        return;
                                    } else if (!release) {
                                        assert(css[index - 1] === '}');
                                    }
                                    currentNames = [];
                                    name = '';
                                    index = skipWhitespace(css, index, length);
                                    break;
                                case ',':
                                    sawWhitespace = false;
                                    currentNames.push(name);
                                    name = '';
                                    index = skipWhitespace(css, index, length);
                                    break;
                                case ' ':
                                case '\n':
                                case '\r':
                                case '\t':
                                    sawWhitespace = true;
                                    index = skipWhitespace(css, index, length);
                                    break;
                                default:
                                    if (sawWhitespace) {
                                        return;
                                    }
                                    name += char;
                                }
                            }
                            var styles = this._rules;
                            for (name in newStyles) {
                                styles[name.toLowerCase()] = newStyles[name];
                            }
                        };
                        StyleSheet.classInitializer = null;
                        StyleSheet.classSymbols = null;
                        StyleSheet.instanceSymbols = null;
                        return StyleSheet;
                    }(flash.events.EventDispatcher);
                    text.StyleSheet = StyleSheet;
                    function parseStyle(css, index, length, names, newStyles) {
                        release || assert(index > 0);
                        release || assert(css[index - 1] === '{');
                        var style = {};
                        var name = '';
                        var sawWhitespace = false;
                        var upperCase = false;
                        index = skipWhitespace(css, index, length);
                        // Outer loop parsing property names.
                        nameLoop:
                            while (index < length) {
                                var char = css[index++];
                                switch (char) {
                                case '}':
                                    if (name.length > 0) {
                                        return -1;
                                    }
                                    break nameLoop;
                                case ':':
                                    var value = '';
                                    var propertyName = name;
                                    // Reset outer-loop state.
                                    name = '';
                                    sawWhitespace = false;
                                    upperCase = false;
                                    // Inner loop parsing property values.
                                    valueLoop:
                                        while (index < length) {
                                            char = css[index];
                                            switch (char) {
                                            case ';':
                                            case '\r':
                                            case '\n':
                                                index++;
                                                index = skipWhitespace(css, index, length);
                                            // Fallthrough.
                                            case '}':
                                                style[propertyName] = value;
                                                continue nameLoop;
                                            default:
                                                index++;
                                                value += char;
                                            }
                                        }
                                    // If we got here, the inner loop ended by exhausting the string, so the definition
                                    // wasn't properly closed.
                                    return -1;
                                case '-':
                                    if (css[index] === ':') {
                                        name += char;
                                    } else {
                                        upperCase = true;
                                    }
                                    break;
                                case ' ':
                                case '\n':
                                case '\r':
                                case '\t':
                                    sawWhitespace = true;
                                    name += char;
                                    upperCase = false;
                                    break;
                                default:
                                    // Names that're interrupted by whitespace are invalid.
                                    if (sawWhitespace) {
                                        return -1;
                                    }
                                    if (upperCase) {
                                        char = char.toUpperCase();
                                        upperCase = false;
                                    }
                                    name += char;
                                }
                            }
                        if (css[index - 1] !== '}') {
                            return -1;
                        }
                        for (var i = 0; i < names.length; i++) {
                            newStyles[names[i]] = style;
                        }
                        return index;
                    }
                    function skipWhitespace(css, index, length) {
                        while (index < length) {
                            var char = css[index];
                            switch (char) {
                            case ' ':
                            case '\n':
                            case '\r':
                            case '\t':
                                index++;
                                break;
                            default:
                                return index;
                            }
                        }
                        release || assert(index === length);
                        return length;
                    }
                    var TextDisplayMode = function (_super) {
                        __extends(TextDisplayMode, _super);
                        function TextDisplayMode() {
                            _super.call(this);
                        }
                        TextDisplayMode.classInitializer = null;
                        TextDisplayMode.classSymbols = null;
                        TextDisplayMode.instanceSymbols = null;
                        // JS -> AS Bindings
                        TextDisplayMode.LCD = 'lcd';
                        TextDisplayMode.CRT = 'crt';
                        TextDisplayMode.DEFAULT = 'default';
                        return TextDisplayMode;
                    }(AS.ASObject);
                    text.TextDisplayMode = TextDisplayMode;
                }(text = flash.text || (flash.text = {})));
                var text;
                (function (text_1) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var assert = Shumway.Debug.assert;
                    var warning = Shumway.Debug.warning;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var clamp = Shumway.NumberUtilities.clamp;
                    var TextField = function (_super) {
                        __extends(TextField, _super);
                        function TextField() {
                            _super.call(this);
                            if (!this._fieldsInitialized) {
                                this._initializeFields();
                            }
                            if (!this._symbol) {
                                this._setFillAndLineBoundsFromWidthAndHeight(100 * 20, 100 * 20);
                            }
                        }
                        TextField.prototype.applySymbol = function () {
                            this._initializeFields();
                            release || assert(this._symbol);
                            var symbol = this._symbol;
                            this._setFillAndLineBoundsFromSymbol(symbol);
                            var defaultTextFormat = this._textContent.defaultTextFormat;
                            defaultTextFormat.color = symbol.color;
                            defaultTextFormat.size = symbol.size / 20 | 0;
                            defaultTextFormat.font = symbol.face;
                            defaultTextFormat.bold = symbol.bold;
                            defaultTextFormat.italic = symbol.italic;
                            defaultTextFormat.align = symbol.align;
                            defaultTextFormat.leftMargin = symbol.leftMargin / 20 | 0;
                            defaultTextFormat.rightMargin = symbol.rightMargin / 20 | 0;
                            defaultTextFormat.indent = symbol.indent / 20 | 0;
                            defaultTextFormat.leading = symbol.leading / 20 | 0;
                            this._multiline = symbol.multiline;
                            this._embedFonts = symbol.embedFonts;
                            this._selectable = symbol.selectable;
                            this._displayAsPassword = symbol.displayAsPassword;
                            this._type = symbol.type;
                            this._maxChars = symbol.maxChars;
                            if (symbol.border) {
                                this.background = true;
                                this.border = true;
                            }
                            if (symbol.html) {
                                this.htmlText = symbol.initialText;
                            } else {
                                this.text = symbol.initialText;
                            }
                            this.wordWrap = symbol.wordWrap;
                            this.autoSize = symbol.autoSize;
                        };
                        TextField.prototype._initializeFields = function () {
                            _super.prototype._initializeFields.call(this);
                            this._alwaysShowSelection = false;
                            this._antiAliasType = text_1.AntiAliasType.NORMAL;
                            this._autoSize = text_1.TextFieldAutoSize.NONE;
                            this._background = false;
                            this._backgroundColor = 4294967295;
                            this._border = false;
                            this._borderColor = 255;
                            this._bottomScrollV = 1;
                            this._caretIndex = 0;
                            this._condenseWhite = false;
                            this._embedFonts = false;
                            this._gridFitType = text_1.GridFitType.PIXEL;
                            this._htmlText = '';
                            this._length = 0;
                            this._textInteractionMode = text_1.TextInteractionMode.NORMAL;
                            this._maxChars = 0;
                            this._maxScrollH = 0;
                            this._maxScrollV = 1;
                            this._mouseWheelEnabled = false;
                            this._multiline = false;
                            this._numLines = 1;
                            this._displayAsPassword = false;
                            this._restrict = null;
                            this._selectable = true;
                            this._selectedText = '';
                            this._selectionBeginIndex = 0;
                            this._selectionEndIndex = 0;
                            this._sharpness = 0;
                            this._styleSheet = null;
                            this._textColor = null;
                            this._textHeight = 0;
                            this._textWidth = 0;
                            this._thickness = 0;
                            this._type = text_1.TextFieldType.DYNAMIC;
                            this._useRichTextClipboard = false;
                            this._lineMetricsData = null;
                            var defaultTextFormat = new this.sec.flash.text.TextFormat(this.sec.flash.text.Font.axClass.DEFAULT_FONT_SERIF, 12, 0, false, false, false, '', '', text_1.TextFormatAlign.LEFT);
                            defaultTextFormat.letterSpacing = 0;
                            defaultTextFormat.kerning = 0;
                            this._textContent = new Shumway.TextContent(this.sec, defaultTextFormat);
                        };
                        TextField.prototype._setFillAndLineBoundsFromSymbol = function (symbol) {
                            _super.prototype._setFillAndLineBoundsFromSymbol.call(this, symbol);
                            this._textContent.bounds = this._lineBounds;
                            this._invalidateContent();
                        };
                        TextField.prototype._setFillAndLineBoundsFromWidthAndHeight = function (width, height) {
                            _super.prototype._setFillAndLineBoundsFromWidthAndHeight.call(this, width, height);
                            this._textContent.bounds = this._lineBounds;
                            this._invalidateContent();
                        };
                        TextField.prototype._canHaveTextContent = function () {
                            return true;
                        };
                        TextField.prototype._getTextContent = function () {
                            return this._textContent;
                        };
                        TextField.prototype._getContentBounds = function (includeStrokes) {
                            if (includeStrokes === void 0) {
                                includeStrokes = true;
                            }
                            this._ensureLineMetrics();
                            return _super.prototype._getContentBounds.call(this, includeStrokes);
                        };
                        TextField.prototype._containsPointDirectly = function (localX, localY, globalX, globalY) {
                            // If this override is reached, the content bounds have already been checked, which is all
                            // we need to do.
                            release || assert(this._getContentBounds().contains(localX, localY));
                            return true;
                        };
                        TextField.prototype._invalidateContent = function () {
                            if (this._textContent.flags & 15    /* Dirty */) {
                                this._setDirtyFlags(8    /* DirtyTextContent */);
                            }
                        };
                        // JS -> AS Bindings
                        //selectedText: string;
                        //appendText: (newText: string) => void;
                        //getXMLText: (beginIndex: number /*int*/ = 0, endIndex: number /*int*/ = 2147483647) =>
                        // string;
                        //insertXMLText: (beginIndex: number /*int*/, endIndex: number /*int*/, richText: string,
                        // pasting: boolean = false) => void; copyRichText: () => string; pasteRichText: (richText:
                        // string) => boolean;
                        // AS -> JS Bindings
                        TextField.isFontCompatible = function (fontName, fontStyle) {
                            fontName = axCoerceString(fontName);
                            fontStyle = axCoerceString(fontStyle);
                            var font = text_1.Font.getByNameAndStyle(fontName, fontStyle);
                            if (!font) {
                                return false;
                            }
                            return font.fontStyle === fontStyle;
                        };
                        Object.defineProperty(TextField.prototype, 'alwaysShowSelection', {
                            get: function () {
                                return this._alwaysShowSelection;
                            },
                            set: function (value) {
                                this._alwaysShowSelection = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'antiAliasType', {
                            get: function () {
                                return this._antiAliasType;
                            },
                            set: function (antiAliasType) {
                                if (Shumway.isNullOrUndefined(antiAliasType)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'antiAliasType');
                                }
                                antiAliasType = axCoerceString(antiAliasType);
                                if (text_1.AntiAliasType.toNumber(antiAliasType) < 0) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidParamError, 'antiAliasType');
                                }
                                this._antiAliasType = antiAliasType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'autoSize', {
                            get: function () {
                                return this._autoSize;
                            },
                            set: function (value) {
                                if (Shumway.isNullOrUndefined(value)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'autoSize');
                                }
                                value = axCoerceString(value);
                                if (value === this._autoSize) {
                                    return;
                                }
                                if (text_1.TextFieldAutoSize.toNumber(value) < 0) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidParamError, 'autoSize');
                                }
                                this._autoSize = value;
                                this._textContent.autoSize = text_1.TextFieldAutoSize.toNumber(value);
                                this._invalidateContent();
                                this._ensureLineMetrics();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'background', {
                            get: function () {
                                return this._background;
                            },
                            set: function (value) {
                                value = !!value;
                                if (value === this._background) {
                                    return;
                                }
                                this._background = value;
                                this._textContent.backgroundColor = value ? this._backgroundColor : 0;
                                this._setDirtyFlags(8    /* DirtyTextContent */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'backgroundColor', {
                            get: function () {
                                return this._backgroundColor >> 8;
                            },
                            set: function (value) {
                                value = (value << 8 | 255) >>> 0;
                                if (value === this._backgroundColor) {
                                    return;
                                }
                                this._backgroundColor = value;
                                if (this._background) {
                                    this._textContent.backgroundColor = value;
                                    this._setDirtyFlags(8    /* DirtyTextContent */);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'border', {
                            get: function () {
                                return this._border;
                            },
                            set: function (value) {
                                value = !!value;
                                if (value === this._border) {
                                    return;
                                }
                                this._border = value;
                                this._textContent.borderColor = value ? this._borderColor : 0;
                                this._setDirtyFlags(8    /* DirtyTextContent */);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'borderColor', {
                            get: function () {
                                return this._borderColor >> 8;
                            },
                            set: function (value) {
                                value = (value << 8 | 255) >>> 0;
                                if (value === this._borderColor) {
                                    return;
                                }
                                this._borderColor = value;
                                if (this._border) {
                                    this._textContent.borderColor = value;
                                    this._setDirtyFlags(8    /* DirtyTextContent */);
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'bottomScrollV', {
                            // Returns bottommost line that is currently visible.
                            get: function () {
                                return this._bottomScrollV;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'caretIndex', {
                            get: function () {
                                release || notImplemented('public flash.text.TextField::get caretIndex');
                                return;    // return this._caretIndex;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'condenseWhite', {
                            get: function () {
                                return this._condenseWhite;
                            },
                            set: function (value) {
                                this._condenseWhite = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'defaultTextFormat', {
                            get: function () {
                                return this._textContent.defaultTextFormat.clone();
                            },
                            set: function (format) {
                                if (Shumway.isNullOrUndefined(format)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'format');
                                }
                                var defaultTextFormat = this._textContent.defaultTextFormat;
                                defaultTextFormat.merge(format);
                                if (defaultTextFormat.color === null) {
                                    defaultTextFormat.color = this._textColor;
                                } else {
                                    this._textColor = +defaultTextFormat.color;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'embedFonts', {
                            get: function () {
                                return this._embedFonts;
                            },
                            set: function (value) {
                                this._embedFonts = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'gridFitType', {
                            get: function () {
                                return this._gridFitType;
                            },
                            set: function (gridFitType) {
                                if (Shumway.isNullOrUndefined(gridFitType)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'gridFitType');
                                }
                                gridFitType = axCoerceString(gridFitType);
                                release || assert(flash.text.GridFitType.toNumber(gridFitType) >= 0);
                                this._gridFitType = gridFitType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'htmlText', {
                            get: function () {
                                return this._htmlText;
                            },
                            set: function (value) {
                                if (Shumway.isNullOrUndefined(value)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'value');
                                }
                                value = axCoerceString(value);
                                // Flash resets the bold and italic flags when an html value is set on a text field created
                                // from a symbol.
                                if (this._symbol) {
                                    this._textContent.defaultTextFormat.bold = false;
                                    this._textContent.defaultTextFormat.italic = false;
                                }
                                this._textContent.parseHtml(value, this._styleSheet, this._multiline);
                                this._htmlText = value;
                                this._invalidateContent();
                                this._ensureLineMetrics();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'length', {
                            get: function () {
                                return this._length;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'textInteractionMode', {
                            get: function () {
                                release || notImplemented('public flash.text.TextField::get textInteractionMode');
                                return;    // return this._textInteractionMode;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'maxChars', {
                            get: function () {
                                return this._maxChars;
                            },
                            set: function (value) {
                                this._maxChars = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'maxScrollH', {
                            get: function () {
                                this._ensureLineMetrics();
                                return this._maxScrollH;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'maxScrollV', {
                            get: function () {
                                this._ensureLineMetrics();
                                return this._maxScrollV;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'mouseWheelEnabled', {
                            get: function () {
                                return this._mouseWheelEnabled;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.text.TextField::set mouseWheelEnabled');
                                this._mouseWheelEnabled = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'multiline', {
                            get: function () {
                                return this._multiline;
                            },
                            set: function (value) {
                                this._multiline = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'numLines', {
                            get: function () {
                                return this._numLines;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'displayAsPassword', {
                            get: function () {
                                return this._displayAsPassword;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.text.TextField::set displayAsPassword');
                                this._displayAsPassword = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'restrict', {
                            get: function () {
                                return this._restrict;
                            },
                            set: function (value) {
                                release || somewhatImplemented('public flash.text.TextField::set restrict');
                                this._restrict = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'scrollH', {
                            // Returns the current vertical scrolling position in lines.
                            get: function () {
                                return this._textContent.scrollH;
                            },
                            set: function (value) {
                                value = value | 0;
                                this._ensureLineMetrics();
                                this._textContent.scrollH = clamp(Math.abs(value), 0, this._maxScrollH);
                                this._invalidateContent();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'scrollV', {
                            // Returns the current horizontal scrolling position in pixels.
                            get: function () {
                                return this._textContent.scrollV;
                            },
                            set: function (value) {
                                value = value | 0;
                                this._ensureLineMetrics();
                                this._textContent.scrollV = clamp(value, 1, this._maxScrollV);
                                this._invalidateContent();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'selectable', {
                            get: function () {
                                return this._selectable;
                            },
                            set: function (value) {
                                this._selectable = !!value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'selectedText', {
                            get: function () {
                                return this._textContent.plainText.substring(this._selectionBeginIndex, this._selectionEndIndex);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'selectionBeginIndex', {
                            get: function () {
                                return this._selectionBeginIndex;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'selectionEndIndex', {
                            get: function () {
                                return this._selectionEndIndex;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'sharpness', {
                            get: function () {
                                return this._sharpness;
                            },
                            set: function (value) {
                                this._sharpness = clamp(+value, -400, 400);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'styleSheet', {
                            get: function () {
                                return this._styleSheet;
                            },
                            set: function (value) {
                                this._styleSheet = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'text', {
                            get: function () {
                                return this._textContent.plainText;
                            },
                            set: function (value) {
                                if (Shumway.isNullOrUndefined(value)) {
                                    this.sec.throwError('TypeError', AVMX.Errors.NullPointerError, 'value');
                                }
                                value = axCoerceString(value) || '';
                                if (value === this._textContent.plainText) {
                                    return;
                                }
                                this._textContent.plainText = value;
                                this._invalidateContent();
                                this._ensureLineMetrics();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'textColor', {
                            get: function () {
                                return this._textColor === null ? +this._textContent.defaultTextFormat.color : this._textColor;
                            },
                            set: function (value) {
                                this._textColor = this._textContent.defaultTextFormat.color = value >>> 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'textHeight', {
                            get: function () {
                                this._ensureLineMetrics();
                                return this._textHeight / 20 | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'textWidth', {
                            get: function () {
                                this._ensureLineMetrics();
                                return this._textWidth / 20 | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'thickness', {
                            get: function () {
                                return this._thickness;
                            },
                            set: function (value) {
                                this._thickness = clamp(+value, -200, 200);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'type', {
                            get: function () {
                                return this._type;
                            },
                            set: function (value) {
                                this._type = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'wordWrap', {
                            get: function () {
                                return this._textContent.wordWrap;
                            },
                            set: function (value) {
                                value = !!value;
                                if (value === this._textContent.wordWrap) {
                                    return;
                                }
                                this._textContent.wordWrap = !!value;
                                this._invalidateContent();
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextField.prototype, 'useRichTextClipboard', {
                            get: function () {
                                release || notImplemented('public flash.text.TextField::get useRichTextClipboard');
                                return;    // return this._useRichTextClipboard;
                            },
                            set: function (value) {
                                value = !!value;
                                release || notImplemented('public flash.text.TextField::set useRichTextClipboard');
                                return;    // this._useRichTextClipboard = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        TextField.prototype.copyRichText = function () {
                            release || notImplemented('public flash.text.TextField::copyRichText');
                        };
                        TextField.prototype.pasteRichText = function (richText) {
                            richText = axCoerceString(richText);
                            release || notImplemented('public flash.text.TextField::pasteRichText');
                        };
                        TextField.prototype.getXMLText = function (beginIndex, endIndex) {
                            if (endIndex === void 0) {
                                endIndex = 2147483647;
                            }
                            beginIndex = +beginIndex;
                            endIndex = +endIndex;
                            release || notImplemented('public flash.text.TextField::getXMLText');
                            return '';
                        };
                        TextField.prototype.insertXMLText = function (beginIndex, endIndex, richText, pasting) {
                            beginIndex = +beginIndex;
                            endIndex = +endIndex;
                            richText = axCoerceString(richText);
                            pasting = !!pasting;
                            release || notImplemented('public flash.text.TextField::insertXMLText');
                        };
                        TextField.prototype._ensureLineMetrics = function () {
                            if (!this._hasDirtyFlags(8    /* DirtyTextContent */)) {
                                return;
                            }
                            var serializer = this.sec.player;
                            var lineMetricsData = serializer.syncDisplayObject(this, false);
                            var textWidth = lineMetricsData.readInt();
                            var textHeight = lineMetricsData.readInt();
                            var offsetX = lineMetricsData.readInt();
                            var bounds = this._lineBounds;
                            if (this._autoSize !== text_1.TextFieldAutoSize.NONE) {
                                bounds.xMin = offsetX;
                                bounds.xMax = offsetX + textWidth + 80;
                                bounds.yMax = bounds.yMin + textHeight + 80;
                            }
                            this._textWidth = textWidth;
                            this._textHeight = textHeight;
                            this._numLines = lineMetricsData.readInt();
                            this._lineMetricsData = lineMetricsData;
                            if (this._textHeight > bounds.height) {
                                var maxScrollV = 1;
                                var bottomScrollV = 1;
                                lineMetricsData.position = 16;
                                var y = 0;
                                for (var i = 0; i < this._numLines; i++) {
                                    lineMetricsData.position += 8;
                                    var ascent = lineMetricsData.readInt();
                                    var descent = lineMetricsData.readInt();
                                    var leading = lineMetricsData.readInt();
                                    var height = ascent + descent + leading;
                                    if (y > bounds.height / 20) {
                                        maxScrollV++;
                                    } else {
                                        bottomScrollV++;
                                    }
                                    y += height;
                                }
                                this._maxScrollV = maxScrollV;
                                this._bottomScrollV = bottomScrollV;
                            }
                            if (this._textWidth > bounds.width) {
                                this._maxScrollH = (this._textWidth + 80 - bounds.width) / 20 | 0;
                            } else {
                                this._maxScrollH = 0;
                            }
                        };
                        TextField.prototype.appendText = function (newText) {
                            this._textContent.appendText(axCoerceString(newText));
                        };
                        TextField.prototype.getCharBoundaries = function (charIndex) {
                            charIndex = charIndex | 0;
                            release || somewhatImplemented('public flash.text.TextField::getCharBoundaries');
                            var fakeCharHeight = this.textHeight, fakeCharWidth = fakeCharHeight * 0.75;
                            return new this.sec.flash.geom.Rectangle(charIndex * fakeCharWidth, 0, fakeCharWidth, fakeCharHeight);
                        };
                        TextField.prototype.getCharIndexAtPoint = function (x, y) {
                            x = +x;
                            y = +y;
                            release || notImplemented('public flash.text.TextField::getCharIndexAtPoint');
                            return;
                        };
                        TextField.prototype.getFirstCharInParagraph = function (charIndex) {
                            charIndex = charIndex | 0;
                            release || notImplemented('public flash.text.TextField::getFirstCharInParagraph');
                            return;
                        };
                        TextField.prototype.getLineIndexAtPoint = function (x, y) {
                            x = +x;
                            y = +y;
                            release || notImplemented('public flash.text.TextField::getLineIndexAtPoint');
                            return;
                        };
                        TextField.prototype.getLineIndexOfChar = function (charIndex) {
                            charIndex = charIndex | 0;
                            release || notImplemented('public flash.text.TextField::getLineIndexOfChar');
                            return;
                        };
                        TextField.prototype.getLineLength = function (lineIndex) {
                            lineIndex = lineIndex | 0;
                            release || notImplemented('public flash.text.TextField::getLineLength');
                            return;
                        };
                        TextField.prototype.getLineMetrics = function (lineIndex) {
                            lineIndex = lineIndex | 0;
                            if (lineIndex < 0 || lineIndex > this._numLines - 1) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            this._ensureLineMetrics();
                            var lineMetricsData = this._lineMetricsData;
                            lineMetricsData.position = 16 + lineIndex * 20;
                            // The lines left position includes the gutter widths (it should also include the the margin
                            // and indent, which we don't support yet).
                            var x = lineMetricsData.readInt() + this._lineBounds.xMin + 2;
                            var width = lineMetricsData.readInt();
                            var ascent = lineMetricsData.readInt();
                            var descent = lineMetricsData.readInt();
                            var leading = lineMetricsData.readInt();
                            var height = ascent + descent + leading;
                            return new this.sec.flash.text.TextLineMetrics(x, width, height, ascent, descent, leading);
                        };
                        TextField.prototype.getLineOffset = function (lineIndex) {
                            lineIndex = lineIndex | 0;
                            var lines = this._textContent.plainText.split('\r');
                            if (lineIndex < 0 || lineIndex >= lines.length) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            var offset = 0;
                            for (var i = 0; i < lineIndex; i++) {
                                offset += lines[i].length + 1;    // Length + `\r`
                            }
                            // TODO:  I've tried modifying the width of the text field so that lines wrap, but this doesn't seem
                            // to have any effect on how line offsets are computed. I'm leaving in the |somewhatImplemented| call
                            // since this is not fully tested.
                            release || release || somewhatImplemented('public flash.text.TextField::getLineOffset');
                            return offset;
                        };
                        TextField.prototype.getLineText = function (lineIndex) {
                            lineIndex = lineIndex | 0;
                            var lines = this._textContent.plainText.split('\r');
                            if (lineIndex < 0 || lineIndex >= lines.length) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            return lines[lineIndex];
                        };
                        TextField.prototype.getParagraphLength = function (charIndex) {
                            charIndex = charIndex | 0;
                            release || notImplemented('public flash.text.TextField::getParagraphLength');
                            return;
                        };
                        /**
                         * Returns a TextFormat object that contains the intersection of formatting information for the
                         * range of text between |beginIndex| and |endIndex|.
                         */
                        TextField.prototype.getTextFormat = function (beginIndex, endIndex) {
                            if (beginIndex === void 0) {
                                beginIndex = -1;
                            }
                            if (endIndex === void 0) {
                                endIndex = -1;
                            }
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            var plainText = this._textContent.plainText;
                            var maxIndex = plainText.length;
                            if (beginIndex < 0) {
                                beginIndex = 0;
                                if (endIndex < 0) {
                                    endIndex = maxIndex;
                                }
                            } else {
                                if (endIndex < 0) {
                                    endIndex = beginIndex + 1;
                                }
                            }
                            if (endIndex <= beginIndex || endIndex > maxIndex) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            var format;
                            var textRuns = this._textContent.textRuns;
                            for (var i = 0; i < textRuns.length; i++) {
                                var run = textRuns[i];
                                if (run.intersects(beginIndex, endIndex)) {
                                    if (format) {
                                        format.intersect(run.textFormat);
                                    } else {
                                        format = run.textFormat.clone();
                                    }
                                }
                            }
                            return format;
                        };
                        TextField.prototype.getTextRuns = function (beginIndex, endIndex) {
                            if (beginIndex === void 0) {
                                beginIndex = 0;
                            }
                            if (endIndex === void 0) {
                                endIndex = 2147483647;
                            }
                            var textRuns = this._textContent.textRuns;
                            var result = [];
                            for (var i = 0; i < textRuns.length; i++) {
                                var textRun = textRuns[i];
                                if (textRun.beginIndex >= beginIndex && textRun.endIndex <= endIndex) {
                                    result.push(textRun.clone());
                                }
                            }
                            return this.sec.createArrayUnsafe(result);
                        };
                        TextField.prototype.getRawText = function () {
                            release || notImplemented('public flash.text.TextField::getRawText');
                            return;
                        };
                        TextField.prototype.replaceSelectedText = function (value) {
                            value = '' + value;
                            this.replaceText(this._selectionBeginIndex, this._selectionEndIndex, value);
                        };
                        TextField.prototype.replaceText = function (beginIndex, endIndex, newText) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            newText = '' + newText;
                            if (beginIndex < 0 || endIndex < 0) {
                                return;
                            }
                            this._textContent.replaceText(beginIndex, endIndex, newText);
                            this._invalidateContent();
                            this._ensureLineMetrics();
                        };
                        TextField.prototype.setSelection = function (beginIndex, endIndex) {
                            this._selectionBeginIndex = beginIndex | 0;
                            this._selectionEndIndex = endIndex | 0;
                        };
                        TextField.prototype.setTextFormat = function (format, beginIndex, endIndex) {
                            if (beginIndex === void 0) {
                                beginIndex = -1;
                            }
                            if (endIndex === void 0) {
                                endIndex = -1;
                            }
                            format = format;
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            var plainText = this._textContent.plainText;
                            var maxIndex = plainText.length;
                            if (beginIndex < 0) {
                                beginIndex = 0;
                                if (endIndex < 0) {
                                    endIndex = maxIndex;
                                }
                            } else {
                                if (endIndex < 0) {
                                    endIndex = beginIndex + 1;
                                }
                            }
                            if (beginIndex > maxIndex || endIndex > maxIndex) {
                                this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError);
                            }
                            if (endIndex <= beginIndex) {
                                return;
                            }
                            var subText = plainText.substring(beginIndex, endIndex);
                            this._textContent.replaceText(beginIndex, endIndex, subText, format);
                            this._invalidateContent();
                            this._ensureLineMetrics();
                        };
                        TextField.prototype.getImageReference = function (id) {
                            //id = "" + id;
                            release || notImplemented('public flash.text.TextField::getImageReference');
                            return;
                        };
                        TextField.classSymbols = null;
                        TextField.instanceSymbols = null;
                        TextField.classInitializer = null;
                        return TextField;
                    }(flash.display.InteractiveObject);
                    text_1.TextField = TextField;
                    var TextSymbol = function (_super) {
                        __extends(TextSymbol, _super);
                        function TextSymbol(data, sec) {
                            _super.call(this, data, sec.flash.text.TextField.axClass, true);
                            this.color = 0;
                            this.size = 0;
                            this.face = '';
                            this.bold = false;
                            this.italic = false;
                            this.align = flash.text.TextFormatAlign.LEFT;
                            this.leftMargin = 0;
                            this.rightMargin = 0;
                            this.indent = 0;
                            this.leading = 0;
                            this.multiline = false;
                            this.wordWrap = false;
                            this.embedFonts = false;
                            this.selectable = true;
                            this.border = false;
                            this.initialText = '';
                            this.html = false;
                            this.displayAsPassword = false;
                            this.type = flash.text.TextFieldType.DYNAMIC;
                            this.maxChars = 0;
                            this.autoSize = flash.text.TextFieldAutoSize.NONE;
                            this.variableName = null;
                            this.textContent = null;
                        }
                        TextSymbol.FromTextData = function (data, loaderInfo) {
                            var sec = loaderInfo.sec;
                            var symbol = new TextSymbol(data, sec);
                            symbol._setBoundsFromData(data);
                            var tag = data.tag;
                            if (data.static) {
                                symbol.dynamic = false;
                                symbol.symbolClass = sec.flash.text.StaticText.axClass;
                                if (tag.initialText) {
                                    var textContent = new Shumway.TextContent(sec);
                                    textContent.bounds = symbol.lineBounds;
                                    textContent.parseHtml(tag.initialText, null, false);
                                    textContent.matrix = new sec.flash.geom.Matrix();
                                    textContent.matrix.copyFromUntyped(data.matrix);
                                    textContent.coords = data.coords;
                                    symbol.textContent = textContent;
                                }
                            }
                            if (tag.flags & 4    /* HasColor */) {
                                symbol.color = tag.color >>> 8;
                            }
                            if (tag.flags & 1    /* HasFont */) {
                                symbol.size = tag.fontHeight;
                                // Requesting the font symbol guarantees that it's loaded and initialized.
                                var fontSymbol = loaderInfo.getSymbolById(tag.fontId);
                                if (fontSymbol) {
                                    symbol.face = tag.flags & 256    /* UseOutlines */ ? fontSymbol.name : 'swffont' + fontSymbol.syncId;
                                    symbol.bold = fontSymbol.bold;
                                    symbol.italic = fontSymbol.italic;
                                } else {
                                    warning('Font ' + tag.fontId + ' is not defined.');
                                }
                            }
                            if (tag.flags & 8192    /* HasLayout */) {
                                symbol.align = flash.text.TextFormatAlign.fromNumber(tag.align);
                                symbol.leftMargin = tag.leftMargin;
                                symbol.rightMargin = tag.rightMargin;
                                symbol.indent = tag.indent;
                                symbol.leading = tag.leading;
                            }
                            symbol.multiline = !!(tag.flags & 32    /* Multiline */);
                            symbol.wordWrap = !!(tag.flags & 64    /* WordWrap */);
                            symbol.embedFonts = !!(tag.flags & 256    /* UseOutlines */);
                            symbol.selectable = !(tag.flags & 4096    /* NoSelect */);
                            symbol.border = !!(tag.flags & 2048    /* Border */);
                            if (tag.flags & 128    /* HasText */) {
                                symbol.initialText = tag.initialText;
                            }
                            symbol.html = !!(tag.flags & 512    /* Html */);
                            symbol.displayAsPassword = !!(tag.flags & 16    /* Password */);
                            symbol.type = tag.flags & 8    /* ReadOnly */ ? flash.text.TextFieldType.DYNAMIC : flash.text.TextFieldType.INPUT;
                            if (tag.flags & 2    /* HasMaxLength */) {
                                symbol.maxChars = tag.maxLength;
                            }
                            symbol.autoSize = tag.flags & 16384    /* AutoSize */ ? flash.text.TextFieldAutoSize.LEFT : flash.text.TextFieldAutoSize.NONE;
                            symbol.variableName = tag.variableName;
                            return symbol;
                        };
                        /**
                         * Turns raw DefineLabel tag data into an object that's consumable as a text symbol and then
                         * passes that into `FromTextData`, returning the resulting TextSymbol.
                         *
                         * This has to be done outside the SWF parser because it relies on any used fonts being
                         * available as symbols, which isn't the case in the SWF parser.
                         */
                        TextSymbol.FromLabelData = function (data, loaderInfo) {
                            var bounds = data.fillBounds;
                            var records = data.records;
                            var coords = data.coords = [];
                            var htmlText = '';
                            var size = 12;
                            var face = 'Times Roman';
                            var bold = false;
                            var italic = false;
                            var color = 0;
                            var x = 0;
                            var y = 0;
                            var codes;
                            for (var i = 0; i < records.length; i++) {
                                var record = records[i];
                                if (record.flags & 8    /* HasFont */) {
                                    var fontSymbol = loaderInfo.getSymbolById(record.fontId);
                                    if (fontSymbol) {
                                        codes = fontSymbol.codes;
                                        size = record.fontHeight;
                                        if (!fontSymbol.originalSize) {
                                            size /= 20;
                                        }
                                        face = fontSymbol.metrics ? 'swffont' + fontSymbol.syncId : fontSymbol.name;
                                        bold = fontSymbol.bold;
                                        italic = fontSymbol.italic;
                                    } else {
                                        Shumway.Debug.warning('Label ' + data.id + 'refers to undefined font symbol ' + record.fontId);
                                    }
                                }
                                if (record.flags & 4    /* HasColor */) {
                                    color = record.color >>> 8;
                                }
                                if (record.flags & 1    /* HasMoveX */) {
                                    x = record.moveX;
                                }
                                if (record.flags & 2    /* HasMoveY */) {
                                    y = record.moveY;
                                }
                                var text = '';
                                var entries = record.entries;
                                var j = 0;
                                var entry;
                                while (entry = entries[j++]) {
                                    var code = codes[entry.glyphIndex];
                                    release || assert(code, 'undefined label glyph');
                                    var char = String.fromCharCode(code);
                                    text += charEscapeMap[char] || char;
                                    coords.push(x, y);
                                    x += entry.advance;
                                }
                                if (italic) {
                                    text = '<i>' + text + '</i>';
                                }
                                if (bold) {
                                    text = '<b>' + text + '</b>';
                                }
                                htmlText += '<font size="' + size + '" face="' + face + '"' + ' color="#' + ('000000' + color.toString(16)).slice(-6) + '">' + text + '</font>';
                            }
                            data.tag.initialText = htmlText;
                            return TextSymbol.FromTextData(data, loaderInfo);
                        };
                        return TextSymbol;
                    }(Shumway.Timeline.DisplaySymbol);
                    text_1.TextSymbol = TextSymbol;
                    var charEscapeMap = {
                        '<': '&lt;',
                        '>': '&gt;',
                        '&': '&amp;'
                    };
                }(text = flash.text || (flash.text = {})));
                var text;
                (function (text) {
                    var TextFieldAutoSize = function (_super) {
                        __extends(TextFieldAutoSize, _super);
                        function TextFieldAutoSize() {
                            _super.call(this);
                        }
                        TextFieldAutoSize.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return TextFieldAutoSize.NONE;
                            case 1:
                                return TextFieldAutoSize.CENTER;
                            case 2:
                                return TextFieldAutoSize.LEFT;
                            case 3:
                                return TextFieldAutoSize.RIGHT;
                            default:
                                return null;
                            }
                        };
                        TextFieldAutoSize.toNumber = function (value) {
                            switch (value) {
                            case TextFieldAutoSize.NONE:
                                return 0;
                            case TextFieldAutoSize.CENTER:
                                return 1;
                            case TextFieldAutoSize.LEFT:
                                return 2;
                            case TextFieldAutoSize.RIGHT:
                                return 3;
                            default:
                                return -1;
                            }
                        };
                        TextFieldAutoSize.classInitializer = null;
                        TextFieldAutoSize.classSymbols = null;
                        TextFieldAutoSize.instanceSymbols = null;
                        // JS -> AS Bindings
                        TextFieldAutoSize.NONE = 'none';
                        TextFieldAutoSize.LEFT = 'left';
                        TextFieldAutoSize.CENTER = 'center';
                        TextFieldAutoSize.RIGHT = 'right';
                        return TextFieldAutoSize;
                    }(AS.ASObject);
                    text.TextFieldAutoSize = TextFieldAutoSize;
                    var TextFieldType = function (_super) {
                        __extends(TextFieldType, _super);
                        function TextFieldType() {
                            _super.call(this);
                        }
                        TextFieldType.classInitializer = null;
                        TextFieldType.classSymbols = null;
                        TextFieldType.instanceSymbols = null;
                        // JS -> AS Bindings
                        TextFieldType.INPUT = 'input';
                        TextFieldType.DYNAMIC = 'dynamic';
                        return TextFieldType;
                    }(AS.ASObject);
                    text.TextFieldType = TextFieldType;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var roundHalfEven = Shumway.NumberUtilities.roundHalfEven;
                    var TextFormat = function (_super) {
                        __extends(TextFormat, _super);
                        function TextFormat(font, size, color, bold, italic, underline, url, target, align, leftMargin, rightMargin, indent, leading) {
                            if (font === void 0) {
                                font = null;
                            }
                            if (size === void 0) {
                                size = null;
                            }
                            if (color === void 0) {
                                color = null;
                            }
                            if (bold === void 0) {
                                bold = null;
                            }
                            if (italic === void 0) {
                                italic = null;
                            }
                            if (underline === void 0) {
                                underline = null;
                            }
                            if (url === void 0) {
                                url = null;
                            }
                            if (target === void 0) {
                                target = null;
                            }
                            if (align === void 0) {
                                align = null;
                            }
                            if (leftMargin === void 0) {
                                leftMargin = null;
                            }
                            if (rightMargin === void 0) {
                                rightMargin = null;
                            }
                            if (indent === void 0) {
                                indent = null;
                            }
                            if (leading === void 0) {
                                leading = null;
                            }
                            _super.call(this);
                            this.font = font;
                            this.size = size;
                            this.color = color;
                            this.bold = bold;
                            this.italic = italic;
                            this.underline = underline;
                            this.url = url;
                            this.target = target;
                            this.align = align;
                            this.leftMargin = leftMargin;
                            this.rightMargin = rightMargin;
                            this.indent = indent;
                            this.leading = leading;
                            this._blockIndent = null;
                            this._bullet = null;
                            this._display = text.TextFormatDisplay.BLOCK;
                            this._kerning = null;
                            this._letterSpacing = null;
                            this._tabStops = null;
                        }
                        Object.defineProperty(TextFormat.prototype, 'align', {
                            // AS -> JS Bindings
                            get: function () {
                                return this._align;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                //if (TextFormatAlign.toNumber(value) < 0) {
                                //  this.sec.throwError("ArgumentError", Errors.InvalidEnumError, "align");
                                //}
                                this._align = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'blockIndent', {
                            get: function () {
                                return this._blockIndent;
                            },
                            set: function (value) {
                                this._blockIndent = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'bold', {
                            get: function () {
                                return this._bold;
                            },
                            set: function (value) {
                                this._bold = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'bullet', {
                            get: function () {
                                return this._bullet;
                            },
                            set: function (value) {
                                this._bullet = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'color', {
                            get: function () {
                                return this._color;
                            },
                            set: function (value) {
                                this._color = value != null ? +value | 0 : null;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'display', {
                            get: function () {
                                return this._display;
                            },
                            set: function (value) {
                                this._display = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'font', {
                            get: function () {
                                return this._font;
                            },
                            set: function (value) {
                                this._font = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'style', {
                            get: function () {
                                if (this._bold && this._italic) {
                                    return text.FontStyle.BOLD_ITALIC;
                                } else if (this._bold) {
                                    return text.FontStyle.BOLD;
                                } else if (this._italic) {
                                    return text.FontStyle.ITALIC;
                                } else {
                                    return text.FontStyle.REGULAR;
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'indent', {
                            get: function () {
                                return this._indent;
                            },
                            set: function (value) {
                                this._indent = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'italic', {
                            get: function () {
                                return this._italic;
                            },
                            set: function (value) {
                                this._italic = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'kerning', {
                            get: function () {
                                return this._kerning;
                            },
                            set: function (value) {
                                this._kerning = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'leading', {
                            get: function () {
                                return this._leading;
                            },
                            set: function (value) {
                                this._leading = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'leftMargin', {
                            get: function () {
                                return this._leftMargin;
                            },
                            set: function (value) {
                                this._leftMargin = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'letterSpacing', {
                            get: function () {
                                return this._letterSpacing;
                            },
                            set: function (value) {
                                this._letterSpacing = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'rightMargin', {
                            get: function () {
                                return this._rightMargin;
                            },
                            set: function (value) {
                                this._rightMargin = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'size', {
                            get: function () {
                                return this._size;
                            },
                            set: function (value) {
                                this._size = TextFormat.coerceNumber(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'tabStops', {
                            get: function () {
                                return this.sec.createArrayUnsafe(this._tabStops);
                            },
                            set: function (value) {
                                if (value == null) {
                                    this._tabStops = null;
                                    return;
                                }
                                if (!this.sec.AXArray.axIsType(value)) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.CheckTypeFailedError, value, 'Array');
                                }
                                this._tabStops = value.value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'target', {
                            get: function () {
                                return this._target;
                            },
                            set: function (value) {
                                this._target = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'underline', {
                            get: function () {
                                return this._underline;
                            },
                            set: function (value) {
                                this._underline = TextFormat.coerceBoolean(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextFormat.prototype, 'url', {
                            get: function () {
                                return this._url;
                            },
                            set: function (value) {
                                this._url = axCoerceString(value);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * All integer values on TextFormat are typed as Object and coerced to ints using the following
                         * "algorithm":
                         * - if the supplied value is null or undefined, the field is set to null
                         * - else if coercing to number results in NaN or the value is greater than MAX_INT, set to
                         *   -0x80000000
                         * - else, round the coerced value using half-even rounding
                         */
                        TextFormat.coerceNumber = function (value) {
                            /* tslint:disable */
                            if (value == undefined) {
                                return null;
                            }
                            /* tslint:enable */
                            if (isNaN(value) || value > 268435455) {
                                return -2147483648;
                            }
                            return roundHalfEven(value);
                        };
                        /**
                         * Boolean values are only stored as bools if they're not undefined or null. In that case,
                         * they're stored as null.
                         */
                        TextFormat.coerceBoolean = function (value) {
                            /* tslint:disable */
                            return value == undefined ? null : !!value;    /* tslint:enable */
                        };
                        TextFormat.prototype.clone = function () {
                            var tf = new this.sec.flash.text.TextFormat(this._font, this._size, this._color, this._bold, this._italic, this._underline, this._url, this._target, this._align, this._leftMargin, this._rightMargin, this._indent, this._leading);
                            tf._blockIndent = this._blockIndent;
                            tf._bullet = this._bullet;
                            tf._display = this._display;
                            tf._kerning = this._kerning;
                            tf._letterSpacing = this._letterSpacing;
                            tf._tabStops = this._tabStops;
                            return tf;
                        };
                        TextFormat.prototype.equals = function (other) {
                            return this._align === other._align && this._blockIndent === other._blockIndent && this._bold === other._bold && this._bullet === other._bullet && this._color === other._color && this._display === other._display && this._font === other._font && this._indent === other._indent && this._italic === other._italic && this._kerning === other._kerning && this._leading === other._leading && this._leftMargin === other._leftMargin && this._letterSpacing === other._letterSpacing && this._rightMargin === other._rightMargin && this._size === other._size && this._tabStops === other._tabStops && this._target === other._target && this._underline === other._underline && this._url === other._url;
                        };
                        TextFormat.prototype.merge = function (other) {
                            if (other._align !== null) {
                                this._align = other._align;
                            }
                            if (other._blockIndent !== null) {
                                this._blockIndent = other._blockIndent;
                            }
                            if (other._bold !== null) {
                                this._bold = other._bold;
                            }
                            if (other._bullet !== null) {
                                this._bullet = other._bullet;
                            }
                            if (other._color !== null) {
                                this._color = other._color;
                            }
                            if (other._display !== null) {
                                this._display = other._display;
                            }
                            if (other._font) {
                                this._font = other._font;
                            }
                            if (other._indent !== null) {
                                this._indent = other._indent;
                            }
                            if (other._italic !== null) {
                                this._italic = other._italic;
                            }
                            if (other._kerning !== null) {
                                this._kerning = other._kerning;
                            }
                            if (other._leading !== null) {
                                this._leading = other._leading;
                            }
                            if (other._leftMargin !== null) {
                                this._leftMargin = other._leftMargin;
                            }
                            if (other._letterSpacing !== null) {
                                this._letterSpacing = other._letterSpacing;
                            }
                            if (other._rightMargin !== null) {
                                this._rightMargin = other._rightMargin;
                            }
                            if (other._size !== null) {
                                this._size = other._size;
                            }
                            if (other._tabStops !== null) {
                                this._tabStops = other._tabStops;
                            }
                            if (other._target) {
                                this._target = other._target;
                            }
                            if (other._underline !== null) {
                                this._underline = other._underline;
                            }
                            if (other._url) {
                                this._url = other._url;
                            }
                        };
                        TextFormat.prototype.intersect = function (other) {
                            if (other._align !== this._align) {
                                this._align = null;
                            }
                            if (other._blockIndent !== this._blockIndent) {
                                this._blockIndent = null;
                            }
                            if (other._bold !== this._bold) {
                                this._bold = null;
                            }
                            if (other._bullet !== this._bullet) {
                                this._bullet = null;
                            }
                            if (other._color !== this._color) {
                                this._color = null;
                            }
                            if (other._display !== this._display) {
                                this._display = null;
                            }
                            if (other._font !== this._font) {
                                this._font = null;
                            }
                            if (other._indent !== this._indent) {
                                this._indent = null;
                            }
                            if (other._italic !== this._italic) {
                                this._italic = null;
                            }
                            if (other._kerning !== this._kerning) {
                                this._kerning = null;
                            }
                            if (other._leading !== this._leading) {
                                this._leading = null;
                            }
                            if (other._leftMargin !== this._leftMargin) {
                                this._leftMargin = null;
                            }
                            if (other._letterSpacing !== this._letterSpacing) {
                                this._letterSpacing = null;
                            }
                            if (other._rightMargin !== this._rightMargin) {
                                this._rightMargin = null;
                            }
                            if (other._size !== this._size) {
                                this._size = null;
                            }
                            if (other._tabStops !== this._tabStops) {
                                this._tabStops = null;
                            }
                            if (other._target !== this._target) {
                                this._target = null;
                            }
                            if (other._underline !== this._underline) {
                                this._underline = null;
                            }
                            if (other._url !== this._url) {
                                this._url = null;
                            }
                        };
                        TextFormat.prototype.transform = function (formatObject) {
                            var v = formatObject.textAlign;
                            if (v) {
                                this.align = v;
                            }
                            v = formatObject.fontWeight;
                            if (v === 'bold') {
                                this.bold = true;
                            } else if (v === 'normal') {
                                this.bold = false;
                            }
                            v = formatObject.color;
                            if (v) {
                                // When parsing colors, whitespace is trimmed away, and all numbers are accepted, as long
                                // as they make up the full string after the "#", without any non-numeric pre- or suffix.
                                // This implementation is somewhat atrocious, but it should be reasonably fast and works.
                                var colorStr = axCoerceString(v).trim().toLowerCase();
                                if (colorStr[0] === '#') {
                                    var numericPart = colorStr.substr(1);
                                    while (numericPart[0] === '0') {
                                        numericPart = numericPart.substr(1);
                                    }
                                    var colorVal = parseInt(numericPart, 16);
                                    if (colorVal.toString(16) === numericPart) {
                                        this.color = colorVal;
                                    }
                                }
                            }
                            v = formatObject.display;
                            if (v) {
                                this.display = v;
                            }
                            v = formatObject.fontFamily;
                            if (v) {
                                // TODO: Sanitize fontFamily string.
                                this.font = v.replace('sans-serif', '_sans').replace('serif', '_serif');
                            }
                            v = formatObject.textIndent;
                            if (v) {
                                this.indent = parseInt(v);
                            }
                            v = formatObject.fontStyle;
                            if (v === 'italic') {
                                this.italic = true;
                            } else if (v === 'normal') {
                                this.italic = false;
                            }
                            v = formatObject.kerning;
                            if (v === 'true') {
                                this.kerning = 1;
                            } else if (v === 'false') {
                                this.kerning = 0;
                            } else {
                                this.kerning = parseInt(v);
                            }
                            v = formatObject.leading;
                            if (v) {
                                this.leading = parseInt(v);
                            }
                            v = formatObject.marginLeft;
                            if (v) {
                                this.leftMargin = parseInt(v);
                            }
                            v = formatObject.letterSpacing;
                            if (v) {
                                this.letterSpacing = parseFloat(v);
                            }
                            v = formatObject.marginRight;
                            if (v) {
                                this.rightMargin = parseInt(v);
                            }
                            v = formatObject.fontSize;
                            if (v) {
                                var size = parseInt(v);
                                if (size > 0) {
                                    this.size = size;
                                }
                            }
                            v = formatObject.textDecoration;
                            if (v === 'none') {
                                this.underline = false;
                            } else if (v === 'underline') {
                                this.underline = true;
                            }
                            return this;
                        };
                        TextFormat.classInitializer = null;
                        TextFormat.classSymbols = null;
                        // [];
                        TextFormat.instanceSymbols = null;
                        // [];
                        return TextFormat;
                    }(AS.ASObject);
                    text.TextFormat = TextFormat;
                    var TextFormatAlign = function (_super) {
                        __extends(TextFormatAlign, _super);
                        function TextFormatAlign() {
                            _super.call(this);
                        }
                        TextFormatAlign.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return TextFormatAlign.LEFT;
                            case 1:
                                return TextFormatAlign.RIGHT;
                            case 2:
                                return TextFormatAlign.CENTER;
                            case 3:
                                return TextFormatAlign.JUSTIFY;
                            case 4:
                                return TextFormatAlign.START;
                            case 5:
                                return TextFormatAlign.END;
                            default:
                                return null;
                            }
                        };
                        TextFormatAlign.toNumber = function (value) {
                            switch (value) {
                            case TextFormatAlign.LEFT:
                                return 0;
                            case TextFormatAlign.RIGHT:
                                return 1;
                            case TextFormatAlign.CENTER:
                                return 2;
                            case TextFormatAlign.JUSTIFY:
                                return 3;
                            case TextFormatAlign.START:
                                return 4;
                            case TextFormatAlign.END:
                                return 5;
                            default:
                                return -1;
                            }
                        };
                        TextFormatAlign.classInitializer = null;
                        TextFormatAlign.classSymbols = null;
                        TextFormatAlign.instanceSymbols = null;
                        // JS -> AS Bindings
                        TextFormatAlign.LEFT = 'left';
                        TextFormatAlign.CENTER = 'center';
                        TextFormatAlign.RIGHT = 'right';
                        TextFormatAlign.JUSTIFY = 'justify';
                        TextFormatAlign.START = 'start';
                        TextFormatAlign.END = 'end';
                        return TextFormatAlign;
                    }(AS.ASObject);
                    text.TextFormatAlign = TextFormatAlign;
                    var TextFormatDisplay = function (_super) {
                        __extends(TextFormatDisplay, _super);
                        function TextFormatDisplay() {
                            _super.call(this);
                        }
                        TextFormatDisplay.classInitializer = null;
                        TextFormatDisplay.classSymbols = null;
                        TextFormatDisplay.instanceSymbols = null;
                        // JS -> AS Bindings
                        TextFormatDisplay.INLINE = 'inline';
                        TextFormatDisplay.BLOCK = 'block';
                        return TextFormatDisplay;
                    }(AS.ASObject);
                    text.TextFormatDisplay = TextFormatDisplay;
                    var TextInteractionMode = function (_super) {
                        __extends(TextInteractionMode, _super);
                        function TextInteractionMode() {
                            _super.call(this);
                        }
                        TextInteractionMode.classInitializer = null;
                        TextInteractionMode.classSymbols = null;
                        TextInteractionMode.instanceSymbols = null;
                        // JS -> AS Bindings
                        TextInteractionMode.NORMAL = 'normal';
                        TextInteractionMode.SELECTION = 'selection';
                        return TextInteractionMode;
                    }(AS.ASObject);
                    text.TextInteractionMode = TextInteractionMode;
                    var TextLineMetrics = function (_super) {
                        __extends(TextLineMetrics, _super);
                        function TextLineMetrics(x, width, height, ascent, descent, leading) {
                            _super.call(this);
                            this.x = +x;
                            this.width = +width;
                            this.height = +height;
                            this.ascent = +ascent;
                            this.descent = +descent;
                            this.leading = +leading;
                        }
                        TextLineMetrics.classInitializer = null;
                        TextLineMetrics.classSymbols = null;
                        TextLineMetrics.instanceSymbols = null;
                        // ["x", "width", "height", "ascent", "descent", "leading"];
                        return TextLineMetrics;
                    }(AS.ASObject);
                    text.TextLineMetrics = TextLineMetrics;
                    var TextRun = function (_super) {
                        __extends(TextRun, _super);
                        function TextRun(beginIndex, endIndex, textFormat) {
                            _super.call(this);
                            this._beginIndex = beginIndex | 0;
                            this._endIndex = endIndex | 0;
                            this._textFormat = textFormat;
                        }
                        Object.defineProperty(TextRun.prototype, 'beginIndex', {
                            get: function () {
                                return this._beginIndex;
                            },
                            set: function (value) {
                                this._beginIndex = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextRun.prototype, 'endIndex', {
                            get: function () {
                                return this._endIndex;
                            },
                            set: function (value) {
                                this._endIndex = value | 0;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TextRun.prototype, 'textFormat', {
                            get: function () {
                                return this._textFormat;
                            },
                            set: function (value) {
                                this._textFormat = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        TextRun.prototype.clone = function () {
                            return new this.sec.flash.text.TextRun(this.beginIndex, this.endIndex, this.textFormat.clone());
                        };
                        TextRun.prototype.containsIndex = function (index) {
                            return index >= this._beginIndex && index < this._endIndex;
                        };
                        TextRun.prototype.intersects = function (beginIndex, endIndex) {
                            return Math.max(this._beginIndex, beginIndex) < Math.min(this._endIndex, endIndex);
                        };
                        TextRun.classInitializer = null;
                        return TextRun;
                    }(AS.ASObject);
                    text.TextRun = TextRun;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var TextSnapshot = function (_super) {
                        __extends(TextSnapshot, _super);
                        function TextSnapshot() {
                            _super.call(this);
                        }
                        Object.defineProperty(TextSnapshot.prototype, 'charCount', {
                            // _charCount: number /*int*/;
                            get: function () {
                                release || notImplemented('public flash.text.TextSnapshot::get charCount');
                                return;    // return this._charCount;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        TextSnapshot.prototype.findText = function (beginIndex, textToFind, caseSensitive) {
                            beginIndex = beginIndex | 0;
                            textToFind = axCoerceString(textToFind);
                            caseSensitive = !!caseSensitive;
                            release || notImplemented('public flash.text.TextSnapshot::findText');
                            return;
                        };
                        TextSnapshot.prototype.getSelected = function (beginIndex, endIndex) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            release || notImplemented('public flash.text.TextSnapshot::getSelected');
                            return;
                        };
                        TextSnapshot.prototype.getSelectedText = function (includeLineEndings) {
                            if (includeLineEndings === void 0) {
                                includeLineEndings = false;
                            }
                            includeLineEndings = !!includeLineEndings;
                            release || notImplemented('public flash.text.TextSnapshot::getSelectedText');
                            return;
                        };
                        TextSnapshot.prototype.getText = function (beginIndex, endIndex, includeLineEndings) {
                            if (includeLineEndings === void 0) {
                                includeLineEndings = false;
                            }
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            includeLineEndings = !!includeLineEndings;
                            release || notImplemented('public flash.text.TextSnapshot::getText');
                            return;
                        };
                        TextSnapshot.prototype.getTextRunInfo = function (beginIndex, endIndex) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            release || notImplemented('public flash.text.TextSnapshot::getTextRunInfo');
                            return;
                        };
                        TextSnapshot.prototype.hitTestTextNearPos = function (x, y, maxDistance) {
                            if (maxDistance === void 0) {
                                maxDistance = 0;
                            }
                            x = +x;
                            y = +y;
                            maxDistance = +maxDistance;
                            release || notImplemented('public flash.text.TextSnapshot::hitTestTextNearPos');
                            return;
                        };
                        TextSnapshot.prototype.setSelectColor = function (hexColor) {
                            if (hexColor === void 0) {
                                hexColor = 16776960;
                            }
                            hexColor = hexColor >>> 0;
                            release || notImplemented('public flash.text.TextSnapshot::setSelectColor');
                            return;
                        };
                        TextSnapshot.prototype.setSelected = function (beginIndex, endIndex, select) {
                            beginIndex = beginIndex | 0;
                            endIndex = endIndex | 0;
                            select = !!select;
                            release || notImplemented('public flash.text.TextSnapshot::setSelected');
                            return;
                        };
                        // Called whenever the class is initialized.
                        TextSnapshot.classInitializer = null;
                        return TextSnapshot;
                    }(AS.ASObject);
                    text.TextSnapshot = TextSnapshot;
                }(text = flash.text || (flash.text = {})));
                var trace;
                (function (trace) {
                    var notImplemented = Shumway.Debug.notImplemented;
                    var Trace = function (_super) {
                        __extends(Trace, _super);
                        function Trace() {
                            _super.call(this);
                        }
                        // AS -> JS Bindings
                        Trace.setLevel = function (l, target) {
                            if (target === void 0) {
                                target = 2;
                            }
                            l = l | 0;
                            target = target | 0;
                            release || notImplemented('public flash.trace.Trace::static setLevel');
                            return;
                        };
                        Trace.getLevel = function (target) {
                            if (target === void 0) {
                                target = 2;
                            }
                            target = target | 0;
                            release || notImplemented('public flash.trace.Trace::static getLevel');
                            return;
                        };
                        Trace.setListener = function (f) {
                            f = f;
                            release || notImplemented('public flash.trace.Trace::static setListener');
                            return;
                        };
                        Trace.getListener = function () {
                            release || notImplemented('public flash.trace.Trace::static getListener');
                            return;
                        };
                        // Called whenever the class is initialized.
                        Trace.classInitializer = null;
                        // List of static symbols to link.
                        Trace.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Trace.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        Trace.OFF = undefined;
                        Trace.METHODS = 1;
                        Trace.METHODS_WITH_ARGS = 2;
                        Trace.METHODS_AND_LINES = 3;
                        Trace.METHODS_AND_LINES_WITH_ARGS = 4;
                        Trace.FILE = 1;
                        Trace.LISTENER = 2;
                        return Trace;
                    }(AS.ASObject);
                    trace.Trace = Trace;
                }(trace = flash.trace || (flash.trace = {})));
                var ui;
                (function (ui) {
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var ContextMenu = function (_super) {
                        __extends(ContextMenu, _super);
                        function ContextMenu() {
                            _super.call(this);
                            this._builtInItems = new this.sec.flash.ui.ContextMenuBuiltInItems();
                            this._customItems = [];
                        }
                        Object.defineProperty(ContextMenu, 'isSupported', {
                            get: function () {
                                somewhatImplemented('ContextMenu::isSupported');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, 'builtInItems', {
                            get: function () {
                                // TODO: Should clone here probably.
                                release || somewhatImplemented('public flash.ui.ContextMenu::get builtInItems');
                                return this._builtInItems;
                            },
                            set: function (value) {
                                // TODO: Should clone here probably.
                                value = value;
                                release || somewhatImplemented('public flash.ui.ContextMenu::set builtInItems');
                                this._builtInItems = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, 'customItems', {
                            get: function () {
                                // TODO: Should clone here probably.
                                release || somewhatImplemented('public flash.ui.ContextMenu::get customItems');
                                return this.sec.createArrayUnsafe(this._customItems);
                            },
                            set: function (value) {
                                // TODO: Should clone here probably.
                                value = value;
                                release || somewhatImplemented('public flash.ui.ContextMenu::set customItems');
                                this._customItems = value.value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, 'link', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.ContextMenu::get link');
                                return this._link;
                            },
                            set: function (value) {
                                value = value;
                                release || somewhatImplemented('public flash.ui.ContextMenu::set link');
                                this._link = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, 'clipboardMenu', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.ContextMenu::get clipboardMenu');
                                return this._clipboardMenu;
                            },
                            set: function (value) {
                                value = !!value;
                                release || somewhatImplemented('public flash.ui.ContextMenu::set clipboardMenu');
                                this._clipboardMenu = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenu.prototype, 'clipboardItems', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.ContextMenu::get clipboardItems');
                                return this._clipboardItems;
                            },
                            set: function (value) {
                                value = value;
                                release || somewhatImplemented('public flash.ui.ContextMenu::set clipboardItems');
                                this._clipboardItems = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ContextMenu.prototype.hideBuiltInItems = function () {
                            var items = this.builtInItems;
                            if (!items) {
                                return;
                            }
                            items.save = false;
                            items.zoom = false;
                            items.quality = false;
                            items.play = false;
                            items.loop = false;
                            items.rewind = false;
                            items.forwardAndBack = false;
                            items.print = false;
                        };
                        ContextMenu.prototype.clone = function () {
                            var result = new this.sec.flash.ui.ContextMenu();
                            result._builtInItems = this._builtInItems.clone();
                            this.cloneLinkAndClipboardProperties(result);
                            var customItems = this._customItems;
                            for (var i = 0; i < customItems.length; i++) {
                                result._customItems.push(customItems[i].clone());
                            }
                            return result;
                        };
                        ContextMenu.prototype.cloneLinkAndClipboardProperties = function (c) {
                            c = c;
                            release || somewhatImplemented('public flash.ui.ContextMenu::cloneLinkAndClipboardProperties');
                            return;
                        };
                        ContextMenu.classInitializer = null;
                        return ContextMenu;
                    }(flash.display.NativeMenu);
                    ui.ContextMenu = ContextMenu;
                    var ContextMenuBuiltInItems = function (_super) {
                        __extends(ContextMenuBuiltInItems, _super);
                        function ContextMenuBuiltInItems() {
                            _super.call(this);
                            this._save = true;
                            this._zoom = true;
                            this._quality = true;
                            this._play = true;
                            this._loop = true;
                            this._rewind = true;
                            this._forwardAndBack = true;
                            this._print = true;
                        }
                        Object.defineProperty(ContextMenuBuiltInItems.prototype, 'save', {
                            get: function () {
                                return this._save;
                            },
                            set: function (val) {
                                this._save = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuBuiltInItems.prototype, 'zoom', {
                            get: function () {
                                return this._zoom;
                            },
                            set: function (val) {
                                this._zoom = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuBuiltInItems.prototype, 'quality', {
                            get: function () {
                                return this._quality;
                            },
                            set: function (val) {
                                this._quality = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuBuiltInItems.prototype, 'play', {
                            get: function () {
                                return this._play;
                            },
                            set: function (val) {
                                this._play = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuBuiltInItems.prototype, 'loop', {
                            get: function () {
                                return this._loop;
                            },
                            set: function (val) {
                                this._loop = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuBuiltInItems.prototype, 'rewind', {
                            get: function () {
                                return this._rewind;
                            },
                            set: function (val) {
                                this._rewind = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuBuiltInItems.prototype, 'forwardAndBack', {
                            get: function () {
                                return this._forwardAndBack;
                            },
                            set: function (val) {
                                this._forwardAndBack = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuBuiltInItems.prototype, 'print', {
                            get: function () {
                                return this._print;
                            },
                            set: function (val) {
                                this._print = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ContextMenuBuiltInItems.prototype.clone = function () {
                            var items = new this.sec.flash.ui.ContextMenuBuiltInItems();
                            items._save = this._save;
                            items._zoom = this._zoom;
                            items._quality = this._quality;
                            items._play = this._play;
                            items._loop = this._loop;
                            items._rewind = this._rewind;
                            items._forwardAndBack = this._forwardAndBack;
                            items._print = this._print;
                            return items;
                        };
                        ContextMenuBuiltInItems.classInitializer = null;
                        return ContextMenuBuiltInItems;
                    }(AS.ASObject);
                    ui.ContextMenuBuiltInItems = ContextMenuBuiltInItems;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var ContextMenuClipboardItems = function (_super) {
                        __extends(ContextMenuClipboardItems, _super);
                        function ContextMenuClipboardItems() {
                            _super.call(this);
                            this._cut = true;
                            this._copy = true;
                            this._paste = true;
                            this._clear = true;
                            this._selectAll = true;
                        }
                        Object.defineProperty(ContextMenuClipboardItems.prototype, 'cut', {
                            get: function () {
                                release || somewhatImplemented('cut');
                                return this._cut;
                            },
                            set: function (val) {
                                release || somewhatImplemented('cut');
                                this._cut = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuClipboardItems.prototype, 'copy', {
                            get: function () {
                                release || somewhatImplemented('copy');
                                return this._copy;
                            },
                            set: function (val) {
                                release || somewhatImplemented('copy');
                                this._copy = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuClipboardItems.prototype, 'paste', {
                            get: function () {
                                release || somewhatImplemented('paste');
                                return this._paste;
                            },
                            set: function (val) {
                                release || somewhatImplemented('paste');
                                this._paste = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuClipboardItems.prototype, 'clear', {
                            get: function () {
                                release || somewhatImplemented('clear');
                                return this._clear;
                            },
                            set: function (val) {
                                release || somewhatImplemented('clear');
                                this._clear = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuClipboardItems.prototype, 'selectAll', {
                            get: function () {
                                release || somewhatImplemented('selectAll');
                                return this._selectAll;
                            },
                            set: function (val) {
                                release || somewhatImplemented('selectAll');
                                this._selectAll = !!val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ContextMenuClipboardItems.prototype.clone = function () {
                            var items = new this.sec.flash.ui.ContextMenuClipboardItems();
                            items._cut = this._cut;
                            items._copy = this._copy;
                            items._paste = this._paste;
                            items._clear = this._clear;
                            items._selectAll = this._selectAll;
                            return items;
                        };
                        ContextMenuClipboardItems.classInitializer = null;
                        ContextMenuClipboardItems.classSymbols = null;
                        // [];
                        ContextMenuClipboardItems.instanceSymbols = null;
                        return ContextMenuClipboardItems;
                    }(AS.ASObject);
                    ui.ContextMenuClipboardItems = ContextMenuClipboardItems;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var ContextMenuItem = function (_super) {
                        __extends(ContextMenuItem, _super);
                        function ContextMenuItem(caption, separatorBefore, enabled, visible) {
                            if (separatorBefore === void 0) {
                                separatorBefore = false;
                            }
                            if (enabled === void 0) {
                                enabled = true;
                            }
                            if (visible === void 0) {
                                visible = true;
                            }
                            _super.call(this);
                            caption = axCoerceString(caption);
                            separatorBefore = !!separatorBefore;
                            enabled = !!enabled;
                            visible = !!visible;
                            this._caption = caption ? caption : '';
                            this._separatorBefore = separatorBefore;
                            this._enabled = enabled;
                            this._visible = visible;
                        }
                        Object.defineProperty(ContextMenuItem.prototype, 'caption', {
                            get: function () {
                                return this._caption;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                this._caption = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuItem.prototype, 'separatorBefore', {
                            get: function () {
                                return this._separatorBefore;
                            },
                            set: function (value) {
                                value = !!value;
                                this._separatorBefore = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ContextMenuItem.prototype, 'visible', {
                            get: function () {
                                return this._visible;
                            },
                            set: function (value) {
                                value = !!value;
                                this._visible = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // Called whenever the class is initialized.
                        ContextMenuItem.classInitializer = null;
                        // List of static symbols to link.
                        ContextMenuItem.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        ContextMenuItem.instanceSymbols = null;
                        // ["clone"];
                        return ContextMenuItem;
                    }(flash.display.NativeMenuItem);
                    ui.ContextMenuItem = ContextMenuItem;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var GameInput = function (_super) {
                        __extends(GameInput, _super);
                        function GameInput() {
                            _super.call(this, undefined);
                        }
                        Object.defineProperty(GameInput.prototype, 'numDevices', {
                            // JS -> AS Bindings
                            // AS -> JS Bindings
                            // static _numDevices: number /*int*/;
                            // static _isSupported: boolean;
                            get: function () {
                                release || somewhatImplemented('public flash.ui.GameInput::get numDevices');
                                return 0;    // return this._numDevices;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInput.prototype, 'isSupported', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.GameInput::get isSupported');
                                return false;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GameInput.getDeviceAt = function (index) {
                            index = index | 0;
                            release || somewhatImplemented('public flash.ui.GameInput::static getDeviceAt');
                            this.sec.throwError('RangeError', AVMX.Errors.ParamRangeError, 'index');
                            return null;
                        };
                        // Called whenever the class is initialized.
                        GameInput.classInitializer = null;
                        // List of static symbols to link.
                        GameInput.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GameInput.instanceSymbols = null;
                        // [];
                        return GameInput;
                    }(flash.events.EventDispatcher);
                    ui.GameInput = GameInput;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var GameInputControl = function (_super) {
                        __extends(GameInputControl, _super);
                        function GameInputControl() {
                            _super.call(this);
                        }
                        Object.defineProperty(GameInputControl.prototype, 'numValues', {
                            // _numValues: number /*int*/;
                            // _index: number /*int*/;
                            // _relative: boolean;
                            // _type: string;
                            // _hand: string;
                            // _finger: string;
                            // _device: flash.ui.GameInputDevice;
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputControl::get numValues');
                                return;    // return this._numValues;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, 'index', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputControl::get index');
                                return;    // return this._index;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, 'relative', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputControl::get relative');
                                return;    // return this._relative;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, 'type', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputControl::get type');
                                return;    // return this._type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, 'hand', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputControl::get hand');
                                return;    // return this._hand;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, 'finger', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputControl::get finger');
                                return;    // return this._finger;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputControl.prototype, 'device', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputControl::get device');
                                return;    // return this._device;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GameInputControl.prototype.getValueAt = function (index) {
                            if (index === void 0) {
                                index = 0;
                            }
                            index = index | 0;
                            release || notImplemented('public flash.ui.GameInputControl::getValueAt');
                            return;
                        };
                        // Called whenever the class is initialized.
                        GameInputControl.classInitializer = null;
                        // List of static symbols to link.
                        GameInputControl.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GameInputControl.instanceSymbols = null;
                        // [];
                        return GameInputControl;
                    }(flash.events.EventDispatcher);
                    ui.GameInputControl = GameInputControl;
                    var GameInputControlType = function (_super) {
                        __extends(GameInputControlType, _super);
                        function GameInputControlType() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        GameInputControlType.classInitializer = null;
                        // List of static symbols to link.
                        GameInputControlType.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GameInputControlType.instanceSymbols = null;
                        // [];
                        GameInputControlType.MOVEMENT = 'movement';
                        GameInputControlType.ROTATION = 'rotation';
                        GameInputControlType.DIRECTION = 'direction';
                        GameInputControlType.ACCELERATION = 'acceleration';
                        GameInputControlType.BUTTON = 'button';
                        GameInputControlType.TRIGGER = 'trigger';
                        return GameInputControlType;
                    }(AS.ASObject);
                    ui.GameInputControlType = GameInputControlType;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var GameInputDevice = function (_super) {
                        __extends(GameInputDevice, _super);
                        function GameInputDevice() {
                            _super.call(this);
                        }
                        Object.defineProperty(GameInputDevice.prototype, 'numControls', {
                            // _numControls: number /*int*/;
                            // _sampleInterval: number /*int*/;
                            // _enabled: boolean;
                            // _id: string;
                            // _name: string;
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputDevice::get numControls');
                                return;    // return this._numControls;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputDevice.prototype, 'sampleInterval', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputDevice::get sampleInterval');
                                return;    // return this._sampleInterval;
                            },
                            set: function (val) {
                                val = val | 0;
                                release || notImplemented('public flash.ui.GameInputDevice::set sampleInterval');
                                return;    // this._sampleInterval = val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputDevice.prototype, 'enabled', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputDevice::get enabled');
                                return;    // return this._enabled;
                            },
                            set: function (val) {
                                val = !!val;
                                release || notImplemented('public flash.ui.GameInputDevice::set enabled');
                                return;    // this._enabled = val;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputDevice.prototype, 'id', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputDevice::get id');
                                return;    // return this._id;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(GameInputDevice.prototype, 'name', {
                            get: function () {
                                release || notImplemented('public flash.ui.GameInputDevice::get name');
                                return;    // return this._name;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        GameInputDevice.prototype.getControlAt = function (i) {
                            i = i | 0;
                            release || notImplemented('public flash.ui.GameInputDevice::getControlAt');
                            return;
                        };
                        GameInputDevice.prototype.startCachingSamples = function (numSamples, controls) {
                            numSamples = numSamples | 0;
                            controls = controls;
                            release || notImplemented('public flash.ui.GameInputDevice::startCachingSamples');
                            return;
                        };
                        GameInputDevice.prototype.stopCachingSamples = function () {
                            release || notImplemented('public flash.ui.GameInputDevice::stopCachingSamples');
                            return;
                        };
                        GameInputDevice.prototype.getCachedSamples = function (data, append) {
                            if (append === void 0) {
                                append = false;
                            }
                            data = data;
                            append = !!append;
                            release || notImplemented('public flash.ui.GameInputDevice::getCachedSamples');
                            return;
                        };
                        // Called whenever the class is initialized.
                        GameInputDevice.classInitializer = null;
                        // List of static symbols to link.
                        GameInputDevice.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GameInputDevice.instanceSymbols = null;
                        // [];
                        GameInputDevice.MAX_BUFFER_SIZE = 4800;
                        return GameInputDevice;
                    }(flash.events.EventDispatcher);
                    ui.GameInputDevice = GameInputDevice;
                    var GameInputFinger = function (_super) {
                        __extends(GameInputFinger, _super);
                        function GameInputFinger() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        GameInputFinger.classInitializer = null;
                        // List of static symbols to link.
                        GameInputFinger.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GameInputFinger.instanceSymbols = null;
                        // [];
                        GameInputFinger.THUMB = 'thumb';
                        GameInputFinger.INDEX = 'index';
                        GameInputFinger.MIDDLE = 'middle';
                        GameInputFinger.UNKNOWN = 'unknown';
                        return GameInputFinger;
                    }(AS.ASObject);
                    ui.GameInputFinger = GameInputFinger;
                    var GameInputHand = function (_super) {
                        __extends(GameInputHand, _super);
                        function GameInputHand() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        GameInputHand.classInitializer = null;
                        // List of static symbols to link.
                        GameInputHand.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        GameInputHand.instanceSymbols = null;
                        // [];
                        GameInputHand.RIGHT = 'right';
                        GameInputHand.LEFT = 'left';
                        GameInputHand.UNKNOWN = 'unknown';
                        return GameInputHand;
                    }(AS.ASObject);
                    ui.GameInputHand = GameInputHand;
                    var notImplemented = Shumway.Debug.notImplemented;
                    /**
                     * Dispatches AS3 keyboard events to the focus event dispatcher.
                     */
                    var KeyboardEventDispatcher = function () {
                        function KeyboardEventDispatcher() {
                            this._lastKeyCode = 0;
                            this._captureKeyPress = false;
                            this._charCodeMap = [];
                        }
                        /**
                         * Converts DOM keyboard event data into AS3 keyboard events.
                         */
                        KeyboardEventDispatcher.prototype.dispatchKeyboardEvent = function (event) {
                            var keyCode = event.keyCode;
                            if (event.type === 'keydown') {
                                this._lastKeyCode = keyCode;
                                // Trying to capture charCode for ASCII keys.
                                this._captureKeyPress = keyCode === 8 || keyCode === 9 || keyCode === 13 || keyCode === 32 || keyCode >= 48 && keyCode <= 90 || keyCode > 145;
                                if (this._captureKeyPress) {
                                    return;    // skipping keydown, waiting for keypress
                                }
                                this._charCodeMap[keyCode] = 0;
                            } else if (event.type === 'keypress') {
                                if (this._captureKeyPress) {
                                    keyCode = this._lastKeyCode;
                                    this._charCodeMap[keyCode] = event.charCode;
                                } else {
                                    return;
                                }
                            }
                            if (this.target) {
                                var isKeyUp = event.type === 'keyup';
                                this.target.dispatchEvent(new this.target.sec.flash.events.KeyboardEvent(isKeyUp ? 'keyUp' : 'keyDown', true, false, isKeyUp ? this._charCodeMap[keyCode] : event.charCode, isKeyUp ? event.keyCode : this._lastKeyCode, event.location, event.ctrlKey, event.altKey, event.shiftKey));
                            }
                        };
                        return KeyboardEventDispatcher;
                    }();
                    ui.KeyboardEventDispatcher = KeyboardEventDispatcher;
                    var Keyboard = function (_super) {
                        __extends(Keyboard, _super);
                        function Keyboard() {
                            _super.call(this);
                        }
                        Object.defineProperty(Keyboard, 'capsLock', {
                            // JS -> AS Bindings
                            //static KEYNAME_UPARROW: string = "Up";
                            //static KEYNAME_DOWNARROW: string = "Down";
                            //static KEYNAME_LEFTARROW: string = "Left";
                            //static KEYNAME_RIGHTARROW: string = "Right";
                            //static KEYNAME_F1: string = "F1";
                            //static KEYNAME_F2: string = "F2";
                            //static KEYNAME_F3: string = "F3";
                            //static KEYNAME_F4: string = "F4";
                            //static KEYNAME_F5: string = "F5";
                            //static KEYNAME_F6: string = "F6";
                            //static KEYNAME_F7: string = "F7";
                            //static KEYNAME_F8: string = "F8";
                            //static KEYNAME_F9: string = "F9";
                            //static KEYNAME_F10: string = "F10";
                            //static KEYNAME_F11: string = "F11";
                            //static KEYNAME_F12: string = "F12";
                            //static KEYNAME_F13: string = "F13";
                            //static KEYNAME_F14: string = "F14";
                            //static KEYNAME_F15: string = "F15";
                            //static KEYNAME_F16: string = "F16";
                            //static KEYNAME_F17: string = "F17";
                            //static KEYNAME_F18: string = "F18";
                            //static KEYNAME_F19: string = "F19";
                            //static KEYNAME_F20: string = "F20";
                            //static KEYNAME_F21: string = "F21";
                            //static KEYNAME_F22: string = "F22";
                            //static KEYNAME_F23: string = "F23";
                            //static KEYNAME_F24: string = "F24";
                            //static KEYNAME_F25: string = "F25";
                            //static KEYNAME_F26: string = "F26";
                            //static KEYNAME_F27: string = "F27";
                            //static KEYNAME_F28: string = "F28";
                            //static KEYNAME_F29: string = "F29";
                            //static KEYNAME_F30: string = "F30";
                            //static KEYNAME_F31: string = "F31";
                            //static KEYNAME_F32: string = "F32";
                            //static KEYNAME_F33: string = "F33";
                            //static KEYNAME_F34: string = "F34";
                            //static KEYNAME_F35: string = "F35";
                            //static KEYNAME_INSERT: string = "Insert";
                            //static KEYNAME_DELETE: string = "Delete";
                            //static KEYNAME_HOME: string = "Home";
                            //static KEYNAME_BEGIN: string = "Begin";
                            //static KEYNAME_END: string = "End";
                            //static KEYNAME_PAGEUP: string = "PgUp";
                            //static KEYNAME_PAGEDOWN: string = "PgDn";
                            //static KEYNAME_PRINTSCREEN: string = "PrntScrn";
                            //static KEYNAME_SCROLLLOCK: string = "ScrlLck";
                            //static KEYNAME_PAUSE: string = "Pause";
                            //static KEYNAME_SYSREQ: string = "SysReq";
                            //static KEYNAME_BREAK: string = "Break";
                            //static KEYNAME_RESET: string = "Reset";
                            //static KEYNAME_STOP: string = "Stop";
                            //static KEYNAME_MENU: string = "Menu";
                            //static KEYNAME_USER: string = "User";
                            //static KEYNAME_SYSTEM: string = "Sys";
                            //static KEYNAME_PRINT: string = "Print";
                            //static KEYNAME_CLEARLINE: string = "ClrLn";
                            //static KEYNAME_CLEARDISPLAY: string = "ClrDsp";
                            //static KEYNAME_INSERTLINE: string = "InsLn";
                            //static KEYNAME_DELETELINE: string = "DelLn";
                            //static KEYNAME_INSERTCHAR: string = "InsChr";
                            //static KEYNAME_DELETECHAR: string = "DelChr";
                            //static KEYNAME_PREV: string = "Prev";
                            //static KEYNAME_NEXT: string = "Next";
                            //static KEYNAME_SELECT: string = "Select";
                            //static KEYNAME_EXECUTE: string = "Exec";
                            //static KEYNAME_UNDO: string = "Undo";
                            //static KEYNAME_REDO: string = "Redo";
                            //static KEYNAME_FIND: string = "Find";
                            //static KEYNAME_HELP: string = "Help";
                            //static KEYNAME_MODESWITCH: string = "ModeSw";
                            //static STRING_UPARROW: string = "";
                            //static STRING_DOWNARROW: string = "";
                            //static STRING_LEFTARROW: string = "";
                            //static STRING_RIGHTARROW: string = "";
                            //static STRING_F1: string = "";
                            //static STRING_F2: string = "";
                            //static STRING_F3: string = "";
                            //static STRING_F4: string = "";
                            //static STRING_F5: string = "";
                            //static STRING_F6: string = "";
                            //static STRING_F7: string = "";
                            //static STRING_F8: string = "";
                            //static STRING_F9: string = "";
                            //static STRING_F10: string = "";
                            //static STRING_F11: string = "";
                            //static STRING_F12: string = "";
                            //static STRING_F13: string = "";
                            //static STRING_F14: string = "";
                            //static STRING_F15: string = "";
                            //static STRING_F16: string = "";
                            //static STRING_F17: string = "";
                            //static STRING_F18: string = "";
                            //static STRING_F19: string = "";
                            //static STRING_F20: string = "";
                            //static STRING_F21: string = "";
                            //static STRING_F22: string = "";
                            //static STRING_F23: string = "";
                            //static STRING_F24: string = "";
                            //static STRING_F25: string = "";
                            //static STRING_F26: string = "";
                            //static STRING_F27: string = "";
                            //static STRING_F28: string = "";
                            //static STRING_F29: string = "";
                            //static STRING_F30: string = "";
                            //static STRING_F31: string = "";
                            //static STRING_F32: string = "";
                            //static STRING_F33: string = "";
                            //static STRING_F34: string = "";
                            //static STRING_F35: string = "";
                            //static STRING_INSERT: string = "";
                            //static STRING_DELETE: string = "";
                            //static STRING_HOME: string = "";
                            //static STRING_BEGIN: string = "";
                            //static STRING_END: string = "";
                            //static STRING_PAGEUP: string = "";
                            //static STRING_PAGEDOWN: string = "";
                            //static STRING_PRINTSCREEN: string = "";
                            //static STRING_SCROLLLOCK: string = "";
                            //static STRING_PAUSE: string = "";
                            //static STRING_SYSREQ: string = "";
                            //static STRING_BREAK: string = "";
                            //static STRING_RESET: string = "";
                            //static STRING_STOP: string = "";
                            //static STRING_MENU: string = "";
                            //static STRING_USER: string = "";
                            //static STRING_SYSTEM: string = "";
                            //static STRING_PRINT: string = "";
                            //static STRING_CLEARLINE: string = "";
                            //static STRING_CLEARDISPLAY: string = "";
                            //static STRING_INSERTLINE: string = "";
                            //static STRING_DELETELINE: string = "";
                            //static STRING_INSERTCHAR: string = "";
                            //static STRING_DELETECHAR: string = "";
                            //static STRING_PREV: string = "";
                            //static STRING_NEXT: string = "";
                            //static STRING_SELECT: string = "";
                            //static STRING_EXECUTE: string = "";
                            //static STRING_UNDO: string = "";
                            //static STRING_REDO: string = "";
                            //static STRING_FIND: string = "";
                            //static STRING_HELP: string = "";
                            //static STRING_MODESWITCH: string = "";
                            //static CharCodeStrings: any [] = undefined;
                            //static NUMBER_0: number /*uint*/ = 48;
                            //static NUMBER_1: number /*uint*/ = 49;
                            //static NUMBER_2: number /*uint*/ = 50;
                            //static NUMBER_3: number /*uint*/ = 51;
                            //static NUMBER_4: number /*uint*/ = 52;
                            //static NUMBER_5: number /*uint*/ = 53;
                            //static NUMBER_6: number /*uint*/ = 54;
                            //static NUMBER_7: number /*uint*/ = 55;
                            //static NUMBER_8: number /*uint*/ = 56;
                            //static NUMBER_9: number /*uint*/ = 57;
                            //static A: number /*uint*/ = 65;
                            //static B: number /*uint*/ = 66;
                            //static C: number /*uint*/ = 67;
                            //static D: number /*uint*/ = 68;
                            //static E: number /*uint*/ = 69;
                            //static F: number /*uint*/ = 70;
                            //static G: number /*uint*/ = 71;
                            //static H: number /*uint*/ = 72;
                            //static I: number /*uint*/ = 73;
                            //static J: number /*uint*/ = 74;
                            //static K: number /*uint*/ = 75;
                            //static L: number /*uint*/ = 76;
                            //static M: number /*uint*/ = 77;
                            //static N: number /*uint*/ = 78;
                            //static O: number /*uint*/ = 79;
                            //static P: number /*uint*/ = 80;
                            //static Q: number /*uint*/ = 81;
                            //static R: number /*uint*/ = 82;
                            //static S: number /*uint*/ = 83;
                            //static T: number /*uint*/ = 84;
                            //static U: number /*uint*/ = 85;
                            //static V: number /*uint*/ = 86;
                            //static W: number /*uint*/ = 87;
                            //static X: number /*uint*/ = 88;
                            //static Y: number /*uint*/ = 89;
                            //static Z: number /*uint*/ = 90;
                            //static SEMICOLON: number /*uint*/ = 186;
                            //static EQUAL: number /*uint*/ = 187;
                            //static COMMA: number /*uint*/ = 188;
                            //static MINUS: number /*uint*/ = 189;
                            //static PERIOD: number /*uint*/ = 190;
                            //static SLASH: number /*uint*/ = 191;
                            //static BACKQUOTE: number /*uint*/ = 192;
                            //static LEFTBRACKET: number /*uint*/ = 219;
                            //static BACKSLASH: number /*uint*/ = 220;
                            //static RIGHTBRACKET: number /*uint*/ = 221;
                            //static QUOTE: number /*uint*/ = 222;
                            //static ALTERNATE: number /*uint*/ = 18;
                            //static BACKSPACE: number /*uint*/ = 8;
                            //static CAPS_LOCK: number /*uint*/ = 20;
                            //static COMMAND: number /*uint*/ = 15;
                            //static CONTROL: number /*uint*/ = 17;
                            //static DELETE: number /*uint*/ = 46;
                            //static DOWN: number /*uint*/ = 40;
                            //static END: number /*uint*/ = 35;
                            //static ENTER: number /*uint*/ = 13;
                            //static ESCAPE: number /*uint*/ = 27;
                            //static F1: number /*uint*/ = 112;
                            //static F2: number /*uint*/ = 113;
                            //static F3: number /*uint*/ = 114;
                            //static F4: number /*uint*/ = 115;
                            //static F5: number /*uint*/ = 116;
                            //static F6: number /*uint*/ = 117;
                            //static F7: number /*uint*/ = 118;
                            //static F8: number /*uint*/ = 119;
                            //static F9: number /*uint*/ = 120;
                            //static F10: number /*uint*/ = 121;
                            //static F11: number /*uint*/ = 122;
                            //static F12: number /*uint*/ = 123;
                            //static F13: number /*uint*/ = 124;
                            //static F14: number /*uint*/ = 125;
                            //static F15: number /*uint*/ = 126;
                            //static HOME: number /*uint*/ = 36;
                            //static INSERT: number /*uint*/ = 45;
                            //static LEFT: number /*uint*/ = 37;
                            //static NUMPAD: number /*uint*/ = 21;
                            //static NUMPAD_0: number /*uint*/ = 96;
                            //static NUMPAD_1: number /*uint*/ = 97;
                            //static NUMPAD_2: number /*uint*/ = 98;
                            //static NUMPAD_3: number /*uint*/ = 99;
                            //static NUMPAD_4: number /*uint*/ = 100;
                            //static NUMPAD_5: number /*uint*/ = 101;
                            //static NUMPAD_6: number /*uint*/ = 102;
                            //static NUMPAD_7: number /*uint*/ = 103;
                            //static NUMPAD_8: number /*uint*/ = 104;
                            //static NUMPAD_9: number /*uint*/ = 105;
                            //static NUMPAD_ADD: number /*uint*/ = 107;
                            //static NUMPAD_DECIMAL: number /*uint*/ = 110;
                            //static NUMPAD_DIVIDE: number /*uint*/ = 111;
                            //static NUMPAD_ENTER: number /*uint*/ = 108;
                            //static NUMPAD_MULTIPLY: number /*uint*/ = 106;
                            //static NUMPAD_SUBTRACT: number /*uint*/ = 109;
                            //static PAGE_DOWN: number /*uint*/ = 34;
                            //static PAGE_UP: number /*uint*/ = 33;
                            //static RIGHT: number /*uint*/ = 39;
                            //static SHIFT: number /*uint*/ = 16;
                            //static SPACE: number /*uint*/ = 32;
                            //static TAB: number /*uint*/ = 9;
                            //static UP: number /*uint*/ = 38;
                            //static RED: number /*uint*/ = 16777216;
                            //static GREEN: number /*uint*/ = 16777217;
                            //static YELLOW: number /*uint*/ = 16777218;
                            //static BLUE: number /*uint*/ = 16777219;
                            //static CHANNEL_UP: number /*uint*/ = 16777220;
                            //static CHANNEL_DOWN: number /*uint*/ = 16777221;
                            //static RECORD: number /*uint*/ = 16777222;
                            //static PLAY: number /*uint*/ = 16777223;
                            //static PAUSE: number /*uint*/ = 16777224;
                            //static STOP: number /*uint*/ = 16777225;
                            //static FAST_FORWARD: number /*uint*/ = 16777226;
                            //static REWIND: number /*uint*/ = 16777227;
                            //static SKIP_FORWARD: number /*uint*/ = 16777228;
                            //static SKIP_BACKWARD: number /*uint*/ = 16777229;
                            //static NEXT: number /*uint*/ = 16777230;
                            //static PREVIOUS: number /*uint*/ = 16777231;
                            //static LIVE: number /*uint*/ = 16777232;
                            //static LAST: number /*uint*/ = 16777233;
                            //static MENU: number /*uint*/ = 16777234;
                            //static INFO: number /*uint*/ = 16777235;
                            //static GUIDE: number /*uint*/ = 16777236;
                            //static EXIT: number /*uint*/ = 16777237;
                            //static BACK: number /*uint*/ = 16777238;
                            //static AUDIO: number /*uint*/ = 16777239;
                            //static SUBTITLE: number /*uint*/ = 16777240;
                            //static DVR: number /*uint*/ = 16777241;
                            //static VOD: number /*uint*/ = 16777242;
                            //static INPUT: number /*uint*/ = 16777243;
                            //static SETUP: number /*uint*/ = 16777244;
                            //static HELP: number /*uint*/ = 16777245;
                            //static MASTER_SHELL: number /*uint*/ = 16777246;
                            //static SEARCH: number /*uint*/ = 16777247;
                            // AS -> JS Bindings
                            // static _capsLock: boolean;
                            // static _numLock: boolean;
                            // static _hasVirtualKeyboard: boolean;
                            // static _physicalKeyboardType: string;
                            get: function () {
                                release || notImplemented('public flash.ui.Keyboard::get capsLock');
                                return;    // return this._capsLock;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Keyboard, 'numLock', {
                            get: function () {
                                release || notImplemented('public flash.ui.Keyboard::get numLock');
                                return;    // return this._numLock;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Keyboard, 'hasVirtualKeyboard', {
                            get: function () {
                                release || notImplemented('public flash.ui.Keyboard::get hasVirtualKeyboard');
                                return;    // return this._hasVirtualKeyboard;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Keyboard, 'physicalKeyboardType', {
                            get: function () {
                                release || notImplemented('public flash.ui.Keyboard::get physicalKeyboardType');
                                return;    // return this._physicalKeyboardType;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Keyboard.isAccessible = function () {
                            release || notImplemented('public flash.ui.Keyboard::static isAccessible');
                            return;
                        };
                        // Called whenever the class is initialized.
                        Keyboard.classInitializer = null;
                        // List of static symbols to link.
                        Keyboard.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Keyboard.instanceSymbols = null;
                        // [];
                        return Keyboard;
                    }(AS.ASObject);
                    ui.Keyboard = Keyboard;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var assert = Shumway.Debug.assert;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var events = flash.events;
                    /**
                     * Dispatches AS3 mouse events.
                     */
                    var MouseEventDispatcher = function () {
                        function MouseEventDispatcher() {
                            this.stage = null;
                            this.currentTarget = null;
                        }
                        /**
                         * Finds the interactive object on which the event is dispatched.
                         */
                        MouseEventDispatcher.prototype._findTarget = function (point, testingType) {
                            var globalX = point.x * 20 | 0;
                            var globalY = point.y * 20 | 0;
                            var objects = [];
                            this.stage._containsGlobalPoint(globalX, globalY, testingType, objects);
                            release || assert(objects.length < 2);
                            if (objects.length) {
                                return objects[0];
                            }
                            return objects.length ? objects[0] : null;
                        };
                        /**
                         * Converts DOM mouse event data into AS3 mouse events.
                         */
                        MouseEventDispatcher.prototype._dispatchMouseEvent = function (target, type, data, relatedObject) {
                            if (relatedObject === void 0) {
                                relatedObject = null;
                            }
                            var localPoint = target.globalToLocal(data.point);
                            var event = new this.stage.sec.flash.events.MouseEvent(type, type !== events.MouseEvent.ROLL_OVER && type !== events.MouseEvent.ROLL_OUT && type !== events.MouseEvent.MOUSE_LEAVE, false, localPoint.x, localPoint.y, relatedObject, data.ctrlKey, data.altKey, data.shiftKey, !!data.buttons);
                            target.dispatchEvent(event);
                        };
                        /**
                         * Handles the mouse event and returns the target on which the event was dispatched.
                         */
                        MouseEventDispatcher.prototype.handleMouseEvent = function (data) {
                            var stage = this.stage;
                            if (!stage) {
                                return stage;
                            }
                            var globalPoint = data.point;
                            var mouseClass = this.stage.sec.flash.ui.Mouse.axClass;
                            mouseClass.updateCurrentPosition(globalPoint);
                            var currentTarget = this.currentTarget;
                            var target = null;
                            var type = flash.events.MouseEvent.typeFromDOMType(data.type);
                            if (globalPoint.x >= 0 && globalPoint.x < stage.stageWidth && globalPoint.y >= 0 && globalPoint.y < stage.stageHeight) {
                                target = this._findTarget(globalPoint, 3    /* Mouse */) || this.stage;
                            } else {
                                if (!currentTarget) {
                                    return stage;
                                }
                                this._dispatchMouseEvent(stage, events.MouseEvent.MOUSE_LEAVE, data);
                                if (type !== events.MouseEvent.MOUSE_MOVE) {
                                    return stage;
                                }
                            }
                            if (mouseClass.draggableObject) {
                                var dropTarget = this._findTarget(globalPoint, 5    /* Drop */);
                                mouseClass.draggableObject._updateDragState(dropTarget);
                            }
                            switch (type) {
                            case events.MouseEvent.MOUSE_DOWN:
                                if (data.buttons & 1    /* Left */) {
                                    data.buttons = 1    /* Left */;
                                } else if (data.buttons & 2    /* Middle */) {
                                    type = events.MouseEvent.MIDDLE_MOUSE_DOWN;
                                    data.buttons = 2    /* Middle */;
                                } else if (data.buttons & 4    /* Right */) {
                                    type = events.MouseEvent.RIGHT_MOUSE_DOWN;
                                    data.buttons = 4    /* Right */;
                                }
                                target._mouseDown = true;
                                break;
                            case events.MouseEvent.MOUSE_UP:
                                if (data.buttons & 1    /* Left */) {
                                    data.buttons = 1    /* Left */;
                                } else if (data.buttons & 2    /* Middle */) {
                                    type = events.MouseEvent.MIDDLE_MOUSE_UP;
                                    data.buttons = 2    /* Middle */;
                                } else if (data.buttons & 4    /* Right */) {
                                    type = events.MouseEvent.RIGHT_MOUSE_UP;
                                    data.buttons = 4    /* Right */;
                                }
                                target._mouseDown = false;
                                break;
                            case events.MouseEvent.CLICK:
                                if (!(data.buttons & 1    /* Left */)) {
                                    if (data.buttons & 2    /* Middle */) {
                                        type = events.MouseEvent.MIDDLE_CLICK;
                                    } else if (data.buttons & 4    /* Right */) {
                                        type = events.MouseEvent.RIGHT_CLICK;
                                    }
                                }
                                data.buttons = 0;
                                break;
                            case events.MouseEvent.DOUBLE_CLICK:
                                if (!target.doubleClickEnabled) {
                                    return;
                                }
                                data.buttons = 0;
                                break;
                            case events.MouseEvent.MOUSE_MOVE:
                                this.currentTarget = target;
                                data.buttons &= 1    /* Left */;
                                if (target === currentTarget) {
                                    break;
                                }
                                var commonAncestor = target ? target.findNearestCommonAncestor(currentTarget) : stage;
                                if (currentTarget && currentTarget !== stage) {
                                    currentTarget._mouseOver = false;
                                    // TODO: Support track as menu.
                                    currentTarget._mouseDown = false;
                                    this._dispatchMouseEvent(currentTarget, events.MouseEvent.MOUSE_OUT, data, target);
                                    var nodeLeft = currentTarget;
                                    while (nodeLeft && nodeLeft !== commonAncestor) {
                                        this._dispatchMouseEvent(nodeLeft, events.MouseEvent.ROLL_OUT, data, target);
                                        nodeLeft = nodeLeft.parent;
                                    }
                                }
                                if (!target) {
                                    return stage;
                                }
                                if (target === stage) {
                                    break;
                                }
                                var nodeEntered = target;
                                while (nodeEntered && nodeEntered !== commonAncestor) {
                                    this._dispatchMouseEvent(nodeEntered, events.MouseEvent.ROLL_OVER, data, currentTarget);
                                    nodeEntered = nodeEntered.parent;
                                }
                                target._mouseOver = true;
                                this._dispatchMouseEvent(target, events.MouseEvent.MOUSE_OVER, data, currentTarget);
                                return target;
                            }
                            // TODO: handle MOUSE_WHEEL and MOUSE_RELEASE_OUTSIDE
                            this._dispatchMouseEvent(target, type, data);
                            return target;
                        };
                        return MouseEventDispatcher;
                    }();
                    ui.MouseEventDispatcher = MouseEventDispatcher;
                    var Mouse = function (_super) {
                        __extends(Mouse, _super);
                        function Mouse() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        Mouse.classInitializer = function () {
                            this._currentPosition = new this.sec.flash.geom.Point();
                            this._cursor = ui.MouseCursor.AUTO;
                            this.draggableObject = null;
                        };
                        Object.defineProperty(Mouse, 'supportsCursor', {
                            //static _supportsNativeCursor: boolean;
                            get: function () {
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Mouse, 'cursor', {
                            get: function () {
                                return this._cursor;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                if (ui.MouseCursor.toNumber(value) < 0) {
                                    this.sec.throwError('ArgumentError', AVMX.Errors.InvalidParamError, 'cursor');
                                }
                                this._cursor = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Mouse, 'supportsNativeCursor', {
                            get: function () {
                                return true;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Mouse.hide = function () {
                            release || somewhatImplemented('public flash.ui.Mouse::static hide');
                            return;
                        };
                        Mouse.show = function () {
                            release || somewhatImplemented('public flash.ui.Mouse::static show');
                            return;
                        };
                        Mouse.registerCursor = function (name, cursor) {
                            name = axCoerceString(name);
                            cursor = cursor;
                            release || notImplemented('public flash.ui.Mouse::static registerCursor');
                            return;
                        };
                        Mouse.unregisterCursor = function (name) {
                            name = axCoerceString(name);
                            release || notImplemented('public flash.ui.Mouse::static unregisterCursor');
                            return;
                        };
                        /**
                         * Remembers the current mouse position.
                         */
                        Mouse.updateCurrentPosition = function (value) {
                            this._currentPosition.copyFrom(value);
                        };
                        return Mouse;
                    }(AS.ASObject);
                    ui.Mouse = Mouse;
                    var MouseCursor = function (_super) {
                        __extends(MouseCursor, _super);
                        function MouseCursor() {
                            _super.call(this);
                        }
                        MouseCursor.fromNumber = function (n) {
                            switch (n) {
                            case 0:
                                return MouseCursor.AUTO;
                            case 1:
                                return MouseCursor.ARROW;
                            case 2:
                                return MouseCursor.BUTTON;
                            case 3:
                                return MouseCursor.HAND;
                            case 4:
                                return MouseCursor.IBEAM;
                            default:
                                return null;
                            }
                        };
                        MouseCursor.toNumber = function (value) {
                            switch (value) {
                            case MouseCursor.AUTO:
                                return 0;
                            case MouseCursor.ARROW:
                                return 1;
                            case MouseCursor.BUTTON:
                                return 2;
                            case MouseCursor.HAND:
                                return 3;
                            case MouseCursor.IBEAM:
                                return 4;
                            default:
                                return -1;
                            }
                        };
                        // Called whenever the class is initialized.
                        MouseCursor.classInitializer = null;
                        // List of static symbols to link.
                        MouseCursor.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        MouseCursor.instanceSymbols = null;
                        // [];
                        // JS -> AS Bindings
                        MouseCursor.AUTO = 'auto';
                        MouseCursor.ARROW = 'arrow';
                        MouseCursor.BUTTON = 'button';
                        MouseCursor.HAND = 'hand';
                        MouseCursor.IBEAM = 'ibeam';
                        return MouseCursor;
                    }(AS.ASObject);
                    ui.MouseCursor = MouseCursor;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var MouseCursorData = function (_super) {
                        __extends(MouseCursorData, _super);
                        function MouseCursorData() {
                            _super.call(this);
                        }
                        Object.defineProperty(MouseCursorData.prototype, 'data', {
                            // _data: ASVector<any>;
                            // _hotSpot: flash.geom.Point;
                            // _frameRate: number;
                            get: function () {
                                release || notImplemented('public flash.ui.MouseCursorData::get data');
                                return;    // return this._data;
                            },
                            set: function (data) {
                                data = data;
                                release || notImplemented('public flash.ui.MouseCursorData::set data');
                                return;    // this._data = data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseCursorData.prototype, 'hotSpot', {
                            get: function () {
                                release || notImplemented('public flash.ui.MouseCursorData::get hotSpot');
                                return;    // return this._hotSpot;
                            },
                            set: function (data) {
                                data = data;
                                release || notImplemented('public flash.ui.MouseCursorData::set hotSpot');
                                return;    // this._hotSpot = data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(MouseCursorData.prototype, 'frameRate', {
                            get: function () {
                                release || notImplemented('public flash.ui.MouseCursorData::get frameRate');
                                return;    // return this._frameRate;
                            },
                            set: function (data) {
                                data = +data;
                                release || notImplemented('public flash.ui.MouseCursorData::set frameRate');
                                return;    // this._frameRate = data;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // Called whenever the class is initialized.
                        MouseCursorData.classInitializer = null;
                        // List of static symbols to link.
                        MouseCursorData.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        MouseCursorData.instanceSymbols = null;
                        // [];
                        return MouseCursorData;
                    }(AS.ASObject);
                    ui.MouseCursorData = MouseCursorData;
                    var somewhatImplemented = Shumway.Debug.somewhatImplemented;
                    var notImplemented = Shumway.Debug.notImplemented;
                    var axCoerceString = Shumway.AVMX.axCoerceString;
                    var Multitouch = function (_super) {
                        __extends(Multitouch, _super);
                        function Multitouch() {
                            _super.call(this);
                        }
                        Object.defineProperty(Multitouch, 'inputMode', {
                            // static _inputMode: string;
                            // static _supportsTouchEvents: boolean;
                            // static _supportsGestureEvents: boolean;
                            // static _supportedGestures: ASVector<any>;
                            // static _maxTouchPoints: number /*int*/;
                            // static _mapTouchToMouse: boolean;
                            get: function () {
                                release || notImplemented('public flash.ui.Multitouch::get inputMode');
                                return;    // return this._inputMode;
                            },
                            set: function (value) {
                                value = axCoerceString(value);
                                release || notImplemented('public flash.ui.Multitouch::set inputMode');
                                return;    // this._inputMode = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch, 'supportsTouchEvents', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.Multitouch::get supportsTouchEvents');
                                return false;    // return this._supportsTouchEvents;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch, 'supportsGestureEvents', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.Multitouch::get supportsGestureEvents');
                                return false;    // return this._supportsGestureEvents;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch, 'supportedGestures', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.Multitouch::get supportedGestures');
                                return null;    // return this._supportedGestures;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch, 'maxTouchPoints', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.Multitouch::get maxTouchPoints');
                                return 0;    // return this._maxTouchPoints;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Multitouch, 'mapTouchToMouse', {
                            get: function () {
                                release || somewhatImplemented('public flash.ui.Multitouch::get mapTouchToMouse');
                                return true;    // return this._mapTouchToMouse;
                            },
                            set: function (value) {
                                value = !!value;
                                release || notImplemented('public flash.ui.Multitouch::set mapTouchToMouse');
                                return;    // this._mapTouchToMouse = value;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        // Called whenever the class is initialized.
                        Multitouch.classInitializer = null;
                        // List of static symbols to link.
                        Multitouch.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Multitouch.instanceSymbols = null;
                        // [];
                        return Multitouch;
                    }(AS.ASObject);
                    ui.Multitouch = Multitouch;
                    var MultitouchInputMode = function (_super) {
                        __extends(MultitouchInputMode, _super);
                        function MultitouchInputMode() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        MultitouchInputMode.classInitializer = null;
                        // List of static symbols to link.
                        MultitouchInputMode.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        MultitouchInputMode.instanceSymbols = null;
                        // [];
                        MultitouchInputMode.NONE = 'none';
                        MultitouchInputMode.GESTURE = 'gesture';
                        MultitouchInputMode.TOUCH_POINT = 'touchPoint';
                        return MultitouchInputMode;
                    }(AS.ASObject);
                    ui.MultitouchInputMode = MultitouchInputMode;
                }(ui = flash.ui || (flash.ui = {})));
                var utils;
                (function (utils) {
                    var Endian = function (_super) {
                        __extends(Endian, _super);
                        function Endian() {
                            _super.call(this);
                        }
                        // Called whenever the class is initialized.
                        Endian.classInitializer = null;
                        // List of static symbols to link.
                        Endian.classSymbols = null;
                        // [];
                        // List of instance symbols to link.
                        Endian.instanceSymbols = null;
                        // [];
                        Endian.BIG_ENDIAN = 'bigEndian';
                        Endian.LITTLE_ENDIAN = 'littleEndian';
                        return Endian;
                    }(AS.ASObject);
                    utils.Endian = Endian;
                    var Timer = function (_super) {
                        __extends(Timer, _super);
                        function Timer(delay, repeatCount) {
                            _super.call(this);
                            this._delay = +delay;
                            this._repeatCount = repeatCount | 0;
                            this._iteration = 0;
                        }
                        Object.defineProperty(Timer.prototype, 'running', {
                            get: function () {
                                return this._running;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Timer.prototype, 'delay', {
                            get: function () {
                                return this._delay;
                            },
                            set: function (value) {
                                value = +value;
                                if (value < 0 || !isFinite(value)) {
                                    this.sec.throwError('RangeError', AVMX.Errors.DelayRangeError);
                                }
                                this._delay = value;
                                if (this._running) {
                                    this.stop();
                                    this.start();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Timer.prototype, 'repeatCount', {
                            get: function () {
                                return this._repeatCount;
                            },
                            set: function (value) {
                                this._repeatCount = value | 0;
                                if (this._repeatCount && this._running && this._iteration >= this._repeatCount) {
                                    this.stop();
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(Timer.prototype, 'currentCount', {
                            get: function () {
                                return this._iteration;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Timer.prototype.reset = function () {
                            if (this._running) {
                                this.stop();
                            }
                            this._iteration = 0;
                        };
                        Timer.prototype.stop = function () {
                            this._running = false;
                            clearInterval(this._interval);
                        };
                        Timer.prototype.start = function () {
                            if (this._running) {
                                return;
                            }
                            this._running = true;
                            this._interval = setInterval(this._tick.bind(this), this._delay);
                        };
                        Timer.prototype._tick = function () {
                            this._iteration++;
                            if (!this._running) {
                                return;
                            }
                            if (flash.utils.Timer.dispatchingEnabled) {
                                AVMX.enterTimeline('Timer.Timer');
                                try {
                                    this.dispatchEvent(new this.sec.flash.events.TimerEvent('timer', true, false));
                                } catch (e) {
                                    Shumway.Debug.warning('caught error under Timer TIMER event: ', e);
                                }
                                AVMX.leaveTimeline();
                            }
                            if (this._repeatCount !== 0 && this._iteration >= this._repeatCount) {
                                this.stop();
                                AVMX.enterTimeline('Timer.TimerComplete');
                                try {
                                    this.dispatchEvent(new this.sec.flash.events.TimerEvent(flash.events.TimerEvent.TIMER_COMPLETE, false, false));
                                } catch (e) {
                                    Shumway.Debug.warning('caught error under Timer COMPLETE event: ', e);
                                }
                                AVMX.leaveTimeline();
                            }
                        };
                        Timer.classInitializer = null;
                        Timer.classSymbols = null;
                        // [];
                        Timer.instanceSymbols = null;
                        /**
                         * This lets you toggle timer event dispatching which is useful when trying to profile other
                         * parts of the system.
                         */
                        Timer.dispatchingEnabled = true;
                        return Timer;
                    }(flash.events.EventDispatcher);
                    utils.Timer = Timer;
                    var SetIntervalTimer = function (_super) {
                        __extends(SetIntervalTimer, _super);
                        function SetIntervalTimer(closure, delay, repeats, rest) {
                            _super.call(this, +delay, !!repeats ? 0 : 1);
                            closure = closure;
                            rest = rest;
                        }
                        SetIntervalTimer.classInitializer = null;
                        return SetIntervalTimer;
                    }(flash.utils.Timer);
                    utils.SetIntervalTimer = SetIntervalTimer;
                }(utils = flash.utils || (flash.utils = {})));
            }(flash = AS.flash || (AS.flash = {})));
        }(AS = AVMX.AS || (AVMX.AS = {})));
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
}(Shumway || (Shumway = {})));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var flashPackage = Shumway.AVMX.AS.flash;
///<reference path='references.ts' />
var Shumway;
(function (Shumway) {
    var AVMX;
    (function (AVMX) {
        var AS;
        (function (AS) {
            function M(name, asClass) {
                AS.registerNativeClass(name, asClass);
            }
            M('flash.display.DisplayObject', AS.flash.display.DisplayObject);
            M('flash.display.InteractiveObject', AS.flash.display.InteractiveObject);
            M('flash.display.DisplayObjectContainer', AS.flash.display.DisplayObjectContainer);
            M('flash.display.Sprite', AS.flash.display.Sprite);
            M('flash.display.MovieClip', AS.flash.display.MovieClip);
            M('flash.display.Shape', AS.flash.display.Shape);
            M('flash.display.Bitmap', AS.flash.display.Bitmap);
            M('flash.display.BitmapData', AS.flash.display.BitmapData);
            M('flash.display.Stage', AS.flash.display.Stage);
            M('flash.display.Loader', AS.flash.display.Loader);
            M('flash.display.LoaderInfo', AS.flash.display.LoaderInfo);
            M('flash.display.Graphics', AS.flash.display.Graphics);
            M('flash.display.SimpleButton', AS.flash.display.SimpleButton);
            M('flash.display.MorphShape', AS.flash.display.MorphShape);
            M('flash.display.NativeMenu', AS.flash.display.NativeMenu);
            M('flash.display.NativeMenuItem', AS.flash.display.NativeMenuItem);
            M('flash.display.FrameLabel', AS.flash.display.FrameLabel);
            M('flash.display.Scene', AS.flash.display.Scene);
            M('flash.display.AVM1Movie', AS.flash.display.AVM1Movie);
            M('flash.display.GradientType', AS.flash.display.GradientType);
            M('flash.display.SpreadMethod', AS.flash.display.SpreadMethod);
            M('flash.display.InterpolationMethod', AS.flash.display.InterpolationMethod);
            M('flash.display.LineScaleMode', AS.flash.display.LineScaleMode);
            M('flash.display.CapsStyle', AS.flash.display.CapsStyle);
            M('flash.display.JointStyle', AS.flash.display.JointStyle);
            M('flash.filters.BevelFilter', AS.flash.filters.BevelFilter);
            M('flash.filters.BitmapFilter', AS.flash.filters.BitmapFilter);
            M('flash.filters.BlurFilter', AS.flash.filters.BlurFilter);
            M('flash.filters.ColorMatrixFilter', AS.flash.filters.ColorMatrixFilter);
            M('flash.filters.ConvolutionFilter', AS.flash.filters.ConvolutionFilter);
            M('flash.filters.DisplacementMapFilter', AS.flash.filters.DisplacementMapFilter);
            M('flash.filters.DropShadowFilter', AS.flash.filters.DropShadowFilter);
            M('flash.filters.GlowFilter', AS.flash.filters.GlowFilter);
            M('flash.filters.GradientBevelFilter', AS.flash.filters.GradientBevelFilter);
            M('flash.filters.GradientGlowFilter', AS.flash.filters.GradientGlowFilter);
            M('flash.geom.Point', AS.flash.geom.Point);
            M('flash.geom.Rectangle', AS.flash.geom.Rectangle);
            M('flash.geom.Matrix', AS.flash.geom.Matrix);
            M('flash.geom.Matrix3D', AS.flash.geom.Matrix3D);
            M('flash.geom.Vector3D', AS.flash.geom.Vector3D);
            M('flash.geom.Transform', AS.flash.geom.Transform);
            M('flash.geom.ColorTransform', AS.flash.geom.ColorTransform);
            M('flash.geom.PerspectiveProjection', AS.flash.geom.PerspectiveProjection);
            M('flash.events.EventDispatcher', AS.flash.events.EventDispatcher);
            M('flash.events.Event', AS.flash.events.Event);
            M('flash.events.ErrorEvent', AS.flash.events.ErrorEvent);
            M('flash.events.IOErrorEvent', AS.flash.events.IOErrorEvent);
            M('flash.events.KeyboardEvent', AS.flash.events.KeyboardEvent);
            M('flash.events.MouseEvent', AS.flash.events.MouseEvent);
            M('flash.events.GestureEvent', AS.flash.events.GestureEvent);
            M('flash.events.TextEvent', AS.flash.events.TextEvent);
            M('flash.events.TimerEvent', AS.flash.events.TimerEvent);
            M('flash.events.ProgressEvent', AS.flash.events.ProgressEvent);
            M('flash.events.StatusEvent', AS.flash.events.StatusEvent);
            M('flash.events.NetStatusEvent', AS.flash.events.NetStatusEvent);
            M('flash.events.HTTPStatusEvent', AS.flash.events.HTTPStatusEvent);
            M('flash.events.AsyncErrorEvent', AS.flash.events.AsyncErrorEvent);
            M('flash.events.UncaughtErrorEvents', AS.flash.events.UncaughtErrorEvents);
            M('flash.external.ExternalInterface', AS.flash.external.ExternalInterface);
            M('flash.ui.ContextMenu', AS.flash.ui.ContextMenu);
            M('flash.ui.ContextMenuItem', AS.flash.ui.ContextMenuItem);
            M('flash.ui.ContextMenuBuiltInItems', AS.flash.ui.ContextMenuBuiltInItems);
            M('flash.ui.ContextMenuClipboardItems', AS.flash.ui.ContextMenuClipboardItems);
            M('flash.ui.Keyboard', AS.flash.ui.Keyboard);
            M('flash.ui.Mouse', AS.flash.ui.Mouse);
            M('flash.ui.MouseCursorData', AS.flash.ui.MouseCursorData);
            M('flash.ui.GameInput', AS.flash.ui.GameInput);
            M('flash.events.GameInputEvent', AS.flash.events.GameInputEvent);
            M('flash.ui.GameInputControl', AS.flash.ui.GameInputControl);
            M('flash.ui.GameInputControlType', AS.flash.ui.GameInputControlType);
            M('flash.ui.GameInputDevice', AS.flash.ui.GameInputDevice);
            M('flash.ui.GameInputFinger', AS.flash.ui.GameInputFinger);
            M('flash.ui.GameInputHand', AS.flash.ui.GameInputHand);
            M('flash.ui.Multitouch', AS.flash.ui.Multitouch);
            M('flash.ui.MultitouchInputMode', AS.flash.ui.MultitouchInputMode);
            M('flash.events.TouchEvent', AS.flash.events.TouchEvent);
            M('flash.text.Font', AS.flash.text.Font);
            M('flash.text.TextField', AS.flash.text.TextField);
            M('flash.text.StaticText', AS.flash.text.StaticText);
            M('flash.text.StyleSheet', AS.flash.text.StyleSheet);
            M('flash.text.TextFormat', AS.flash.text.TextFormat);
            M('flash.text.TextRun', AS.flash.text.TextRun);
            M('flash.text.TextSnapshot', AS.flash.text.TextSnapshot);
            M('flash.text.TextLineMetrics', AS.flash.text.TextLineMetrics);
            M('flash.media.Sound', AS.flash.media.Sound);
            M('flash.media.SoundChannel', AS.flash.media.SoundChannel);
            M('flash.media.SoundMixer', AS.flash.media.SoundMixer);
            M('flash.media.SoundTransform', AS.flash.media.SoundTransform);
            M('flash.media.Video', AS.flash.media.Video);
            M('flash.media.StageVideo', AS.flash.media.StageVideo);
            M('flash.media.ID3Info', AS.flash.media.ID3Info);
            M('flash.media.Microphone', AS.flash.media.Microphone);
            M('flash.media.Camera', AS.flash.media.Camera);
            M('flash.net.FileFilter', AS.flash.net.FileFilter);
            M('flash.net.FileReference', AS.flash.net.FileReference);
            M('flash.net.FileReferenceList', AS.flash.net.FileReferenceList);
            M('flash.net.NetConnection', AS.flash.net.NetConnection);
            M('flash.net.NetStream', AS.flash.net.NetStream);
            M('flash.net.NetStreamInfo', AS.flash.net.NetStreamInfo);
            M('flash.net.Responder', AS.flash.net.Responder);
            M('flash.net.URLRequest', AS.flash.net.URLRequest);
            M('flash.net.URLRequestHeader', AS.flash.net.URLRequestHeader);
            M('flash.net.URLStream', AS.flash.net.URLStream);
            M('flash.net.URLLoader', AS.flash.net.URLLoader);
            M('flash.net.SharedObject', AS.flash.net.SharedObject);
            M('flash.net.ObjectEncoding', AS.flash.net.ObjectEncoding);
            M('flash.net.LocalConnection', AS.flash.net.LocalConnection);
            M('flash.net.Socket', AS.flash.net.Socket);
            M('flash.net.URLVariables', AS.flash.net.URLVariables);
            M('flash.system.Capabilities', AS.flash.system.Capabilities);
            M('flash.system.Security', AS.flash.system.Security);
            M('flash.system.System', AS.flash.system.System);
            M('flash.system.SecurityDomain', AS.flash.system.SecurityDomain);
            M('flash.system.ApplicationDomain', AS.flash.system.ApplicationDomain);
            M('flash.system.JPEGLoaderContext', AS.flash.system.JPEGLoaderContext);
            M('flash.system.LoaderContext', AS.flash.system.LoaderContext);
            M('flash.accessibility.Accessibility', AS.flash.accessibility.Accessibility);
            M('flash.accessibility.AccessibilityProperties', AS.flash.accessibility.AccessibilityProperties);
            M('flash.utils.Timer', AS.flash.utils.Timer);
            M('flash.utils.ByteArray', AS.flash.utils.ByteArray);
            M('flash.xml.XMLNode', AS.flash.xml.XMLNode);
            M('flash.xml.XMLDocument', AS.flash.xml.XMLDocument);
            AS.registerNativeFunction('flash.system.fscommand', AS.flash.system.fscommand);
            function constructClassFromSymbol(symbol, axClass) {
                var instance = Object.create(axClass.tPrototype);
                if (instance._symbol) {
                    release || Shumway.Debug.assert(instance._symbol === symbol);
                } else {
                    instance._symbol = symbol;
                }
                instance.applySymbol();
                return instance;
            }
            AS.constructClassFromSymbol = constructClassFromSymbol;
        }(AS = AVMX.AS || (AVMX.AS = {})));
    }(AVMX = Shumway.AVMX || (Shumway.AVMX = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='../../build/ts/avm2.d.ts' />
/// <reference path='../../build/ts/swf.d.ts' />
///<reference path='module.ts' />
///<reference path='../htmlparser.ts' />
///<reference path='../TextContent.ts' />
///<reference path='settings.ts' />
///<reference path='symbol.ts' />
///<reference path='../rtmp/references.ts' />
///<reference path='geom/Matrix.ts' />
///<reference path='geom/Matrix3D.ts' />
///<reference path='geom/Orientation3D.ts' />
///<reference path='geom/PerspectiveProjection.ts' />
///<reference path='geom/Point.ts' />
///<reference path='geom/Rectangle.ts' />
///<reference path='geom/Transform.ts' />
///<reference path='geom/Utils3D.ts' />
///<reference path='geom/Vector3D.ts' />
///<reference path='accessibility/Accessibility.ts' />
///<reference path='accessibility/AccessibilityImplementation.ts' />
///<reference path='accessibility/AccessibilityProperties.ts' />
// ///<reference path='accessibility/ISearchableText.ts' />
// ///<reference path='accessibility/ISimpleTextSelection.ts' />
// ///<reference path='automation/ActionGenerator.ts' />
// ///<reference path='automation/AutomationAction.ts' />
// ///<reference path='automation/Configuration.ts' />
// ///<reference path='automation/KeyboardAutomationAction.ts' />
// ///<reference path='automation/MouseAutomationAction.ts' />
// ///<reference path='automation/StageCapture.ts' />
// ///<reference path='automation/StageCaptureEvent.ts' />
// ///<reference path='desktop/Clipboard.ts' />
// ///<reference path='desktop/ClipboardFormats.ts' />
// ///<reference path='desktop/ClipboardTransferMode.ts' />
///<reference path='events/Event.ts' />
///<reference path='events/EventDispatcher.ts' />
///<reference path='events/EventPhase.ts' />
// ///<reference path='events/AccelerometerEvent.ts' />
// ///<reference path='events/ActivityEvent.ts' />
// ///<reference path='events/ContextMenuEvent.ts' />
// ///<reference path='events/DataEvent.ts' />
///<reference path='events/TextEvent.ts' />
///<reference path='events/ErrorEvent.ts' />
///<reference path='events/AsyncErrorEvent.ts' />
// ///<reference path='events/FocusEvent.ts' />
// ///<reference path='events/FullScreenEvent.ts' />
///<reference path='events/GameInputEvent.ts' />
// ///<reference path='events/GeolocationEvent.ts' />
///<reference path='events/GestureEvent.ts' />
// ///<reference path='events/GesturePhase.ts' />
///<reference path='events/HTTPStatusEvent.ts' />
///<reference path='events/IEventDispatcher.ts' />
// ///<reference path='events/IMEEvent.ts' />
///<reference path='events/IOErrorEvent.ts' />
///<reference path='events/KeyboardEvent.ts' />
///<reference path='events/MouseEvent.ts' />
// ///<reference path='events/NetDataEvent.ts' />
// ///<reference path='events/NetFilterEvent.ts' />
// ///<reference path='events/NetMonitorEvent.ts' />
///<reference path='events/NetStatusEvent.ts' />
// ///<reference path='events/OutputProgressEvent.ts' />
// ///<reference path='events/PressAndTapGestureEvent.ts' />
///<reference path='events/ProgressEvent.ts' />
// ///<reference path='events/SampleDataEvent.ts' />
///<reference path='events/SecurityErrorEvent.ts' />
// ///<reference path='events/ShaderEvent.ts' />
// ///<reference path='events/SoftKeyboardEvent.ts' />
// ///<reference path='events/SoftKeyboardTrigger.ts' />
// ///<reference path='events/StageVideoAvailabilityEvent.ts' />
// ///<reference path='events/StageVideoEvent.ts' />
///<reference path='events/StatusEvent.ts' />
// ///<reference path='events/SyncEvent.ts' />
// ///<reference path='events/ThrottleEvent.ts' />
// ///<reference path='events/ThrottleType.ts' />
///<reference path='events/TimerEvent.ts' />
///<reference path='events/TouchEvent.ts' />
// ///<reference path='events/TransformGestureEvent.ts' />
///<reference path='events/UncaughtErrorEvent.ts' />
///<reference path='events/UncaughtErrorEvents.ts' />
// ///<reference path='events/VideoEvent.ts' />
///<reference path='display/DisplayObject.ts' />
///<reference path='display/Bitmap.ts' />
///<reference path='display/Shape.ts' />
///<reference path='display/InteractiveObject.ts' />
///<reference path='display/SimpleButton.ts' />
///<reference path='display/DisplayObjectContainer.ts' />
///<reference path='display/JointStyle.ts' />
///<reference path='display/CapsStyle.ts' />
///<reference path='display/LineScaleMode.ts' />
///<reference path='display/GradientType.ts' />
///<reference path='display/SpreadMethod.ts' />
///<reference path='display/InterpolationMethod.ts' />
///<reference path='display/GraphicsBitmapFill.ts' />
///<reference path='display/GraphicsEndFill.ts' />
///<reference path='display/GraphicsGradientFill.ts' />
///<reference path='display/GraphicsPath.ts' />
///<reference path='display/GraphicsPathCommand.ts' />
///<reference path='display/GraphicsPathWinding.ts' />
// ///<reference path='display/GraphicsShaderFill.ts' />
///<reference path='display/GraphicsSolidFill.ts' />
///<reference path='display/GraphicsStroke.ts' />
///<reference path='display/GraphicsTrianglePath.ts' />
///<reference path='display/IDrawCommand.ts' />
///<reference path='display/IGraphicsData.ts' />
///<reference path='display/IGraphicsFill.ts' />
///<reference path='display/IGraphicsPath.ts' />
///<reference path='display/IGraphicsStroke.ts' />
///<reference path='display/Graphics.ts' />
///<reference path='display/Sprite.ts' />
///<reference path='display/MovieClip.ts' />
///<reference path='display/MovieClipSoundStream.ts' />
///<reference path='display/Stage.ts' />
///<reference path='display/ActionScriptVersion.ts' />
///<reference path='display/BlendMode.ts' />
///<reference path='display/ColorCorrection.ts' />
///<reference path='display/ColorCorrectionSupport.ts' />
///<reference path='display/FocusDirection.ts' />
///<reference path='display/FrameLabel.ts' />
///<reference path='display/BitmapData.ts' />
///<reference path='display/BitmapDataChannel.ts' />
///<reference path='display/BitmapEncodingColorSpace.ts' />
///<reference path='display/IBitmapDrawable.ts' />
///<reference path='display/JPEGEncoderOptions.ts' />
// ///<reference path='display/JPEGXREncoderOptions.ts' />
///<reference path='display/Loader.ts' />
///<reference path='display/LoaderInfo.ts' />
///<reference path='display/MorphShape.ts' />
///<reference path='display/NativeMenu.ts' />
///<reference path='display/NativeMenuItem.ts' />
///<reference path='display/PNGEncoderOptions.ts' />
///<reference path='display/PixelSnapping.ts' />
///<reference path='display/SWFVersion.ts' />
///<reference path='display/Scene.ts' />
// ///<reference path='display/Shader.ts' />
// ///<reference path='display/ShaderData.ts' />
// ///<reference path='display/ShaderInput.ts' />
// ///<reference path='display/ShaderJob.ts' />
// ///<reference path='display/ShaderParameter.ts' />
// ///<reference path='display/ShaderParameterType.ts' />
// ///<reference path='display/ShaderPrecision.ts' />
// ///<reference path='display/Stage3D.ts' />
///<reference path='display/StageAlign.ts' />
///<reference path='display/StageDisplayState.ts' />
///<reference path='display/StageQuality.ts' />
///<reference path='display/StageScaleMode.ts' />
///<reference path='display/TriangleCulling.ts' />
///<reference path='display/AVM1Movie.ts' />
// ///<reference path='display3D/Context3D.ts' />
// ///<reference path='display3D/Context3DBlendFactor.ts' />
// ///<reference path='display3D/Context3DClearMask.ts' />
// ///<reference path='display3D/Context3DCompareMode.ts' />
// ///<reference path='display3D/Context3DProfile.ts' />
// ///<reference path='display3D/Context3DProgramType.ts' />
// ///<reference path='display3D/Context3DRenderMode.ts' />
// ///<reference path='display3D/Context3DStencilAction.ts' />
// ///<reference path='display3D/Context3DTextureFormat.ts' />
// ///<reference path='display3D/Context3DTriangleFace.ts' />
// ///<reference path='display3D/Context3DVertexBufferFormat.ts' />
// ///<reference path='display3D/IndexBuffer3D.ts' />
// ///<reference path='display3D/Program3D.ts' />
// ///<reference path='display3D/VertexBuffer3D.ts' />
// ///<reference path='display3D/textures/CubeTexture.ts' />
// ///<reference path='display3D/textures/Texture.ts' />
// ///<reference path='display3D/textures/TextureBase.ts' />
// ///<reference path='errors/EOFError.ts' />
// ///<reference path='errors/IOError.ts' />
///<reference path='errors/IllegalOperationError.ts' />
// ///<reference path='errors/InvalidSWFError.ts' />
// ///<reference path='errors/MemoryError.ts' />
// ///<reference path='errors/ScriptTimeoutError.ts' />
// ///<reference path='errors/StackOverflowError.ts' />
///<reference path='external/ExternalInterface.ts' />
///<reference path='filters/BitmapFilterQuality.ts' />
///<reference path='filters/BitmapFilterType.ts' />
///<reference path='filters/BitmapFilter.ts' />
///<reference path='filters/BevelFilter.ts' />
///<reference path='filters/BlurFilter.ts' />
///<reference path='filters/ColorMatrixFilter.ts' />
///<reference path='filters/ConvolutionFilter.ts' />
///<reference path='filters/DisplacementMapFilterMode.ts' />
///<reference path='filters/DisplacementMapFilter.ts' />
///<reference path='filters/DropShadowFilter.ts' />
///<reference path='filters/GlowFilter.ts' />
///<reference path='filters/GradientBevelFilter.ts' />
///<reference path='filters/GradientGlowFilter.ts' />
// ///<reference path='filters/ShaderFilter.ts' />
///<reference path='geom/ColorTransform.ts' />
// ///<reference path='globalization/Collator.ts' />
// ///<reference path='globalization/CollatorMode.ts' />
// ///<reference path='globalization/CurrencyFormatter.ts' />
// ///<reference path='globalization/CurrencyParseResult.ts' />
// ///<reference path='globalization/DateTimeFormatter.ts' />
// ///<reference path='globalization/DateTimeNameContext.ts' />
// ///<reference path='globalization/DateTimeNameStyle.ts' />
// ///<reference path='globalization/DateTimeStyle.ts' />
// ///<reference path='globalization/LastOperationStatus.ts' />
// ///<reference path='globalization/LocaleID.ts' />
// ///<reference path='globalization/NationalDigitsType.ts' />
// ///<reference path='globalization/NumberFormatter.ts' />
// ///<reference path='globalization/NumberParseResult.ts' />
// ///<reference path='globalization/StringTools.ts' />
// ///<reference path='media/AudioDecoder.ts' />
///<reference path='media/Camera.ts' />
// ///<reference path='media/H264Level.ts' />
// ///<reference path='media/H264Profile.ts' />
// ///<reference path='media/H264VideoStreamSettings.ts' />
///<reference path='media/ID3Info.ts' />
///<reference path='media/Microphone.ts' />
// ///<reference path='media/MicrophoneEnhancedMode.ts' />
// ///<reference path='media/MicrophoneEnhancedOptions.ts' />
///<reference path='media/Sound.ts' />
///<reference path='media/SoundChannel.ts' />
// ///<reference path='media/SoundCodec.ts' />
///<reference path='media/SoundLoaderContext.ts' />
///<reference path='media/SoundMixer.ts' />
///<reference path='media/SoundTransform.ts' />
///<reference path='media/StageVideo.ts' />
///<reference path='media/StageVideoAvailability.ts' />
///<reference path='media/Video.ts' />
// ///<reference path='media/VideoCodec.ts' />
// ///<reference path='media/VideoStatus.ts' />
///<reference path='media/VideoStreamSettings.ts' />
// ///<reference path='net/DynamicPropertyOutput.ts' />
///<reference path='net/FileFilter.ts' />
///<reference path='net/FileReference.ts' />
///<reference path='net/FileReferenceList.ts' />
// ///<reference path='net/GroupSpecifier.ts' />
// ///<reference path='net/IDynamicPropertyOutput.ts' />
// ///<reference path='net/IDynamicPropertyWriter.ts' />
///<reference path='net/LocalConnection.ts' />
///<reference path='net/NetConnection.ts' />
// ///<reference path='net/NetGroup.ts' />
// ///<reference path='net/NetGroupInfo.ts' />
// ///<reference path='net/NetGroupReceiveMode.ts' />
// ///<reference path='net/NetGroupReplicationStrategy.ts' />
// ///<reference path='net/NetGroupSendMode.ts' />
// ///<reference path='net/NetGroupSendResult.ts' />
// ///<reference path='net/NetMonitor.ts' />
///<reference path='net/NetStream.ts' />
// ///<reference path='net/NetStreamAppendBytesAction.ts' />
///<reference path='net/NetStreamInfo.ts' />
///<reference path='net/NetStreamMulticastInfo.ts' />
///<reference path='net/NetStreamPlayOptions.ts' />
// ///<reference path='net/NetStreamPlayTransitions.ts' />
///<reference path='net/Responder.ts' />
// ///<reference path='net/SecureSocket.ts' />
///<reference path='net/SharedObject.ts' />
// ///<reference path='net/SharedObjectFlushStatus.ts' />
///<reference path='net/Socket.ts' />
///<reference path='net/URLLoader.ts' />
// ///<reference path='net/URLLoaderDataFormat.ts' />
///<reference path='net/URLRequest.ts' />
///<reference path='net/URLRequestHeader.ts' />
// ///<reference path='net/URLRequestMethod.ts' />
///<reference path='net/URLStream.ts' />
///<reference path='net/URLVariables.ts' />
// ///<reference path='net/XMLSocket.ts' />
// ///<reference path='printing/PrintJob.ts' />
// ///<reference path='printing/PrintJobOptions.ts' />
// ///<reference path='printing/PrintJobOrientation.ts' />
// ///<reference path='profiler/Telemetry.ts' />
// ///<reference path='sampler/ClassFactory.ts' />
// ///<reference path='sampler/DeleteObjectSample.ts' />
// ///<reference path='sampler/NewObjectSample.ts' />
// ///<reference path='sampler/Sample.ts' />
// ///<reference path='sampler/StackFrame.ts' />
// ///<reference path='security/CertificateStatus.ts' />
// ///<reference path='security/X500DistinguishedName.ts' />
// ///<reference path='security/X509Certificate.ts' />
///<reference path='sensors/Accelerometer.ts' />
///<reference path='sensors/Geolocation.ts' />
///<reference path='system/ApplicationDomain.ts' />
// ///<reference path='system/ApplicationInstaller.ts' />
// ///<reference path='system/AuthorizedFeatures.ts' />
// ///<reference path='system/AuthorizedFeaturesLoader.ts' />
///<reference path='system/Capabilities.ts' />
// ///<reference path='system/DomainMemoryWithStage3D.ts' />
///<reference path='system/FSCommand.ts' />
// ///<reference path='system/IMEConversionMode.ts' />
///<reference path='system/ImageDecodingPolicy.ts' />
///<reference path='system/LoaderContext.ts' />
///<reference path='system/JPEGLoaderContext.ts' />
///<reference path='system/MessageChannel.ts' />
///<reference path='system/MessageChannelState.ts' />
///<reference path='system/Security.ts' />
///<reference path='system/SecurityDomain.ts' />
///<reference path='system/SecurityPanel.ts' />
// ///<reference path='system/SystemUpdaterType.ts' />
///<reference path='system/TouchscreenType.ts' />
///<reference path='text/AntiAliasType.ts' />
// ///<reference path='text/CSMSettings.ts' />
///<reference path='text/FontStyle.ts' />
///<reference path='text/FontType.ts' />
///<reference path='text/Font.ts' />
///<reference path='text/GridFitType.ts' />
///<reference path='text/StaticText.ts' />
///<reference path='text/StyleSheet.ts' />
// ///<reference path='text/TextColorType.ts' />
///<reference path='text/TextDisplayMode.ts' />
// ///<reference path='text/TextExtent.ts' />
///<reference path='text/TextField.ts' />
///<reference path='text/TextFieldAutoSize.ts' />
///<reference path='text/TextFieldType.ts' />
///<reference path='text/TextFormat.ts' />
///<reference path='text/TextFormatAlign.ts' />
///<reference path='text/TextFormatDisplay.ts' />
///<reference path='text/TextInteractionMode.ts' />
///<reference path='text/TextLineMetrics.ts' />
// ///<reference path='text/TextRenderer.ts' />
///<reference path='text/TextRun.ts' />
///<reference path='text/TextSnapshot.ts' />
// ///<reference path='text/engine/BreakOpportunity.ts' />
// ///<reference path='text/engine/CFFHinting.ts' />
// ///<reference path='text/engine/ContentElement.ts' />
// ///<reference path='text/engine/DigitCase.ts' />
// ///<reference path='text/engine/DigitWidth.ts' />
// ///<reference path='text/engine/EastAsianJustifier.ts' />
// ///<reference path='text/engine/ElementFormat.ts' />
// ///<reference path='text/engine/FontDescription.ts' />
// ///<reference path='text/engine/FontLookup.ts' />
// ///<reference path='text/engine/FontMetrics.ts' />
// ///<reference path='text/engine/FontPosture.ts' />
// ///<reference path='text/engine/FontWeight.ts' />
// ///<reference path='text/engine/GraphicElement.ts' />
// ///<reference path='text/engine/GroupElement.ts' />
// ///<reference path='text/engine/JustificationStyle.ts' />
// ///<reference path='text/engine/Kerning.ts' />
// ///<reference path='text/engine/LigatureLevel.ts' />
// ///<reference path='text/engine/LineJustification.ts' />
// ///<reference path='text/engine/RenderingMode.ts' />
// ///<reference path='text/engine/TextJustifier.ts' />
// ///<reference path='text/engine/SpaceJustifier.ts' />
// ///<reference path='text/engine/TabAlignment.ts' />
// ///<reference path='text/engine/TabStop.ts' />
// ///<reference path='text/engine/TextBaseline.ts' />
// ///<reference path='text/engine/TextBlock.ts' />
// ///<reference path='text/engine/TextElement.ts' />
// ///<reference path='text/engine/TextLine.ts' />
// ///<reference path='text/engine/TextLineCreationResult.ts' />
// ///<reference path='text/engine/TextLineMirrorRegion.ts' />
// ///<reference path='text/engine/TextLineValidity.ts' />
// ///<reference path='text/engine/TextRotation.ts' />
// ///<reference path='text/engine/TypographicCase.ts' />
// ///<reference path='text/ime/CompositionAttributeRange.ts' />
// ///<reference path='text/ime/IIMEClient.ts' />
///<reference path='trace/Trace.ts' />
///<reference path='ui/ContextMenu.ts' />
///<reference path='ui/ContextMenuBuiltInItems.ts' />
///<reference path='ui/ContextMenuClipboardItems.ts' />
///<reference path='ui/ContextMenuItem.ts' />
///<reference path='ui/GameInput.ts' />
///<reference path='ui/GameInputControl.ts' />
///<reference path='ui/GameInputControlType.ts' />
///<reference path='ui/GameInputDevice.ts' />
///<reference path='ui/GameInputFinger.ts' />
///<reference path='ui/GameInputHand.ts' />
// ///<reference path='ui/KeyLocation.ts' />
///<reference path='ui/Keyboard.ts' />
// ///<reference path='ui/KeyboardType.ts' />
///<reference path='ui/Mouse.ts' />
///<reference path='ui/MouseCursor.ts' />
///<reference path='ui/MouseCursorData.ts' />
///<reference path='ui/Multitouch.ts' />
///<reference path='ui/MultitouchInputMode.ts' />
///<reference path='utils/Endian.ts' />
///<reference path='utils/IDataInput2.ts' />
///<reference path='utils/IDataOutput2.ts' />
///<reference path='utils/IExternalizable.ts' />
///<reference path='utils/Timer.ts' />
///<reference path='utils/SetIntervalTimer.ts' />
///<reference path='avm1.d.ts' />
// ///<reference path='linker.ts' />
///<reference path='link.ts' />
//# sourceMappingURL=flash.js.map
console.timeEnd('Load Flash TS Dependencies');
// Load AVM1 Dependencies
console.time('Load AVM1 Dependencies');
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var AVM1;
    (function (AVM1) {
        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;
        var shumwayOptions = Shumway.Settings.shumwayOptions;
        var avm1Options = shumwayOptions.register(new OptionSet('AVM1'));
        AVM1.avm1TraceEnabled = avm1Options.register(new Option('t1', 'traceAvm1', 'boolean', false, 'trace AVM1 execution'));
        AVM1.avm1ErrorsEnabled = avm1Options.register(new Option('e1', 'errorsAvm1', 'boolean', false, 'fail on AVM1 warnings and errors'));
        AVM1.avm1WarningsEnabled = avm1Options.register(new Option('w1', 'warningsAvm1', 'boolean', false, 'Emit messages for AVM1 warnings and errors'));
        AVM1.avm1TimeoutDisabled = avm1Options.register(new Option('ha1', 'nohangAvm1', 'boolean', false, 'disable fail on AVM1 hang'));
        AVM1.avm1CompilerEnabled = avm1Options.register(new Option('ca1', 'compileAvm1', 'boolean', true, 'compiles AVM1 code'));
        AVM1.avm1DebuggerEnabled = avm1Options.register(new Option('da1', 'debugAvm1', 'boolean', false, 'allows AVM1 code debugging'));
        AVM1.avm1WellknownActionsCompilationsEnabled = avm1Options.register(new Option('cw1', 'wellknownAvm1', 'boolean', true, 'Replaces well-known actions patterns instead of compilation'));
        var ActionsDataStream = function () {
            function ActionsDataStream(array, swfVersion) {
                this.array = array;
                this.position = 0;
                this.end = array.length;
                // TODO use system locale to determine if the shift-JIS
                // decoding is necessary
                this.readANSI = swfVersion < 6;
                // endianess sanity check
                var buffer = new ArrayBuffer(4);
                new Int32Array(buffer)[0] = 1;
                if (!new Uint8Array(buffer)[0]) {
                    throw new Error('big-endian platform');
                }
            }
            ActionsDataStream.prototype.readUI8 = function () {
                return this.array[this.position++];
            };
            ActionsDataStream.prototype.readUI16 = function () {
                var position = this.position, array = this.array;
                var value = array[position + 1] << 8 | array[position];
                this.position = position + 2;
                return value;
            };
            ActionsDataStream.prototype.readSI16 = function () {
                var position = this.position, array = this.array;
                var value = array[position + 1] << 8 | array[position];
                this.position = position + 2;
                return value < 32768 ? value : value - 65536;
            };
            ActionsDataStream.prototype.readInteger = function () {
                var position = this.position, array = this.array;
                var value = array[position] | array[position + 1] << 8 | array[position + 2] << 16 | array[position + 3] << 24;
                this.position = position + 4;
                return value;
            };
            ActionsDataStream.prototype.readFloat = function () {
                var position = this.position;
                var array = this.array;
                var buffer = new ArrayBuffer(4);
                var bytes = new Uint8Array(buffer);
                bytes[0] = array[position];
                bytes[1] = array[position + 1];
                bytes[2] = array[position + 2];
                bytes[3] = array[position + 3];
                this.position = position + 4;
                return new Float32Array(buffer)[0];
            };
            ActionsDataStream.prototype.readDouble = function () {
                var position = this.position;
                var array = this.array;
                var buffer = new ArrayBuffer(8);
                var bytes = new Uint8Array(buffer);
                bytes[4] = array[position];
                bytes[5] = array[position + 1];
                bytes[6] = array[position + 2];
                bytes[7] = array[position + 3];
                bytes[0] = array[position + 4];
                bytes[1] = array[position + 5];
                bytes[2] = array[position + 6];
                bytes[3] = array[position + 7];
                this.position = position + 8;
                return new Float64Array(buffer)[0];
            };
            ActionsDataStream.prototype.readBoolean = function () {
                return !!this.readUI8();
            };
            ActionsDataStream.prototype.readANSIString = function () {
                var value = '';
                var ch;
                while (ch = this.readUI8()) {
                    value += String.fromCharCode(ch);
                }
                return value;
            };
            ActionsDataStream.prototype.readUTF8String = function () {
                var value = '';
                var ch;
                while (ch = this.readUI8()) {
                    if (ch < 128) {
                        value += String.fromCharCode(ch);
                        continue;
                    }
                    if ((ch & 192) === 128) {
                        // Invalid UTF8 encoding: initial char -- using it as is
                        value += String.fromCharCode(ch);
                        continue;
                    }
                    var lastPosition = this.position - 1;
                    // in case if we need to recover
                    var currentPrefix = 192;
                    var validBits = 5;
                    do {
                        var mask = currentPrefix >> 1 | 128;
                        if ((ch & mask) === currentPrefix) {
                            break;
                        }
                        currentPrefix = mask;
                        --validBits;
                    } while (validBits >= 0);
                    var code = ch & (1 << validBits) - 1;
                    for (var i = 5; i >= validBits; --i) {
                        ch = this.readUI8();
                        if ((ch & 192) !== 128) {
                            // Invalid UTF8 encoding: bad chars in the tail, using previous chars as is
                            var skipToPosition = this.position - 1;
                            this.position = lastPosition;
                            while (this.position < skipToPosition) {
                                value += String.fromCharCode(this.readUI8());
                            }
                            continue;
                        }
                        code = code << 6 | ch & 63;
                    }
                    if (code >= 65536) {
                        value += String.fromCharCode(code - 65536 >> 10 & 1023 | 55296, code & 1023 | 56320);
                    } else {
                        value += String.fromCharCode(code);
                    }
                }
                return value;
            };
            ActionsDataStream.prototype.readString = function () {
                return this.readANSI ? this.readANSIString() : this.readUTF8String();
            };
            ActionsDataStream.prototype.readBytes = function (length) {
                var position = this.position;
                var remaining = Math.max(this.end - position, 0);
                if (remaining < length) {
                    length = remaining;
                }
                var subarray = this.array.subarray(position, position + length);
                this.position = position + length;
                return subarray;
            };
            return ActionsDataStream;
        }();
        AVM1.ActionsDataStream = ActionsDataStream;
        var ActionsDataStream = Shumway.AVM1.ActionsDataStream;
        var ParsedPushRegisterAction = function () {
            function ParsedPushRegisterAction(registerNumber) {
                this.registerNumber = registerNumber;
            }
            return ParsedPushRegisterAction;
        }();
        AVM1.ParsedPushRegisterAction = ParsedPushRegisterAction;
        var ParsedPushConstantAction = function () {
            function ParsedPushConstantAction(constantIndex) {
                this.constantIndex = constantIndex;
            }
            return ParsedPushConstantAction;
        }();
        AVM1.ParsedPushConstantAction = ParsedPushConstantAction;
        var ActionsDataParser = function () {
            function ActionsDataParser(actionsData, swfVersion) {
                this._actionsData = actionsData;
                this.dataId = actionsData.id;
                this._stream = new ActionsDataStream(actionsData.bytes, swfVersion);
            }
            Object.defineProperty(ActionsDataParser.prototype, 'position', {
                get: function () {
                    return this._stream.position;
                },
                set: function (value) {
                    this._stream.position = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ActionsDataParser.prototype, 'eof', {
                get: function () {
                    return this._stream.position >= this._stream.end;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ActionsDataParser.prototype, 'length', {
                get: function () {
                    return this._stream.end;
                },
                enumerable: true,
                configurable: true
            });
            ActionsDataParser.prototype.readNext = function () {
                var stream = this._stream;
                var currentPosition = stream.position;
                var actionCode = stream.readUI8();
                var length = actionCode >= 128 ? stream.readUI16() : 0;
                var nextPosition = stream.position + length;
                var args = null;
                switch (actionCode | 0) {
                case 129    /* ActionGotoFrame */:
                    var frame = stream.readUI16();
                    var nextActionCode = stream.readUI8();
                    var play = false;
                    if (nextActionCode !== 6 && nextActionCode !== 7) {
                        stream.position--;
                    } else {
                        nextPosition++;
                        play = nextActionCode === 6;
                    }
                    args = [
                        frame,
                        play
                    ];
                    break;
                case 131    /* ActionGetURL */:
                    var urlString = stream.readString();
                    var targetString = stream.readString();
                    args = [
                        urlString,
                        targetString
                    ];
                    break;
                case 138    /* ActionWaitForFrame */:
                    var frame = stream.readUI16();
                    var count = stream.readUI8();
                    args = [
                        frame,
                        count
                    ];
                    break;
                case 139    /* ActionSetTarget */:
                    var targetName = stream.readString();
                    args = [targetName];
                    break;
                case 140    /* ActionGoToLabel */:
                    var label = stream.readString();
                    var nextActionCode = stream.readUI8();
                    var play = false;
                    if (nextActionCode !== 6 && nextActionCode !== 7) {
                        stream.position--;
                    } else {
                        nextPosition++;
                        play = nextActionCode === 6;
                    }
                    args = [
                        label,
                        play
                    ];
                    break;
                case 150    /* ActionPush */:
                    var type, value;
                    args = [];
                    while (stream.position < nextPosition) {
                        type = stream.readUI8();
                        switch (type | 0) {
                        case 0:
                            value = stream.readString();
                            break;
                        case 1:
                            value = stream.readFloat();
                            break;
                        case 2:
                            value = null;
                            break;
                        case 3:
                            value = void 0;
                            break;
                        case 4:
                            value = new ParsedPushRegisterAction(stream.readUI8());
                            break;
                        case 5:
                            value = stream.readBoolean();
                            break;
                        case 6:
                            value = stream.readDouble();
                            break;
                        case 7:
                            value = stream.readInteger();
                            break;
                        case 8:
                            value = new ParsedPushConstantAction(stream.readUI8());
                            break;
                        case 9:
                            value = new ParsedPushConstantAction(stream.readUI16());
                            break;
                        default:
                            console.error('Unknown value type: ' + type);
                            stream.position = nextPosition;
                            continue;
                        }
                        args.push(value);
                    }
                    break;
                case 153    /* ActionJump */:
                    var offset = stream.readSI16();
                    args = [offset];
                    break;
                case 157    /* ActionIf */:
                    var offset = stream.readSI16();
                    args = [offset];
                    break;
                case 154    /* ActionGetURL2 */:
                    var flags = stream.readUI8();
                    args = [flags];
                    break;
                case 159    /* ActionGotoFrame2 */:
                    var flags = stream.readUI8();
                    args = [flags];
                    if (!!(flags & 2)) {
                        args.push(stream.readUI16());
                    }
                    break;
                case 141    /* ActionWaitForFrame2 */:
                    var count = stream.readUI8();
                    args = [count];
                    break;
                case 136    /* ActionConstantPool */:
                    var count = stream.readUI16();
                    var constantPool = [];
                    for (var i = 0; i < count; i++) {
                        constantPool.push(stream.readString());
                    }
                    args = [constantPool];
                    break;
                case 155    /* ActionDefineFunction */:
                    var functionName = stream.readString();
                    var count = stream.readUI16();
                    var functionParams = [];
                    for (var i = 0; i < count; i++) {
                        functionParams.push(stream.readString());
                    }
                    var codeSize = stream.readUI16();
                    nextPosition += codeSize;
                    var functionBody = new AVM1.AVM1ActionsData(stream.readBytes(codeSize), this.dataId + '_f' + stream.position, this._actionsData);
                    args = [
                        functionBody,
                        functionName,
                        functionParams
                    ];
                    break;
                case 148    /* ActionWith */:
                    var codeSize = stream.readUI16();
                    nextPosition += codeSize;
                    var withBody = new AVM1.AVM1ActionsData(stream.readBytes(codeSize), this.dataId + '_w' + stream.position, this._actionsData);
                    args = [withBody];
                    break;
                case 135    /* ActionStoreRegister */:
                    var register = stream.readUI8();
                    args = [register];
                    break;
                case 142    /* ActionDefineFunction2 */:
                    var functionName = stream.readString();
                    var count = stream.readUI16();
                    var registerCount = stream.readUI8();
                    var flags = stream.readUI16();
                    var registerAllocation = [];
                    var functionParams = [];
                    for (var i = 0; i < count; i++) {
                        var register = stream.readUI8();
                        var paramName = stream.readString();
                        functionParams.push(paramName);
                        if (register) {
                            registerAllocation[register] = {
                                type: 1    /* Argument */,
                                name: paramName,
                                index: i
                            };
                        }
                    }
                    var j = 1;
                    // order this, arguments, super, _root, _parent, and _global
                    if (flags & 1) {
                        registerAllocation[j++] = { type: 2    /* This */ };
                    }
                    if (flags & 4) {
                        registerAllocation[j++] = { type: 4    /* Arguments */ };
                    }
                    if (flags & 16) {
                        registerAllocation[j++] = { type: 8    /* Super */ };
                    }
                    if (flags & 64) {
                        registerAllocation[j++] = { type: 64    /* Root */ };
                    }
                    if (flags & 128) {
                        registerAllocation[j++] = { type: 32    /* Parent */ };
                    }
                    if (flags & 256) {
                        registerAllocation[j++] = { type: 16    /* Global */ };
                    }
                    var suppressArguments = 0;
                    if (flags & 2) {
                        suppressArguments |= 2    /* This */;
                    }
                    if (flags & 8) {
                        suppressArguments |= 4    /* Arguments */;
                    }
                    if (flags & 32) {
                        suppressArguments |= 8    /* Super */;
                    }
                    var codeSize = stream.readUI16();
                    nextPosition += codeSize;
                    var functionBody = new AVM1.AVM1ActionsData(stream.readBytes(codeSize), this.dataId + '_f' + stream.position, this._actionsData);
                    args = [
                        functionBody,
                        functionName,
                        functionParams,
                        registerCount,
                        registerAllocation,
                        suppressArguments
                    ];
                    break;
                case 143    /* ActionTry */:
                    var flags = stream.readUI8();
                    var catchIsRegisterFlag = !!(flags & 4);
                    var finallyBlockFlag = !!(flags & 2);
                    var catchBlockFlag = !!(flags & 1);
                    var trySize = stream.readUI16();
                    var catchSize = stream.readUI16();
                    var finallySize = stream.readUI16();
                    var catchTarget = catchIsRegisterFlag ? stream.readUI8() : stream.readString();
                    nextPosition += trySize + catchSize + finallySize;
                    var tryBody = new AVM1.AVM1ActionsData(stream.readBytes(trySize), this.dataId + '_t' + stream.position, this._actionsData);
                    var catchBody = new AVM1.AVM1ActionsData(stream.readBytes(catchSize), this.dataId + '_c' + stream.position, this._actionsData);
                    var finallyBody = new AVM1.AVM1ActionsData(stream.readBytes(finallySize), this.dataId + '_z' + stream.position, this._actionsData);
                    args = [
                        catchIsRegisterFlag,
                        catchTarget,
                        tryBody,
                        catchBlockFlag,
                        catchBody,
                        finallyBlockFlag,
                        finallyBody
                    ];
                    break;
                case 137    /* ActionStrictMode */:
                    var mode = stream.readUI8();
                    args = [mode];
                    break;
                }
                stream.position = nextPosition;
                return {
                    position: currentPosition,
                    actionCode: actionCode,
                    actionName: ActionNamesMap[actionCode],
                    args: args
                };
            };
            ActionsDataParser.prototype.skip = function (count) {
                var stream = this._stream;
                while (count > 0 && stream.position < stream.end) {
                    var actionCode = stream.readUI8();
                    var length = actionCode >= 128 ? stream.readUI16() : 0;
                    stream.position += length;
                    count--;
                }
            };
            return ActionsDataParser;
        }();
        AVM1.ActionsDataParser = ActionsDataParser;
        var ActionNamesMap = {
            0: 'EOA',
            4: 'ActionNextFrame',
            5: 'ActionPreviousFrame',
            6: 'ActionPlay',
            7: 'ActionStop',
            8: 'ActionToggleQuality',
            9: 'ActionStopSounds',
            10: 'ActionAdd',
            11: 'ActionSubtract',
            12: 'ActionMultiply',
            13: 'ActionDivide',
            14: 'ActionEquals',
            15: 'ActionLess',
            16: 'ActionAnd',
            17: 'ActionOr',
            18: 'ActionNot',
            19: 'ActionStringEquals',
            20: 'ActionStringLength',
            21: 'ActionStringExtract',
            23: 'ActionPop',
            24: 'ActionToInteger',
            28: 'ActionGetVariable',
            29: 'ActionSetVariable',
            32: 'ActionSetTarget2',
            33: 'ActionStringAdd',
            34: 'ActionGetProperty',
            35: 'ActionSetProperty',
            36: 'ActionCloneSprite',
            37: 'ActionRemoveSprite',
            38: 'ActionTrace',
            39: 'ActionStartDrag',
            40: 'ActionEndDrag',
            41: 'ActionStringLess',
            42: 'ActionThrow',
            43: 'ActionCastOp',
            44: 'ActionImplementsOp',
            45: 'ActionFSCommand2',
            48: 'ActionRandomNumber',
            49: 'ActionMBStringLength',
            50: 'ActionCharToAscii',
            51: 'ActionAsciiToChar',
            52: 'ActionGetTime',
            53: 'ActionMBStringExtract',
            54: 'ActionMBCharToAscii',
            55: 'ActionMBAsciiToChar',
            58: 'ActionDelete',
            59: 'ActionDelete2',
            60: 'ActionDefineLocal',
            61: 'ActionCallFunction',
            62: 'ActionReturn',
            63: 'ActionModulo',
            64: 'ActionNewObject',
            65: 'ActionDefineLocal2',
            66: 'ActionInitArray',
            67: 'ActionInitObject',
            68: 'ActionTypeOf',
            69: 'ActionTargetPath',
            70: 'ActionEnumerate',
            71: 'ActionAdd2',
            72: 'ActionLess2',
            73: 'ActionEquals2',
            74: 'ActionToNumber',
            75: 'ActionToString',
            76: 'ActionPushDuplicate',
            77: 'ActionStackSwap',
            78: 'ActionGetMember',
            79: 'ActionSetMember',
            80: 'ActionIncrement',
            81: 'ActionDecrement',
            82: 'ActionCallMethod',
            83: 'ActionNewMethod',
            84: 'ActionInstanceOf',
            85: 'ActionEnumerate2',
            96: 'ActionBitAnd',
            97: 'ActionBitOr',
            98: 'ActionBitXor',
            99: 'ActionBitLShift',
            100: 'ActionBitRShift',
            101: 'ActionBitURShift',
            102: 'ActionStrictEquals',
            103: 'ActionGreater',
            104: 'ActionStringGreater',
            105: 'ActionExtends',
            129: 'ActionGotoFrame',
            131: 'ActionGetURL',
            135: 'ActionStoreRegister',
            136: 'ActionConstantPool',
            137: 'ActionStrictMode',
            138: 'ActionWaitForFrame',
            139: 'ActionSetTarget',
            140: 'ActionGoToLabel',
            141: 'ActionWaitForFrame2',
            142: 'ActionDefineFunction2',
            143: 'ActionTry',
            148: 'ActionWith',
            150: 'ActionPush',
            153: 'ActionJump',
            154: 'ActionGetURL2',
            155: 'ActionDefineFunction',
            157: 'ActionIf',
            158: 'ActionCall',
            159: 'ActionGotoFrame2'
        };
        var ActionsDataAnalyzer = function () {
            function ActionsDataAnalyzer() {
                this.parentResults = null;
                this.registersLimit = 0;
            }
            ActionsDataAnalyzer.prototype.analyze = function (parser) {
                var actions = [];
                var labels = [0];
                var processedLabels = [true];
                var constantPoolFound = false;
                var singleConstantPoolAt0 = null;
                // Parsing all actions we can reach. Every action will have next position
                // and conditional jump location.
                var queue = [0];
                while (queue.length > 0) {
                    var position = queue.shift();
                    if (actions[position]) {
                        continue;
                    }
                    parser.position = position;
                    // reading block of actions until the first jump of end of actions
                    while (!parser.eof && !actions[position]) {
                        var action = parser.readNext();
                        if (action.actionCode === 0) {
                            break;
                        }
                        var nextPosition = parser.position;
                        var item = {
                            action: action,
                            next: nextPosition,
                            conditionalJumpTo: -1
                        };
                        var jumpPosition = 0;
                        var branching = false;
                        var nonConditionalBranching = false;
                        switch (action.actionCode) {
                        case 138    /* ActionWaitForFrame */:
                        case 141    /* ActionWaitForFrame2 */:
                            branching = true;
                            // skip is specified in amount of actions (instead of bytes)
                            var skipCount = action.actionCode === 138    /* ActionWaitForFrame */ ? action.args[1] : action.args[0];
                            parser.skip(skipCount);
                            jumpPosition = parser.position;
                            parser.position = nextPosition;
                            break;
                        case 153    /* ActionJump */:
                            nonConditionalBranching = true;
                            branching = true;
                            jumpPosition = nextPosition + action.args[0];
                            break;
                        case 157    /* ActionIf */:
                            branching = true;
                            jumpPosition = nextPosition + action.args[0];
                            break;
                        case 42    /* ActionThrow */:
                        case 62    /* ActionReturn */:
                        case 0    /* None */:
                            nonConditionalBranching = true;
                            branching = true;
                            jumpPosition = parser.length;
                            break;
                        case 136    /* ActionConstantPool */:
                            if (constantPoolFound) {
                                singleConstantPoolAt0 = null;
                                // reset if more than one found
                                break;
                            }
                            constantPoolFound = true;
                            if (position === 0) {
                                // For now only counting at position 0 of the block of actions
                                singleConstantPoolAt0 = action.args[0];
                            }
                            break;
                        }
                        if (branching) {
                            if (jumpPosition < 0 || jumpPosition > parser.length) {
                                console.error('jump outside the action block;');
                                jumpPosition = parser.length;
                            }
                            if (nonConditionalBranching) {
                                item.next = jumpPosition;
                            } else {
                                item.conditionalJumpTo = jumpPosition;
                            }
                            if (!processedLabels[jumpPosition]) {
                                labels.push(jumpPosition);
                                queue.push(jumpPosition);
                                processedLabels[jumpPosition] = true;
                            }
                        }
                        actions[position] = item;
                        if (nonConditionalBranching) {
                            break;
                        }
                        position = nextPosition;
                    }
                }
                // Creating blocks for every unique label
                var blocks = [];
                labels.forEach(function (position) {
                    if (!actions[position]) {
                        return;
                    }
                    var items = [];
                    var lastPosition = position;
                    // continue grabbing items until other label or next code exist
                    do {
                        var item = actions[lastPosition];
                        items.push(item);
                        lastPosition = item.next;
                    } while (!processedLabels[lastPosition] && actions[lastPosition]);
                    blocks.push({
                        label: position,
                        items: items,
                        jump: lastPosition
                    });
                });
                // Determines if action blocks (or defined function) is using the single
                // constants pool defined at the beginning of the action block.
                var singleConstantPool = null;
                if (constantPoolFound) {
                    singleConstantPool = singleConstantPoolAt0;
                } else if (this.parentResults) {
                    // Trying to use parent's constant pool if available.
                    singleConstantPool = this.parentResults.singleConstantPool;
                }
                return {
                    actions: actions,
                    blocks: blocks,
                    dataId: parser.dataId,
                    singleConstantPool: singleConstantPool,
                    registersLimit: this.registersLimit
                };
            };
            return ActionsDataAnalyzer;
        }();
        AVM1.ActionsDataAnalyzer = ActionsDataAnalyzer;
    }(AVM1 = Shumway.AVM1 || (Shumway.AVM1 = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    var AVM1;
    (function (AVM1) {
        /**
         * Base class for object instances we prefer to not inherit Object.prototype properties.
         */
        var NullPrototypeObject = function () {
            function NullPrototypeObject() {
            }
            return NullPrototypeObject;
        }();
        AVM1.NullPrototypeObject = NullPrototypeObject;
        // Just assigning class prototype to null will not work, using next best thing.
        NullPrototypeObject.prototype = Object.create(null);
        var AVM1PropertyDescriptor = function () {
            function AVM1PropertyDescriptor(flags, value, get, set, watcher) {
                this.flags = flags;
                this.value = value;
                this.get = get;
                this.set = set;
                this.watcher = watcher;    // Empty block
            }
            return AVM1PropertyDescriptor;
        }();
        AVM1.AVM1PropertyDescriptor = AVM1PropertyDescriptor;
        var DEBUG_PROPERTY_PREFIX = '$Bg';
        /**
         * Base class for the ActionScript AVM1 object.
         */
        var AVM1Object = function (_super) {
            __extends(AVM1Object, _super);
            function AVM1Object(avm1Context) {
                _super.call(this);
                this._avm1Context = avm1Context;
                this._ownProperties = Object.create(null);
                this._prototype = null;
                var self = this;
                // Using IAVM1Callable here to avoid circular calls between AVM1Object and
                // AVM1Function during constructions.
                // TODO do we need to support __proto__ for all SWF versions?
                var getter = {
                    alCall: function (thisArg, args) {
                        return self.alPrototype;
                    }
                };
                var setter = {
                    alCall: function (thisArg, args) {
                        self.alPrototype = args[0];
                    }
                };
                var desc = new AVM1PropertyDescriptor(128    /* ACCESSOR */ | 2    /* DONT_DELETE */ | 1    /* DONT_ENUM */, null, getter, setter);
                this.alSetOwnProperty('__proto__', desc);
            }
            Object.defineProperty(AVM1Object.prototype, 'context', {
                get: function () {
                    return this._avm1Context;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(AVM1Object.prototype, 'alPrototype', {
                get: function () {
                    return this._prototype;
                },
                set: function (v) {
                    // checking for circular references
                    var p = v;
                    while (p) {
                        if (p === this) {
                            return;    // possible loop in __proto__ chain is found
                        }
                        p = p.alPrototype;
                    }
                    // TODO recursive chain check
                    this._prototype = v;
                },
                enumerable: true,
                configurable: true
            });
            AVM1Object.prototype.alGetPrototypeProperty = function () {
                return this.alGet('prototype');
            };
            // TODO shall we add mode for readonly/native flags of the prototype property?
            AVM1Object.prototype.alSetOwnPrototypeProperty = function (v) {
                this.alSetOwnProperty('prototype', new AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */, v));
            };
            AVM1Object.prototype.alGetConstructorProperty = function () {
                return this.alGet('__constructor__');
            };
            AVM1Object.prototype.alSetOwnConstructorProperty = function (v) {
                this.alSetOwnProperty('__constructor__', new AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */, v));
            };
            AVM1Object.prototype._debugEscapeProperty = function (p) {
                var context = this.context;
                var name = alToString(context, p);
                if (!context.isPropertyCaseSensitive) {
                    name = name.toLowerCase();
                }
                return DEBUG_PROPERTY_PREFIX + name;
            };
            AVM1Object.prototype.alGetOwnProperty = function (name) {
                if (typeof name === 'string' && !this.context.isPropertyCaseSensitive) {
                    name = name.toLowerCase();
                }
                release || Shumway.Debug.assert(alIsName(this.context, name));
                // TODO __resolve
                return this._ownProperties[name];
            };
            AVM1Object.prototype.alSetOwnProperty = function (p, desc) {
                var name = this.context.normalizeName(p);
                if (!desc.originalName && !this.context.isPropertyCaseSensitive) {
                    desc.originalName = p;
                }
                if (!release) {
                    Shumway.Debug.assert(desc instanceof AVM1PropertyDescriptor);
                    // Ensure that a descriptor isn't used multiple times. If it were, we couldn't update
                    // values in-place.
                    Shumway.Debug.assert(!desc['owningObject'] || desc['owningObject'] === this);
                    desc['owningObject'] = this;
                    // adding data property on the main object for convenience of debugging.
                    if (desc.flags & 64    /* DATA */ && !(desc.flags & 1    /* DONT_ENUM */)) {
                        Object.defineProperty(this, this._debugEscapeProperty(name), {
                            value: desc.value,
                            enumerable: true,
                            configurable: true
                        });
                    }
                }
                this._ownProperties[name] = desc;
            };
            AVM1Object.prototype.alHasOwnProperty = function (p) {
                var name = this.context.normalizeName(p);
                return !!this._ownProperties[name];
            };
            AVM1Object.prototype.alDeleteOwnProperty = function (p) {
                var name = this.context.normalizeName(p);
                delete this._ownProperties[name];
                if (!release) {
                    delete this[this._debugEscapeProperty(p)];
                }
            };
            AVM1Object.prototype.alGetOwnPropertiesKeys = function () {
                var keys = [];
                if (!this.context.isPropertyCaseSensitive) {
                    for (var name in this._ownProperties) {
                        var desc = this._ownProperties[name];
                        release || Shumway.Debug.assert('originalName' in desc);
                        if (!(desc.flags & 1    /* DONT_ENUM */)) {
                            keys.push(desc.originalName);
                        }
                    }
                } else {
                    for (var name in this._ownProperties) {
                        var desc = this._ownProperties[name];
                        if (!(desc.flags & 1    /* DONT_ENUM */)) {
                            keys.push(name);
                        }
                    }
                }
                return keys;
            };
            AVM1Object.prototype.alGetProperty = function (p) {
                var desc = this.alGetOwnProperty(p);
                if (desc) {
                    return desc;
                }
                if (!this._prototype) {
                    return undefined;
                }
                return this._prototype.alGetProperty(p);
            };
            AVM1Object.prototype.alGet = function (p) {
                name = this.context.normalizeName(p);
                var desc = this.alGetProperty(name);
                if (!desc) {
                    return undefined;
                }
                if (desc.flags & 64    /* DATA */) {
                    return desc.value;
                }
                release || Shumway.Debug.assert(desc.flags & 128    /* ACCESSOR */);
                var getter = desc.get;
                if (!getter) {
                    return undefined;
                }
                return getter.alCall(this);
            };
            AVM1Object.prototype.alCanPut = function (p) {
                var desc = this.alGetOwnProperty(p);
                if (desc) {
                    if (desc.flags & 128    /* ACCESSOR */) {
                        return !!desc.set;
                    } else {
                        return !(desc.flags & 4    /* READ_ONLY */);
                    }
                }
                var proto = this._prototype;
                if (!proto) {
                    return true;
                }
                return proto.alCanPut(p);
            };
            AVM1Object.prototype.alPut = function (p, v) {
                // Perform all lookups with the canonicalized name, but keep the original name around to
                // pass it to `alSetOwnProperty`, which stores it on the descriptor.
                var originalName = p;
                p = this.context.normalizeName(p);
                if (!this.alCanPut(p)) {
                    return;
                }
                var ownDesc = this.alGetOwnProperty(p);
                if (ownDesc && ownDesc.flags & 64    /* DATA */) {
                    if (ownDesc.watcher) {
                        v = ownDesc.watcher.callback.alCall(this, [
                            ownDesc.watcher.name,
                            ownDesc.value,
                            v,
                            ownDesc.watcher.userData
                        ]);
                    }
                    // Real properties (i.e., not things like "_root" on MovieClips) can be updated in-place.
                    if (p in this._ownProperties) {
                        ownDesc.value = v;
                    } else {
                        this.alSetOwnProperty(originalName, new AVM1PropertyDescriptor(ownDesc.flags, v));
                    }
                    return;
                }
                var desc = this.alGetProperty(p);
                if (desc && desc.flags & 128    /* ACCESSOR */) {
                    if (desc.watcher) {
                        var oldValue = desc.get ? desc.get.alCall(this) : undefined;
                        v = desc.watcher.callback.alCall(this, [
                            desc.watcher.name,
                            oldValue,
                            v,
                            desc.watcher.userData
                        ]);
                    }
                    var setter = desc.set;
                    release || Shumway.Debug.assert(setter);
                    setter.alCall(this, [v]);
                } else {
                    if (desc && desc.watcher) {
                        release || Shumway.Debug.assert(desc.flags & 64    /* DATA */);
                        v = desc.watcher.callback.alCall(this, [
                            desc.watcher.name,
                            desc.value,
                            v,
                            desc.watcher.userData
                        ]);
                    }
                    var newDesc = new AVM1PropertyDescriptor(desc ? desc.flags : 64    /* DATA */, v);
                    this.alSetOwnProperty(originalName, newDesc);
                }
            };
            AVM1Object.prototype.alHasProperty = function (p) {
                var desc = this.alGetProperty(p);
                return !!desc;
            };
            AVM1Object.prototype.alDeleteProperty = function (p) {
                var desc = this.alGetOwnProperty(p);
                if (!desc) {
                    return true;
                }
                if (desc.flags & 2    /* DONT_DELETE */) {
                    return false;
                }
                this.alDeleteOwnProperty(p);
                return true;
            };
            AVM1Object.prototype.alAddPropertyWatcher = function (p, callback, userData) {
                // TODO verify/test this functionality to match ActionScript
                var desc = this.alGetProperty(p);
                if (!desc) {
                    return false;
                }
                desc.watcher = {
                    name: p,
                    callback: callback,
                    userData: userData
                };
                return true;
            };
            AVM1Object.prototype.alRemotePropertyWatcher = function (p) {
                var desc = this.alGetProperty(p);
                if (!desc || !desc.watcher) {
                    return false;
                }
                desc.watcher = undefined;
                return true;
            };
            AVM1Object.prototype.alDefaultValue = function (hint) {
                if (hint === void 0) {
                    hint = 0    /* NUMBER */;
                }
                if (hint === 1    /* STRING */) {
                    var toString = this.alGet(this.context.normalizeName('toString'));
                    if (alIsFunction(toString)) {
                        var str = toString.alCall(this);
                        return str;
                    }
                    var valueOf = this.alGet(this.context.normalizeName('valueOf'));
                    if (alIsFunction(valueOf)) {
                        var val = valueOf.alCall(this);
                        return val;
                    }
                } else {
                    release || Shumway.Debug.assert(hint === 0    /* NUMBER */);
                    var valueOf = this.alGet(this.context.normalizeName('valueOf'));
                    if (alIsFunction(valueOf)) {
                        var val = valueOf.alCall(this);
                        return val;
                    }
                    var toString = this.alGet(this.context.normalizeName('toString'));
                    if (alIsFunction(toString)) {
                        var str = toString.alCall(this);
                        return str;
                    }
                }
                // TODO is this a default?
                return this;
            };
            AVM1Object.prototype.alGetKeys = function () {
                var ownKeys = this.alGetOwnPropertiesKeys();
                var proto = this._prototype;
                if (!proto) {
                    return ownKeys;
                }
                var otherKeys = proto.alGetKeys();
                if (ownKeys.length === 0) {
                    return otherKeys;
                }
                // Merging two keys sets
                // TODO check if we shall worry about __proto__ usage here
                var context = this.context;
                // If the context is case-insensitive, names only differing in their casing overwrite each
                // other. Iterating over the keys returns the first original, case-preserved key that was
                // ever used for the property, though.
                if (!context.isPropertyCaseSensitive) {
                    var keyLists = [
                        ownKeys,
                        otherKeys
                    ];
                    var canonicalKeysMap = Object.create(null);
                    var keys = [];
                    for (var k = 0; k < keyLists.length; k++) {
                        var keyList = keyLists[k];
                        for (var i = keyList.length; i--;) {
                            var key = keyList[i];
                            var canonicalKey = context.normalizeName(key);
                            if (canonicalKeysMap[canonicalKey]) {
                                continue;
                            }
                            canonicalKeysMap[canonicalKey] = true;
                            keys.push(key);
                        }
                    }
                    return keys;
                } else {
                    var processed = Object.create(null);
                    for (var i = 0; i < ownKeys.length; i++) {
                        processed[ownKeys[i]] = true;
                    }
                    for (var i = 0; i < otherKeys.length; i++) {
                        processed[otherKeys[i]] = true;
                    }
                    return Object.getOwnPropertyNames(processed);
                }
            };
            return AVM1Object;
        }(NullPrototypeObject);
        AVM1.AVM1Object = AVM1Object;
        /**
         * Base class for ActionsScript functions.
         */
        var AVM1Function = function (_super) {
            __extends(AVM1Function, _super);
            function AVM1Function(context) {
                _super.call(this, context);
                this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
            }
            AVM1Function.prototype.alConstruct = function (args) {
                throw new Error('not implemented AVM1Function.alConstruct');
            };
            AVM1Function.prototype.alCall = function (thisArg, args) {
                throw new Error('not implemented AVM1Function.alCall');
            };
            /**
             * Wraps the function to the callable JavaScript function.
             * @returns {Function} a JavaScript function.
             */
            AVM1Function.prototype.toJSFunction = function (thisArg) {
                if (thisArg === void 0) {
                    thisArg = null;
                }
                var fn = this;
                var context = this.context;
                return function () {
                    var args = Array.prototype.slice.call(arguments, 0);
                    return context.executeFunction(fn, thisArg, args);
                };
            };
            return AVM1Function;
        }(AVM1Object);
        AVM1.AVM1Function = AVM1Function;
        /**
         * Base class for ActionScript functions with native JavaScript implementation.
         */
        var AVM1NativeFunction = function (_super) {
            __extends(AVM1NativeFunction, _super);
            /**
             * @param {IAVM1Context} context
             * @param {Function} fn The native function for regular calling.
             * @param {Function} ctor The native function for construction.
             */
            function AVM1NativeFunction(context, fn, ctor) {
                _super.call(this, context);
                this._fn = fn;
                if (ctor) {
                    this._ctor = ctor;
                }
            }
            AVM1NativeFunction.prototype.alConstruct = function (args) {
                if (!this._ctor) {
                    throw new Error('not a constructor');
                }
                return this._ctor.apply(this, args);
            };
            AVM1NativeFunction.prototype.alCall = function (thisArg, args) {
                if (!this._fn) {
                    throw new Error('not callable');
                }
                return this._fn.apply(thisArg, args);
            };
            return AVM1NativeFunction;
        }(AVM1Function);
        AVM1.AVM1NativeFunction = AVM1NativeFunction;
        /**
         * Base class the is used for the interpreter.
         * See {AVM1InterpretedFunction} implementation
         */
        var AVM1EvalFunction = function (_super) {
            __extends(AVM1EvalFunction, _super);
            function AVM1EvalFunction(context) {
                _super.call(this, context);
                var proto = new AVM1Object(context);
                proto.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                proto.alSetOwnProperty('constructor', new AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */ | 2    /* DONT_DELETE */));
                this.alSetOwnPrototypeProperty(proto);
            }
            AVM1EvalFunction.prototype.alConstruct = function (args) {
                var obj = new AVM1Object(this.context);
                var objPrototype = this.alGetPrototypeProperty();
                if (!(objPrototype instanceof AVM1Object)) {
                    objPrototype = this.context.builtins.Object.alGetPrototypeProperty();
                }
                obj.alPrototype = objPrototype;
                obj.alSetOwnConstructorProperty(this);
                var result = this.alCall(obj, args);
                return result instanceof AVM1Object ? result : obj;
            };
            return AVM1EvalFunction;
        }(AVM1Function);
        AVM1.AVM1EvalFunction = AVM1EvalFunction;
        // TODO create classes for the ActionScript errors.
        function AVM1TypeError(msg) {
        }
        AVM1TypeError.prototype = Object.create(Error.prototype);
        function alToPrimitive(context, v, preferredType) {
            if (!(v instanceof AVM1Object)) {
                return v;
            }
            var obj = v;
            return preferredType !== undefined ? obj.alDefaultValue(preferredType) : obj.alDefaultValue();
        }
        AVM1.alToPrimitive = alToPrimitive;
        function alToBoolean(context, v) {
            switch (typeof v) {
            case 'undefined':
                return false;
            case 'object':
                return v !== null;
            case 'boolean':
                return v;
            case 'string':
            case 'number':
                return !!v;
            default:
                release || Shumway.Debug.assert(false);
            }
        }
        AVM1.alToBoolean = alToBoolean;
        function alToNumber(context, v) {
            if (typeof v === 'object' && v !== null) {
                v = alToPrimitive(context, v, 0    /* NUMBER */);
            }
            switch (typeof v) {
            case 'undefined':
                return context.swfVersion >= 7 ? NaN : 0;
            case 'object':
                if (v === null) {
                    return context.swfVersion >= 7 ? NaN : 0;
                }
                return context.swfVersion >= 5 ? NaN : 0;
            case 'boolean':
                return v ? 1 : 0;
            case 'number':
                return v;
            case 'string':
                if (v === '' && context.swfVersion < 5) {
                    return 0;
                }
                return +v;
            default:
                release || Shumway.Debug.assert(false);
            }
        }
        AVM1.alToNumber = alToNumber;
        function alToInteger(context, v) {
            var n = alToNumber(context, v);
            if (isNaN(n)) {
                return 0;
            }
            if (n === 0 || n === Number.POSITIVE_INFINITY || n === Number.NEGATIVE_INFINITY) {
                return n;
            }
            return n < 0 ? Math.ceil(n) : Math.floor(n);
        }
        AVM1.alToInteger = alToInteger;
        function alToInt32(context, v) {
            var n = alToNumber(context, v);
            return n | 0;
        }
        AVM1.alToInt32 = alToInt32;
        function alToString(context, v) {
            if (typeof v === 'object' && v !== null) {
                v = alToPrimitive(context, v, 1    /* STRING */);
            }
            switch (typeof v) {
            case 'undefined':
                return context.swfVersion >= 7 ? 'undefined' : '';
            case 'object':
                if (v === null) {
                    return 'null';
                }
                return '[type ' + alGetObjectClass(v) + ']';
            case 'boolean':
                return v ? 'true' : 'false';
            case 'number':
                return v + '';
            case 'string':
                return v;
            default:
                release || Shumway.Debug.assert(false);
            }
        }
        AVM1.alToString = alToString;
        function alIsName(context, v) {
            return typeof v === 'number' || typeof v === 'string' && (context.isPropertyCaseSensitive || v === v.toLowerCase());
        }
        AVM1.alIsName = alIsName;
        function alToObject(context, v) {
            switch (typeof v) {
            case 'undefined':
                throw new AVM1TypeError();
            case 'object':
                if (v === null) {
                    throw new AVM1TypeError();
                }
                // TODO verify if all objects here are inherited from AVM1Object
                if (Array.isArray(v)) {
                    return new AVM1.Natives.AVM1ArrayNative(context, v);
                }
                return v;
            case 'boolean':
                return new AVM1.Natives.AVM1BooleanNative(context, v);
            case 'number':
                return new AVM1.Natives.AVM1NumberNative(context, v);
            case 'string':
                return new AVM1.Natives.AVM1StringNative(context, v);
            default:
                release || Shumway.Debug.assert(false);
            }
        }
        AVM1.alToObject = alToObject;
        function alNewObject(context) {
            var obj = new AVM1Object(context);
            obj.alPrototype = context.builtins.Object.alGetPrototypeProperty();
            obj.alSetOwnConstructorProperty(context.builtins.Object);
            return obj;
        }
        AVM1.alNewObject = alNewObject;
        function alGetObjectClass(obj) {
            if (obj instanceof AVM1Function) {
                return 'Function';
            }
            // TODO more cases
            return 'Object';
        }
        AVM1.alGetObjectClass = alGetObjectClass;
        /**
         * Non-standard string coercion function roughly matching the behavior of AVM2's axCoerceString.
         *
         * This is useful when dealing with AVM2 objects in the implementation of AVM1 builtins: they
         * frequently expect either a string or `null`, but not `undefined`.
         */
        function alCoerceString(context, x) {
            if (x instanceof AVM1Object) {
                return alToString(context, x);
            }
            return Shumway.AVMX.axCoerceString(x);
        }
        AVM1.alCoerceString = alCoerceString;
        function alCoerceNumber(context, x) {
            if (Shumway.isNullOrUndefined(x)) {
                return undefined;
            }
            return alToNumber(context, x);
        }
        AVM1.alCoerceNumber = alCoerceNumber;
        function alIsIndex(context, p) {
            if (p instanceof AVM1Object) {
                return Shumway.isIndex(alToString(context, p));
            }
            return Shumway.isIndex(p);
        }
        AVM1.alIsIndex = alIsIndex;
        function alForEachProperty(obj, fn, thisArg) {
            obj.alGetKeys().forEach(fn, thisArg);
        }
        AVM1.alForEachProperty = alForEachProperty;
        function alIsFunction(obj) {
            return obj instanceof AVM1Function;
        }
        AVM1.alIsFunction = alIsFunction;
        function alCallProperty(obj, p, args) {
            var callable = obj.alGet(p);
            callable.alCall(obj, args);
        }
        AVM1.alCallProperty = alCallProperty;
        function alInstanceOf(context, obj, cls) {
            if (!(obj instanceof AVM1Object)) {
                return false;
            }
            if (!(cls instanceof AVM1Object)) {
                return false;
            }
            var proto = cls.alGetPrototypeProperty();
            for (var i = obj; i; i = i.alPrototype) {
                if (i === proto) {
                    return true;
                }
            }
            return false;
        }
        AVM1.alInstanceOf = alInstanceOf;
        function alIsArray(context, v) {
            return alInstanceOf(context, v, context.builtins.Array);
        }
        AVM1.alIsArray = alIsArray;
        function alIsArrayLike(context, v) {
            if (!(v instanceof AVM1Object)) {
                return false;
            }
            var length = alToInteger(context, v.alGet('length'));
            if (isNaN(length) || length < 0 || length >= 4294967296) {
                return false;
            }
            return true;
        }
        AVM1.alIsArrayLike = alIsArrayLike;
        function alIterateArray(context, arr, fn, thisArg) {
            if (thisArg === void 0) {
                thisArg = null;
            }
            var length = alToInteger(context, arr.alGet('length'));
            if (isNaN(length) || length >= 4294967296) {
                return;
            }
            for (var i = 0; i < length; i++) {
                fn.call(thisArg, arr.alGet(i), i);
            }
        }
        AVM1.alIterateArray = alIterateArray;
        function alIsString(context, v) {
            return typeof v === 'string';
        }
        AVM1.alIsString = alIsString;
        function alDefineObjectProperties(obj, descriptors) {
            var context = obj.context;
            Object.getOwnPropertyNames(descriptors).forEach(function (name) {
                var desc = descriptors[name];
                var value, getter, setter;
                var flags = 0;
                if (typeof desc === 'object') {
                    if (desc.get || desc.set) {
                        getter = desc.get ? new AVM1NativeFunction(context, desc.get) : undefined;
                        setter = desc.set ? new AVM1NativeFunction(context, desc.set) : undefined;
                        flags |= 128    /* ACCESSOR */;
                    } else {
                        value = desc.value;
                        if (typeof value === 'function') {
                            value = new AVM1NativeFunction(context, value);
                        }
                        flags |= 64    /* DATA */;
                        if (!desc.writable) {
                            flags |= 4    /* READ_ONLY */;
                        }
                    }
                    if (!desc.enumerable) {
                        flags |= 1    /* DONT_ENUM */;
                    }
                    if (!desc.configurable) {
                        flags |= 2    /* DONT_DELETE */;
                    }
                } else {
                    value = desc;
                    if (typeof value === 'function') {
                        value = new AVM1NativeFunction(context, value);
                    }
                    flags |= 64    /* DATA */ | 2    /* DONT_DELETE */ | 1    /* DONT_ENUM */ | 4    /* READ_ONLY */;
                }
                obj.alSetOwnProperty(name, new AVM1PropertyDescriptor(flags, value, getter, setter));
            });
        }
        AVM1.alDefineObjectProperties = alDefineObjectProperties;
        var Natives;
        (function (Natives) {
            // Object natives
            var AVM1ObjectPrototype = function (_super) {
                __extends(AVM1ObjectPrototype, _super);
                function AVM1ObjectPrototype(context) {
                    _super.call(this, context);    // Initialization must be perfromed later after the Function creation.
                                                   // See the _initializePrototype and createBuiltins below.
                }
                AVM1ObjectPrototype.prototype._initializePrototype = function () {
                    var context = this.context;
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: context.builtins.Object,
                            writable: true
                        },
                        valueOf: {
                            value: this._valueOf,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        },
                        addProperty: { value: this.addProperty },
                        hasOwnProperty: { value: this.hasOwnProperty },
                        isPropertyEnumerable: { value: this.isPropertyEnumerable },
                        isPrototypeOf: { value: this.isPrototypeOf },
                        unwatch: { value: this.unwatch },
                        watch: { value: this.watch }
                    });
                };
                AVM1ObjectPrototype.prototype._valueOf = function () {
                    return this;
                };
                AVM1ObjectPrototype.prototype._toString = function () {
                    if (AVM1.alIsFunction(this)) {
                        // Really weird case of functions.
                        return '[type ' + AVM1.alGetObjectClass(this) + ']';
                    }
                    return '[object ' + AVM1.alGetObjectClass(this) + ']';
                };
                AVM1ObjectPrototype.prototype.addProperty = function (name, getter, setter) {
                    if (typeof name !== 'string' || name === '') {
                        return false;
                    }
                    if (!AVM1.alIsFunction(getter)) {
                        return false;
                    }
                    if (!AVM1.alIsFunction(setter) && setter !== null) {
                        return false;
                    }
                    var desc = this.alGetOwnProperty(name);
                    if (desc && !!(desc.flags & 2    /* DONT_DELETE */)) {
                        return false;    // protected property
                    }
                    this.alSetOwnProperty(name, new AVM1.AVM1PropertyDescriptor(128    /* ACCESSOR */, null, getter, setter || undefined));
                    return true;
                };
                AVM1ObjectPrototype.prototype.hasOwnProperty = function (name) {
                    return this.alHasOwnProperty(name);
                };
                AVM1ObjectPrototype.prototype.isPropertyEnumerable = function (name) {
                    var desc = this.alGetProperty(name);
                    return !(desc.flags & 1    /* DONT_ENUM */);
                };
                AVM1ObjectPrototype.prototype.isPrototypeOf = function (theClass) {
                    return AVM1.alInstanceOf(this.context, this, theClass);
                };
                AVM1ObjectPrototype.prototype.unwatch = function (name) {
                    name = AVM1.alCoerceString(this.context, name);
                    return this.alRemotePropertyWatcher(name);
                };
                AVM1ObjectPrototype.prototype.watch = function (name, callback, userData) {
                    name = AVM1.alCoerceString(this.context, name);
                    if (!AVM1.alIsFunction(callback)) {
                        return false;
                    }
                    return this.alAddPropertyWatcher(name, callback, userData);
                };
                return AVM1ObjectPrototype;
            }(AVM1.AVM1Object);
            var AVM1ObjectFunction = function (_super) {
                __extends(AVM1ObjectFunction, _super);
                function AVM1ObjectFunction(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
                    var proto = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        prototype: { value: proto },
                        registerClass: { value: this.registerClass }
                    });
                }
                AVM1ObjectFunction.prototype.registerClass = function (name, theClass) {
                    this.context.registerClass(name, theClass);
                };
                AVM1ObjectFunction.prototype.alConstruct = function (args) {
                    if (args) {
                        var value = args[0];
                        if (value instanceof AVM1.AVM1Object) {
                            return value;
                        }
                        switch (typeof value) {
                        case 'string':
                        case 'boolean':
                        case 'number':
                            return AVM1.alToObject(this.context, value);
                        }
                    }
                    // null or undefined
                    return AVM1.alNewObject(this.context);
                };
                AVM1ObjectFunction.prototype.alCall = function (thisArg, args) {
                    if (!args || args[0] === null || args[0] === undefined) {
                        return AVM1.alNewObject(this.context);
                    }
                    return AVM1.alToObject(this.context, args[0]);
                };
                return AVM1ObjectFunction;
            }(AVM1.AVM1Function);
            Natives.AVM1ObjectFunction = AVM1ObjectFunction;
            // Function natives
            var AVM1FunctionPrototype = function (_super) {
                __extends(AVM1FunctionPrototype, _super);
                function AVM1FunctionPrototype(context) {
                    _super.call(this, context);
                }
                AVM1FunctionPrototype.prototype._initializePrototype = function () {
                    var context = this.context;
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: context.builtins.Function,
                            writable: true
                        },
                        call: this.call,
                        apply: this.apply
                    });
                };
                AVM1FunctionPrototype.prototype.call = function (thisArg) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    var fn = alEnsureType(this, AVM1.AVM1Function);
                    return fn.alCall(thisArg, args);
                };
                AVM1FunctionPrototype.prototype.apply = function (thisArg, args) {
                    var fn = alEnsureType(this, AVM1.AVM1Function);
                    var nativeArgs = !args ? undefined : alEnsureType(args, AVM1ArrayNative).value;
                    return fn.alCall(thisArg, nativeArgs);
                };
                return AVM1FunctionPrototype;
            }(AVM1.AVM1Object);
            var AVM1FunctionFunction = function (_super) {
                __extends(AVM1FunctionFunction, _super);
                function AVM1FunctionFunction(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
                    var proto = context.builtins.Function.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, { prototype: { value: proto } });
                }
                AVM1FunctionFunction.prototype.alConstruct = function (args) {
                    // ActionScript just returns the first argument.
                    return args ? args[0] : undefined;
                };
                AVM1FunctionFunction.prototype.alCall = function (thisArg, args) {
                    // ActionScript just returns the first argument.
                    return args ? args[0] : undefined;
                };
                return AVM1FunctionFunction;
            }(AVM1.AVM1Function);
            Natives.AVM1FunctionFunction = AVM1FunctionFunction;
            // Boolean natives
            var AVM1BooleanNative = function (_super) {
                __extends(AVM1BooleanNative, _super);
                function AVM1BooleanNative(context, value) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Boolean.alGetPrototypeProperty();
                    this.alSetOwnConstructorProperty(context.builtins.Boolean);
                    this.value = value;
                }
                AVM1BooleanNative.prototype.valueOf = function () {
                    return this.value;
                };
                return AVM1BooleanNative;
            }(AVM1.AVM1Object);
            Natives.AVM1BooleanNative = AVM1BooleanNative;
            var AVM1BooleanPrototype = function (_super) {
                __extends(AVM1BooleanPrototype, _super);
                function AVM1BooleanPrototype(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: context.builtins.Boolean,
                            writable: true
                        },
                        valueOf: {
                            value: this._valueOf,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        }
                    });
                }
                AVM1BooleanPrototype.prototype._valueOf = function () {
                    var native = alEnsureType(this, AVM1BooleanNative);
                    return native.value;
                };
                AVM1BooleanPrototype.prototype._toString = function () {
                    var native = alEnsureType(this, AVM1BooleanNative);
                    return native.value ? 'true' : 'false';
                };
                return AVM1BooleanPrototype;
            }(AVM1.AVM1Object);
            Natives.AVM1BooleanPrototype = AVM1BooleanPrototype;
            var AVM1BooleanFunction = function (_super) {
                __extends(AVM1BooleanFunction, _super);
                function AVM1BooleanFunction(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
                    var proto = new AVM1BooleanPrototype(context);
                    AVM1.alDefineObjectProperties(this, { prototype: { value: proto } });
                }
                AVM1BooleanFunction.prototype.alConstruct = function (args) {
                    var value = args ? AVM1.alToBoolean(this.context, args[0]) : false;
                    return new AVM1BooleanNative(this.context, value);
                };
                AVM1BooleanFunction.prototype.alCall = function (thisArg, args) {
                    // TODO returns boolean value?
                    var value = args ? AVM1.alToBoolean(this.context, args[0]) : false;
                    return value;
                };
                return AVM1BooleanFunction;
            }(AVM1.AVM1Function);
            Natives.AVM1BooleanFunction = AVM1BooleanFunction;
            // Number natives
            var AVM1NumberNative = function (_super) {
                __extends(AVM1NumberNative, _super);
                function AVM1NumberNative(context, value) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Number.alGetPrototypeProperty();
                    this.alSetOwnConstructorProperty(context.builtins.Number);
                    this.value = value;
                }
                AVM1NumberNative.prototype.valueOf = function () {
                    return this.value;
                };
                return AVM1NumberNative;
            }(AVM1.AVM1Object);
            Natives.AVM1NumberNative = AVM1NumberNative;
            var AVM1NumberPrototype = function (_super) {
                __extends(AVM1NumberPrototype, _super);
                function AVM1NumberPrototype(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: context.builtins.Number,
                            writable: true
                        },
                        valueOf: {
                            value: this._valueOf,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        }
                    });
                }
                AVM1NumberPrototype.prototype._valueOf = function () {
                    var native = alEnsureType(this, AVM1NumberNative);
                    return native.value;
                };
                AVM1NumberPrototype.prototype._toString = function (radix) {
                    var native = alEnsureType(this, AVM1NumberNative);
                    return native.value.toString(radix || 10);
                };
                return AVM1NumberPrototype;
            }(AVM1.AVM1Object);
            Natives.AVM1NumberPrototype = AVM1NumberPrototype;
            var AVM1NumberFunction = function (_super) {
                __extends(AVM1NumberFunction, _super);
                function AVM1NumberFunction(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
                    var proto = new AVM1NumberPrototype(context);
                    AVM1.alDefineObjectProperties(this, {
                        prototype: { value: proto },
                        MAX_VALUE: Number.MAX_VALUE,
                        MIN_VALUE: Number.MIN_VALUE,
                        NaN: Number.NaN,
                        NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY,
                        POSITIVE_INFINITY: Number.POSITIVE_INFINITY
                    });
                }
                AVM1NumberFunction.prototype.alConstruct = function (args) {
                    var value = args ? AVM1.alToNumber(this.context, args[0]) : 0;
                    return new AVM1NumberNative(this.context, value);
                };
                AVM1NumberFunction.prototype.alCall = function (thisArg, args) {
                    // TODO returns number value?
                    var value = args ? AVM1.alToNumber(this.context, args[0]) : 0;
                    return value;
                };
                return AVM1NumberFunction;
            }(AVM1.AVM1Function);
            Natives.AVM1NumberFunction = AVM1NumberFunction;
            // String natives
            var AVM1StringNative = function (_super) {
                __extends(AVM1StringNative, _super);
                function AVM1StringNative(context, value) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.String.alGetPrototypeProperty();
                    this.alSetOwnConstructorProperty(context.builtins.String);
                    this.value = value;
                }
                AVM1StringNative.prototype.toString = function () {
                    return this.value;
                };
                return AVM1StringNative;
            }(AVM1.AVM1Object);
            Natives.AVM1StringNative = AVM1StringNative;
            // Most of the methods of String prototype are generic and accept any object.
            var AVM1StringPrototype = function (_super) {
                __extends(AVM1StringPrototype, _super);
                function AVM1StringPrototype(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: context.builtins.String,
                            writable: true
                        },
                        valueOf: {
                            value: this._valueOf,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        },
                        length: { get: this.getLength },
                        charAt: {
                            value: this.charAt,
                            writable: true
                        },
                        charCodeAt: {
                            value: this.charCodeAt,
                            writable: true
                        },
                        concat: {
                            value: this.concat,
                            writable: true
                        },
                        indexOf: {
                            value: this.indexOf,
                            writable: true
                        },
                        lastIndexOf: {
                            value: this.lastIndexOf,
                            writable: true
                        },
                        slice: {
                            value: this.slice,
                            writable: true
                        },
                        split: {
                            value: this.split,
                            writable: true
                        },
                        substr: {
                            value: this.substr,
                            writable: true
                        },
                        substring: {
                            value: this.substring,
                            writable: true
                        },
                        toLowerCase: {
                            value: this.toLowerCase,
                            writable: true
                        },
                        toUpperCase: {
                            value: this.toUpperCase,
                            writable: true
                        }
                    });
                }
                AVM1StringPrototype.prototype._valueOf = function () {
                    var native = alEnsureType(this, AVM1StringNative);
                    return native.value;
                };
                AVM1StringPrototype.prototype._toString = function () {
                    var native = alEnsureType(this, AVM1StringNative);
                    return native.value;
                };
                AVM1StringPrototype.prototype.getLength = function () {
                    var native = alEnsureType(this, AVM1StringNative);
                    return native.value.length;
                };
                AVM1StringPrototype.prototype.charAt = function (index) {
                    var value = AVM1.alToString(this.context, this);
                    return value.charAt(AVM1.alToInteger(this.context, index));
                };
                AVM1StringPrototype.prototype.charCodeAt = function (index) {
                    var value = AVM1.alToString(this.context, this);
                    return value.charCodeAt(AVM1.alToInteger(this.context, index));
                };
                AVM1StringPrototype.prototype.concat = function () {
                    var items = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        items[_i - 0] = arguments[_i];
                    }
                    var stringItems = [AVM1.alToString(this.context, this)];
                    for (var i = 0; i < items.length; ++i) {
                        stringItems.push(AVM1.alToString(this.context, items[i]));
                    }
                    return stringItems.join('');
                };
                AVM1StringPrototype.prototype.indexOf = function (searchString, position) {
                    var value = AVM1.alToString(this.context, this);
                    searchString = AVM1.alToString(this.context, searchString);
                    position = AVM1.alToInteger(this.context, position);
                    return value.indexOf(searchString, position);
                };
                AVM1StringPrototype.prototype.lastIndexOf = function (searchString, position) {
                    var value = AVM1.alToString(this.context, this);
                    searchString = AVM1.alToString(this.context, searchString);
                    position = arguments.length < 2 ? NaN : AVM1.alToNumber(this.context, position);
                    // SWF6 alToNumber(undefined) === 0
                    if (position < 0) {
                        // Different from JS
                        return -1;
                    }
                    return value.lastIndexOf(searchString, isNaN(position) ? undefined : position);
                };
                AVM1StringPrototype.prototype.slice = function (start, end) {
                    if (arguments.length === 0) {
                        // Different from JS
                        return undefined;
                    }
                    var value = AVM1.alToString(this.context, this);
                    start = AVM1.alToInteger(this.context, start);
                    end = end === undefined ? undefined : AVM1.alToInteger(this.context, end);
                    return value.slice(start, end);
                };
                AVM1StringPrototype.prototype.split = function (separator, limit) {
                    var value = AVM1.alToString(this.context, this);
                    // TODO separator as regular expression?
                    separator = AVM1.alToString(this.context, separator);
                    limit = (limit === undefined ? ~0 : AVM1.alToInt32(this.context, limit)) >>> 0;
                    return new AVM1ArrayNative(this.context, value.split(separator, limit));
                };
                AVM1StringPrototype.prototype.substr = function (start, length) {
                    // Different from JS
                    var value = AVM1.alToString(this.context, this);
                    var valueLength = value.length;
                    start = AVM1.alToInteger(this.context, start);
                    length = length === undefined ? valueLength : AVM1.alToInteger(this.context, length);
                    if (start < 0) {
                        start = Math.max(0, valueLength + start);
                    }
                    if (length < 0) {
                        if (-length <= start) {
                            return '';
                        }
                        length = Math.max(0, valueLength + length);
                    }
                    return value.substr(start, length);
                };
                AVM1StringPrototype.prototype.substring = function (start, end) {
                    var value = AVM1.alToString(this.context, this);
                    start = AVM1.alToInteger(this.context, start);
                    if (start >= value.length) {
                        // Different from JS
                        return '';
                    }
                    end = end === undefined ? undefined : AVM1.alToInteger(this.context, end);
                    return value.substring(start, end);
                };
                AVM1StringPrototype.prototype.toLowerCase = function () {
                    var value = AVM1.alToString(this.context, this);
                    return value.toLowerCase();
                };
                AVM1StringPrototype.prototype.toUpperCase = function () {
                    var value = AVM1.alToString(this.context, this);
                    return value.toUpperCase();
                };
                return AVM1StringPrototype;
            }(AVM1.AVM1Object);
            Natives.AVM1StringPrototype = AVM1StringPrototype;
            var AVM1StringFunction = function (_super) {
                __extends(AVM1StringFunction, _super);
                function AVM1StringFunction(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
                    var proto = new AVM1StringPrototype(context);
                    AVM1.alDefineObjectProperties(this, {
                        prototype: { value: proto },
                        fromCharCode: { value: this.fromCharCode }
                    });
                }
                AVM1StringFunction.prototype.alConstruct = function (args) {
                    var value = args ? AVM1.alToString(this.context, args[0]) : '';
                    return new AVM1StringNative(this.context, value);
                };
                AVM1StringFunction.prototype.alCall = function (thisArg, args) {
                    var value = args ? AVM1.alToString(this.context, args[0]) : '';
                    return value;
                };
                AVM1StringFunction.prototype.fromCharCode = function () {
                    var _this = this;
                    var codes = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        codes[_i - 0] = arguments[_i];
                    }
                    codes = codes.map(function (code) {
                        return AVM1.alToInt32(_this.context, code) & 65535;
                    });
                    return String.fromCharCode.apply(String, codes);
                };
                return AVM1StringFunction;
            }(AVM1.AVM1Function);
            Natives.AVM1StringFunction = AVM1StringFunction;
            // Array natives
            var cachedArrayPropertyDescriptor = new AVM1.AVM1PropertyDescriptor(64    /* DATA */, undefined);
            var AVM1ArrayNative = function (_super) {
                __extends(AVM1ArrayNative, _super);
                function AVM1ArrayNative(context, value) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Array.alGetPrototypeProperty();
                    this.alSetOwnConstructorProperty(context.builtins.Array);
                    this.value = value;
                }
                AVM1ArrayNative.prototype.alGetOwnProperty = function (p) {
                    if (AVM1.alIsIndex(this.context, p)) {
                        var index = AVM1.alToInt32(this.context, p);
                        if (Object.getOwnPropertyDescriptor(this.value, index)) {
                            cachedArrayPropertyDescriptor.value = this.value[index];
                            return cachedArrayPropertyDescriptor;
                        }
                    }
                    return _super.prototype.alGetOwnProperty.call(this, p);
                };
                AVM1ArrayNative.prototype.alSetOwnProperty = function (p, v) {
                    if (AVM1.alIsIndex(this.context, p)) {
                        var index = AVM1.alToInt32(this.context, p);
                        if (!(v.flags & 64    /* DATA */) || !!(v.flags & 1    /* DONT_ENUM */) || !!(v.flags & 2    /* DONT_DELETE */)) {
                            throw new Error('Special property is non-supported for array');
                        }
                        this.value[index] = v.value;
                        return;
                    }
                    _super.prototype.alSetOwnProperty.call(this, p, v);
                };
                AVM1ArrayNative.prototype.alDeleteOwnProperty = function (p) {
                    if (AVM1.alIsIndex(this.context, p)) {
                        var index = AVM1.alToInt32(this.context, p);
                        delete this.value[index];
                        return;
                    }
                    _super.prototype.alDeleteOwnProperty.call(this, p);
                };
                AVM1ArrayNative.prototype.alGetOwnPropertiesKeys = function () {
                    var keys = _super.prototype.alGetOwnPropertiesKeys.call(this);
                    var itemIndices = [];
                    for (var i in this.value) {
                        itemIndices.push(i);
                    }
                    return itemIndices.concat(keys);
                };
                /**
                 * Creates a JavaScript array from the AVM1 list object.
                 * @param arr     An array-like AVM1 object.
                 * @param fn      A function that converts AVM1 list object item to JavaScript object.
                 * @param thisArg Optional. Value to use as this when executing fn.
                 * @returns {any[]} A JavaScript array.
                 */
                AVM1ArrayNative.mapToJSArray = function (arr, fn, thisArg) {
                    if (arr instanceof AVM1ArrayNative) {
                        return arr.value.map(fn, thisArg);
                    }
                    // This method is generic, so array-like objects can use it.
                    if (!AVM1.alIsArrayLike(arr.context, arr)) {
                        // TODO generate proper AVM1 exception.
                        throw new Error('Invalid type');    // Interpreter will catch this.
                    }
                    var result = [];
                    AVM1.alIterateArray(arr.context, arr, function (item, index) {
                        result.push(fn.call(thisArg, item, index));
                    });
                    return result;
                };
                return AVM1ArrayNative;
            }(AVM1.AVM1Object);
            Natives.AVM1ArrayNative = AVM1ArrayNative;
            var AVM1ArraySortOnOptions;
            (function (AVM1ArraySortOnOptions) {
                AVM1ArraySortOnOptions[AVM1ArraySortOnOptions['CASEINSENSITIVE'] = 1] = 'CASEINSENSITIVE';
                AVM1ArraySortOnOptions[AVM1ArraySortOnOptions['DESCENDING'] = 2] = 'DESCENDING';
                AVM1ArraySortOnOptions[AVM1ArraySortOnOptions['UNIQUESORT'] = 4] = 'UNIQUESORT';
                AVM1ArraySortOnOptions[AVM1ArraySortOnOptions['RETURNINDEXEDARRAY'] = 8] = 'RETURNINDEXEDARRAY';
                AVM1ArraySortOnOptions[AVM1ArraySortOnOptions['NUMERIC'] = 16] = 'NUMERIC';
            }(AVM1ArraySortOnOptions || (AVM1ArraySortOnOptions = {})));
            // TODO implement all the Array class and its prototype natives
            var AVM1ArrayPrototype = function (_super) {
                __extends(AVM1ArrayPrototype, _super);
                function AVM1ArrayPrototype(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: context.builtins.Array,
                            writable: true
                        },
                        join: {
                            value: this.join,
                            writable: true
                        },
                        length: {
                            get: this.getLength,
                            set: this.setLength
                        },
                        concat: {
                            value: this.concat,
                            writable: true
                        },
                        pop: {
                            value: this.pop,
                            writable: true
                        },
                        push: {
                            value: this.push,
                            writable: true
                        },
                        shift: {
                            value: this.shift,
                            writable: true
                        },
                        slice: {
                            value: this.slice,
                            writable: true
                        },
                        splice: {
                            value: this.splice,
                            writable: true
                        },
                        sort: {
                            value: this.sort,
                            writable: true
                        },
                        sortOn: {
                            value: this.sortOn,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        },
                        unshift: {
                            value: this.unshift,
                            writable: true
                        }
                    });
                }
                AVM1ArrayPrototype.prototype._toString = function () {
                    var join = this.context.builtins.Array.alGetPrototypeProperty().alGet('join');
                    return join.alCall(this);
                };
                AVM1ArrayPrototype.prototype.getLength = function () {
                    var arr = alEnsureType(this, AVM1ArrayNative).value;
                    return arr.length;
                };
                AVM1ArrayPrototype.prototype.setLength = function (length) {
                    if (!Shumway.isIndex(length)) {
                        return;    // no action on invalid length
                    }
                    length = AVM1.alToInt32(this.context, length) >>> 0;
                    var arr = alEnsureType(this, AVM1ArrayNative).value;
                    arr.length = length;
                };
                AVM1ArrayPrototype.prototype.concat = function () {
                    var items = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        items[_i - 0] = arguments[_i];
                    }
                    if (this instanceof AVM1ArrayNative) {
                        // Faster case for native array implementation
                        var arr = alEnsureType(this, AVM1ArrayNative).value;
                        for (var i = 0; i < arr.length; i++) {
                            if (items[i] instanceof AVM1ArrayNative) {
                                items[i] = alEnsureType(items[i], AVM1ArrayNative).value;
                            }
                        }
                        return new AVM1ArrayNative(this.context, Array.prototype.concat.apply(arr, items));
                    }
                    // Generic behavior
                    var a = [];
                    var e = this;
                    var isArrayObject = AVM1.alIsArrayLike(this.context, this);
                    var i = 0;
                    while (true) {
                        if (isArrayObject) {
                            AVM1.alIterateArray(this.context, e, function (value) {
                                return a.push(value);
                            });
                        } else {
                            a.push(AVM1.alToString(this.context, e));
                        }
                        if (i >= items.length) {
                            break;
                        }
                        e = items[i++];
                        isArrayObject = AVM1.alIsArray(this.context, e);    // not-logical behavior
                    }
                    return new AVM1ArrayNative(this.context, a);
                };
                AVM1ArrayPrototype.prototype.join = function (separator) {
                    separator = separator === undefined ? ',' : AVM1.alCoerceString(this.context, separator);
                    if (this instanceof AVM1ArrayNative) {
                        // Faster case for native array implementation
                        var arr = alEnsureType(this, AVM1ArrayNative).value;
                        if (arr.length === 0) {
                            return '';
                        }
                        if (arr.every(function (i) {
                                return !(i instanceof AVM1.AVM1Object);
                            })) {
                            return arr.join(separator);
                        }
                    }
                    var context = this.context;
                    var length = AVM1.alToInt32(context, this.alGet('length')) >>> 0;
                    if (length === 0) {
                        return '';
                    }
                    var result = [];
                    for (var i = 0; i < length; i++) {
                        var item = this.alGet(i);
                        result[i] = item === null || item === undefined ? '' : AVM1.alCoerceString(context, item);
                    }
                    return result.join(separator);
                };
                AVM1ArrayPrototype.prototype.pop = function () {
                    if (this instanceof AVM1ArrayNative) {
                        // Faster case for native array implementation
                        var arr = alEnsureType(this, AVM1ArrayNative).value;
                        return arr.pop();
                    }
                    var length = AVM1.alToInt32(this.context, this.alGet('length')) >>> 0;
                    if (length === 0) {
                        return undefined;
                    }
                    var i = length - 1;
                    var result = this.alGet(i);
                    this.alDeleteProperty(i);
                    this.alPut('length', i);
                    return result;
                };
                AVM1ArrayPrototype.prototype.push = function () {
                    var items = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        items[_i - 0] = arguments[_i];
                    }
                    if (this instanceof AVM1ArrayNative) {
                        // Faster case for native array implementation
                        var arr = alEnsureType(this, AVM1ArrayNative).value;
                        return Array.prototype.push.apply(arr, items);
                    }
                    var length = AVM1.alToInt32(this.context, this.alGet('length')) >>> 0;
                    for (var i = 0; i < items.length; i++) {
                        this.alPut(length, items[i]);
                        length++;    // TODO check overflow
                    }
                    this.alPut('length', length);
                    return length;
                };
                AVM1ArrayPrototype.prototype.shift = function () {
                    if (this instanceof AVM1ArrayNative) {
                        // Faster case for native array implementation
                        var arr = alEnsureType(this, AVM1ArrayNative).value;
                        return arr.shift();
                    }
                    var length = AVM1.alToInt32(this.context, this.alGet('length')) >>> 0;
                    if (length === 0) {
                        return undefined;
                    }
                    var result = this.alGet(0);
                    for (var i = 1; i < length; i++) {
                        if (this.alHasProperty(i)) {
                            this.alPut(i - 1, this.alGet(i));
                        } else {
                            this.alDeleteProperty(i - 1);
                        }
                    }
                    this.alDeleteProperty(length - 1);
                    this.alPut('length', length - 1);
                    return result;
                };
                AVM1ArrayPrototype.prototype.slice = function (start, end) {
                    start = AVM1.alToInteger(this.context, start);
                    end = end !== undefined ? AVM1.alToInteger(this.context, end) : undefined;
                    if (this instanceof AVM1ArrayNative) {
                        // Faster case for native array implementation
                        var arr = alEnsureType(this, AVM1ArrayNative).value;
                        return new AVM1ArrayNative(this.context, arr.slice(start, end));
                    }
                    var a = [];
                    var length = AVM1.alToInt32(this.context, this.alGet('length')) >>> 0;
                    start = start < 0 ? Math.max(length + start, 0) : Math.min(length, start);
                    end = end === undefined ? length : end < 0 ? Math.max(length + end, 0) : Math.min(length, end);
                    for (var i = start, j = 0; i < end; i++, j++) {
                        if (this.alHasProperty(i)) {
                            a[j] = this.alGet(i);
                        }
                    }
                    return new AVM1ArrayNative(this.context, a);
                };
                AVM1ArrayPrototype.prototype.splice = function (start, deleteCount) {
                    var items = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        items[_i - 2] = arguments[_i];
                    }
                    start = AVM1.alToInteger(this.context, start);
                    deleteCount = AVM1.alToInteger(this.context, deleteCount);
                    if (this instanceof AVM1ArrayNative) {
                        // Faster case for native array implementation
                        var arr = alEnsureType(this, AVM1ArrayNative).value;
                        return new AVM1ArrayNative(this.context, Array.prototype.splice.apply(arr, [
                            start,
                            deleteCount
                        ].concat(items)));
                    }
                    var a = [];
                    var length = AVM1.alToInt32(this.context, this.alGet('length')) >>> 0;
                    start = start < 0 ? Math.max(length + start, 0) : Math.min(length, start);
                    deleteCount = Math.min(Math.max(deleteCount, 0), length - start);
                    for (var i = 0; i < deleteCount; i++) {
                        if (this.alHasProperty(start + i)) {
                            a[i] = this.alGet(start + i);
                        }
                    }
                    var delta = items.length - deleteCount;
                    if (delta < 0) {
                        for (var i = start - delta; i < length; i++) {
                            if (this.alHasProperty(i)) {
                                this.alPut(i + delta, this.alGet(i));
                            } else {
                                this.alDeleteProperty(i + delta);
                            }
                        }
                        for (var i = delta; i < 0; i++) {
                            this.alDeleteProperty(length + i);
                        }
                    } else if (delta > 0) {
                        // TODO check overflow
                        for (var i = length - 1; i >= start + delta; i--) {
                            if (this.alHasProperty(i)) {
                                this.alPut(i + delta, this.alGet(i));
                            } else {
                                this.alDeleteProperty(i + delta);
                            }
                        }
                    }
                    for (var i = 0; i < items.length; i++) {
                        this.alPut(start + i, items[i]);
                    }
                    this.alPut('length', length + delta);
                    return new AVM1ArrayNative(this.context, a);
                };
                AVM1ArrayPrototype.prototype.sort = function (comparefn) {
                    var arr = alEnsureType(this, AVM1ArrayNative).value;
                    if (!AVM1.alIsFunction(comparefn)) {
                        arr.sort();
                    } else {
                        var args = [
                            undefined,
                            undefined
                        ];
                        arr.sort(function (a, b) {
                            args[0] = a;
                            args[1] = b;
                            return comparefn.alCall(null, args);
                        });
                    }
                    return this;
                };
                AVM1ArrayPrototype.prototype.sortOn = function (fieldNames, options) {
                    var context = this.context;
                    // The field names and options we'll end up using.
                    var fieldNamesList = [];
                    var optionsList = [];
                    if (AVM1.alIsString(context, fieldNames)) {
                        fieldNamesList = [AVM1.alToString(context, fieldNames)];
                        optionsList = [AVM1.alToInt32(context, options)];
                    } else if (AVM1.alIsArray(context, fieldNames)) {
                        fieldNamesList = [];
                        optionsList = [];
                        var optionsArray = AVM1.alIsArray(context, options) ? options : null;
                        var length = AVM1.alToInteger(context, fieldNames.alGet('length'));
                        if (optionsArray) {
                            // checking in length of fieldNames == options
                            var optionsLength = AVM1.alToInteger(context, optionsArray.alGet('length'));
                            if (length !== optionsLength) {
                                optionsArray = null;
                            }
                        }
                        for (var i = 0; i < length; i++) {
                            fieldNamesList.push(AVM1.alToString(context, fieldNames.alGet(i)));
                            optionsList.push(optionsArray ? AVM1.alToInt32(context, optionsArray.alGet(i)) : 0);
                        }
                    } else {
                        // Field parameters are incorrect.
                        return undefined;
                    }
                    // TODO revisit this code
                    var optionsVal = optionsList[0];
                    release || Shumway.Debug.assertNotImplemented(!(optionsVal & AVM1ArraySortOnOptions.UNIQUESORT), 'UNIQUESORT');
                    release || Shumway.Debug.assertNotImplemented(!(optionsVal & AVM1ArraySortOnOptions.RETURNINDEXEDARRAY), 'RETURNINDEXEDARRAY');
                    var comparer = function (a, b) {
                        var aObj = AVM1.alToObject(context, a);
                        var bObj = AVM1.alToObject(context, b);
                        if (!a || !b) {
                            return !a ? !b ? 0 : -1 : +1;
                        }
                        for (var i = 0; i < fieldNamesList.length; i++) {
                            var aField = aObj.alGet(fieldNamesList[i]);
                            var bField = bObj.alGet(fieldNamesList[i]);
                            var result;
                            if (optionsList[i] & AVM1ArraySortOnOptions.NUMERIC) {
                                var aNum = AVM1.alToNumber(context, aField);
                                var bNum = AVM1.alToNumber(context, bField);
                                result = aNum < bNum ? -1 : aNum > bNum ? +1 : 0;
                            } else {
                                var aStr = AVM1.alToString(context, aField);
                                var bStr = AVM1.alToString(context, bField);
                                if (optionsList[i] & AVM1ArraySortOnOptions.CASEINSENSITIVE) {
                                    aStr = aStr.toLowerCase();
                                    bStr = bStr.toLowerCase();
                                }
                                result = aStr < bStr ? -1 : aStr > bStr ? +1 : 0;
                            }
                            if (result !== 0) {
                                return !(optionsList[i] & AVM1ArraySortOnOptions.DESCENDING) ? result : -result;
                            }
                        }
                        return 0;
                    };
                    var arr = alEnsureType(this, AVM1ArrayNative).value;
                    arr.sort(comparer);
                    // Strange, the documentation said to do not return anything.
                    return this;
                };
                AVM1ArrayPrototype.prototype.unshift = function () {
                    var items = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        items[_i - 0] = arguments[_i];
                    }
                    if (this instanceof AVM1ArrayNative) {
                        // Faster case for native array implementation
                        var arr = alEnsureType(this, AVM1ArrayNative).value;
                        return Array.prototype.unshift.apply(arr, items);
                    }
                    var length = AVM1.alToInt32(this.context, this.alGet('length')) >>> 0;
                    var insertCount = items.length;
                    // TODO check overflow
                    for (var i = length - 1; i >= 0; i--) {
                        if (this.alHasProperty(i)) {
                            this.alPut(i + insertCount, this.alGet(i));
                        } else {
                            this.alDeleteProperty(i + insertCount);
                        }
                    }
                    for (var i = 0; i < items.length; i++) {
                        this.alPut(i, items[i]);
                    }
                    length += insertCount;
                    this.alPut('length', length);
                    // ActionScript does not do that?
                    return length;
                };
                return AVM1ArrayPrototype;
            }(AVM1.AVM1Object);
            Natives.AVM1ArrayPrototype = AVM1ArrayPrototype;
            var AVM1ArrayFunction = function (_super) {
                __extends(AVM1ArrayFunction, _super);
                function AVM1ArrayFunction(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
                    var proto = new AVM1ArrayPrototype(context);
                    AVM1.alDefineObjectProperties(this, { prototype: { value: proto } });
                }
                AVM1ArrayFunction.prototype.alConstruct = function (args) {
                    if (!args) {
                        return new AVM1ArrayNative(this.context, []);
                    }
                    if (args.length === 1 && typeof args[0] === 'number') {
                        var len = args[0];
                        if (len >>> 0 !== len) {
                            throw new Error('Range error');    // TODO avm1 native
                        }
                        return new AVM1ArrayNative(this.context, new Array(len));
                    }
                    return new AVM1ArrayNative(this.context, args);
                };
                AVM1ArrayFunction.prototype.alCall = function (thisArg, args) {
                    return this.alConstruct.apply(this, args);
                };
                return AVM1ArrayFunction;
            }(AVM1.AVM1Function);
            Natives.AVM1ArrayFunction = AVM1ArrayFunction;
            // Math natives
            var AVM1MathObject = function (_super) {
                __extends(AVM1MathObject, _super);
                function AVM1MathObject(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        E: Math.E,
                        LN10: Math.LN10,
                        LN2: Math.LN2,
                        LOG10E: Math.LOG10E,
                        LOG2E: Math.LOG2E,
                        PI: Math.PI,
                        SQRT1_2: Math.SQRT1_2,
                        SQRT2: Math.SQRT2,
                        abs: this.abs,
                        acos: this.acos,
                        asin: this.asin,
                        atan: this.atan,
                        atan2: this.atan2,
                        ceil: this.ceil,
                        cos: this.cos,
                        exp: this.exp,
                        floor: this.floor,
                        log: this.log,
                        max: this.max,
                        min: this.min,
                        pow: this.pow,
                        random: this.random,
                        round: this.round,
                        sin: this.sin,
                        sqrt: this.sqrt,
                        tan: this.tan
                    });
                }
                AVM1MathObject.prototype.abs = function (x) {
                    return Math.abs(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.acos = function (x) {
                    return Math.acos(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.asin = function (x) {
                    return Math.asin(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.atan = function (x) {
                    return Math.atan(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.atan2 = function (y, x) {
                    return Math.atan2(AVM1.alToNumber(this.context, y), AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.ceil = function (x) {
                    return Math.ceil(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.cos = function (x) {
                    return Math.cos(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.exp = function (x) {
                    return Math.exp(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.floor = function (x) {
                    return Math.floor(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.log = function (x) {
                    return Math.log(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.max = function () {
                    var _this = this;
                    var values = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        values[_i - 0] = arguments[_i];
                    }
                    values = values.map(function (x) {
                        return AVM1.alToNumber(_this.context, x);
                    });
                    return Math.max.apply(null, values);
                };
                AVM1MathObject.prototype.min = function () {
                    var _this = this;
                    var values = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        values[_i - 0] = arguments[_i];
                    }
                    values = values.map(function (x) {
                        return AVM1.alToNumber(_this.context, x);
                    });
                    return Math.min.apply(null, values);
                };
                AVM1MathObject.prototype.pow = function (x, y) {
                    return Math.pow(AVM1.alToNumber(this.context, x), AVM1.alToNumber(this.context, y));
                };
                AVM1MathObject.prototype.random = function () {
                    return Math.random();
                };
                AVM1MathObject.prototype.round = function (x) {
                    return Math.round(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.sin = function (x) {
                    return Math.sin(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.sqrt = function (x) {
                    return Math.sqrt(AVM1.alToNumber(this.context, x));
                };
                AVM1MathObject.prototype.tan = function (x) {
                    return Math.tan(AVM1.alToNumber(this.context, x));
                };
                return AVM1MathObject;
            }(AVM1.AVM1Object);
            // Date natives
            var AVM1DateNative = function (_super) {
                __extends(AVM1DateNative, _super);
                function AVM1DateNative(context, value) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Date.alGetPrototypeProperty();
                    this.alSetOwnConstructorProperty(context.builtins.Date);
                    this.value = value;
                }
                AVM1DateNative.prototype.alDefaultValue = function (hint) {
                    if (hint !== undefined) {
                        return _super.prototype.alDefaultValue.call(this, hint);
                    }
                    if (this.context.swfVersion >= 6) {
                        return _super.prototype.alDefaultValue.call(this, 1    /* STRING */);
                    } else {
                        return _super.prototype.alDefaultValue.call(this, 0    /* NUMBER */);
                    }
                };
                return AVM1DateNative;
            }(AVM1.AVM1Object);
            // TODO implement all the Date class and its prototype natives
            var AVM1DatePrototype = function (_super) {
                __extends(AVM1DatePrototype, _super);
                function AVM1DatePrototype(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: context.builtins.Date,
                            writable: true
                        },
                        valueOf: {
                            value: this._valueOf,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        },
                        toLocaleString: {
                            value: this._toLocaleString,
                            writable: true
                        },
                        toDateString: {
                            value: this.toDateString,
                            writable: true
                        },
                        toTimeString: {
                            value: this.toTimeString,
                            writable: true
                        },
                        toLocaleDateString: {
                            value: this.toLocaleDateString,
                            writable: true
                        },
                        toLocaleTimeString: {
                            value: this.toLocaleTimeString,
                            writable: true
                        },
                        getTime: {
                            value: this.getTime,
                            writable: true
                        },
                        getFullYear: {
                            value: this.getFullYear,
                            writable: true
                        },
                        getUTCFullYear: {
                            value: this.getUTCFullYear,
                            writable: true
                        },
                        getMonth: {
                            value: this.getMonth,
                            writable: true
                        },
                        getUTCMonth: {
                            value: this.getUTCMonth,
                            writable: true
                        },
                        getDate: {
                            value: this.getDate,
                            writable: true
                        },
                        getUTCDate: {
                            value: this.getUTCDate,
                            writable: true
                        },
                        getDay: {
                            value: this.getDay,
                            writable: true
                        },
                        getUTCDay: {
                            value: this.getUTCDay,
                            writable: true
                        },
                        getHours: {
                            value: this.getHours,
                            writable: true
                        },
                        getUTCHours: {
                            value: this.getUTCHours,
                            writable: true
                        },
                        getMinutes: {
                            value: this.getMinutes,
                            writable: true
                        },
                        getUTCMinutes: {
                            value: this.getUTCMinutes,
                            writable: true
                        },
                        getSeconds: {
                            value: this.getSeconds,
                            writable: true
                        },
                        getUTCSeconds: {
                            value: this.getUTCSeconds,
                            writable: true
                        },
                        getMilliseconds: {
                            value: this.getMilliseconds,
                            writable: true
                        },
                        getUTCMilliseconds: {
                            value: this.getUTCMilliseconds,
                            writable: true
                        },
                        getTimezoneOffset: {
                            value: this.getTimezoneOffset,
                            writable: true
                        },
                        setTime: {
                            value: this.setTime,
                            writable: true
                        },
                        setMilliseconds: {
                            value: this.setMilliseconds,
                            writable: true
                        },
                        setUTCMilliseconds: {
                            value: this.setUTCMilliseconds,
                            writable: true
                        },
                        setSeconds: {
                            value: this.setSeconds,
                            writable: true
                        },
                        setUTCSeconds: {
                            value: this.setUTCSeconds,
                            writable: true
                        },
                        setMinutes: {
                            value: this.setMinutes,
                            writable: true
                        },
                        setUTCMinutes: {
                            value: this.setUTCMinutes,
                            writable: true
                        },
                        setHours: {
                            value: this.setHours,
                            writable: true
                        },
                        setUTCHours: {
                            value: this.setUTCHours,
                            writable: true
                        },
                        setDate: {
                            value: this.setDate,
                            writable: true
                        },
                        setUTCDate: {
                            value: this.setUTCDate,
                            writable: true
                        },
                        setMonth: {
                            value: this.setMonth,
                            writable: true
                        },
                        setUTCMonth: {
                            value: this.setUTCMonth,
                            writable: true
                        },
                        setFullYear: {
                            value: this.setFullYear,
                            writable: true
                        },
                        setUTCFullYear: {
                            value: this.setUTCFullYear,
                            writable: true
                        },
                        toUTCString: {
                            value: this.toUTCString,
                            writable: true
                        }
                    });
                }
                AVM1DatePrototype.prototype._valueOf = function () {
                    var native = alEnsureType(this, AVM1DateNative);
                    return native.value.valueOf();
                };
                AVM1DatePrototype.prototype._toString = function () {
                    var native = alEnsureType(this, AVM1DateNative);
                    return native.value.toString();
                };
                AVM1DatePrototype.prototype._toLocaleString = function () {
                    var native = alEnsureType(this, AVM1DateNative);
                    return native.value.toLocaleString();
                };
                AVM1DatePrototype.prototype.toDateString = function () {
                    return alEnsureType(this, AVM1DateNative).value.toDateString();
                };
                AVM1DatePrototype.prototype.toTimeString = function () {
                    return alEnsureType(this, AVM1DateNative).value.toTimeString();
                };
                AVM1DatePrototype.prototype.toLocaleDateString = function () {
                    return alEnsureType(this, AVM1DateNative).value.toLocaleDateString();
                };
                AVM1DatePrototype.prototype.toLocaleTimeString = function () {
                    return alEnsureType(this, AVM1DateNative).value.toLocaleTimeString();
                };
                AVM1DatePrototype.prototype.getTime = function () {
                    return alEnsureType(this, AVM1DateNative).value.getTime();
                };
                AVM1DatePrototype.prototype.getFullYear = function () {
                    return alEnsureType(this, AVM1DateNative).value.getFullYear();
                };
                AVM1DatePrototype.prototype.getUTCFullYear = function () {
                    return alEnsureType(this, AVM1DateNative).value.getUTCFullYear();
                };
                AVM1DatePrototype.prototype.getMonth = function () {
                    return alEnsureType(this, AVM1DateNative).value.getMonth();
                };
                AVM1DatePrototype.prototype.getUTCMonth = function () {
                    return alEnsureType(this, AVM1DateNative).value.getUTCMonth();
                };
                AVM1DatePrototype.prototype.getDate = function () {
                    return alEnsureType(this, AVM1DateNative).value.getDate();
                };
                AVM1DatePrototype.prototype.getUTCDate = function () {
                    return alEnsureType(this, AVM1DateNative).value.getUTCDate();
                };
                AVM1DatePrototype.prototype.getDay = function () {
                    return alEnsureType(this, AVM1DateNative).value.getDay();
                };
                AVM1DatePrototype.prototype.getUTCDay = function () {
                    return alEnsureType(this, AVM1DateNative).value.getUTCDay();
                };
                AVM1DatePrototype.prototype.getHours = function () {
                    return alEnsureType(this, AVM1DateNative).value.getHours();
                };
                AVM1DatePrototype.prototype.getUTCHours = function () {
                    return alEnsureType(this, AVM1DateNative).value.getUTCHours();
                };
                AVM1DatePrototype.prototype.getMinutes = function () {
                    return alEnsureType(this, AVM1DateNative).value.getMinutes();
                };
                AVM1DatePrototype.prototype.getUTCMinutes = function () {
                    return alEnsureType(this, AVM1DateNative).value.getUTCMinutes();
                };
                AVM1DatePrototype.prototype.getSeconds = function () {
                    return alEnsureType(this, AVM1DateNative).value.getSeconds();
                };
                AVM1DatePrototype.prototype.getUTCSeconds = function () {
                    return alEnsureType(this, AVM1DateNative).value.getUTCSeconds();
                };
                AVM1DatePrototype.prototype.getMilliseconds = function () {
                    return alEnsureType(this, AVM1DateNative).value.getMilliseconds();
                };
                AVM1DatePrototype.prototype.getUTCMilliseconds = function () {
                    return alEnsureType(this, AVM1DateNative).value.getUTCMilliseconds();
                };
                AVM1DatePrototype.prototype.getTimezoneOffset = function () {
                    return alEnsureType(this, AVM1DateNative).value.getTimezoneOffset();
                };
                AVM1DatePrototype.prototype.setTime = function (time) {
                    time = AVM1.alToNumber(this.context, time);
                    return alEnsureType(this, AVM1DateNative).value.setTime(time);
                };
                AVM1DatePrototype.prototype.setMilliseconds = function (ms) {
                    ms = AVM1.alToNumber(this.context, ms);
                    return alEnsureType(this, AVM1DateNative).value.setMilliseconds(ms);
                };
                AVM1DatePrototype.prototype.setUTCMilliseconds = function (ms) {
                    ms = AVM1.alToNumber(this.context, ms);
                    return alEnsureType(this, AVM1DateNative).value.setUTCMilliseconds(ms);
                };
                AVM1DatePrototype.prototype.setSeconds = function (sec, ms) {
                    sec = AVM1.alToNumber(this.context, sec);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setSeconds(sec);
                    } else {
                        ms = AVM1.alToNumber(this.context, ms);
                        return alEnsureType(this, AVM1DateNative).value.setSeconds(sec, ms);
                    }
                };
                AVM1DatePrototype.prototype.setUTCSeconds = function (sec, ms) {
                    sec = AVM1.alToNumber(this.context, sec);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setUTCSeconds(sec);
                    } else {
                        ms = AVM1.alToNumber(this.context, ms);
                        return alEnsureType(this, AVM1DateNative).value.setUTCSeconds(sec, ms);
                    }
                };
                AVM1DatePrototype.prototype.setMinutes = function (min, sec, ms) {
                    min = AVM1.alToNumber(this.context, min);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setMinutes(min);
                    } else {
                        sec = AVM1.alToNumber(this.context, sec);
                        if (arguments.length <= 2) {
                            return alEnsureType(this, AVM1DateNative).value.setMinutes(min, sec);
                        } else {
                            ms = AVM1.alToNumber(this.context, ms);
                            return alEnsureType(this, AVM1DateNative).value.setMinutes(min, sec, ms);
                        }
                    }
                };
                AVM1DatePrototype.prototype.setUTCMinutes = function (min, sec, ms) {
                    min = AVM1.alToNumber(this.context, min);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setUTCMinutes(min);
                    } else {
                        sec = AVM1.alToNumber(this.context, sec);
                        if (arguments.length <= 2) {
                            return alEnsureType(this, AVM1DateNative).value.setUTCMinutes(min, sec);
                        } else {
                            ms = AVM1.alToNumber(this.context, ms);
                            return alEnsureType(this, AVM1DateNative).value.setUTCMinutes(min, sec, ms);
                        }
                    }
                };
                AVM1DatePrototype.prototype.setHours = function (hour, min, sec, ms) {
                    hour = AVM1.alToNumber(this.context, hour);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setHours(hour);
                    } else {
                        min = AVM1.alToNumber(this.context, min);
                        if (arguments.length <= 2) {
                            return alEnsureType(this, AVM1DateNative).value.setHours(hour, min);
                        } else {
                            sec = AVM1.alToNumber(this.context, sec);
                            if (arguments.length <= 3) {
                                return alEnsureType(this, AVM1DateNative).value.setHours(hour, min, sec);
                            } else {
                                ms = AVM1.alToNumber(this.context, ms);
                                return alEnsureType(this, AVM1DateNative).value.setHours(hour, min, sec, ms);
                            }
                        }
                    }
                };
                AVM1DatePrototype.prototype.setUTCHours = function (hour, min, sec, ms) {
                    hour = AVM1.alToNumber(this.context, hour);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setUTCHours(hour);
                    } else {
                        min = AVM1.alToNumber(this.context, min);
                        if (arguments.length <= 2) {
                            return alEnsureType(this, AVM1DateNative).value.setUTCHours(hour, min);
                        } else {
                            sec = AVM1.alToNumber(this.context, sec);
                            if (arguments.length <= 3) {
                                return alEnsureType(this, AVM1DateNative).value.setUTCHours(hour, min, sec);
                            } else {
                                ms = AVM1.alToNumber(this.context, ms);
                                return alEnsureType(this, AVM1DateNative).value.setUTCHours(hour, min, sec, ms);
                            }
                        }
                    }
                };
                AVM1DatePrototype.prototype.setDate = function (date) {
                    date = AVM1.alToNumber(this.context, date);
                    return alEnsureType(this, AVM1DateNative).value.setDate(date);
                };
                AVM1DatePrototype.prototype.setUTCDate = function (date) {
                    date = AVM1.alToNumber(this.context, date);
                    return alEnsureType(this, AVM1DateNative).value.setUTCDate(date);
                };
                AVM1DatePrototype.prototype.setMonth = function (month, date) {
                    month = AVM1.alToNumber(this.context, month);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setMonth(month);
                    } else {
                        date = AVM1.alToNumber(this.context, date);
                        return alEnsureType(this, AVM1DateNative).value.setMonth(month, date);
                    }
                };
                AVM1DatePrototype.prototype.setUTCMonth = function (month, date) {
                    month = AVM1.alToNumber(this.context, month);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setUTCMonth(month);
                    } else {
                        date = AVM1.alToNumber(this.context, date);
                        return alEnsureType(this, AVM1DateNative).value.setUTCMonth(month, date);
                    }
                };
                AVM1DatePrototype.prototype.setFullYear = function (year, month, date) {
                    year = AVM1.alToNumber(this.context, year);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setFullYear(year);
                    } else {
                        month = AVM1.alToNumber(this.context, month);
                        if (arguments.length <= 2) {
                            return alEnsureType(this, AVM1DateNative).value.setFullYear(year, month);
                        } else {
                            date = AVM1.alToNumber(this.context, date);
                            return alEnsureType(this, AVM1DateNative).value.setFullYear(year, month, date);
                        }
                    }
                };
                AVM1DatePrototype.prototype.setUTCFullYear = function (year, month, date) {
                    year = AVM1.alToNumber(this.context, year);
                    if (arguments.length <= 1) {
                        return alEnsureType(this, AVM1DateNative).value.setUTCFullYear(year);
                    } else {
                        month = AVM1.alToNumber(this.context, month);
                        if (arguments.length <= 2) {
                            return alEnsureType(this, AVM1DateNative).value.setUTCFullYear(year, month);
                        } else {
                            date = AVM1.alToNumber(this.context, date);
                            return alEnsureType(this, AVM1DateNative).value.setUTCFullYear(year, month, date);
                        }
                    }
                };
                AVM1DatePrototype.prototype.toUTCString = function () {
                    return alEnsureType(this, AVM1DateNative).value.toUTCString();
                };
                return AVM1DatePrototype;
            }(AVM1.AVM1Object);
            var AVM1DateFunction = function (_super) {
                __extends(AVM1DateFunction, _super);
                function AVM1DateFunction(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
                    var proto = new AVM1DatePrototype(context);
                    AVM1.alDefineObjectProperties(this, {
                        prototype: { value: proto },
                        UTC: {
                            value: this._UTC,
                            writable: true
                        }
                    });
                }
                AVM1DateFunction.prototype.alConstruct = function (args) {
                    var context = this.context;
                    var value;
                    switch (args.length) {
                    case 0:
                        value = new Date();
                        break;
                    case 1:
                        value = new Date(AVM1.alToPrimitive(context, args[0]));
                        break;
                    default:
                        var numbers = [];
                        for (var i = 0; i < args.length; i++) {
                            numbers.push(AVM1.alToNumber(context, args[i]));
                        }
                        value = new Date(AVM1.alToNumber(context, args[0]), AVM1.alToNumber(context, args[1]), args.length > 2 ? AVM1.alToNumber(context, args[2]) : 1, args.length > 3 ? AVM1.alToNumber(context, args[3]) : 0, args.length > 4 ? AVM1.alToNumber(context, args[4]) : 0, args.length > 5 ? AVM1.alToNumber(context, args[5]) : 0, args.length > 6 ? AVM1.alToNumber(context, args[6]) : 0);
                        break;
                    }
                    return new AVM1DateNative(context, value);
                };
                AVM1DateFunction.prototype.alCall = function (thisArg, args) {
                    return AVM1.alCallProperty(this.alConstruct.apply(this, args), 'toString');
                };
                AVM1DateFunction.prototype._UTC = function (year, month, date, hours, seconds, ms) {
                    var context = this.context;
                    return Date.UTC(AVM1.alToNumber(context, arguments[0]), AVM1.alToNumber(context, arguments[1]), arguments.length > 2 ? AVM1.alToNumber(context, arguments[2]) : 1, arguments.length > 3 ? AVM1.alToNumber(context, arguments[3]) : 0, arguments.length > 4 ? AVM1.alToNumber(context, arguments[4]) : 0, arguments.length > 5 ? AVM1.alToNumber(context, arguments[5]) : 0, arguments.length > 6 ? AVM1.alToNumber(context, arguments[6]) : 0);
                };
                return AVM1DateFunction;
            }(AVM1.AVM1Function);
            // Error natives
            var AVM1ErrorNative = function (_super) {
                __extends(AVM1ErrorNative, _super);
                function AVM1ErrorNative(context, message) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Error.alGetPrototypeProperty();
                    this.alSetOwnConstructorProperty(context.builtins.Error);
                    if (message !== undefined) {
                        this.alPut('message', message);
                    }
                }
                return AVM1ErrorNative;
            }(AVM1.AVM1Object);
            Natives.AVM1ErrorNative = AVM1ErrorNative;
            var AVM1ErrorPrototype = function (_super) {
                __extends(AVM1ErrorPrototype, _super);
                function AVM1ErrorPrototype(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: context.builtins.Error,
                            writable: true
                        },
                        name: {
                            value: 'Error',
                            writable: true
                        },
                        message: {
                            value: 'Error',
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        }
                    });
                }
                AVM1ErrorPrototype.prototype._toString = function () {
                    return this.alGet('message');
                };
                return AVM1ErrorPrototype;
            }(AVM1.AVM1Object);
            Natives.AVM1ErrorPrototype = AVM1ErrorPrototype;
            var AVM1ErrorFunction = function (_super) {
                __extends(AVM1ErrorFunction, _super);
                function AVM1ErrorFunction(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Function.alGetPrototypeProperty();
                    var proto = new AVM1ErrorPrototype(context);
                    AVM1.alDefineObjectProperties(this, { prototype: { value: proto } });
                }
                AVM1ErrorFunction.prototype.alConstruct = function (args) {
                    var value = args && args[0] !== undefined ? AVM1.alCoerceString(this.context, args[0]) : undefined;
                    return new AVM1ErrorNative(this.context, value);
                };
                AVM1ErrorFunction.prototype.alCall = function (thisArg, args) {
                    var value = args && args[0] !== undefined ? AVM1.alCoerceString(this.context, args[0]) : undefined;
                    return new AVM1ErrorNative(this.context, value);
                };
                return AVM1ErrorFunction;
            }(AVM1.AVM1Function);
            Natives.AVM1ErrorFunction = AVM1ErrorFunction;
            function alEnsureType(obj, cls) {
                if (obj instanceof cls) {
                    return obj;
                }
                throw new Error('Invalid type');
            }
            /**
             * Installs built-ins on the AVM1Context. It shall be a first call before
             * any AVM1Object is instantiated.
             * @param {IAVM1Context} context
             */
            function installBuiltins(context) {
                var builtins = context.builtins;
                // Resolving cyclic dependency between Object/Function functions and their prototypes.
                var objectProto = new AVM1ObjectPrototype(context);
                var dummyObject = new AVM1.AVM1Object(context);
                dummyObject.alSetOwnPrototypeProperty(objectProto);
                builtins.Object = dummyObject;
                var functionProto = new AVM1FunctionPrototype(context);
                var dummyFunction = new AVM1.AVM1Object(context);
                dummyFunction.alSetOwnPrototypeProperty(functionProto);
                builtins.Function = dummyFunction;
                objectProto._initializePrototype();
                functionProto._initializePrototype();
                builtins.Object = new AVM1ObjectFunction(context);
                builtins.Function = new AVM1FunctionFunction(context);
                builtins.Boolean = new AVM1BooleanFunction(context);
                builtins.Number = new AVM1NumberFunction(context);
                builtins.String = new AVM1StringFunction(context);
                builtins.Array = new AVM1ArrayFunction(context);
                builtins.Date = new AVM1DateFunction(context);
                builtins.Math = new AVM1MathObject(context);
                builtins.Error = new AVM1ErrorFunction(context);
            }
            Natives.installBuiltins = installBuiltins;
        }(Natives = AVM1.Natives || (AVM1.Natives = {})));
        var assert = Shumway.Debug.assert;
        var AVM1ActionsData = function () {
            function AVM1ActionsData(bytes, id, parent) {
                if (parent === void 0) {
                    parent = null;
                }
                this.bytes = bytes;
                this.id = id;
                this.parent = parent;
                release || assert(bytes instanceof Uint8Array);
                this.ir = null;
                this.compiled = null;
            }
            return AVM1ActionsData;
        }();
        AVM1.AVM1ActionsData = AVM1ActionsData;
        var ActionsDataFactory = function () {
            function ActionsDataFactory() {
                this._cache = new WeakMap();
            }
            ActionsDataFactory.prototype.createActionsData = function (bytes, id, parent) {
                if (parent === void 0) {
                    parent = null;
                }
                var actionsData = this._cache.get(bytes);
                if (!actionsData) {
                    actionsData = new AVM1ActionsData(bytes, id, parent);
                    this._cache.set(bytes, actionsData);
                }
                release || assert(actionsData.bytes === bytes && actionsData.id === id && actionsData.parent === parent);
                return actionsData;
            };
            return ActionsDataFactory;
        }();
        AVM1.ActionsDataFactory = ActionsDataFactory;
        var AVM1Context = function () {
            function AVM1Context(swfVersion) {
                this.swfVersion = swfVersion;
                this.globals = null;
                this.actionsDataFactory = new ActionsDataFactory();
                if (swfVersion > 6) {
                    this.isPropertyCaseSensitive = true;
                    this.normalizeName = this.normalizeNameCaseSensitive;
                } else {
                    this.isPropertyCaseSensitive = false;
                    this._nameCache = Object.create(null);
                    this.normalizeName = this.normalizeNameCaseInsensitive;
                }
                this.builtins = {};
                Shumway.AVM1.Natives.installBuiltins(this);
                this.eventObservers = Object.create(null);
                this.assets = {};
                this.assetsSymbols = [];
                this.assetsClasses = [];
                this.staticStates = new WeakMap();
            }
            AVM1Context.prototype.resolveTarget = function (target) {
            };
            AVM1Context.prototype.resolveRoot = function () {
            };
            AVM1Context.prototype.checkTimeout = function () {
            };
            AVM1Context.prototype.executeActions = function (actionsData, scopeObj) {
            };
            AVM1Context.prototype.executeFunction = function (fn, thisArg, args) {
            };
            AVM1Context.prototype.normalizeNameCaseSensitive = function (name) {
                switch (typeof name) {
                case 'number':
                case 'string':
                    return name;
                default:
                    return AVM1.alToString(this, name);
                }
            };
            AVM1Context.prototype.normalizeNameCaseInsensitive = function (name) {
                switch (typeof name) {
                case 'number':
                    return name;
                case 'string':
                    break;
                default:
                    name = AVM1.alToString(this, name);
                }
                var normalizedName = this._nameCache[name];
                if (normalizedName) {
                    return normalizedName;
                }
                normalizedName = name.toLowerCase();
                this._nameCache[name] = normalizedName;
                return normalizedName;
            };
            AVM1Context.prototype._getEventPropertyObservers = function (propertyName, create) {
                if (!this.isPropertyCaseSensitive) {
                    propertyName = propertyName.toLowerCase();
                }
                var observers = this.eventObservers[propertyName];
                if (observers) {
                    return observers;
                }
                if (create) {
                    observers = [];
                    this.eventObservers[propertyName] = observers;
                    return observers;
                }
                return null;
            };
            AVM1Context.prototype.registerEventPropertyObserver = function (propertyName, observer) {
                var observers = this._getEventPropertyObservers(propertyName, true);
                observers.push(observer);
            };
            AVM1Context.prototype.unregisterEventPropertyObserver = function (propertyName, observer) {
                var observers = this._getEventPropertyObservers(propertyName, false);
                if (!observers) {
                    return;
                }
                var j = observers.indexOf(observer);
                if (j < 0) {
                    return;
                }
                observers.splice(j, 1);
            };
            AVM1Context.prototype.broadcastEventPropertyChange = function (propertyName) {
                var observers = this._getEventPropertyObservers(propertyName, false);
                if (!observers) {
                    return;
                }
                observers.forEach(function (observer) {
                    return observer.onEventPropertyModified(propertyName);
                });
            };
            AVM1Context.prototype.addAsset = function (className, symbolId, symbolProps) {
                release || Shumway.Debug.assert(typeof className === 'string' && !isNaN(symbolId));
                this.assets[className.toLowerCase()] = symbolId;
                this.assetsSymbols[symbolId] = symbolProps;
            };
            AVM1Context.prototype.registerClass = function (className, theClass) {
                className = AVM1.alCoerceString(this, className);
                if (className === null) {
                    this.utils.warn('Cannot register class for symbol: className is missing');
                    return null;
                }
                var symbolId = this.assets[className.toLowerCase()];
                if (symbolId === undefined) {
                    this.utils.warn('Cannot register ' + className + ' class for symbol');
                    return;
                }
                this.assetsClasses[symbolId] = theClass;
            };
            AVM1Context.prototype.getSymbolClass = function (symbolId) {
                return this.assetsClasses[symbolId] || null;
            };
            AVM1Context.prototype.getAsset = function (className) {
                className = AVM1.alCoerceString(this, className);
                if (className === null) {
                    return undefined;
                }
                var symbolId = this.assets[className.toLowerCase()];
                if (symbolId === undefined) {
                    return undefined;
                }
                var symbol = this.assetsSymbols[symbolId];
                if (!symbol) {
                    symbol = this.loaderInfo.getSymbolById(symbolId);
                    if (!symbol) {
                        Shumway.Debug.warning('Symbol ' + symbolId + ' is not defined.');
                        return undefined;
                    }
                    this.assetsSymbols[symbolId] = symbol;
                }
                return {
                    symbolId: symbolId,
                    symbolProps: symbol
                };
            };
            AVM1Context.prototype.setStage = function (stage) {
                AVM1.Lib.AVM1Key.bindStage(this, this.globals.Key, stage);
                AVM1.Lib.AVM1Mouse.bindStage(this, this.globals.Mouse, stage);
                AVM1.Lib.AVM1Stage.bindStage(this, this.globals.Stage, stage);
            };
            AVM1Context.prototype.getStaticState = function (cls) {
                var state = this.staticStates.get(cls);
                if (!state) {
                    state = Object.create(null);
                    var initStatic = cls.alInitStatic;
                    if (initStatic) {
                        initStatic.call(state, this);
                    }
                    this.staticStates.set(cls, state);
                }
                return state;
            };
            AVM1Context.prototype.resolveLevel = function (level) {
                release || Shumway.Debug.assert(typeof level === 'number');
                var as3Root = this.levelsContainer._getRootForLevel(level);
                if (!as3Root) {
                    this.utils.warn('Unable to resolve level ' + level + ' root');
                    return undefined;
                }
                return AVM1.Lib.getAVM1Object(as3Root, this);
            };
            return AVM1Context;
        }();
        AVM1.AVM1Context = AVM1Context;
        var Telemetry = Shumway.Telemetry;
        var assert = Shumway.Debug.assert;
        AVM1.Debugger = {
            pause: false,
            breakpoints: {}
        };
        function avm1Warn(message, arg1, arg2, arg3, arg4) {
            if (AVM1.avm1ErrorsEnabled.value) {
                try {
                    throw new Error(message);    // using throw as a way to break in browsers debugger
                } catch (e) {
                }
            }
            if (AVM1.avm1WarningsEnabled.value) {
                Shumway.Debug.warning.apply(console, arguments);
            }
        }
        AVM1.MAX_AVM1_HANG_TIMEOUT = 1000;
        AVM1.CHECK_AVM1_HANG_EVERY = 1000;
        var MAX_AVM1_ERRORS_LIMIT = 1000;
        var MAX_AVM1_STACK_LIMIT = 256;
        var AVM1ScopeListItemFlags;
        (function (AVM1ScopeListItemFlags) {
            AVM1ScopeListItemFlags[AVM1ScopeListItemFlags['DEFAULT'] = 0] = 'DEFAULT';
            AVM1ScopeListItemFlags[AVM1ScopeListItemFlags['TARGET'] = 1] = 'TARGET';
            AVM1ScopeListItemFlags[AVM1ScopeListItemFlags['REPLACE_TARGET'] = 2] = 'REPLACE_TARGET';
        }(AVM1ScopeListItemFlags || (AVM1ScopeListItemFlags = {})));
        var AVM1ScopeListItem = function () {
            function AVM1ScopeListItem(scope, previousScopeItem) {
                this.scope = scope;
                this.previousScopeItem = previousScopeItem;
                this.flags = AVM1ScopeListItemFlags.DEFAULT;
            }
            return AVM1ScopeListItem;
        }();
        // Similar to function scope, mostly for 'this'.
        var GlobalPropertiesScope = function (_super) {
            __extends(GlobalPropertiesScope, _super);
            function GlobalPropertiesScope(context, thisArg) {
                _super.call(this, context);
                this.alSetOwnProperty('this', new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */ | 2    /* DONT_DELETE */ | 4    /* READ_ONLY */, thisArg));
                this.alSetOwnProperty('_global', new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */ | 2    /* DONT_DELETE */ | 4    /* READ_ONLY */, context.globals));
            }
            return GlobalPropertiesScope;
        }(AVM1.AVM1Object);
        var AVM1CallFrame = function () {
            function AVM1CallFrame(previousFrame, currentThis, fn, args, ectx) {
                this.previousFrame = previousFrame;
                this.currentThis = currentThis;
                this.fn = fn;
                this.args = args;
                this.ectx = ectx;
                this.inSequence = !previousFrame ? false : previousFrame.calleeThis === currentThis && previousFrame.calleeFn === fn;
                this.resetCallee();
            }
            AVM1CallFrame.prototype.setCallee = function (thisArg, superArg, fn, args) {
                this.calleeThis = thisArg;
                this.calleeSuper = superArg;
                this.calleeFn = fn;
                if (!release) {
                    this.calleeArgs = args;
                }
            };
            AVM1CallFrame.prototype.resetCallee = function () {
                this.calleeThis = null;
                this.calleeSuper = null;
                this.calleeFn = null;
            };
            return AVM1CallFrame;
        }();
        var AVM1RuntimeUtilsImpl = function () {
            function AVM1RuntimeUtilsImpl(context) {
                this._context = context;
            }
            AVM1RuntimeUtilsImpl.prototype.hasProperty = function (obj, name) {
                return as2HasProperty(this._context, obj, name);
            };
            AVM1RuntimeUtilsImpl.prototype.getProperty = function (obj, name) {
                return as2GetProperty(this._context, obj, name);
            };
            AVM1RuntimeUtilsImpl.prototype.setProperty = function (obj, name, value) {
                return as2SetProperty(this._context, obj, name, value);
            };
            AVM1RuntimeUtilsImpl.prototype.warn = function (msg) {
                avm1Warn.apply(null, arguments);
            };
            return AVM1RuntimeUtilsImpl;
        }();
        var AVM1ContextImpl = function (_super) {
            __extends(AVM1ContextImpl, _super);
            function AVM1ContextImpl(loaderInfo) {
                var swfVersion = loaderInfo.swfVersion;
                _super.call(this, swfVersion);
                this.loaderInfo = loaderInfo;
                this.sec = loaderInfo.sec;
                // REDUX:
                this.globals = AVM1.Lib.AVM1Globals.createGlobalsObject(this);
                this.actions = new AVM1.Lib.AVM1NativeActions(this);
                this.initialScope = new AVM1ScopeListItem(this.globals, null);
                this.utils = new AVM1RuntimeUtilsImpl(this);
                this.isActive = false;
                this.executionProhibited = false;
                this.actionTracer = AVM1.avm1TraceEnabled.value ? new ActionTracer() : null;
                this.abortExecutionAt = 0;
                this.stackDepth = 0;
                this.frame = null;
                this.isTryCatchListening = false;
                this.errorsIgnored = 0;
                this.deferScriptExecution = true;
            }
            AVM1ContextImpl.prototype._getExecutionContext = function () {
                // We probably entering this function from some native function,
                // so faking execution context. Let's reuse last created context.
                return this.frame.ectx;
            };
            AVM1ContextImpl.prototype.resolveTarget = function (target) {
                var ectx = this._getExecutionContext();
                return avm1ResolveTarget(ectx, target, true);
            };
            AVM1ContextImpl.prototype.resolveRoot = function () {
                var ectx = this._getExecutionContext();
                return avm1ResolveRoot(ectx);
            };
            AVM1ContextImpl.prototype.checkTimeout = function () {
                if (Date.now() >= this.abortExecutionAt) {
                    throw new AVM1CriticalError('long running script -- AVM1 instruction hang timeout');
                }
            };
            AVM1ContextImpl.prototype.pushCallFrame = function (thisArg, fn, args, ectx) {
                var nextFrame = new AVM1CallFrame(this.frame, thisArg, fn, args, ectx);
                this.frame = nextFrame;
                return nextFrame;
            };
            AVM1ContextImpl.prototype.popCallFrame = function () {
                var previousFrame = this.frame.previousFrame;
                this.frame = previousFrame;
                return previousFrame;
            };
            AVM1ContextImpl.prototype.executeActions = function (actionsData, scopeObj) {
                if (this.executionProhibited) {
                    return;    // no more avm1 for this context
                }
                var savedIsActive = this.isActive;
                if (!savedIsActive) {
                    this.isActive = true;
                    this.abortExecutionAt = AVM1.avm1TimeoutDisabled.value ? Number.MAX_VALUE : Date.now() + AVM1.MAX_AVM1_HANG_TIMEOUT;
                    this.errorsIgnored = 0;
                }
                var caughtError;
                try {
                    executeActionsData(this, actionsData, scopeObj);
                } catch (e) {
                    caughtError = e;
                }
                this.isActive = savedIsActive;
                if (caughtError) {
                    // Note: this doesn't use `finally` because that's a no-go for performance.
                    throw caughtError;
                }
            };
            AVM1ContextImpl.prototype.executeFunction = function (fn, thisArg, args) {
                if (this.executionProhibited) {
                    return;    // no more avm1 for this context
                }
                var savedIsActive = this.isActive;
                if (!savedIsActive) {
                    this.isActive = true;
                    this.abortExecutionAt = AVM1.avm1TimeoutDisabled.value ? Number.MAX_VALUE : Date.now() + AVM1.MAX_AVM1_HANG_TIMEOUT;
                    this.errorsIgnored = 0;
                }
                var caughtError;
                var result;
                try {
                    result = fn.alCall(thisArg, args);
                } catch (e) {
                    caughtError = e;
                }
                this.isActive = savedIsActive;
                if (caughtError) {
                    // Note: this doesn't use `finally` because that's a no-go for performance.
                    throw caughtError;
                }
                return result;
            };
            return AVM1ContextImpl;
        }(AVM1.AVM1Context);
        AVM1.AVM1Context.create = function (loaderInfo) {
            return new AVM1ContextImpl(loaderInfo);
        };
        var AVM1Error = function () {
            function AVM1Error(error) {
                this.error = error;
            }
            return AVM1Error;
        }();
        var AVM1CriticalError = function (_super) {
            __extends(AVM1CriticalError, _super);
            function AVM1CriticalError(message, error) {
                _super.call(this, message);
                this.error = error;
            }
            return AVM1CriticalError;
        }(Error);
        function isAVM1MovieClip(obj) {
            return typeof obj === 'object' && obj && obj instanceof AVM1.Lib.AVM1MovieClip;
        }
        function as2GetType(v) {
            if (v === null) {
                return 'null';
            }
            var type = typeof v;
            if (typeof v === 'object') {
                if (v instanceof AVM1.Lib.AVM1MovieClip) {
                    return 'movieclip';
                }
                if (v instanceof AVM1.AVM1Function) {
                    return 'function';
                }
            }
            return type;
        }
        function as2ToAddPrimitive(context, value) {
            return AVM1.alToPrimitive(context, value);
        }
        /**
         * Performs "less" comparison of two arugments.
         * @returns {boolean} Returns true if x is less than y, otherwise false
         */
        function as2Compare(context, x, y) {
            var x2 = AVM1.alToPrimitive(context, x);
            var y2 = AVM1.alToPrimitive(context, y);
            if (typeof x2 === 'string' && typeof y2 === 'string') {
                var xs = AVM1.alToString(context, x2), ys = AVM1.alToString(context, y2);
                return xs < ys;
            } else {
                var xn = AVM1.alToNumber(context, x2), yn = AVM1.alToNumber(context, y2);
                return isNaN(xn) || isNaN(yn) ? undefined : xn < yn;
            }
        }
        /**
         * Performs equality comparison of two arugments. The equality comparison
         * algorithm from EcmaScript 3, Section 11.9.3 is applied.
         * http://ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf#page=67
         * @returns {boolean} Coerces x and y to the same type and returns true if they're equal, false otherwise.
         */
        function as2Equals(context, x, y) {
            // Spec steps 1 through 13 can be condensed to ...
            if (typeof x === typeof y) {
                return x === y;
            }
            // Spec steps 14 and 15.
            if (x == null && y == null) {
                return true;
            }
            // Spec steps 16 and 17.
            if (typeof x === 'number' && typeof y === 'string') {
                // Unfolding the recursion for `as2Equals(context, x, alToNumber(y))`
                return y === '' ? false : x === +y;    // in AVM1, ToNumber('') === NaN
            }
            if (typeof x === 'string' && typeof y === 'number') {
                // Unfolding the recursion for `as2Equals(context, alToNumber(x), y)`
                return x === '' ? false : +x === y;    // in AVM1, ToNumber('') === NaN
            }
            // Spec step 18.
            if (typeof x === 'boolean') {
                // Unfolding the recursion for `as2Equals(context, alToNumber(x), y)`
                x = +x;
                // typeof x === 'number'
                if (typeof y === 'number' || typeof y === 'string') {
                    return y === '' ? false : x === +y;
                }
            }
            // Spec step 19.
            if (typeof y === 'boolean') {
                // Unfolding the recursion for `as2Equals(context, x, alToNumber(y))`
                y = +y;
                // typeof y === 'number'
                if (typeof x === 'number' || typeof x === 'string') {
                    return x === '' ? false : +x === y;
                }
            }
            // Spec step 20.
            if ((typeof x === 'number' || typeof x === 'string') && typeof y === 'object' && y !== null) {
                y = AVM1.alToPrimitive(context, y);
                if (typeof y === 'object') {
                    return false;    // avoiding infinite recursion
                }
                return as2Equals(context, x, y);
            }
            // Spec step 21.
            if (typeof x === 'object' && x !== null && (typeof y === 'number' || typeof y === 'string')) {
                x = AVM1.alToPrimitive(context, x);
                if (typeof x === 'object') {
                    return false;    // avoiding infinite recursion
                }
                return as2Equals(context, x, y);
            }
            return false;
        }
        function as2InstanceOf(obj, constructor) {
            // TODO refactor this -- quick and dirty hack for now
            if (Shumway.isNullOrUndefined(obj) || Shumway.isNullOrUndefined(constructor)) {
                return false;
            }
            if (constructor === Shumway.AVMX.AS.ASString) {
                return typeof obj === 'string';
            } else if (constructor === Shumway.AVMX.AS.ASNumber) {
                return typeof obj === 'number';
            } else if (constructor === Shumway.AVMX.AS.ASBoolean) {
                return typeof obj === 'boolean';
            } else if (constructor === Shumway.AVMX.AS.ASArray) {
                return Array.isArray(obj);
            } else if (constructor === Shumway.AVMX.AS.ASFunction) {
                return typeof obj === 'function';
            } else if (constructor === Shumway.AVMX.AS.ASObject) {
                return typeof obj === 'object';
            }
            var baseProto = constructor.alGetPrototypeProperty();
            if (!baseProto) {
                return false;
            }
            var proto = obj;
            while (proto) {
                if (proto === baseProto) {
                    return true;    // found the type if the chain
                }
                proto = proto.alPrototype;
            }
            // TODO interface check
            return false;
        }
        function as2HasProperty(context, obj, name) {
            var avm1Obj = AVM1.alToObject(context, obj);
            name = context.normalizeName(name);
            return avm1Obj.alHasProperty(name);
        }
        function as2GetProperty(context, obj, name) {
            var avm1Obj = AVM1.alToObject(context, obj);
            return avm1Obj.alGet(name);
        }
        function as2SetProperty(context, obj, name, value) {
            var avm1Obj = AVM1.alToObject(context, obj);
            avm1Obj.alPut(name, value);
            as2SyncEvents(context, name);
        }
        function as2DeleteProperty(context, obj, name) {
            var avm1Obj = AVM1.alToObject(context, obj);
            name = context.normalizeName(name);
            var result = avm1Obj.alDeleteProperty(name);
            as2SyncEvents(context, name);
            return result;
        }
        function as2SyncEvents(context, name) {
            name = AVM1.alCoerceString(context, name);
            if (name[0] !== 'o' || name[1] !== 'n') {
                return;
            }
            // Maybe an event property, trying to broadcast change.
            context.broadcastEventPropertyChange(name);
        }
        function as2CastError(ex) {
            if (typeof InternalError !== 'undefined' && ex instanceof InternalError && ex.message === 'too much recursion') {
                // HACK converting too much recursion into AVM1CriticalError
                return new AVM1CriticalError('long running script -- AVM1 recursion limit is reached');
            }
            return ex;
        }
        function as2Construct(ctor, args) {
            var result;
            if (AVM1.alIsFunction(ctor)) {
                result = ctor.alConstruct(args);
            } else {
                // AVM1 simply ignores attempts to invoke non-methods.
                return undefined;
            }
            return result;
        }
        function as2Enumerate(obj, fn, thisArg) {
            var processed = Object.create(null);
            // TODO remove/refactor
            AVM1.alForEachProperty(obj, function (name) {
                if (processed[name]) {
                    return;    // skipping already reported properties
                }
                fn.call(thisArg, name);
                processed[name] = true;
            }, thisArg);
        }
        function avm1FindSuperPropertyOwner(context, frame, propertyName) {
            if (context.swfVersion < 6) {
                return null;
            }
            var proto = frame.inSequence && frame.previousFrame.calleeSuper;
            if (!proto) {
                // Finding first object in prototype chain link that has the property.
                proto = frame.currentThis;
                while (proto && !proto.alHasOwnProperty(propertyName)) {
                    proto = proto.alPrototype;
                }
                if (!proto) {
                    return null;
                }
            }
            // Skipping one chain link
            proto = proto.alPrototype;
            return proto;
        }
        var DEFAULT_REGISTER_COUNT = 4;
        function executeActionsData(context, actionsData, scope) {
            var actionTracer = context.actionTracer;
            var globalPropertiesScopeList = new AVM1ScopeListItem(new GlobalPropertiesScope(context, scope), context.initialScope);
            var scopeList = new AVM1ScopeListItem(scope, globalPropertiesScopeList);
            scopeList.flags |= AVM1ScopeListItemFlags.TARGET;
            var caughtError;
            release || actionTracer && actionTracer.message('ActionScript Execution Starts');
            release || actionTracer && actionTracer.indent();
            var ectx = ExecutionContext.create(context, scopeList, [], DEFAULT_REGISTER_COUNT);
            context.pushCallFrame(scope, null, null, ectx);
            try {
                interpretActionsData(ectx, actionsData);
            } catch (e) {
                caughtError = as2CastError(e);
            }
            ectx.dispose();
            if (caughtError instanceof AVM1CriticalError) {
                context.executionProhibited = true;
                console.error('Disabling AVM1 execution');
            }
            context.popCallFrame();
            release || actionTracer && actionTracer.unindent();
            release || actionTracer && actionTracer.message('ActionScript Execution Stops');
            if (caughtError) {
                // Note: this doesn't use `finally` because that's a no-go for performance.
                throw caughtError;    // TODO shall we just ignore it?
            }
        }
        function createBuiltinType(context, cls, args) {
            var builtins = context.builtins;
            var obj = undefined;
            if (cls === builtins.Array || cls === builtins.Object || cls === builtins.Date || cls === builtins.String || cls === builtins.Function) {
                obj = cls.alConstruct(args);
            }
            if (cls === builtins.Boolean || cls === builtins.Number) {
                obj = cls.alConstruct(args).value;
            }
            if (obj instanceof AVM1.AVM1Object) {
                var desc = new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */, cls);
                obj.alSetOwnProperty('__constructor__', desc);
            }
            return obj;
        }
        var AVM1SuperWrapper = function (_super) {
            __extends(AVM1SuperWrapper, _super);
            function AVM1SuperWrapper(context, callFrame) {
                _super.call(this, context);
                this.callFrame = callFrame;
                this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
            }
            return AVM1SuperWrapper;
        }(AVM1.AVM1Object);
        var AVM1Arguments = function (_super) {
            __extends(AVM1Arguments, _super);
            function AVM1Arguments(context, args, callee, caller) {
                _super.call(this, context, args);
                AVM1.alDefineObjectProperties(this, {
                    callee: { value: callee },
                    caller: { value: caller }
                });
            }
            return AVM1Arguments;
        }(AVM1.Natives.AVM1ArrayNative);
        var ExecutionContext = function () {
            function ExecutionContext(context, scopeList, constantPool, registerCount) {
                this.context = context;
                this.actions = context.actions;
                this.isSwfVersion5 = context.swfVersion >= 5;
                this.registers = [];
                this.stack = [];
                this.frame = null;
                this.recoveringFromError = false;
                this.isEndOfActions = false;
                this.reset(scopeList, constantPool, registerCount);
            }
            ExecutionContext.alInitStatic = function () {
                this.cache = [];
            };
            ExecutionContext.prototype.reset = function (scopeList, constantPool, registerCount) {
                this.scopeList = scopeList;
                this.constantPool = constantPool;
                this.registers.length = registerCount;
            };
            ExecutionContext.prototype.clean = function () {
                this.scopeList = null;
                this.constantPool = null;
                this.registers.length = 0;
                this.stack.length = 0;
                this.frame = null;
                this.recoveringFromError = false;
                this.isEndOfActions = false;
            };
            ExecutionContext.prototype.pushScope = function (newScopeList) {
                var newContext = Object.create(this);
                newContext.stack = [];
                if (!Shumway.isNullOrUndefined(newScopeList)) {
                    newContext.scopeList = newScopeList;
                }
                return newContext;
            };
            ExecutionContext.prototype.dispose = function () {
                this.clean();
                var state = this.context.getStaticState(ExecutionContext);
                if (state.cache.length < ExecutionContext.MAX_CACHED_EXECUTIONCONTEXTS) {
                    state.cache.push(this);
                }
            };
            ExecutionContext.create = function (context, scopeList, constantPool, registerCount) {
                var state = context.getStaticState(ExecutionContext);
                var ectx;
                if (state.cache.length > 0) {
                    ectx = state.cache.pop();
                    ectx.reset(scopeList, constantPool, registerCount);
                } else {
                    ectx = new ExecutionContext(context, scopeList, constantPool, registerCount);
                }
                return ectx;
            };
            ExecutionContext.MAX_CACHED_EXECUTIONCONTEXTS = 20;
            return ExecutionContext;
        }();
        /**
         * Interpreted function closure.
         */
        var AVM1InterpreterScope = function (_super) {
            __extends(AVM1InterpreterScope, _super);
            function AVM1InterpreterScope(context) {
                _super.call(this, context);
                this.alPut('toString', new AVM1.AVM1NativeFunction(context, this._toString));
            }
            AVM1InterpreterScope.prototype._toString = function () {
                // It shall return 'this'
                return this;
            };
            return AVM1InterpreterScope;
        }(AVM1.AVM1Object);
        var AVM1InterpretedFunction = function (_super) {
            __extends(AVM1InterpretedFunction, _super);
            function AVM1InterpretedFunction(context, ectx, actionsData, functionName, parametersNames, registersCount, registersAllocation, suppressArguments) {
                _super.call(this, context);
                this.functionName = functionName;
                this.actionsData = actionsData;
                this.parametersNames = parametersNames;
                this.registersAllocation = registersAllocation;
                this.suppressArguments = suppressArguments;
                this.scopeList = ectx.scopeList;
                this.constantPool = ectx.constantPool;
                var skipArguments = null;
                var registersAllocationCount = !registersAllocation ? 0 : registersAllocation.length;
                for (var i = 0; i < registersAllocationCount; i++) {
                    var registerAllocation = registersAllocation[i];
                    if (registerAllocation && registerAllocation.type === 1    /* Argument */) {
                        if (!skipArguments) {
                            skipArguments = [];
                        }
                        skipArguments[registersAllocation[i].index] = true;
                    }
                }
                this.skipArguments = skipArguments;
                var registersLength = Math.min(registersCount, 255);
                // max allowed for DefineFunction2
                registersLength = Math.max(registersLength, registersAllocationCount + 1);
                this.registersLength = registersLength;
            }
            AVM1InterpretedFunction.prototype.alCall = function (thisArg, args) {
                var currentContext = this.context;
                if (currentContext.executionProhibited) {
                    return;    // no more avm1 execution, ever
                }
                var newScope = new AVM1InterpreterScope(currentContext);
                var newScopeList = new AVM1ScopeListItem(newScope, this.scopeList);
                var oldScope = this.scopeList.scope;
                thisArg = thisArg || oldScope;
                // REDUX no isGlobalObject check?
                args = args || [];
                var ectx = ExecutionContext.create(currentContext, newScopeList, this.constantPool, this.registersLength);
                var caller = currentContext.frame ? currentContext.frame.fn : undefined;
                var frame = currentContext.pushCallFrame(thisArg, this, args, ectx);
                var supperWrapper;
                var suppressArguments = this.suppressArguments;
                if (!(suppressArguments & 4    /* Arguments */)) {
                    newScope.alPut('arguments', new AVM1Arguments(currentContext, args, this, caller));
                }
                if (!(suppressArguments & 2    /* This */)) {
                    newScope.alPut('this', thisArg);
                }
                if (!(suppressArguments & 8    /* Super */)) {
                    supperWrapper = new AVM1SuperWrapper(currentContext, frame);
                    newScope.alPut('super', supperWrapper);
                }
                var i;
                var registers = ectx.registers;
                var registersAllocation = this.registersAllocation;
                var registersAllocationCount = !registersAllocation ? 0 : registersAllocation.length;
                for (i = 0; i < registersAllocationCount; i++) {
                    var registerAllocation = registersAllocation[i];
                    if (registerAllocation) {
                        switch (registerAllocation.type) {
                        case 1    /* Argument */:
                            registers[i] = args[registerAllocation.index];
                            break;
                        case 2    /* This */:
                            registers[i] = thisArg;
                            break;
                        case 4    /* Arguments */:
                            registers[i] = new AVM1Arguments(currentContext, args, this, caller);
                            break;
                        case 8    /* Super */:
                            supperWrapper = supperWrapper || new AVM1SuperWrapper(currentContext, frame);
                            registers[i] = supperWrapper;
                            break;
                        case 16    /* Global */:
                            registers[i] = currentContext.globals;
                            break;
                        case 32    /* Parent */:
                            registers[i] = oldScope.alGet('_parent');
                            break;
                        case 64    /* Root */:
                            registers[i] = avm1ResolveRoot(ectx);
                            break;
                        }
                    }
                }
                var parametersNames = this.parametersNames;
                var skipArguments = this.skipArguments;
                for (i = 0; i < args.length || i < parametersNames.length; i++) {
                    if (skipArguments && skipArguments[i]) {
                        continue;
                    }
                    newScope.alPut(parametersNames[i], args[i]);
                }
                var result;
                var caughtError;
                var actionTracer = currentContext.actionTracer;
                var actionsData = this.actionsData;
                release || actionTracer && actionTracer.indent();
                if (++currentContext.stackDepth >= MAX_AVM1_STACK_LIMIT) {
                    throw new AVM1CriticalError('long running script -- AVM1 recursion limit is reached');
                }
                try {
                    result = interpretActionsData(ectx, actionsData);
                } catch (e) {
                    caughtError = e;
                }
                currentContext.stackDepth--;
                currentContext.popCallFrame();
                ectx.dispose();
                release || actionTracer && actionTracer.unindent();
                if (caughtError) {
                    // Note: this doesn't use `finally` because that's a no-go for performance.
                    throw caughtError;
                }
                return result;
            };
            return AVM1InterpretedFunction;
        }(AVM1.AVM1EvalFunction);
        function fixArgsCount(numArgs, maxAmount) {
            if (isNaN(numArgs) || numArgs < 0) {
                avm1Warn('Invalid amount of arguments: ' + numArgs);
                return 0;
            }
            numArgs |= 0;
            if (numArgs > maxAmount) {
                avm1Warn('Truncating amount of arguments: from ' + numArgs + ' to ' + maxAmount);
                return maxAmount;
            }
            return numArgs;
        }
        function avm1ReadFunctionArgs(stack) {
            var numArgs = +stack.pop();
            numArgs = fixArgsCount(numArgs, stack.length);
            var args = [];
            for (var i = 0; i < numArgs; i++) {
                args.push(stack.pop());
            }
            return args;
        }
        function avm1SetTarget(ectx, targetPath) {
            var newTarget = null;
            if (targetPath) {
                try {
                    newTarget = avm1ResolveTarget(ectx, targetPath, false);
                    if (!avm1IsTarget(newTarget)) {
                        avm1Warn('Invalid AVM1 target object: ' + targetPath);
                        newTarget = undefined;
                    }
                } catch (e) {
                    avm1Warn('Unable to set target: ' + e);
                }
            }
            if (newTarget) {
                ectx.scopeList.flags |= AVM1ScopeListItemFlags.REPLACE_TARGET;
                ectx.scopeList.replaceTargetBy = newTarget;
            } else {
                ectx.scopeList.flags &= ~AVM1ScopeListItemFlags.REPLACE_TARGET;
                ectx.scopeList.replaceTargetBy = null;
            }
        }
        function isGlobalObject(obj) {
            return obj === this;
        }
        function avm1DefineFunction(ectx, actionsData, functionName, parametersNames, registersCount, registersAllocation, suppressArguments) {
            return new AVM1InterpretedFunction(ectx.context, ectx, actionsData, functionName, parametersNames, registersCount, registersAllocation, suppressArguments);
        }
        function avm1VariableNameHasPath(variableName) {
            return variableName && (variableName.indexOf('.') >= 0 || variableName.indexOf(':') >= 0 || variableName.indexOf('/') >= 0);
        }
        var cachedResolvedVariableResult = {
            scope: null,
            propertyName: null,
            value: undefined
        };
        function avm1IsTarget(target) {
            // TODO refactor
            return target instanceof AVM1.AVM1Object && AVM1.Lib.hasAS3ObjectReference(target);
        }
        function avm1ResolveSimpleVariable(scopeList, variableName, flags) {
            release || Shumway.Debug.assert(AVM1.alIsName(scopeList.scope.context, variableName));
            var currentTarget;
            var resolved = cachedResolvedVariableResult;
            for (var p = scopeList; p; p = p.previousScopeItem) {
                if (p.flags & AVM1ScopeListItemFlags.REPLACE_TARGET && !(flags & 64    /* DISALLOW_TARGET_OVERRIDE */) && !currentTarget) {
                    currentTarget = p.replaceTargetBy;
                }
                if (p.flags & AVM1ScopeListItemFlags.TARGET) {
                    if (flags & 2    /* WRITE */) {
                        // last scope/target we can modify (exclude globals)
                        resolved.scope = currentTarget || p.scope;
                        resolved.propertyName = variableName;
                        resolved.value = flags & 32    /* GET_VALUE */ ? resolved.scope.alGet(variableName) : undefined;
                        return resolved;
                    }
                    if (flags & 1    /* READ */ && currentTarget) {
                        if (currentTarget.alHasProperty(variableName)) {
                            resolved.scope = currentTarget;
                            resolved.propertyName = variableName;
                            resolved.value = flags & 32    /* GET_VALUE */ ? currentTarget.alGet(variableName) : undefined;
                            return resolved;
                        }
                        continue;
                    }
                }
                if (p.scope.alHasProperty(variableName)) {
                    resolved.scope = p.scope;
                    resolved.propertyName = variableName;
                    resolved.value = flags & 32    /* GET_VALUE */ ? p.scope.alGet(variableName) : undefined;
                    return resolved;
                }
            }
            release || Shumway.Debug.assert(!(flags & 2    /* WRITE */));
            return undefined;
        }
        function avm1ResolveVariable(ectx, variableName, flags) {
            // For now it is just very much magical -- designed to pass some of the swfdec tests
            // FIXME refactor
            release || Shumway.Debug.assert(variableName);
            // Canonicalizing the name here is ok even for paths: the only thing that (potentially)
            // happens is that the name is converted to lower-case, which is always valid for paths.
            // The original name is saved because the final property name needs to be extracted from
            // it for property name paths.
            var originalName = variableName;
            variableName = ectx.context.normalizeName(variableName);
            if (!avm1VariableNameHasPath(variableName)) {
                return avm1ResolveSimpleVariable(ectx.scopeList, variableName, flags);
            }
            var i = 0, j = variableName.length;
            var markedAsTarget = true;
            var resolved, ch, needsScopeResolution;
            var propertyName = null, scope = null, obj = undefined;
            if (variableName[0] === '/') {
                resolved = avm1ResolveSimpleVariable(ectx.scopeList, '_root', 1    /* READ */ | 32    /* GET_VALUE */);
                if (resolved) {
                    propertyName = resolved.propertyName;
                    scope = resolved.scope;
                    obj = resolved.value;
                }
                i++;
                needsScopeResolution = false;
            } else {
                resolved = null;
                needsScopeResolution = true;
            }
            if (i >= j) {
                return resolved;
            }
            var q = i;
            while (i < j) {
                if (!needsScopeResolution && !(obj instanceof AVM1.AVM1Object)) {
                    avm1Warn('Unable to resolve variable on invalid object ' + variableName.substring(q, i - 1) + ' (expr ' + variableName + ')');
                    return null;
                }
                var propertyName;
                var q = i;
                if (variableName[i] === '.' && variableName[i + 1] === '.') {
                    i += 2;
                    propertyName = '_parent';
                } else {
                    while (i < j && ((ch = variableName[i]) !== '/' && ch !== '.' && ch !== ':')) {
                        i++;
                    }
                    propertyName = variableName.substring(q, i);
                }
                if (propertyName === '' && i < j) {
                    // Ignoring double delimiters in the middle of the path
                    i++;
                    continue;
                }
                scope = obj;
                var valueFound = false;
                if (markedAsTarget) {
                    // Trying movie clip children first
                    var child = obj instanceof AVM1.Lib.AVM1MovieClip ? obj._lookupChildByName(propertyName) : undefined;
                    if (child) {
                        valueFound = true;
                        obj = child;
                    }
                }
                if (!valueFound) {
                    if (needsScopeResolution) {
                        resolved = avm1ResolveSimpleVariable(ectx.scopeList, propertyName, flags);
                        if (resolved) {
                            valueFound = true;
                            propertyName = resolved.propertyName;
                            scope = resolved.scope;
                            obj = resolved.value;
                        }
                        needsScopeResolution = false;
                    } else if (obj.alHasProperty(propertyName)) {
                        obj = obj.alGet(propertyName);
                        valueFound = true;
                    }
                }
                if (!valueFound && propertyName[0] === '_') {
                    // FIXME hacking to pass some swfdec test cases
                    if (propertyName === '_level0') {
                        obj = ectx.context.resolveLevel(0);
                        valueFound = true;
                    } else if (propertyName === '_root') {
                        obj = avm1ResolveRoot(ectx);
                        valueFound = true;
                    }
                }
                if (!valueFound && !(flags & 2    /* WRITE */)) {
                    avm1Warn('Unable to resolve ' + propertyName + ' on ' + variableName.substring(q, i - 1) + ' (expr ' + variableName + ')');
                    return null;
                }
                if (i >= j) {
                    break;
                }
                var delimiter = variableName[i++];
                if (delimiter === '/' && ((ch = variableName[i]) === ':' || ch === '.')) {
                    delimiter = variableName[i++];
                }
                markedAsTarget = delimiter === '/';
            }
            resolved = cachedResolvedVariableResult;
            resolved.scope = scope;
            resolved.propertyName = originalName.substring(q, i);
            resolved.value = flags & 32    /* GET_VALUE */ ? obj : undefined;
            return resolved;
        }
        function avm1GetTarget(ectx, allowOverride) {
            var scopeList = ectx.scopeList;
            for (var p = scopeList; p.previousScopeItem; p = p.previousScopeItem) {
                if (p.flags & AVM1ScopeListItemFlags.REPLACE_TARGET && allowOverride) {
                    return p.replaceTargetBy;
                }
                if (p.flags & AVM1ScopeListItemFlags.TARGET) {
                    return p.scope;
                }
            }
            release || Shumway.Debug.assert(false, 'Shall not reach this statement');
            return undefined;
        }
        function avm1ResolveTarget(ectx, target, fromCurrentTarget) {
            var result;
            if (avm1IsTarget(target)) {
                result = target;
            } else {
                target = Shumway.isNullOrUndefined(target) ? '' : AVM1.alToString(this, target);
                if (target) {
                    var targetPath = AVM1.alToString(ectx.context, target);
                    var resolved = avm1ResolveVariable(ectx, targetPath, 1    /* READ */ | 128    /* ONLY_TARGETS */ | 32    /* GET_VALUE */ | (fromCurrentTarget ? 0 : 64    /* DISALLOW_TARGET_OVERRIDE */));
                    if (!resolved || !avm1IsTarget(resolved.value)) {
                        avm1Warn('Invalid AVM1 target object: ' + targetPath);
                        result = undefined;
                    } else {
                        result = resolved.value;
                    }
                } else {
                    result = avm1GetTarget(ectx, true);
                }
            }
            return result;
        }
        function avm1ResolveRoot(ectx) {
            var target = avm1GetTarget(ectx, true);
            return target.get_root();
        }
        function avm1ProcessWith(ectx, obj, withBlock) {
            if (Shumway.isNullOrUndefined(obj)) {
                // Not executing anything in the block.
                avm1Warn('The with statement object cannot be undefined.');
                return;
            }
            var context = ectx.context;
            var scopeList = ectx.scopeList;
            var newScopeList = new AVM1ScopeListItem(AVM1.alToObject(context, obj), scopeList);
            var newEctx = ectx.pushScope(newScopeList);
            interpretActionsData(newEctx, withBlock);
        }
        function avm1ProcessTry(ectx, catchIsRegisterFlag, finallyBlockFlag, catchBlockFlag, catchTarget, tryBlock, catchBlock, finallyBlock) {
            var currentContext = ectx.context;
            var scopeList = ectx.scopeList;
            var registers = ectx.registers;
            var savedTryCatchState = currentContext.isTryCatchListening;
            var caughtError;
            try {
                currentContext.isTryCatchListening = true;
                interpretActionsData(ectx.pushScope(), tryBlock);
            } catch (e) {
                currentContext.isTryCatchListening = savedTryCatchState;
                if (!catchBlockFlag || !(e instanceof AVM1Error)) {
                    caughtError = e;
                } else {
                    if (typeof catchTarget === 'string') {
                        var scope = scopeList.scope;
                        scope.alPut(catchTarget, e.error);
                    } else {
                        registers[catchTarget] = e.error;
                    }
                    interpretActionsData(ectx.pushScope(), catchBlock);
                }
            }
            currentContext.isTryCatchListening = savedTryCatchState;
            if (finallyBlockFlag) {
                interpretActionsData(ectx.pushScope(), finallyBlock);
            }
            if (caughtError) {
                throw caughtError;
            }
        }
        // SWF 3 actions
        function avm1_0x81_ActionGotoFrame(ectx, args) {
            var frame = args[0];
            var play = args[1];
            if (play) {
                ectx.actions.gotoAndPlay(frame + 1);
            } else {
                ectx.actions.gotoAndStop(frame + 1);
            }
        }
        function avm1_0x83_ActionGetURL(ectx, args) {
            var actions = ectx.actions;
            var urlString = args[0];
            var targetString = args[1];
            ectx.actions.getURL(urlString, targetString);
        }
        function avm1_0x04_ActionNextFrame(ectx) {
            ectx.actions.nextFrame();
        }
        function avm1_0x05_ActionPreviousFrame(ectx) {
            ectx.actions.prevFrame();
        }
        function avm1_0x06_ActionPlay(ectx) {
            ectx.actions.play();
        }
        function avm1_0x07_ActionStop(ectx) {
            ectx.actions.stop();
        }
        function avm1_0x08_ActionToggleQuality(ectx) {
            ectx.actions.toggleHighQuality();
        }
        function avm1_0x09_ActionStopSounds(ectx) {
            ectx.actions.stopAllSounds();
        }
        function avm1_0x8A_ActionWaitForFrame(ectx, args) {
            var frame = args[0];
            var count = args[1];
            return !ectx.actions.ifFrameLoaded(frame);
        }
        function avm1_0x8B_ActionSetTarget(ectx, args) {
            var targetName = args[0];
            avm1SetTarget(ectx, targetName);
        }
        function avm1_0x8C_ActionGoToLabel(ectx, args) {
            var label = args[0];
            var play = args[1];
            if (play) {
                ectx.actions.gotoAndPlay(label);
            } else {
                ectx.actions.gotoAndStop(label);
            }
        }
        // SWF 4 actions
        function avm1_0x96_ActionPush(ectx, args) {
            var registers = ectx.registers;
            var constantPool = ectx.constantPool;
            var stack = ectx.stack;
            args.forEach(function (value) {
                if (value instanceof AVM1.ParsedPushConstantAction) {
                    stack.push(constantPool[value.constantIndex]);
                } else if (value instanceof AVM1.ParsedPushRegisterAction) {
                    var registerNumber = value.registerNumber;
                    if (registerNumber < 0 || registerNumber >= registers.length) {
                        stack.push(undefined);
                    } else {
                        stack.push(registers[registerNumber]);
                    }
                } else {
                    stack.push(value);
                }
            });
        }
        function avm1_0x17_ActionPop(ectx) {
            var stack = ectx.stack;
            stack.pop();
        }
        function avm1_0x0A_ActionAdd(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            var b = AVM1.alToNumber(ectx.context, stack.pop());
            stack.push(a + b);
        }
        function avm1_0x0B_ActionSubtract(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            var b = AVM1.alToNumber(ectx.context, stack.pop());
            stack.push(b - a);
        }
        function avm1_0x0C_ActionMultiply(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            var b = AVM1.alToNumber(ectx.context, stack.pop());
            stack.push(a * b);
        }
        function avm1_0x0D_ActionDivide(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            var b = AVM1.alToNumber(ectx.context, stack.pop());
            var c = b / a;
            stack.push(isSwfVersion5 ? c : isFinite(c) ? c : '#ERROR#');
        }
        function avm1_0x0E_ActionEquals(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            var b = AVM1.alToNumber(ectx.context, stack.pop());
            var f = a == b;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x0F_ActionLess(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            var b = AVM1.alToNumber(ectx.context, stack.pop());
            var f = b < a;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x10_ActionAnd(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var a = AVM1.alToBoolean(ectx.context, stack.pop());
            var b = AVM1.alToBoolean(ectx.context, stack.pop());
            var f = a && b;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x11_ActionOr(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var a = AVM1.alToBoolean(ectx.context, stack.pop());
            var b = AVM1.alToBoolean(ectx.context, stack.pop());
            var f = a || b;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x12_ActionNot(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var f = !AVM1.alToBoolean(ectx.context, stack.pop());
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x13_ActionStringEquals(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var sa = AVM1.alToString(ectx.context, stack.pop());
            var sb = AVM1.alToString(ectx.context, stack.pop());
            var f = sa == sb;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x14_ActionStringLength(ectx) {
            var stack = ectx.stack;
            var sa = AVM1.alToString(ectx.context, stack.pop());
            stack.push(ectx.actions.length_(sa));
        }
        function avm1_0x31_ActionMBStringLength(ectx) {
            var stack = ectx.stack;
            var sa = AVM1.alToString(ectx.context, stack.pop());
            stack.push(ectx.actions.length_(sa));
        }
        function avm1_0x21_ActionStringAdd(ectx) {
            var stack = ectx.stack;
            var sa = AVM1.alToString(ectx.context, stack.pop());
            var sb = AVM1.alToString(ectx.context, stack.pop());
            stack.push(sb + sa);
        }
        function avm1_0x15_ActionStringExtract(ectx) {
            var stack = ectx.stack;
            var count = stack.pop();
            var index = stack.pop();
            var value = AVM1.alToString(ectx.context, stack.pop());
            stack.push(ectx.actions.substring(value, index, count));
        }
        function avm1_0x35_ActionMBStringExtract(ectx) {
            var stack = ectx.stack;
            var count = stack.pop();
            var index = stack.pop();
            var value = AVM1.alToString(ectx.context, stack.pop());
            stack.push(ectx.actions.mbsubstring(value, index, count));
        }
        function avm1_0x29_ActionStringLess(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var sa = AVM1.alToString(ectx.context, stack.pop());
            var sb = AVM1.alToString(ectx.context, stack.pop());
            var f = sb < sa;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        function avm1_0x18_ActionToInteger(ectx) {
            var stack = ectx.stack;
            var value = AVM1.alToInt32(ectx.context, stack.pop());
            stack.push(value);
        }
        function avm1_0x32_ActionCharToAscii(ectx) {
            var stack = ectx.stack;
            var ch = stack.pop();
            var charCode = ectx.actions.ord(ch);
            stack.push(charCode);
        }
        function avm1_0x36_ActionMBCharToAscii(ectx) {
            var stack = ectx.stack;
            var ch = stack.pop();
            var charCode = ectx.actions.mbord(ch);
            stack.push(charCode);
        }
        function avm1_0x33_ActionAsciiToChar(ectx) {
            var stack = ectx.stack;
            var charCode = +stack.pop();
            var ch = ectx.actions.chr(charCode);
            stack.push(ch);
        }
        function avm1_0x37_ActionMBAsciiToChar(ectx) {
            var stack = ectx.stack;
            var charCode = +stack.pop();
            var ch = ectx.actions.mbchr(charCode);
            stack.push(ch);
        }
        function avm1_0x99_ActionJump(ectx, args) {
        }
        function avm1_0x9D_ActionIf(ectx, args) {
            var stack = ectx.stack;
            var offset = args[0];
            return !!stack.pop();
        }
        function avm1_0x9E_ActionCall(ectx) {
            var stack = ectx.stack;
            var label = stack.pop();
            ectx.actions.call(label);
        }
        function avm1_0x1C_ActionGetVariable(ectx) {
            var stack = ectx.stack;
            var variableName = '' + stack.pop();
            var sp = stack.length;
            stack.push(undefined);
            var resolved = avm1ResolveVariable(ectx, variableName, 1    /* READ */ | 32    /* GET_VALUE */);
            if (Shumway.isNullOrUndefined(resolved)) {
                if (AVM1.avm1WarningsEnabled.value) {
                    avm1Warn('AVM1 warning: cannot look up variable \'' + variableName + '\'');
                }
                return;
            }
            stack[sp] = resolved.value;
        }
        function avm1_0x1D_ActionSetVariable(ectx) {
            var stack = ectx.stack;
            var value = stack.pop();
            var variableName = '' + stack.pop();
            var resolved = avm1ResolveVariable(ectx, variableName, 2    /* WRITE */);
            if (!resolved) {
                if (AVM1.avm1WarningsEnabled.value) {
                    avm1Warn('AVM1 warning: cannot look up variable \'' + variableName + '\'');
                }
                return;
            }
            release || assert(resolved.propertyName);
            resolved.scope.alPut(resolved.propertyName, value);
            as2SyncEvents(ectx.context, resolved.propertyName);
        }
        function avm1_0x9A_ActionGetURL2(ectx, args) {
            var stack = ectx.stack;
            var flags = args[0];
            var target = stack.pop();
            var url = stack.pop();
            var sendVarsMethod;
            if (flags & 1) {
                sendVarsMethod = 'GET';
            } else if (flags & 2) {
                sendVarsMethod = 'POST';
            }
            var loadTargetFlag = flags & 1 << 6;
            var loadVariablesFlag = flags & 1 << 7;
            if (loadVariablesFlag) {
                ectx.actions.loadVariables(url, target, sendVarsMethod);
            } else if (!loadTargetFlag) {
                ectx.actions.getURL(url, target, sendVarsMethod);
            } else {
                ectx.actions.loadMovie(url, target, sendVarsMethod);
            }
        }
        function avm1_0x9F_ActionGotoFrame2(ectx, args) {
            var stack = ectx.stack;
            var flags = args[0];
            var gotoParams = [stack.pop()];
            if (!!(flags & 2)) {
                gotoParams.push(args[1]);
            }
            var gotoMethod = !!(flags & 1) ? ectx.actions.gotoAndPlay : ectx.actions.gotoAndStop;
            gotoMethod.apply(ectx.actions, gotoParams);
        }
        function avm1_0x20_ActionSetTarget2(ectx) {
            var stack = ectx.stack;
            var target = AVM1.alToString(ectx.context, stack.pop());
            avm1SetTarget(ectx, target);
        }
        function avm1_0x22_ActionGetProperty(ectx) {
            var stack = ectx.stack;
            var index = stack.pop();
            var target = stack.pop();
            var sp = stack.length;
            stack.push(undefined);
            var resolved = avm1ResolveTarget(ectx, target, true);
            var propertyName = MovieClipProperties[index];
            if (resolved && propertyName) {
                stack[sp] = resolved.alGet(propertyName);
            }
        }
        function avm1_0x23_ActionSetProperty(ectx) {
            var stack = ectx.stack;
            var value = stack.pop();
            var index = stack.pop();
            var target = stack.pop();
            var resolved = avm1ResolveTarget(ectx, target, true);
            var propertyName = MovieClipProperties[index];
            if (resolved && propertyName) {
                resolved.alPut(propertyName, value);
            }
        }
        function avm1_0x24_ActionCloneSprite(ectx) {
            var stack = ectx.stack;
            var depth = stack.pop();
            var target = stack.pop();
            var source = stack.pop();
            ectx.actions.duplicateMovieClip(source, target, depth);
        }
        function avm1_0x25_ActionRemoveSprite(ectx) {
            var stack = ectx.stack;
            var target = stack.pop();
            ectx.actions.removeMovieClip(target);
        }
        function avm1_0x27_ActionStartDrag(ectx) {
            var stack = ectx.stack;
            var target = stack.pop();
            var lockcenter = stack.pop();
            var constrain = !stack.pop() ? null : {
                y2: stack.pop(),
                x2: stack.pop(),
                y1: stack.pop(),
                x1: stack.pop()
            };
            var dragParams = [
                target,
                lockcenter
            ];
            if (constrain) {
                dragParams = dragParams.concat(constrain.x1, constrain.y1, constrain.x2, constrain.y2);
            }
            ectx.actions.startDrag.apply(ectx.actions, dragParams);
        }
        function avm1_0x28_ActionEndDrag(ectx) {
            ectx.actions.stopDrag();
        }
        function avm1_0x8D_ActionWaitForFrame2(ectx, args) {
            var stack = ectx.stack;
            var count = args[0];
            var frame = stack.pop();
            return !ectx.actions.ifFrameLoaded(frame);
        }
        function avm1_0x26_ActionTrace(ectx) {
            var stack = ectx.stack;
            var value = stack.pop();
            ectx.actions.trace(value);
        }
        function avm1_0x34_ActionGetTime(ectx) {
            var stack = ectx.stack;
            stack.push(ectx.actions.getTimer());
        }
        function avm1_0x30_ActionRandomNumber(ectx) {
            var stack = ectx.stack;
            stack.push(ectx.actions.random(stack.pop()));
        }
        // SWF 5
        function avm1_0x3D_ActionCallFunction(ectx) {
            var stack = ectx.stack;
            var functionName = stack.pop();
            var args = avm1ReadFunctionArgs(stack);
            var sp = stack.length;
            stack.push(undefined);
            var resolved = avm1ResolveVariable(ectx, functionName, 1    /* READ */ | 32    /* GET_VALUE */);
            if (Shumway.isNullOrUndefined(resolved)) {
                avm1Warn('AVM1 warning: cannot look up function \'' + functionName + '\'');
                return;
            }
            var fn = resolved.value;
            // AVM1 simply ignores attempts to invoke non-functions.
            if (!AVM1.alIsFunction(fn)) {
                avm1Warn('AVM1 warning: function \'' + functionName + (fn ? '\' is not callable' : '\' is undefined'));
                return;
            }
            release || assert(stack.length === sp + 1);
            // REDUX
            stack[sp] = fn.alCall(resolved.scope || null, args);
        }
        function avm1_0x52_ActionCallMethod(ectx) {
            var stack = ectx.stack;
            var methodName = stack.pop();
            var obj = stack.pop();
            var args = avm1ReadFunctionArgs(stack);
            var target;
            var sp = stack.length;
            stack.push(undefined);
            // AVM1 simply ignores attempts to invoke methods on non-existing objects.
            if (Shumway.isNullOrUndefined(obj)) {
                avm1Warn('AVM1 warning: method \'' + methodName + '\' can\'t be called on undefined object');
                return;
            }
            var frame = ectx.context.frame;
            var superArg;
            var fn;
            // Per spec, a missing or blank method name causes the container to be treated as
            // a function to call.
            if (Shumway.isNullOrUndefined(methodName) || methodName === '') {
                if (obj instanceof AVM1SuperWrapper) {
                    var superFrame = obj.callFrame;
                    superArg = avm1FindSuperPropertyOwner(ectx.context, superFrame, '__constructor__');
                    if (superArg) {
                        fn = superArg.alGet('__constructor__');
                        target = superFrame.currentThis;
                    }
                } else {
                    // For non-super calls, we call obj with itself as the target.
                    // TODO: ensure this is correct.
                    fn = obj;
                    target = obj;
                }
                // AVM1 simply ignores attempts to invoke non-functions.
                if (AVM1.alIsFunction(fn)) {
                    frame.setCallee(target, superArg, fn, args);
                    stack[sp] = fn.alCall(target, args);
                    frame.resetCallee();
                } else {
                    avm1Warn('AVM1 warning: obj \'' + obj + (obj ? '\' is not callable' : '\' is undefined'));
                }
                release || assert(stack.length === sp + 1);
                return;
            }
            if (obj instanceof AVM1SuperWrapper) {
                var superFrame = obj.callFrame;
                var superArg = avm1FindSuperPropertyOwner(ectx.context, superFrame, methodName);
                if (superArg) {
                    fn = superArg.alGet(methodName);
                    target = superFrame.currentThis;
                }
            } else {
                fn = as2GetProperty(ectx.context, obj, methodName);
                target = AVM1.alToObject(ectx.context, obj);
            }
            // AVM1 simply ignores attempts to invoke non-methods.
            if (!AVM1.alIsFunction(fn)) {
                avm1Warn('AVM1 warning: method \'' + methodName + '\' on object', obj, Shumway.isNullOrUndefined(fn) ? 'is undefined' : 'is not callable');
                return;
            }
            release || assert(stack.length === sp + 1);
            frame.setCallee(target, superArg, fn, args);
            stack[sp] = fn.alCall(target, args);
            frame.resetCallee();
        }
        function avm1_0x88_ActionConstantPool(ectx, args) {
            var constantPool = args[0];
            ectx.constantPool = constantPool;
        }
        function avm1_0x9B_ActionDefineFunction(ectx, args) {
            var stack = ectx.stack;
            var functionBody = args[0];
            var functionName = args[1];
            var functionParams = args[2];
            var fn = avm1DefineFunction(ectx, functionBody, functionName, functionParams, 4, null, 0);
            if (functionName) {
                var scope = ectx.scopeList.scope;
                scope.alPut(functionName, fn);
                as2SyncEvents(ectx.context, functionName);
            } else {
                stack.push(fn);
            }
        }
        function avm1_0x3C_ActionDefineLocal(ectx) {
            var stack = ectx.stack;
            var scope = ectx.scopeList.scope;
            var value = stack.pop();
            var name = stack.pop();
            scope.alPut(name, value);
        }
        function avm1_0x41_ActionDefineLocal2(ectx) {
            var stack = ectx.stack;
            var scope = ectx.scopeList.scope;
            var name = stack.pop();
            scope.alPut(name, undefined);
        }
        function avm1_0x3A_ActionDelete(ectx) {
            var stack = ectx.stack;
            var name = stack.pop();
            var obj = stack.pop();
            if (Shumway.isNullOrUndefined(obj)) {
                // AVM1 just ignores delete on non-existant containers.
                avm1Warn('AVM1 warning: cannot delete member \'' + name + '\' on undefined object');
                return;
            }
            stack.push(as2DeleteProperty(ectx.context, obj, name));
            as2SyncEvents(ectx.context, name);
        }
        function avm1_0x3B_ActionDelete2(ectx) {
            var stack = ectx.stack;
            var name = stack.pop();
            var resolved = avm1ResolveVariable(ectx, name, 1    /* DELETE */);
            if (Shumway.isNullOrUndefined(resolved)) {
                avm1Warn('AVM1 warning: cannot look up variable \'' + name + '\'');
                return;
            }
            stack.push(as2DeleteProperty(ectx.context, resolved.scope, name));
            as2SyncEvents(ectx.context, name);
        }
        function avm1_0x46_ActionEnumerate(ectx) {
            var stack = ectx.stack;
            var objectName = stack.pop();
            stack.push(null);
            var resolved = avm1ResolveVariable(ectx, objectName, 1    /* READ */ | 32    /* GET_VALUE */);
            if (Shumway.isNullOrUndefined(resolved)) {
                avm1Warn('AVM1 warning: cannot look up variable \'' + objectName + '\'');
                return;
            }
            var obj = resolved.value;
            if (Shumway.isNullOrUndefined(obj)) {
                avm1Warn('AVM1 warning: cannot iterate over undefined object');
                return;
            }
            as2Enumerate(obj, function (name) {
                stack.push(name);
            }, null);
        }
        function avm1_0x49_ActionEquals2(ectx) {
            var stack = ectx.stack;
            var a = stack.pop();
            var b = stack.pop();
            stack.push(as2Equals(ectx.context, a, b));
        }
        function avm1_0x4E_ActionGetMember(ectx) {
            var stack = ectx.stack;
            var name = stack.pop();
            var obj = stack.pop();
            stack.push(undefined);
            if (Shumway.isNullOrUndefined(obj)) {
                // AVM1 just ignores gets on non-existant containers.
                avm1Warn('AVM1 warning: cannot get member \'' + name + '\' on undefined object');
                return;
            }
            if (obj instanceof AVM1SuperWrapper) {
                var superFrame = obj.callFrame;
                var superArg = avm1FindSuperPropertyOwner(ectx.context, superFrame, name);
                if (superArg) {
                    stack[stack.length - 1] = superArg.alGet(name);
                }
                return;
            }
            stack[stack.length - 1] = as2GetProperty(ectx.context, obj, name);
        }
        function avm1_0x42_ActionInitArray(ectx) {
            var stack = ectx.stack;
            var obj = new AVM1.Natives.AVM1ArrayNative(ectx.context, avm1ReadFunctionArgs(stack));
            stack.push(obj);
        }
        function avm1_0x43_ActionInitObject(ectx) {
            var stack = ectx.stack;
            var count = +stack.pop();
            count = fixArgsCount(count, stack.length >> 1);
            var obj = AVM1.alNewObject(ectx.context);
            for (var i = 0; i < count; i++) {
                var value = stack.pop();
                var name = stack.pop();
                obj.alPut(name, value);
            }
            stack.push(obj);
        }
        function avm1_0x53_ActionNewMethod(ectx) {
            var stack = ectx.stack;
            var methodName = stack.pop();
            var obj = stack.pop();
            var args = avm1ReadFunctionArgs(stack);
            var sp = stack.length;
            stack.push(undefined);
            // AVM1 simply ignores attempts to construct methods on non-existing objects.
            if (Shumway.isNullOrUndefined(obj)) {
                avm1Warn('AVM1 warning: method \'' + methodName + '\' can\'t be constructed on undefined object');
                return;
            }
            var ctor;
            // Per spec, a missing or blank method name causes the container to be treated as
            // a function to construct.
            if (Shumway.isNullOrUndefined(methodName) || methodName === '') {
                ctor = obj;
            } else {
                ctor = as2GetProperty(ectx.context, obj, methodName);
            }
            var result = as2Construct(ctor, args);
            if (result === undefined) {
                avm1Warn('AVM1 warning: method \'' + methodName + '\' on object', obj, 'is not constructible');
            }
            stack[sp] = result;
            release || assert(stack.length === sp + 1);
        }
        function avm1_0x40_ActionNewObject(ectx) {
            var stack = ectx.stack;
            var objectName = stack.pop();
            var args = avm1ReadFunctionArgs(stack);
            var sp = stack.length;
            stack.push(undefined);
            var resolved = avm1ResolveVariable(ectx, objectName, 1    /* READ */ | 32    /* GET_VALUE */);
            if (Shumway.isNullOrUndefined(resolved)) {
                avm1Warn('AVM1 warning: cannot look up object \'' + objectName + '\'');
                return;
            }
            var obj = resolved.value;
            var result = createBuiltinType(ectx.context, obj, args);
            if (result === undefined) {
                // obj in not a built-in type
                result = as2Construct(obj, args);
                if (result === undefined) {
                    avm1Warn('AVM1 warning: object \'' + objectName + (obj ? '\' is not constructible' : '\' is undefined'));
                }
            }
            release || assert(stack.length === sp + 1);
            stack[sp] = result;
        }
        function avm1_0x4F_ActionSetMember(ectx) {
            var stack = ectx.stack;
            var value = stack.pop();
            var name = stack.pop();
            var obj = stack.pop();
            if (Shumway.isNullOrUndefined(obj)) {
                // AVM1 just ignores sets on non-existant containers
                avm1Warn('AVM1 warning: cannot set member \'' + name + '\' on undefined object');
                return;
            }
            if (obj instanceof AVM1SuperWrapper) {
                avm1Warn('AVM1 warning: cannot set member \'' + name + '\' on super');
                return;
            }
            as2SetProperty(ectx.context, obj, name, value);
        }
        function avm1_0x45_ActionTargetPath(ectx) {
            var stack = ectx.stack;
            var obj = stack.pop();
            stack.push(isAVM1MovieClip(obj) ? obj._target : void 0);
        }
        function avm1_0x94_ActionWith(ectx, args) {
            var stack = ectx.stack;
            var withBody = args[0];
            var obj = stack.pop();
            avm1ProcessWith(ectx, obj, withBody);
        }
        function avm1_0x4A_ActionToNumber(ectx) {
            var stack = ectx.stack;
            stack.push(AVM1.alToNumber(ectx.context, stack.pop()));
        }
        function avm1_0x4B_ActionToString(ectx) {
            var stack = ectx.stack;
            stack.push(AVM1.alToString(ectx.context, stack.pop()));
        }
        function avm1_0x44_ActionTypeOf(ectx) {
            var stack = ectx.stack;
            var obj = stack.pop();
            var result = as2GetType(obj);
            stack.push(result);
        }
        function avm1_0x47_ActionAdd2(ectx) {
            var stack = ectx.stack;
            var a = as2ToAddPrimitive(ectx.context, stack.pop());
            var b = as2ToAddPrimitive(ectx.context, stack.pop());
            if (typeof a === 'string' || typeof b === 'string') {
                stack.push(AVM1.alToString(ectx.context, b) + AVM1.alToString(ectx.context, a));
            } else {
                stack.push(AVM1.alToNumber(ectx.context, b) + AVM1.alToNumber(ectx.context, a));
            }
        }
        function avm1_0x48_ActionLess2(ectx) {
            var stack = ectx.stack;
            var a = stack.pop();
            var b = stack.pop();
            stack.push(as2Compare(ectx.context, b, a));
        }
        function avm1_0x3F_ActionModulo(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            var b = AVM1.alToNumber(ectx.context, stack.pop());
            stack.push(b % a);
        }
        function avm1_0x60_ActionBitAnd(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToInt32(ectx.context, stack.pop());
            var b = AVM1.alToInt32(ectx.context, stack.pop());
            stack.push(b & a);
        }
        function avm1_0x63_ActionBitLShift(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToInt32(ectx.context, stack.pop());
            var b = AVM1.alToInt32(ectx.context, stack.pop());
            stack.push(b << a);
        }
        function avm1_0x61_ActionBitOr(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToInt32(ectx.context, stack.pop());
            var b = AVM1.alToInt32(ectx.context, stack.pop());
            stack.push(b | a);
        }
        function avm1_0x64_ActionBitRShift(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToInt32(ectx.context, stack.pop());
            var b = AVM1.alToInt32(ectx.context, stack.pop());
            stack.push(b >> a);
        }
        function avm1_0x65_ActionBitURShift(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToInt32(ectx.context, stack.pop());
            var b = AVM1.alToInt32(ectx.context, stack.pop());
            stack.push(b >>> a);
        }
        function avm1_0x62_ActionBitXor(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToInt32(ectx.context, stack.pop());
            var b = AVM1.alToInt32(ectx.context, stack.pop());
            stack.push(b ^ a);
        }
        function avm1_0x51_ActionDecrement(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            a--;
            stack.push(a);
        }
        function avm1_0x50_ActionIncrement(ectx) {
            var stack = ectx.stack;
            var a = AVM1.alToNumber(ectx.context, stack.pop());
            a++;
            stack.push(a);
        }
        function avm1_0x4C_ActionPushDuplicate(ectx) {
            var stack = ectx.stack;
            stack.push(stack[stack.length - 1]);
        }
        function avm1_0x3E_ActionReturn(ectx) {
            ectx.isEndOfActions = true;
        }
        function avm1_0x4D_ActionStackSwap(ectx) {
            var stack = ectx.stack;
            stack.push(stack.pop(), stack.pop());
        }
        function avm1_0x87_ActionStoreRegister(ectx, args) {
            var stack = ectx.stack;
            var registers = ectx.registers;
            var register = args[0];
            if (register < 0 || register >= registers.length) {
                return;    // ignoring bad registers references
            }
            registers[register] = stack[stack.length - 1];
        }
        // SWF 6
        function avm1_0x54_ActionInstanceOf(ectx) {
            var stack = ectx.stack;
            var constr = stack.pop();
            var obj = stack.pop();
            stack.push(as2InstanceOf(obj, constr));
        }
        function avm1_0x55_ActionEnumerate2(ectx) {
            var stack = ectx.stack;
            var obj = stack.pop();
            stack.push(null);
            // AVM1 just ignores lookups on non-existant containers
            if (Shumway.isNullOrUndefined(obj)) {
                avm1Warn('AVM1 warning: cannot iterate over undefined object');
                return;
            }
            as2Enumerate(obj, function (name) {
                stack.push(name);
            }, null);
        }
        function avm1_0x66_ActionStrictEquals(ectx) {
            var stack = ectx.stack;
            var a = stack.pop();
            var b = stack.pop();
            stack.push(b === a);
        }
        function avm1_0x67_ActionGreater(ectx) {
            var stack = ectx.stack;
            var a = stack.pop();
            var b = stack.pop();
            stack.push(as2Compare(ectx.context, a, b));
        }
        function avm1_0x68_ActionStringGreater(ectx) {
            var stack = ectx.stack;
            var isSwfVersion5 = ectx.isSwfVersion5;
            var sa = AVM1.alToString(ectx.context, stack.pop());
            var sb = AVM1.alToString(ectx.context, stack.pop());
            var f = sb > sa;
            stack.push(isSwfVersion5 ? f : f ? 1 : 0);
        }
        // SWF 7
        function avm1_0x8E_ActionDefineFunction2(ectx, args) {
            var stack = ectx.stack;
            var scope = ectx.scopeList.scope;
            var functionBody = args[0];
            var functionName = args[1];
            var functionParams = args[2];
            var registerCount = args[3];
            var registerAllocation = args[4];
            var suppressArguments = args[5];
            var fn = avm1DefineFunction(ectx, functionBody, functionName, functionParams, registerCount, registerAllocation, suppressArguments);
            if (functionName) {
                scope.alPut(functionName, fn);
                as2SyncEvents(ectx.context, functionName);
            } else {
                stack.push(fn);
            }
        }
        function avm1_0x69_ActionExtends(ectx) {
            var stack = ectx.stack;
            var context = ectx.context;
            var constrSuper = AVM1.alToObject(context, stack.pop());
            var constr = AVM1.alToObject(context, stack.pop());
            var prototype = constr.alGetPrototypeProperty();
            var prototypeSuper = constrSuper.alGetPrototypeProperty();
            prototype.alPrototype = prototypeSuper;
            var desc = new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */, constrSuper);
            prototype.alSetOwnProperty('__constructor__', desc);
        }
        function avm1_0x2B_ActionCastOp(ectx) {
            var stack = ectx.stack;
            var obj = stack.pop();
            var constr = stack.pop();
            stack.push(as2InstanceOf(obj, constr) ? obj : null);
        }
        function avm1_0x2C_ActionImplementsOp(ectx) {
            var stack = ectx.stack;
            var constr = stack.pop();
            var count = +stack.pop();
            fixArgsCount(count, stack.length);
            var interfaces = [];
            for (var i = 0; i < count; i++) {
                interfaces.push(stack.pop());
            }
            constr._as2Interfaces = interfaces;
        }
        function avm1_0x8F_ActionTry(ectx, args) {
            var catchIsRegisterFlag = args[0];
            var catchTarget = args[1];
            var tryBody = args[2];
            var catchBlockFlag = args[3];
            var catchBody = args[4];
            var finallyBlockFlag = args[5];
            var finallyBody = args[6];
            avm1ProcessTry(ectx, catchIsRegisterFlag, finallyBlockFlag, catchBlockFlag, catchTarget, tryBody, catchBody, finallyBody);
        }
        function avm1_0x2A_ActionThrow(ectx) {
            var stack = ectx.stack;
            var obj = stack.pop();
            throw new AVM1Error(obj);
        }
        function avm1_0x2D_ActionFSCommand2(ectx) {
            var stack = ectx.stack;
            var args = avm1ReadFunctionArgs(stack);
            var sp = stack.length;
            stack.push(undefined);
            var result = ectx.actions.fscommand.apply(ectx.actions, args);
            stack[sp] = result;
        }
        function avm1_0x89_ActionStrictMode(ectx, args) {
            var mode = args[0];
        }
        function wrapAvm1Error(fn) {
            return function avm1ErrorWrapper(executionContext, args) {
                var currentContext;
                try {
                    fn(executionContext, args);
                    executionContext.recoveringFromError = false;
                } catch (e) {
                    // handling AVM1 errors
                    currentContext = executionContext.context;
                    e = as2CastError(e);
                    if (e instanceof AVM1CriticalError) {
                        throw e;
                    }
                    if (e instanceof AVM1Error) {
                        throw e;
                    }
                    Telemetry.instance.reportTelemetry({
                        topic: 'error',
                        error: 1    /* AVM1_ERROR */
                    });
                    if (!executionContext.recoveringFromError) {
                        if (currentContext.errorsIgnored++ >= MAX_AVM1_ERRORS_LIMIT) {
                            throw new AVM1CriticalError('long running script -- AVM1 errors limit is reached');
                        }
                        console.log(typeof e);
                        console.log(Object.getPrototypeOf(e));
                        console.log(Object.getPrototypeOf(Object.getPrototypeOf(e)));
                        console.error('AVM1 error: ' + e);
                    }
                }
            };
        }
        function generateActionCalls() {
            var wrap;
            if (!AVM1.avm1ErrorsEnabled.value) {
                wrap = wrapAvm1Error;
            } else {
                wrap = function (fn) {
                    return fn;
                };
            }
            return {
                ActionGotoFrame: wrap(avm1_0x81_ActionGotoFrame),
                ActionGetURL: wrap(avm1_0x83_ActionGetURL),
                ActionNextFrame: wrap(avm1_0x04_ActionNextFrame),
                ActionPreviousFrame: wrap(avm1_0x05_ActionPreviousFrame),
                ActionPlay: wrap(avm1_0x06_ActionPlay),
                ActionStop: wrap(avm1_0x07_ActionStop),
                ActionToggleQuality: wrap(avm1_0x08_ActionToggleQuality),
                ActionStopSounds: wrap(avm1_0x09_ActionStopSounds),
                ActionWaitForFrame: wrap(avm1_0x8A_ActionWaitForFrame),
                ActionSetTarget: wrap(avm1_0x8B_ActionSetTarget),
                ActionGoToLabel: wrap(avm1_0x8C_ActionGoToLabel),
                ActionPush: wrap(avm1_0x96_ActionPush),
                ActionPop: wrap(avm1_0x17_ActionPop),
                ActionAdd: wrap(avm1_0x0A_ActionAdd),
                ActionSubtract: wrap(avm1_0x0B_ActionSubtract),
                ActionMultiply: wrap(avm1_0x0C_ActionMultiply),
                ActionDivide: wrap(avm1_0x0D_ActionDivide),
                ActionEquals: wrap(avm1_0x0E_ActionEquals),
                ActionLess: wrap(avm1_0x0F_ActionLess),
                ActionAnd: wrap(avm1_0x10_ActionAnd),
                ActionOr: wrap(avm1_0x11_ActionOr),
                ActionNot: wrap(avm1_0x12_ActionNot),
                ActionStringEquals: wrap(avm1_0x13_ActionStringEquals),
                ActionStringLength: wrap(avm1_0x14_ActionStringLength),
                ActionMBStringLength: wrap(avm1_0x31_ActionMBStringLength),
                ActionStringAdd: wrap(avm1_0x21_ActionStringAdd),
                ActionStringExtract: wrap(avm1_0x15_ActionStringExtract),
                ActionMBStringExtract: wrap(avm1_0x35_ActionMBStringExtract),
                ActionStringLess: wrap(avm1_0x29_ActionStringLess),
                ActionToInteger: wrap(avm1_0x18_ActionToInteger),
                ActionCharToAscii: wrap(avm1_0x32_ActionCharToAscii),
                ActionMBCharToAscii: wrap(avm1_0x36_ActionMBCharToAscii),
                ActionAsciiToChar: wrap(avm1_0x33_ActionAsciiToChar),
                ActionMBAsciiToChar: wrap(avm1_0x37_ActionMBAsciiToChar),
                ActionJump: wrap(avm1_0x99_ActionJump),
                ActionIf: wrap(avm1_0x9D_ActionIf),
                ActionCall: wrap(avm1_0x9E_ActionCall),
                ActionGetVariable: wrap(avm1_0x1C_ActionGetVariable),
                ActionSetVariable: wrap(avm1_0x1D_ActionSetVariable),
                ActionGetURL2: wrap(avm1_0x9A_ActionGetURL2),
                ActionGotoFrame2: wrap(avm1_0x9F_ActionGotoFrame2),
                ActionSetTarget2: wrap(avm1_0x20_ActionSetTarget2),
                ActionGetProperty: wrap(avm1_0x22_ActionGetProperty),
                ActionSetProperty: wrap(avm1_0x23_ActionSetProperty),
                ActionCloneSprite: wrap(avm1_0x24_ActionCloneSprite),
                ActionRemoveSprite: wrap(avm1_0x25_ActionRemoveSprite),
                ActionStartDrag: wrap(avm1_0x27_ActionStartDrag),
                ActionEndDrag: wrap(avm1_0x28_ActionEndDrag),
                ActionWaitForFrame2: wrap(avm1_0x8D_ActionWaitForFrame2),
                ActionTrace: wrap(avm1_0x26_ActionTrace),
                ActionGetTime: wrap(avm1_0x34_ActionGetTime),
                ActionRandomNumber: wrap(avm1_0x30_ActionRandomNumber),
                ActionCallFunction: wrap(avm1_0x3D_ActionCallFunction),
                ActionCallMethod: wrap(avm1_0x52_ActionCallMethod),
                ActionConstantPool: wrap(avm1_0x88_ActionConstantPool),
                ActionDefineFunction: wrap(avm1_0x9B_ActionDefineFunction),
                ActionDefineLocal: wrap(avm1_0x3C_ActionDefineLocal),
                ActionDefineLocal2: wrap(avm1_0x41_ActionDefineLocal2),
                ActionDelete: wrap(avm1_0x3A_ActionDelete),
                ActionDelete2: wrap(avm1_0x3B_ActionDelete2),
                ActionEnumerate: wrap(avm1_0x46_ActionEnumerate),
                ActionEquals2: wrap(avm1_0x49_ActionEquals2),
                ActionGetMember: wrap(avm1_0x4E_ActionGetMember),
                ActionInitArray: wrap(avm1_0x42_ActionInitArray),
                ActionInitObject: wrap(avm1_0x43_ActionInitObject),
                ActionNewMethod: wrap(avm1_0x53_ActionNewMethod),
                ActionNewObject: wrap(avm1_0x40_ActionNewObject),
                ActionSetMember: wrap(avm1_0x4F_ActionSetMember),
                ActionTargetPath: wrap(avm1_0x45_ActionTargetPath),
                ActionWith: wrap(avm1_0x94_ActionWith),
                ActionToNumber: wrap(avm1_0x4A_ActionToNumber),
                ActionToString: wrap(avm1_0x4B_ActionToString),
                ActionTypeOf: wrap(avm1_0x44_ActionTypeOf),
                ActionAdd2: wrap(avm1_0x47_ActionAdd2),
                ActionLess2: wrap(avm1_0x48_ActionLess2),
                ActionModulo: wrap(avm1_0x3F_ActionModulo),
                ActionBitAnd: wrap(avm1_0x60_ActionBitAnd),
                ActionBitLShift: wrap(avm1_0x63_ActionBitLShift),
                ActionBitOr: wrap(avm1_0x61_ActionBitOr),
                ActionBitRShift: wrap(avm1_0x64_ActionBitRShift),
                ActionBitURShift: wrap(avm1_0x65_ActionBitURShift),
                ActionBitXor: wrap(avm1_0x62_ActionBitXor),
                ActionDecrement: wrap(avm1_0x51_ActionDecrement),
                ActionIncrement: wrap(avm1_0x50_ActionIncrement),
                ActionPushDuplicate: wrap(avm1_0x4C_ActionPushDuplicate),
                ActionReturn: wrap(avm1_0x3E_ActionReturn),
                ActionStackSwap: wrap(avm1_0x4D_ActionStackSwap),
                ActionStoreRegister: wrap(avm1_0x87_ActionStoreRegister),
                ActionInstanceOf: wrap(avm1_0x54_ActionInstanceOf),
                ActionEnumerate2: wrap(avm1_0x55_ActionEnumerate2),
                ActionStrictEquals: wrap(avm1_0x66_ActionStrictEquals),
                ActionGreater: wrap(avm1_0x67_ActionGreater),
                ActionStringGreater: wrap(avm1_0x68_ActionStringGreater),
                ActionDefineFunction2: wrap(avm1_0x8E_ActionDefineFunction2),
                ActionExtends: wrap(avm1_0x69_ActionExtends),
                ActionCastOp: wrap(avm1_0x2B_ActionCastOp),
                ActionImplementsOp: wrap(avm1_0x2C_ActionImplementsOp),
                ActionTry: wrap(avm1_0x8F_ActionTry),
                ActionThrow: wrap(avm1_0x2A_ActionThrow),
                ActionFSCommand2: wrap(avm1_0x2D_ActionFSCommand2),
                ActionStrictMode: wrap(avm1_0x89_ActionStrictMode)
            };
        }
        AVM1.generateActionCalls = generateActionCalls;
        function interpretAction(executionContext, parsedAction) {
            var stack = executionContext.stack;
            var actionCode = parsedAction.actionCode;
            var args = parsedAction.args;
            var actionTracer = executionContext.context.actionTracer;
            release || actionTracer && actionTracer.print(parsedAction, stack);
            var shallBranch = false;
            switch (actionCode | 0) {
            // SWF 3 actions
            case 129    /* ActionGotoFrame */:
                avm1_0x81_ActionGotoFrame(executionContext, args);
                break;
            case 131    /* ActionGetURL */:
                avm1_0x83_ActionGetURL(executionContext, args);
                break;
            case 4    /* ActionNextFrame */:
                avm1_0x04_ActionNextFrame(executionContext);
                break;
            case 5    /* ActionPreviousFrame */:
                avm1_0x05_ActionPreviousFrame(executionContext);
                break;
            case 6    /* ActionPlay */:
                avm1_0x06_ActionPlay(executionContext);
                break;
            case 7    /* ActionStop */:
                avm1_0x07_ActionStop(executionContext);
                break;
            case 8    /* ActionToggleQuality */:
                avm1_0x08_ActionToggleQuality(executionContext);
                break;
            case 9    /* ActionStopSounds */:
                avm1_0x09_ActionStopSounds(executionContext);
                break;
            case 138    /* ActionWaitForFrame */:
                shallBranch = avm1_0x8A_ActionWaitForFrame(executionContext, args);
                break;
            case 139    /* ActionSetTarget */:
                avm1_0x8B_ActionSetTarget(executionContext, args);
                break;
            case 140    /* ActionGoToLabel */:
                avm1_0x8C_ActionGoToLabel(executionContext, args);
                break;
            // SWF 4 actions
            case 150    /* ActionPush */:
                avm1_0x96_ActionPush(executionContext, args);
                break;
            case 23    /* ActionPop */:
                avm1_0x17_ActionPop(executionContext);
                break;
            case 10    /* ActionAdd */:
                avm1_0x0A_ActionAdd(executionContext);
                break;
            case 11    /* ActionSubtract */:
                avm1_0x0B_ActionSubtract(executionContext);
                break;
            case 12    /* ActionMultiply */:
                avm1_0x0C_ActionMultiply(executionContext);
                break;
            case 13    /* ActionDivide */:
                avm1_0x0D_ActionDivide(executionContext);
                break;
            case 14    /* ActionEquals */:
                avm1_0x0E_ActionEquals(executionContext);
                break;
            case 15    /* ActionLess */:
                avm1_0x0F_ActionLess(executionContext);
                break;
            case 16    /* ActionAnd */:
                avm1_0x10_ActionAnd(executionContext);
                break;
            case 17    /* ActionOr */:
                avm1_0x11_ActionOr(executionContext);
                break;
            case 18    /* ActionNot */:
                avm1_0x12_ActionNot(executionContext);
                break;
            case 19    /* ActionStringEquals */:
                avm1_0x13_ActionStringEquals(executionContext);
                break;
            case 20    /* ActionStringLength */:
                avm1_0x14_ActionStringLength(executionContext);
                break;
            case 49    /* ActionMBStringLength */:
                avm1_0x31_ActionMBStringLength(executionContext);
                break;
            case 33    /* ActionStringAdd */:
                avm1_0x21_ActionStringAdd(executionContext);
                break;
            case 21    /* ActionStringExtract */:
                avm1_0x15_ActionStringExtract(executionContext);
                break;
            case 53    /* ActionMBStringExtract */:
                avm1_0x35_ActionMBStringExtract(executionContext);
                break;
            case 41    /* ActionStringLess */:
                avm1_0x29_ActionStringLess(executionContext);
                break;
            case 24    /* ActionToInteger */:
                avm1_0x18_ActionToInteger(executionContext);
                break;
            case 50    /* ActionCharToAscii */:
                avm1_0x32_ActionCharToAscii(executionContext);
                break;
            case 54    /* ActionMBCharToAscii */:
                avm1_0x36_ActionMBCharToAscii(executionContext);
                break;
            case 51    /* ActionAsciiToChar */:
                avm1_0x33_ActionAsciiToChar(executionContext);
                break;
            case 55    /* ActionMBAsciiToChar */:
                avm1_0x37_ActionMBAsciiToChar(executionContext);
                break;
            case 153    /* ActionJump */:
                avm1_0x99_ActionJump(executionContext, args);
                break;
            case 157    /* ActionIf */:
                shallBranch = avm1_0x9D_ActionIf(executionContext, args);
                break;
            case 158    /* ActionCall */:
                avm1_0x9E_ActionCall(executionContext);
                break;
            case 28    /* ActionGetVariable */:
                avm1_0x1C_ActionGetVariable(executionContext);
                break;
            case 29    /* ActionSetVariable */:
                avm1_0x1D_ActionSetVariable(executionContext);
                break;
            case 154    /* ActionGetURL2 */:
                avm1_0x9A_ActionGetURL2(executionContext, args);
                break;
            case 159    /* ActionGotoFrame2 */:
                avm1_0x9F_ActionGotoFrame2(executionContext, args);
                break;
            case 32    /* ActionSetTarget2 */:
                avm1_0x20_ActionSetTarget2(executionContext);
                break;
            case 34    /* ActionGetProperty */:
                avm1_0x22_ActionGetProperty(executionContext);
                break;
            case 35    /* ActionSetProperty */:
                avm1_0x23_ActionSetProperty(executionContext);
                break;
            case 36    /* ActionCloneSprite */:
                avm1_0x24_ActionCloneSprite(executionContext);
                break;
            case 37    /* ActionRemoveSprite */:
                avm1_0x25_ActionRemoveSprite(executionContext);
                break;
            case 39    /* ActionStartDrag */:
                avm1_0x27_ActionStartDrag(executionContext);
                break;
            case 40    /* ActionEndDrag */:
                avm1_0x28_ActionEndDrag(executionContext);
                break;
            case 141    /* ActionWaitForFrame2 */:
                shallBranch = avm1_0x8D_ActionWaitForFrame2(executionContext, args);
                break;
            case 38    /* ActionTrace */:
                avm1_0x26_ActionTrace(executionContext);
                break;
            case 52    /* ActionGetTime */:
                avm1_0x34_ActionGetTime(executionContext);
                break;
            case 48    /* ActionRandomNumber */:
                avm1_0x30_ActionRandomNumber(executionContext);
                break;
            // SWF 5
            case 61    /* ActionCallFunction */:
                avm1_0x3D_ActionCallFunction(executionContext);
                break;
            case 82    /* ActionCallMethod */:
                avm1_0x52_ActionCallMethod(executionContext);
                break;
            case 136    /* ActionConstantPool */:
                avm1_0x88_ActionConstantPool(executionContext, args);
                break;
            case 155    /* ActionDefineFunction */:
                avm1_0x9B_ActionDefineFunction(executionContext, args);
                break;
            case 60    /* ActionDefineLocal */:
                avm1_0x3C_ActionDefineLocal(executionContext);
                break;
            case 65    /* ActionDefineLocal2 */:
                avm1_0x41_ActionDefineLocal2(executionContext);
                break;
            case 58    /* ActionDelete */:
                avm1_0x3A_ActionDelete(executionContext);
                break;
            case 59    /* ActionDelete2 */:
                avm1_0x3B_ActionDelete2(executionContext);
                break;
            case 70    /* ActionEnumerate */:
                avm1_0x46_ActionEnumerate(executionContext);
                break;
            case 73    /* ActionEquals2 */:
                avm1_0x49_ActionEquals2(executionContext);
                break;
            case 78    /* ActionGetMember */:
                avm1_0x4E_ActionGetMember(executionContext);
                break;
            case 66    /* ActionInitArray */:
                avm1_0x42_ActionInitArray(executionContext);
                break;
            case 67    /* ActionInitObject */:
                avm1_0x43_ActionInitObject(executionContext);
                break;
            case 83    /* ActionNewMethod */:
                avm1_0x53_ActionNewMethod(executionContext);
                break;
            case 64    /* ActionNewObject */:
                avm1_0x40_ActionNewObject(executionContext);
                break;
            case 79    /* ActionSetMember */:
                avm1_0x4F_ActionSetMember(executionContext);
                break;
            case 69    /* ActionTargetPath */:
                avm1_0x45_ActionTargetPath(executionContext);
                break;
            case 148    /* ActionWith */:
                avm1_0x94_ActionWith(executionContext, args);
                break;
            case 74    /* ActionToNumber */:
                avm1_0x4A_ActionToNumber(executionContext);
                break;
            case 75    /* ActionToString */:
                avm1_0x4B_ActionToString(executionContext);
                break;
            case 68    /* ActionTypeOf */:
                avm1_0x44_ActionTypeOf(executionContext);
                break;
            case 71    /* ActionAdd2 */:
                avm1_0x47_ActionAdd2(executionContext);
                break;
            case 72    /* ActionLess2 */:
                avm1_0x48_ActionLess2(executionContext);
                break;
            case 63    /* ActionModulo */:
                avm1_0x3F_ActionModulo(executionContext);
                break;
            case 96    /* ActionBitAnd */:
                avm1_0x60_ActionBitAnd(executionContext);
                break;
            case 99    /* ActionBitLShift */:
                avm1_0x63_ActionBitLShift(executionContext);
                break;
            case 97    /* ActionBitOr */:
                avm1_0x61_ActionBitOr(executionContext);
                break;
            case 100    /* ActionBitRShift */:
                avm1_0x64_ActionBitRShift(executionContext);
                break;
            case 101    /* ActionBitURShift */:
                avm1_0x65_ActionBitURShift(executionContext);
                break;
            case 98    /* ActionBitXor */:
                avm1_0x62_ActionBitXor(executionContext);
                break;
            case 81    /* ActionDecrement */:
                avm1_0x51_ActionDecrement(executionContext);
                break;
            case 80    /* ActionIncrement */:
                avm1_0x50_ActionIncrement(executionContext);
                break;
            case 76    /* ActionPushDuplicate */:
                avm1_0x4C_ActionPushDuplicate(executionContext);
                break;
            case 62    /* ActionReturn */:
                avm1_0x3E_ActionReturn(executionContext);
                break;
            case 77    /* ActionStackSwap */:
                avm1_0x4D_ActionStackSwap(executionContext);
                break;
            case 135    /* ActionStoreRegister */:
                avm1_0x87_ActionStoreRegister(executionContext, args);
                break;
            // SWF 6
            case 84    /* ActionInstanceOf */:
                avm1_0x54_ActionInstanceOf(executionContext);
                break;
            case 85    /* ActionEnumerate2 */:
                avm1_0x55_ActionEnumerate2(executionContext);
                break;
            case 102    /* ActionStrictEquals */:
                avm1_0x66_ActionStrictEquals(executionContext);
                break;
            case 103    /* ActionGreater */:
                avm1_0x67_ActionGreater(executionContext);
                break;
            case 104    /* ActionStringGreater */:
                avm1_0x68_ActionStringGreater(executionContext);
                break;
            // SWF 7
            case 142    /* ActionDefineFunction2 */:
                avm1_0x8E_ActionDefineFunction2(executionContext, args);
                break;
            case 105    /* ActionExtends */:
                avm1_0x69_ActionExtends(executionContext);
                break;
            case 43    /* ActionCastOp */:
                avm1_0x2B_ActionCastOp(executionContext);
                break;
            case 44    /* ActionImplementsOp */:
                avm1_0x2C_ActionImplementsOp(executionContext);
                break;
            case 143    /* ActionTry */:
                avm1_0x8F_ActionTry(executionContext, args);
                break;
            case 42    /* ActionThrow */:
                avm1_0x2A_ActionThrow(executionContext);
                break;
            // Not documented by the spec
            case 45    /* ActionFSCommand2 */:
                avm1_0x2D_ActionFSCommand2(executionContext);
                break;
            case 137    /* ActionStrictMode */:
                avm1_0x89_ActionStrictMode(executionContext, args);
                break;
            case 0    /* None */:
                executionContext.isEndOfActions = true;
                break;
            default:
                throw new Error('Unknown action code: ' + actionCode);
            }
            return shallBranch;
        }
        function interpretActionWithRecovery(executionContext, parsedAction) {
            var currentContext;
            var result;
            try {
                result = interpretAction(executionContext, parsedAction);
                executionContext.recoveringFromError = false;
            } catch (e) {
                // handling AVM1 errors
                currentContext = executionContext.context;
                e = as2CastError(e);
                if (AVM1.avm1ErrorsEnabled.value && !currentContext.isTryCatchListening || e instanceof AVM1CriticalError) {
                    throw e;
                }
                if (e instanceof AVM1Error) {
                    throw e;
                }
                Telemetry.instance.reportTelemetry({
                    topic: 'error',
                    error: 1    /* AVM1_ERROR */
                });
                if (!executionContext.recoveringFromError) {
                    if (currentContext.errorsIgnored++ >= MAX_AVM1_ERRORS_LIMIT) {
                        throw new AVM1CriticalError('long running script -- AVM1 errors limit is reached');
                    }
                    console.error('AVM1 error: ' + e);
                    // REDUX
                    //var avm2 = Shumway.AVM2.Runtime.AVM2;
                    //avm2.instance.exceptions.push({source: 'avm1', message: e.message,
                    //  stack: e.stack});
                    executionContext.recoveringFromError = true;
                }
            }
            return result;
        }
        function analyzeAndCompileActionsData(ectx, actionsData) {
            var context = ectx.context;
            var compiled;
            if (AVM1.avm1WellknownActionsCompilationsEnabled.value) {
                compiled = AVM1.findWellknowCompilation(actionsData, context);
                if (compiled) {
                    actionsData.compiled = compiled;
                    return;
                }
            }
            var parser = new AVM1.ActionsDataParser(actionsData, context.swfVersion);
            var analyzer = new AVM1.ActionsDataAnalyzer();
            analyzer.registersLimit = ectx.registers.length;
            analyzer.parentResults = actionsData.parent && actionsData.parent.ir;
            var ir = analyzer.analyze(parser);
            actionsData.ir = ir;
            if (AVM1.avm1CompilerEnabled.value) {
                try {
                    var c = new AVM1.ActionsDataCompiler();
                    compiled = c.generate(ir);
                    actionsData.compiled = compiled;
                } catch (e) {
                    console.error('Unable to compile AVM1 function: ' + e);
                }
            }
        }
        function interpretActionsData(ectx, actionsData) {
            if (!actionsData.ir && !actionsData.compiled) {
                analyzeAndCompileActionsData(ectx, actionsData);
            }
            var currentContext = ectx.context;
            var scopeList = ectx.scopeList;
            var scope = scopeList.scope;
            var as3Object = scope._as3Object;
            // FIXME refactor
            if (as3Object && as3Object._deferScriptExecution) {
                currentContext.deferScriptExecution = true;
            }
            var compiled = actionsData.compiled;
            if (compiled) {
                release || currentContext.actionTracer && currentContext.actionTracer.message('Running compiled ' + actionsData.id);
                return compiled(ectx);
            }
            var instructionsExecuted = 0;
            var abortExecutionAt = currentContext.abortExecutionAt;
            if (AVM1.avm1DebuggerEnabled.value && (AVM1.Debugger.pause || AVM1.Debugger.breakpoints[ir.dataId])) {
                debugger;
            }
            var ir = actionsData.ir;
            release || Shumway.Debug.assert(ir);
            var position = 0;
            var nextAction = ir.actions[position];
            // will try again if we are skipping errors
            while (nextAction && !ectx.isEndOfActions) {
                // let's check timeout/Date.now every some number of instructions
                if (instructionsExecuted++ % AVM1.CHECK_AVM1_HANG_EVERY === 0 && Date.now() >= abortExecutionAt) {
                    throw new AVM1CriticalError('long running script -- AVM1 instruction hang timeout');
                }
                var shallBranch = interpretActionWithRecovery(ectx, nextAction.action);
                if (shallBranch) {
                    position = nextAction.conditionalJumpTo;
                } else {
                    position = nextAction.next;
                }
                nextAction = ir.actions[position];
            }
            var stack = ectx.stack;
            return stack.pop();
        }
        var ActionTracer = function () {
            function ActionTracer() {
                this._indentation = 0;
                this._indentStringCache = [];
            }
            ActionTracer.prototype._getIndentString = function () {
                return this._indentStringCache[this._indentation] || (this._indentStringCache[this._indentation] = new Array(this._indentation + 1).join('..'));
            };
            ActionTracer.prototype.print = function (parsedAction, stack) {
                var position = parsedAction.position;
                var actionCode = parsedAction.actionCode;
                var actionName = parsedAction.actionName;
                var stackDump = [];
                for (var q = 0; q < stack.length; q++) {
                    var item = stack[q];
                    if (item && typeof item === 'object') {
                        var constr = item.alGetConstructorProperty();
                        stackDump.push('[' + (constr ? constr.name : 'Object') + ']');
                    } else {
                        stackDump.push(item);
                    }
                }
                console.log('AVM1 trace: ' + this._getIndentString() + position + ': ' + actionName + '(' + actionCode.toString(16) + '), ' + 'stack=' + stackDump);
            };
            ActionTracer.prototype.indent = function () {
                this._indentation++;
            };
            ActionTracer.prototype.unindent = function () {
                this._indentation--;
            };
            ActionTracer.prototype.message = function (msg) {
                console.log('AVM1 trace: ------- ' + msg);
            };
            return ActionTracer;
        }();
        (function (MovieClipProperties) {
            MovieClipProperties[MovieClipProperties['_x'] = 0] = '_x';
            MovieClipProperties[MovieClipProperties['_y'] = 1] = '_y';
            MovieClipProperties[MovieClipProperties['_xscale'] = 2] = '_xscale';
            MovieClipProperties[MovieClipProperties['_yscale'] = 3] = '_yscale';
            MovieClipProperties[MovieClipProperties['_currentframe'] = 4] = '_currentframe';
            MovieClipProperties[MovieClipProperties['_totalframes'] = 5] = '_totalframes';
            MovieClipProperties[MovieClipProperties['_alpha'] = 6] = '_alpha';
            MovieClipProperties[MovieClipProperties['_visible'] = 7] = '_visible';
            MovieClipProperties[MovieClipProperties['_width'] = 8] = '_width';
            MovieClipProperties[MovieClipProperties['_height'] = 9] = '_height';
            MovieClipProperties[MovieClipProperties['_rotation'] = 10] = '_rotation';
            MovieClipProperties[MovieClipProperties['_target'] = 11] = '_target';
            MovieClipProperties[MovieClipProperties['_framesloaded'] = 12] = '_framesloaded';
            MovieClipProperties[MovieClipProperties['_name'] = 13] = '_name';
            MovieClipProperties[MovieClipProperties['_droptarget'] = 14] = '_droptarget';
            MovieClipProperties[MovieClipProperties['_url'] = 15] = '_url';
            MovieClipProperties[MovieClipProperties['_highquality'] = 16] = '_highquality';
            MovieClipProperties[MovieClipProperties['_focusrect'] = 17] = '_focusrect';
            MovieClipProperties[MovieClipProperties['_soundbuftime'] = 18] = '_soundbuftime';
            MovieClipProperties[MovieClipProperties['_quality'] = 19] = '_quality';
            MovieClipProperties[MovieClipProperties['_xmouse'] = 20] = '_xmouse';
            MovieClipProperties[MovieClipProperties['_ymouse'] = 21] = '_ymouse';
        }(AVM1.MovieClipProperties || (AVM1.MovieClipProperties = {})));
        var MovieClipProperties = AVM1.MovieClipProperties;
        var notImplemented = Shumway.Debug.notImplemented;
        var cachedActionsCalls = null;
        function getActionsCalls() {
            if (!cachedActionsCalls) {
                cachedActionsCalls = AVM1.generateActionCalls();
            }
            return cachedActionsCalls;
        }
        /**
         *  Bare-minimum JavaScript code generator to make debugging better.
         */
        var ActionsDataCompiler = function () {
            function ActionsDataCompiler() {
            }
            ActionsDataCompiler.prototype.convertArgs = function (args, id, res, ir) {
                var parts = [];
                for (var i = 0; i < args.length; i++) {
                    var arg = args[i];
                    if (typeof arg === 'object' && arg !== null && !Array.isArray(arg)) {
                        if (arg instanceof AVM1.ParsedPushConstantAction) {
                            if (ir.singleConstantPool) {
                                var constant = ir.singleConstantPool[arg.constantIndex];
                                parts.push(constant === undefined ? 'undefined' : JSON.stringify(constant));
                            } else {
                                var hint = '';
                                var currentConstantPool = res.constantPool;
                                if (currentConstantPool) {
                                    var constant = currentConstantPool[arg.constantIndex];
                                    hint = constant === undefined ? 'undefined' : JSON.stringify(constant);
                                    // preventing code breakage due to bad constant
                                    hint = hint.indexOf('*/') >= 0 ? '' : ' /* ' + hint + ' */';
                                }
                                parts.push('constantPool[' + arg.constantIndex + ']' + hint);
                            }
                        } else if (arg instanceof AVM1.ParsedPushRegisterAction) {
                            var registerNumber = arg.registerNumber;
                            if (registerNumber < 0 || registerNumber >= ir.registersLimit) {
                                parts.push('undefined');    // register is out of bounds -- undefined
                            } else {
                                parts.push('registers[' + registerNumber + ']');
                            }
                        } else if (arg instanceof AVM1.AVM1ActionsData) {
                            var resName = 'code_' + id + '_' + i;
                            res[resName] = arg;
                            parts.push('res.' + resName);
                        } else {
                            notImplemented('Unknown AVM1 action argument type');
                        }
                    } else if (arg === undefined) {
                        parts.push('undefined');    // special case
                    } else {
                        parts.push(JSON.stringify(arg));
                    }
                }
                return parts.join(',');
            };
            ActionsDataCompiler.prototype.convertAction = function (item, id, res, indexInBlock, ir) {
                switch (item.action.actionCode) {
                case 153    /* ActionJump */:
                case 62    /* ActionReturn */:
                    return '';
                case 136    /* ActionConstantPool */:
                    res.constantPool = item.action.args[0];
                    return '  constantPool = [' + this.convertArgs(item.action.args[0], id, res, ir) + '];\n' + '  ectx.constantPool = constantPool;\n';
                case 150    /* ActionPush */:
                    return '  stack.push(' + this.convertArgs(item.action.args, id, res, ir) + ');\n';
                case 135    /* ActionStoreRegister */:
                    var registerNumber = item.action.args[0];
                    if (registerNumber < 0 || registerNumber >= ir.registersLimit) {
                        return '';    // register is out of bounds -- noop
                    }
                    return '  registers[' + registerNumber + '] = stack[stack.length - 1];\n';
                case 138    /* ActionWaitForFrame */:
                case 141    /* ActionWaitForFrame2 */:
                    return '  if (calls.' + item.action.actionName + '(ectx,[' + this.convertArgs(item.action.args, id, res, ir) + '])) { position = ' + item.conditionalJumpTo + '; ' + 'checkTimeAfter -= ' + (indexInBlock + 1) + '; break; }\n';
                case 157    /* ActionIf */:
                    return '  if (!!stack.pop()) { position = ' + item.conditionalJumpTo + '; ' + 'checkTimeAfter -= ' + (indexInBlock + 1) + '; break; }\n';
                default:
                    var result = '  calls.' + item.action.actionName + '(ectx' + (item.action.args ? ',[' + this.convertArgs(item.action.args, id, res, ir) + ']' : '') + ');\n';
                    return result;
                }
            };
            ActionsDataCompiler.prototype.generate = function (ir) {
                var _this = this;
                var blocks = ir.blocks;
                var res = {};
                var uniqueId = 0;
                var debugName = ir.dataId;
                var fn = 'return function avm1gen_' + debugName + '(ectx) {\n' + 'var position = 0;\n' + 'var checkTimeAfter = 0;\n' + 'var constantPool = ectx.constantPool, registers = ectx.registers, stack = ectx.stack;\n';
                if (AVM1.avm1DebuggerEnabled.value) {
                    fn += '/* Running ' + debugName + ' */ ' + 'if (Shumway.AVM1.Debugger.pause || Shumway.AVM1.Debugger.breakpoints.' + debugName + ') { debugger; }\n';
                }
                fn += 'while (!ectx.isEndOfActions) {\n' + 'if (checkTimeAfter <= 0) { checkTimeAfter = ' + AVM1.CHECK_AVM1_HANG_EVERY + '; ectx.context.checkTimeout(); }\n' + 'switch(position) {\n';
                blocks.forEach(function (b) {
                    fn += ' case ' + b.label + ':\n';
                    b.items.forEach(function (item, index) {
                        fn += _this.convertAction(item, uniqueId++, res, index, ir);
                    });
                    fn += '  position = ' + b.jump + ';\n' + '  checkTimeAfter -= ' + b.items.length + ';\n' + '  break;\n';
                });
                fn += ' default: ectx.isEndOfActions = true; break;\n}\n}\n' + 'return stack.pop();};';
                fn += '//# sourceURL=avm1gen-' + debugName;
                return new Function('calls', 'res', fn)(getActionsCalls(), res);
            };
            return ActionsDataCompiler;
        }();
        AVM1.ActionsDataCompiler = ActionsDataCompiler;
        // Instead of compiling, we can match frequently used actions patterns and use
        // the dictionary functions without analyzing or compilations of the code.
        // The functions/patterns were selected by analyzing the large amount of
        // real-life SWFs.
        function findWellknowCompilation(actionsData, context) {
            var bytes = actionsData.bytes;
            var fn = null;
            if (bytes.length === 0 || bytes[0] === 0    /* None */) {
                // Empty/no actions or first command is ActionEnd.
                fn = actionsNoop;
            } else if (bytes.length >= 2 && bytes[1] === 0    /* None */) {
                // Single bytes actions: ActionPlay, ActionStop, ActionStopSounds
                // Example: 07 00
                switch (bytes[0]) {
                case 6    /* ActionPlay */:
                    fn = actionsPlay;
                    break;
                case 7    /* ActionStop */:
                    fn = actionsStop;
                    break;
                case 9    /* ActionStopSounds */:
                    fn = actionsStopSounds;
                    break;
                }
            } else if (bytes.length >= 7 && bytes[6] === 0    /* None */ && bytes[0] === 129    /* ActionGotoFrame */ && bytes[1] === 2 && bytes[2] === 0 && bytes[5] === 6    /* ActionPlay */) {
                // ActionGotoFrame n, ActionPlay
                // Example: 81 02 00 04 00 06 00
                var frameIndex = bytes[3] | bytes[4] << 8;
                fn = actionsGotoFrame.bind(null, [
                    frameIndex,
                    true
                ]);
            } else if (bytes.length >= 6 && bytes[0] === 140    /* ActionGoToLabel */ && bytes[2] === 0 && bytes.length >= bytes[1] + 5 && bytes[bytes[1] + 4] === 0    /* None */ && bytes[bytes[1] + 3] === 6    /* ActionPlay */) {
                //  ActionGoToLabel s, ActonPlay
                // Example: 8c 03 00 73 31 00 06 00
                var stream = new AVM1.ActionsDataStream(bytes.subarray(3, 3 + bytes[1]), context.swfVersion);
                var label = stream.readString();
                fn = actionsGotoLabel.bind(null, [
                    label,
                    true
                ]);
            }
            // TODO debugger pause and breakpoints ?
            return fn;
        }
        AVM1.findWellknowCompilation = findWellknowCompilation;
        function actionsNoop(ectx) {
        }
        function actionsPlay(ectx) {
            getActionsCalls().ActionPlay(ectx);
        }
        function actionsStop(ectx) {
            getActionsCalls().ActionStop(ectx);
        }
        function actionsStopSounds(ectx) {
            getActionsCalls().ActionStopSounds(ectx);
        }
        function actionsGotoFrame(args, ectx) {
            getActionsCalls().ActionGotoFrame(ectx, args);
        }
        function actionsGotoLabel(args, ectx) {
            getActionsCalls().ActionGoToLabel(ectx, args);
        }
        var Lib;
        (function (Lib) {
            var flash = Shumway.AVMX.AS.flash;
            Lib.DEPTH_OFFSET = 16384;
            var AVM1EventHandler = function () {
                function AVM1EventHandler(propertyName, eventName, argsConverter) {
                    if (argsConverter === void 0) {
                        argsConverter = null;
                    }
                    this.propertyName = propertyName;
                    this.eventName = eventName;
                    this.argsConverter = argsConverter;
                }
                AVM1EventHandler.prototype.onBind = function (target) {
                };
                AVM1EventHandler.prototype.onUnbind = function (target) {
                };
                return AVM1EventHandler;
            }();
            Lib.AVM1EventHandler = AVM1EventHandler;
            /**
             * Checks if an object contains a reference to a native AS3 object.
             * Returns false for MovieClip instances or instances of constructors with
             * MovieClip on their prototype chain that were created in script using,
             * e.g. new MovieClip(). Those lack the part of their internal structure
             * that makes them displayable.
             */
            function hasAS3ObjectReference(obj) {
                return !!obj._as3Object;
            }
            Lib.hasAS3ObjectReference = hasAS3ObjectReference;
            /**
             * Returns obj's reference to a native AS3 object. If the reference
             * does not exist, returns undefined.
             */
            function getAS3Object(obj) {
                return obj._as3Object;
            }
            Lib.getAS3Object = getAS3Object;
            /**
             * Returns obj's reference to a native AS3 object. If the reference
             * doesn't exist, obj was created in script, e.g. with new MovieClip(),
             * and doesn't reflect a real, displayable display object. In that case,
             * an empty null-proto object is created and returned. This is used for
             * classes that are linked to embedded symbols that extend MovieClip. Their
             * inheritance chain is built by assigning new MovieClip to their prototype.
             * When a proper, displayable, instance of such a class is created via
             * attachMovie, initial values for properties such as tabEnabled
             * can be initialized from values set on the template object.
             */
            function getAS3ObjectOrTemplate(obj) {
                if (obj._as3Object) {
                    return obj._as3Object;
                }
                // The _as3ObjectTemplate is not really an ASObject type, but we will fake
                // that for AVM1SymbolBase's properties transfers.
                if (!obj._as3ObjectTemplate) {
                    var template;
                    var proto = obj.alPrototype;
                    while (proto && !proto.initAVM1SymbolInstance) {
                        template = proto._as3ObjectTemplate;
                        if (template) {
                            break;
                        }
                        proto = proto.alPrototype;
                    }
                    obj._as3ObjectTemplate = Object.create(template || null);
                }
                return obj._as3ObjectTemplate;
            }
            Lib.getAS3ObjectOrTemplate = getAS3ObjectOrTemplate;
            var AVM1LoaderHelper = function () {
                function AVM1LoaderHelper(context) {
                    this._context = context;
                    this._loader = new context.sec.flash.display.Loader();
                }
                Object.defineProperty(AVM1LoaderHelper.prototype, 'loader', {
                    get: function () {
                        return this._loader;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AVM1LoaderHelper.prototype, 'loaderInfo', {
                    get: function () {
                        return this._loader.contentLoaderInfo;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AVM1LoaderHelper.prototype, 'content', {
                    get: function () {
                        return this._loader._content;
                    },
                    enumerable: true,
                    configurable: true
                });
                AVM1LoaderHelper.prototype.load = function (url, method) {
                    var context = this._context;
                    var loader = this._loader;
                    var loaderContext = new context.sec.flash.system.LoaderContext();
                    loaderContext._avm1Context = context;
                    var request = new context.sec.flash.net.URLRequest(url);
                    if (method) {
                        request.method = method;
                    }
                    var loaderInfo = loader.contentLoaderInfo;
                    var result = new Shumway.PromiseWrapper();
                    // Waiting for content in the progress event -- the result promise will be resolved
                    // as soon as loader's content will be set to non-empty value.
                    var progressEventHandler = function (e) {
                        if (!loader._content) {
                            return;
                        }
                        loaderInfo.removeEventListener(flash.events.ProgressEvent.PROGRESS, progressEventHandler);
                        result.resolve(loader._content);
                    };
                    loaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, progressEventHandler);
                    loader.load(request, loaderContext);
                    return result.promise;
                };
                return AVM1LoaderHelper;
            }();
            Lib.AVM1LoaderHelper = AVM1LoaderHelper;
            var AVM1SymbolBase = function (_super) {
                __extends(AVM1SymbolBase, _super);
                function AVM1SymbolBase() {
                    _super.apply(this, arguments);
                }
                AVM1SymbolBase.prototype.initAVM1SymbolInstance = function (context, as3Object) {
                    AVM1.AVM1Object.call(this, context);
                    release || Shumway.Debug.assert(as3Object);
                    this._as3Object = as3Object;
                    var name = as3Object.name;
                    var parent = this.get_parent();
                    if (name && parent) {
                        parent._addChildName(this, name);
                    }
                };
                AVM1SymbolBase.prototype.bindEvents = function (events, autoUnbind) {
                    if (autoUnbind === void 0) {
                        autoUnbind = true;
                    }
                    this._events = events;
                    var eventsMap = Object.create(null);
                    this._eventsMap = eventsMap;
                    this._eventsListeners = Object.create(null);
                    var observer = this;
                    var context = this.context;
                    events.forEach(function (event) {
                        // Normalization will always stay valid in a player instance, so we can safely modify
                        // the event itself, here.
                        var propertyName = event.propertyName = context.normalizeName(event.propertyName);
                        eventsMap[propertyName] = event;
                        context.registerEventPropertyObserver(propertyName, observer);
                        observer._updateEvent(event);
                    });
                    if (autoUnbind) {
                        observer._as3Object.addEventListener('removedFromStage', function removedHandler() {
                            observer._as3Object.removeEventListener('removedFromStage', removedHandler);
                            observer.unbindEvents();
                        });
                    }
                };
                AVM1SymbolBase.prototype.unbindEvents = function () {
                    var events = this._events;
                    var observer = this;
                    var context = this.context;
                    events.forEach(function (event) {
                        context.unregisterEventPropertyObserver(event.propertyName, observer);
                        observer._removeEventListener(event);
                    });
                    this._events = null;
                    this._eventsMap = null;
                    this._eventsListeners = null;
                };
                AVM1SymbolBase.prototype.updateAllEvents = function () {
                    this._events.forEach(function (event) {
                        this._updateEvent(event);
                    }, this);
                };
                AVM1SymbolBase.prototype._updateEvent = function (event) {
                    if (avm1HasEventProperty(this.context, this, event.propertyName)) {
                        this._addEventListener(event);
                    } else {
                        this._removeEventListener(event);
                    }
                };
                AVM1SymbolBase.prototype._addEventListener = function (event) {
                    var propertyName = this.context.normalizeName(event.propertyName);
                    var listener = this._eventsListeners[propertyName];
                    if (!listener) {
                        listener = function avm1EventHandler() {
                            var args = event.argsConverter ? event.argsConverter.apply(null, arguments) : null;
                            avm1BroadcastNativeEvent(this.context, this, propertyName, args);
                        }.bind(this);
                        this._as3Object.addEventListener(event.eventName, listener);
                        event.onBind(this);
                        this._eventsListeners[propertyName] = listener;
                    }
                };
                AVM1SymbolBase.prototype._removeEventListener = function (event) {
                    var propertyName = this.context.normalizeName(event.propertyName);
                    var listener = this._eventsListeners[propertyName];
                    if (listener) {
                        event.onUnbind(this);
                        this._as3Object.removeEventListener(event.eventName, listener);
                        this._eventsListeners[propertyName] = null;
                    }
                };
                AVM1SymbolBase.prototype.onEventPropertyModified = function (propertyName) {
                    var propertyName = this.context.normalizeName(propertyName);
                    var event = this._eventsMap[propertyName];
                    this._updateEvent(event);
                };
                // Common DisplayObject properties
                AVM1SymbolBase.prototype.get_alpha = function () {
                    return this._as3Object.alpha * 100;
                };
                AVM1SymbolBase.prototype.set_alpha = function (value) {
                    value = AVM1.alToNumber(this.context, value);
                    if (isNaN(value)) {
                        return;
                    }
                    this._as3Object.alpha = value / 100;
                };
                AVM1SymbolBase.prototype.getBlendMode = function () {
                    return this._as3Object.blendMode;
                };
                AVM1SymbolBase.prototype.setBlendMode = function (value) {
                    value = typeof value === 'number' ? Lib.BlendModesMap[value] : AVM1.alCoerceString(this.context, value);
                    this._as3Object.blendMode = value || null;
                };
                AVM1SymbolBase.prototype.getCacheAsBitmap = function () {
                    return this._as3Object.cacheAsBitmap;
                };
                AVM1SymbolBase.prototype.setCacheAsBitmap = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.cacheAsBitmap = value;
                };
                AVM1SymbolBase.prototype.getFilters = function () {
                    return Lib.convertFromAS3Filters(this.context, this._as3Object.filters);
                };
                AVM1SymbolBase.prototype.setFilters = function (value) {
                    this._as3Object.filters = Lib.convertToAS3Filters(this.context, value);
                };
                AVM1SymbolBase.prototype.get_focusrect = function () {
                    return this._as3Object.focusRect || false;    // suppressing null
                };
                AVM1SymbolBase.prototype.set_focusrect = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.focusRect = value;
                };
                AVM1SymbolBase.prototype.get_height = function () {
                    return this._as3Object.height;
                };
                AVM1SymbolBase.prototype.set_height = function (value) {
                    value = AVM1.alToNumber(this.context, value);
                    if (isNaN(value)) {
                        return;
                    }
                    this._as3Object.height = value;
                };
                AVM1SymbolBase.prototype.get_highquality = function () {
                    switch (this.get_quality()) {
                    case 'BEST':
                        return 2;
                    case 'HIGH':
                        return 1;
                    default:
                        return 0;
                    }
                };
                AVM1SymbolBase.prototype.set_highquality = function (value) {
                    var quality;
                    switch (AVM1.alToInteger(this.context, value)) {
                    case 2:
                        quality = 'BEST';
                        break;
                    case 1:
                        quality = 'HIGH';
                        break;
                    default:
                        quality = 'LOW';
                        break;
                    }
                    this.set_quality(quality);
                };
                AVM1SymbolBase.prototype.getMenu = function () {
                    Shumway.Debug.somewhatImplemented('AVM1SymbolBase.getMenu');    // return this._as3Object.contextMenu;
                };
                AVM1SymbolBase.prototype.setMenu = function (value) {
                    Shumway.Debug.somewhatImplemented('AVM1SymbolBase.setMenu');    // this._as3Object.contextMenu = value;
                };
                AVM1SymbolBase.prototype.get_name = function () {
                    return this._as3Object ? this._as3Object.name : undefined;
                };
                AVM1SymbolBase.prototype.set_name = function (value) {
                    value = AVM1.alCoerceString(this.context, value);
                    var oldName = this._as3Object.name;
                    this._as3Object.name = value;
                    this.get_parent()._updateChildName(this, oldName, value);
                };
                AVM1SymbolBase.prototype.get_parent = function () {
                    var parent = getAVM1Object(this._as3Object.parent, this.context);
                    // In AVM1, the _parent property is `undefined`, not `null` if the element has no parent.
                    return parent || undefined;
                };
                AVM1SymbolBase.prototype.set_parent = function (value) {
                    Shumway.Debug.notImplemented('AVM1SymbolBase.set_parent');
                };
                AVM1SymbolBase.prototype.getOpaqueBackground = function () {
                    return this._as3Object.opaqueBackground;
                };
                AVM1SymbolBase.prototype.setOpaqueBackground = function (value) {
                    if (Shumway.isNullOrUndefined(value)) {
                        this._as3Object.opaqueBackground = null;
                    } else {
                        this._as3Object.opaqueBackground = AVM1.alToInt32(this.context, value);
                    }
                };
                AVM1SymbolBase.prototype.get_quality = function () {
                    Shumway.Debug.somewhatImplemented('AVM1SymbolBase.get_quality');
                    return 'HIGH';
                };
                AVM1SymbolBase.prototype.set_quality = function (value) {
                    Shumway.Debug.somewhatImplemented('AVM1SymbolBase.set_quality');
                };
                AVM1SymbolBase.prototype.get_root = function () {
                    var as3Object = this._as3Object;
                    while (as3Object && as3Object !== as3Object.root) {
                        var as2Object = getAVM1Object(as3Object, this.context);
                        if (as2Object.get_lockroot()) {
                            return as2Object;
                        }
                        as3Object = as3Object.parent;
                    }
                    if (!as3Object) {
                        return undefined;
                    }
                    return getAVM1Object(as3Object, this.context);
                };
                AVM1SymbolBase.prototype.get_rotation = function () {
                    return this._as3Object.rotation;
                };
                AVM1SymbolBase.prototype.set_rotation = function (value) {
                    value = AVM1.alToNumber(this.context, value);
                    if (isNaN(value)) {
                        return;
                    }
                    this._as3Object.rotation = value;
                };
                AVM1SymbolBase.prototype.getScale9Grid = function () {
                    return Lib.AVM1Rectangle.fromAS3Rectangle(this.context, this._as3Object.scale9Grid);
                };
                AVM1SymbolBase.prototype.setScale9Grid = function (value) {
                    this._as3Object.scale9Grid = Shumway.isNullOrUndefined(value) ? null : Lib.toAS3Rectangle(value);
                };
                AVM1SymbolBase.prototype.getScrollRect = function () {
                    return Lib.AVM1Rectangle.fromAS3Rectangle(this.context, this._as3Object.scrollRect);
                };
                AVM1SymbolBase.prototype.setScrollRect = function (value) {
                    this._as3Object.scrollRect = Shumway.isNullOrUndefined(value) ? null : Lib.toAS3Rectangle(value);
                };
                AVM1SymbolBase.prototype.get_soundbuftime = function () {
                    Shumway.Debug.somewhatImplemented('AVM1SymbolBase.get_soundbuftime');
                    return 0;
                };
                AVM1SymbolBase.prototype.set_soundbuftime = function (value) {
                    Shumway.Debug.somewhatImplemented('AVM1SymbolBase.set_soundbuftime');
                };
                AVM1SymbolBase.prototype.getTabEnabled = function () {
                    return getAS3ObjectOrTemplate(this).tabEnabled;
                };
                AVM1SymbolBase.prototype.setTabEnabled = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    getAS3ObjectOrTemplate(this).tabEnabled = value;
                };
                AVM1SymbolBase.prototype.getTabIndex = function () {
                    var tabIndex = this._as3Object.tabIndex;
                    return tabIndex < 0 ? undefined : tabIndex;
                };
                AVM1SymbolBase.prototype.setTabIndex = function (value) {
                    if (Shumway.isNullOrUndefined(value)) {
                        this._as3Object.tabIndex = -1;
                    } else {
                        this._as3Object.tabIndex = AVM1.alToInteger(this.context, value);
                    }
                };
                AVM1SymbolBase.prototype.get_target = function () {
                    var nativeObject = this._as3Object;
                    if (nativeObject === nativeObject.root) {
                        return '/';
                    }
                    var path = '';
                    do {
                        if (Shumway.isNullOrUndefined(nativeObject)) {
                            release || Shumway.Debug.assert(false);
                            return undefined;    // something went wrong
                        }
                        path = '/' + nativeObject.name + path;
                        nativeObject = nativeObject.parent;
                    } while (nativeObject !== nativeObject.root);
                    return path;
                };
                AVM1SymbolBase.prototype.getTransform = function () {
                    var transformCtor = this.context.globals.Transform;
                    return transformCtor.alConstruct([this]);
                };
                AVM1SymbolBase.prototype.setTransform = function (value) {
                    if (!(value instanceof Lib.AVM1Transform)) {
                        return;
                    }
                    var as3Transform = value.as3Transform;
                    this._as3Object.transform = as3Transform;
                };
                AVM1SymbolBase.prototype.get_visible = function () {
                    return this._as3Object.visible;
                };
                AVM1SymbolBase.prototype.set_visible = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.visible = value;
                };
                AVM1SymbolBase.prototype.get_url = function () {
                    return this._as3Object.loaderInfo.url;
                };
                AVM1SymbolBase.prototype.get_width = function () {
                    return this._as3Object.width;
                };
                AVM1SymbolBase.prototype.set_width = function (value) {
                    value = AVM1.alToNumber(this.context, value);
                    if (isNaN(value)) {
                        return;
                    }
                    this._as3Object.width = value;
                };
                AVM1SymbolBase.prototype.get_x = function () {
                    return this._as3Object.x;
                };
                AVM1SymbolBase.prototype.set_x = function (value) {
                    value = AVM1.alToNumber(this.context, value);
                    if (isNaN(value)) {
                        return;
                    }
                    this._as3Object.x = value;
                };
                AVM1SymbolBase.prototype.get_xmouse = function () {
                    return this._as3Object.mouseX;
                };
                AVM1SymbolBase.prototype.get_xscale = function () {
                    return this._as3Object.scaleX * 100;
                };
                AVM1SymbolBase.prototype.set_xscale = function (value) {
                    value = AVM1.alToNumber(this.context, value);
                    if (isNaN(value)) {
                        return;
                    }
                    this._as3Object.scaleX = value / 100;
                };
                AVM1SymbolBase.prototype.get_y = function () {
                    return this._as3Object.y;
                };
                AVM1SymbolBase.prototype.set_y = function (value) {
                    value = AVM1.alToNumber(this.context, value);
                    if (isNaN(value)) {
                        return;
                    }
                    this._as3Object.y = value;
                };
                AVM1SymbolBase.prototype.get_ymouse = function () {
                    return this._as3Object.mouseY;
                };
                AVM1SymbolBase.prototype.get_yscale = function () {
                    return this._as3Object.scaleY * 100;
                };
                AVM1SymbolBase.prototype.set_yscale = function (value) {
                    value = AVM1.alToNumber(this.context, value);
                    if (isNaN(value)) {
                        return;
                    }
                    this._as3Object.scaleY = value / 100;
                };
                AVM1SymbolBase.prototype.getDepth = function () {
                    return this._as3Object._depth - Lib.DEPTH_OFFSET;
                };
                return AVM1SymbolBase;
            }(AVM1.AVM1Object);
            Lib.AVM1SymbolBase = AVM1SymbolBase;
            Lib.BlendModesMap = [
                undefined,
                'normal',
                'layer',
                'multiply',
                'screen',
                'lighten',
                'darken',
                'difference',
                'add',
                'subtract',
                'invert',
                'alpha',
                'erase',
                'overlay',
                'hardlight'
            ];
            function avm1HasEventProperty(context, target, propertyName) {
                if (target.alHasProperty(propertyName) && target.alGet(propertyName) instanceof AVM1.AVM1Function) {
                    return true;
                }
                var listenersField = target.alGet('_listeners');
                if (!(listenersField instanceof AVM1.Natives.AVM1ArrayNative)) {
                    return false;
                }
                var listeners = listenersField.value;
                return listeners.some(function (listener) {
                    return listener instanceof AVM1.AVM1Object && listener.alHasProperty(propertyName);
                });
            }
            Lib.avm1HasEventProperty = avm1HasEventProperty;
            function avm1BroadcastNativeEvent(context, target, propertyName, args) {
                if (args === void 0) {
                    args = null;
                }
                var handler = target.alGet(propertyName);
                if (handler instanceof AVM1.AVM1Function) {
                    context.executeFunction(handler, target, args);
                }
                var _listeners = target.alGet('_listeners');
                if (_listeners instanceof AVM1.Natives.AVM1ArrayNative) {
                    _listeners.value.forEach(function (listener) {
                        if (!(listener instanceof AVM1.AVM1Object)) {
                            return;
                        }
                        var handlerOnListener = listener.alGet(propertyName);
                        if (handlerOnListener instanceof AVM1.AVM1Function) {
                            context.executeFunction(handlerOnListener, target, args);
                        }
                    });
                }
            }
            function avm1BroadcastEvent(context, target, propertyName, args) {
                if (args === void 0) {
                    args = null;
                }
                var handler = target.alGet(propertyName);
                if (handler instanceof AVM1.AVM1Function) {
                    handler.alCall(target, args);
                }
                var _listeners = target.alGet('_listeners');
                if (_listeners instanceof AVM1.Natives.AVM1ArrayNative) {
                    _listeners.value.forEach(function (listener) {
                        if (!(listener instanceof AVM1.AVM1Object)) {
                            return;
                        }
                        var handlerOnListener = listener.alGet(propertyName);
                        if (handlerOnListener instanceof AVM1.AVM1Function) {
                            handlerOnListener.alCall(target, args);
                        }
                    });
                }
            }
            Lib.avm1BroadcastEvent = avm1BroadcastEvent;
            function createAVM1NativeObject(ctor, nativeObject, context) {
                // We need to walk on __proto__ to find right ctor.prototype.
                var template;
                var proto = ctor.alGetPrototypeProperty();
                while (proto && !proto.initAVM1SymbolInstance) {
                    if (proto._as3ObjectTemplate && !template) {
                        template = proto._as3ObjectTemplate;
                    }
                    proto = proto.alPrototype;
                }
                release || Shumway.Debug.assert(proto);
                var avm1Object = Object.create(proto);
                proto.initAVM1SymbolInstance.call(avm1Object, context, nativeObject);
                avm1Object.alPrototype = ctor.alGetPrototypeProperty();
                avm1Object.alSetOwnConstructorProperty(ctor);
                nativeObject._as2Object = avm1Object;
                ctor.alCall(avm1Object);
                if (template) {
                    // transfer properties from the template
                    for (var prop in template) {
                        nativeObject[prop] = template[prop];
                    }
                }
                return avm1Object;
            }
            function getAVM1Object(as3Object, context) {
                if (!as3Object) {
                    return null;
                }
                if (as3Object._as2Object) {
                    return as3Object._as2Object;
                }
                var sec = context.sec;
                if (sec.flash.display.MovieClip.axClass.axIsType(as3Object)) {
                    var theClass = as3Object._symbol && context.getSymbolClass(as3Object._symbol.data.id);
                    if (theClass) {
                        return createAVM1NativeObject(theClass, as3Object, context);
                    }
                    return createAVM1NativeObject(context.globals.MovieClip, as3Object, context);
                }
                if (sec.flash.display.SimpleButton.axClass.axIsType(as3Object)) {
                    return createAVM1NativeObject(context.globals.Button, as3Object, context);
                }
                if (sec.flash.text.TextField.axClass.axIsType(as3Object)) {
                    return createAVM1NativeObject(context.globals.TextField, as3Object, context);
                }
                if (sec.flash.display.BitmapData.axClass.axIsType(as3Object)) {
                    return new as3Object();
                }
                return null;
            }
            Lib.getAVM1Object = getAVM1Object;
            function wrapAVM1NativeMembers(context, wrap, obj, members, prefixFunctions) {
                if (prefixFunctions === void 0) {
                    prefixFunctions = false;
                }
                function wrapFunction(fn) {
                    if (Shumway.isNullOrUndefined(fn)) {
                        return undefined;
                    }
                    release || Shumway.Debug.assert(typeof fn === 'function');
                    if (!prefixFunctions) {
                        return new AVM1.AVM1NativeFunction(context, fn);
                    }
                    return new AVM1.AVM1NativeFunction(context, function () {
                        var args = Array.prototype.slice.call(arguments, 0);
                        args.unshift(context);
                        return fn.apply(this, args);
                    });
                }
                function getMemberDescriptor(memberName) {
                    var desc;
                    for (var p = obj; p; p = Object.getPrototypeOf(p)) {
                        desc = Object.getOwnPropertyDescriptor(p, memberName);
                        if (desc) {
                            return desc;
                        }
                    }
                    return null;
                }
                if (!members) {
                    return;
                }
                members.forEach(function (memberName) {
                    if (memberName[memberName.length - 1] === '#') {
                        // Property mapping
                        var getterName = 'get' + memberName[0].toUpperCase() + memberName.slice(1, -1);
                        var getter = obj[getterName];
                        var setterName = 'set' + memberName[0].toUpperCase() + memberName.slice(1, -1);
                        var setter = obj[setterName];
                        release || Shumway.Debug.assert(getter || setter, 'define getter or setter');
                        var desc = new AVM1.AVM1PropertyDescriptor(128    /* ACCESSOR */ | 2    /* DONT_DELETE */ | 1    /* DONT_ENUM */, null, wrapFunction(getter), wrapFunction(setter));
                        wrap.alSetOwnProperty(memberName.slice(0, -1), desc);
                        return;
                    }
                    var nativeDesc = getMemberDescriptor(memberName);
                    if (!nativeDesc) {
                        return;
                    }
                    if (nativeDesc.get || nativeDesc.set) {
                        release || Shumway.Debug.assert(false, 'Redefine ' + memberName + ' property getter/setter as functions');
                        return;
                    }
                    var value = nativeDesc.value;
                    if (typeof value === 'function') {
                        value = wrapFunction(value);
                    }
                    var desc = new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 2    /* DONT_DELETE */ | 1    /* DONT_ENUM */, value);
                    wrap.alSetOwnProperty(memberName, desc);
                });
            }
            Lib.wrapAVM1NativeMembers = wrapAVM1NativeMembers;
            function wrapAVM1NativeClass(context, wrapAsFunction, cls, staticMembers, members, call, cstr) {
                var wrappedFn = wrapAsFunction ? new AVM1.AVM1NativeFunction(context, call || function () {
                }, function () {
                    // Creating simple AVM1 object
                    var obj = new cls(context);
                    obj.alPrototype = wrappedPrototype;
                    obj.alSetOwnConstructorProperty(wrappedFn);
                    if (cstr) {
                        cstr.apply(obj, arguments);
                    }
                    return obj;
                }) : new AVM1.AVM1Object(context);
                wrapAVM1NativeMembers(context, wrappedFn, cls, staticMembers, true);
                var wrappedPrototype = new cls(context);
                wrappedPrototype.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                wrapAVM1NativeMembers(context, wrappedPrototype, cls.prototype, members, false);
                AVM1.alDefineObjectProperties(wrappedFn, { prototype: { value: wrappedPrototype } });
                AVM1.alDefineObjectProperties(wrappedPrototype, {
                    constructor: {
                        value: wrappedFn,
                        writable: true
                    }
                });
                return wrappedFn;
            }
            Lib.wrapAVM1NativeClass = wrapAVM1NativeClass;
            // TODO: type arguments strongly
            function initializeAVM1Object(as3Object, context, placeObjectTag) {
                var instanceAVM1 = getAVM1Object(as3Object, context);
                release || Shumway.Debug.assert(instanceAVM1);
                if (placeObjectTag.variableName) {
                    instanceAVM1.alPut('variable', placeObjectTag.variableName);
                }
                var events = placeObjectTag.events;
                if (!events) {
                    return;
                }
                var stageListeners = [];
                var as3Stage = context.globals.Stage._as3Stage;
                for (var j = 0; j < events.length; j++) {
                    var swfEvent = events[j];
                    var actionsData;
                    if (swfEvent.actionsBlock) {
                        actionsData = context.actionsDataFactory.createActionsData(swfEvent.actionsBlock, 's' + placeObjectTag.symbolId + 'd' + placeObjectTag.depth + 'e' + j);
                        swfEvent.actionsBlock = null;
                        swfEvent.compiled = actionsData;
                    } else {
                        actionsData = swfEvent.compiled;
                    }
                    release || Shumway.Debug.assert(actionsData);
                    var handler = clipEventHandler.bind(null, actionsData, instanceAVM1);
                    var flags = swfEvent.flags;
                    for (var eventFlag in ClipEventMappings) {
                        eventFlag |= 0;
                        if (!(flags & (eventFlag | 0))) {
                            continue;
                        }
                        var eventMapping = ClipEventMappings[eventFlag];
                        var eventName = eventMapping.name;
                        if (!eventName) {
                            Shumway.Debug.warning('ClipEvent: ' + eventFlag + ' not implemented');
                            continue;
                        }
                        // AVM1 MovieClips are set to button mode if one of the button-related event listeners is
                        // set. This behaviour is triggered regardless of the actual value they are set to.
                        if (eventMapping.isButtonEvent) {
                            as3Object.buttonMode = true;
                        }
                        // Some AVM1 MovieClip events (e.g. mouse and key events) are bound to
                        // the stage rather then object itself -- binding listeners there.
                        if (eventMapping.isStageEvent) {
                            stageListeners.push({
                                eventName: eventName,
                                handler: handler
                            });
                            as3Stage.addEventListener(eventName, handler);
                        } else {
                            as3Object.addEventListener(eventName, handler);
                        }
                    }
                }
                if (stageListeners.length > 0) {
                    as3Object.addEventListener('removedFromStage', function () {
                        for (var i = 0; i < stageListeners.length; i++) {
                            as3Stage.removeEventListener(stageListeners[i].eventName, stageListeners[i].fn, false);
                        }
                    }, false);
                }
            }
            Lib.initializeAVM1Object = initializeAVM1Object;
            function clipEventHandler(actionsData, receiver) {
                return receiver.context.executeActions(actionsData, receiver);
            }
            var ClipEventMappings;
            ClipEventMappings = Object.create(null);
            ClipEventMappings[1    /* Load */] = {
                name: 'load',
                isStageEvent: false,
                isButtonEvent: false
            };
            // AVM1's enterFrame happens at the same point in the cycle as AVM2's frameConstructed.
            ClipEventMappings[2    /* EnterFrame */] = {
                name: 'frameConstructed',
                isStageEvent: false,
                isButtonEvent: false
            };
            ClipEventMappings[4    /* Unload */] = {
                name: 'unload',
                isStageEvent: false,
                isButtonEvent: false
            };
            ClipEventMappings[8    /* MouseMove */] = {
                name: 'mouseMove',
                isStageEvent: true,
                isButtonEvent: false
            };
            ClipEventMappings[16    /* MouseDown */] = {
                name: 'mouseDown',
                isStageEvent: true,
                isButtonEvent: false
            };
            ClipEventMappings[32    /* MouseUp */] = {
                name: 'mouseUp',
                isStageEvent: true,
                isButtonEvent: false
            };
            ClipEventMappings[64    /* KeyDown */] = {
                name: 'keyDown',
                isStageEvent: true,
                isButtonEvent: false
            };
            ClipEventMappings[128    /* KeyUp */] = {
                name: 'keyUp',
                isStageEvent: true,
                isButtonEvent: false
            };
            ClipEventMappings[256    /* Data */] = {
                name: null,
                isStageEvent: false,
                isButtonEvent: false
            };
            ClipEventMappings[512    /* Initialize */] = {
                name: 'initialize',
                isStageEvent: false,
                isButtonEvent: false
            };
            ClipEventMappings[1024    /* Press */] = {
                name: 'mouseDown',
                isStageEvent: true,
                isButtonEvent: true
            };
            ClipEventMappings[2048    /* Release */] = {
                name: 'click',
                isStageEvent: false,
                isButtonEvent: true
            };
            ClipEventMappings[4096    /* ReleaseOutside */] = {
                name: 'releaseOutside',
                isStageEvent: false,
                isButtonEvent: true
            };
            ClipEventMappings[8192    /* RollOver */] = {
                name: 'mouseOver',
                isStageEvent: true,
                isButtonEvent: true
            };
            ClipEventMappings[16384    /* RollOut */] = {
                name: 'mouseOut',
                isStageEvent: true,
                isButtonEvent: true
            };
            ClipEventMappings[32768    /* DragOver */] = {
                name: null,
                isStageEvent: false,
                isButtonEvent: false
            };
            ClipEventMappings[65536    /* DragOut */] = {
                name: null,
                isStageEvent: false,
                isButtonEvent: false
            };
            ClipEventMappings[131072    /* KeyPress */] = {
                name: null,
                isStageEvent: true,
                isButtonEvent: false
            };
            ClipEventMappings[262144    /* Construct */] = {
                name: 'construct',
                isStageEvent: false,
                isButtonEvent: false
            };
            var notImplemented = Shumway.Debug.notImplemented;
            var flash = Shumway.AVMX.AS.flash;
            // REDUX remove
            var _escape = jsGlobal.escape;
            var _internalTimeouts = [];
            var AVM1Globals = function (_super) {
                __extends(AVM1Globals, _super);
                function AVM1Globals(context) {
                    _super.call(this, context);
                    // built-ins
                    this.NaN = Number.NaN;
                    this.Infinity = Number.POSITIVE_INFINITY;
                    this.undefined = undefined;
                    this._initBuiltins(context);
                    var swfVersion = context.loaderInfo.swfVersion;
                    if (swfVersion >= 8) {
                        this._initializeFlashObject(context);
                    }
                }
                AVM1Globals.createGlobalsObject = function (context) {
                    var globals = new AVM1Globals(context);
                    Lib.wrapAVM1NativeMembers(context, globals, globals, [
                        'flash',
                        'ASSetPropFlags',
                        'clearInterval',
                        'clearTimeout',
                        'escape',
                        'unescape',
                        'setInterval',
                        'setTimeout',
                        'showRedrawRegions',
                        'trace',
                        'updateAfterEvent',
                        'NaN',
                        'Infinity',
                        'isFinite',
                        'isNaN',
                        'parseFloat',
                        'parseInt',
                        'undefined',
                        'Object',
                        'Function',
                        'Array',
                        'Number',
                        'Math',
                        'Boolean',
                        'Date',
                        'String',
                        'Error',
                        'MovieClip',
                        'AsBroadcaster',
                        'System',
                        'Stage',
                        'Button',
                        'TextField',
                        'Color',
                        'Key',
                        'Mouse',
                        'MovieClipLoader',
                        'XML',
                        'XMLNode',
                        'LoadVars',
                        'Sound',
                        'SharedObject',
                        'ContextMenu',
                        'ContextMenuItem',
                        'TextFormat'
                    ], false);
                    return globals;
                };
                AVM1Globals.prototype.ASSetPropFlags = function (obj, children, flags, allowFalse) {
                };
                AVM1Globals.prototype.clearInterval = function (id) {
                    var internalId = _internalTimeouts[id - 1];
                    if (internalId) {
                        clearInterval(internalId);
                        delete _internalTimeouts[id - 1];
                    }
                };
                AVM1Globals.prototype.clearTimeout = function (id) {
                    var internalId = _internalTimeouts[id - 1];
                    if (internalId) {
                        clearTimeout(internalId);
                        delete _internalTimeouts[id - 1];
                    }
                };
                /**
                 * AVM1 escapes slightly more characters than JS's encodeURIComponent, and even more than
                 * the deprecated JS version of escape. That leaves no other option but to do manual post-
                 * processing of the encoded result. :/
                 *
                 * Luckily, unescape isn't thus afflicted - it happily unescapes all the additional things
                 * we escape here.
                 */
                AVM1Globals.prototype.escape = function (str) {
                    var result = encodeURIComponent(str);
                    return result.replace(/!|'|\(|\)|\*|-|\.|_|~/g, function (char) {
                        switch (char) {
                        case '*':
                            return '%2A';
                        case '-':
                            return '%2D';
                        case '.':
                            return '%2E';
                        case '_':
                            return '%5F';
                        default:
                            return _escape(char);
                        }
                    });
                };
                AVM1Globals.prototype.unescape = function (str) {
                    return decodeURIComponent(str);
                };
                AVM1Globals.prototype.setInterval = function () {
                    // AVM1 setInterval silently swallows everything that vaguely looks like an error.
                    if (arguments.length < 2) {
                        return undefined;
                    }
                    var context = this.context;
                    var args = [];
                    if (AVM1.alIsFunction(arguments[0])) {
                        var fn = arguments[0];
                        args.push(fn.toJSFunction(), arguments[1]);
                    } else {
                        if (arguments.length < 3) {
                            return undefined;
                        }
                        var obj = arguments[0];
                        var funName = arguments[1];
                        if (!(obj instanceof AVM1.AVM1Object) || typeof funName !== 'string') {
                            return undefined;
                        }
                        args.push(function () {
                            var fn = obj.alGet(funName);
                            if (!AVM1.alIsFunction(fn)) {
                                return;
                            }
                            var args = Array.prototype.slice.call(arguments, 0);
                            context.executeFunction(fn, obj, args);
                        });
                    }
                    for (var i = 2; i < arguments.length; i++) {
                        args.push(arguments[i]);
                    }
                    // Unconditionally coerce interval to int, as one would do.
                    args[1] = AVM1.alToInteger(context, args[1]);
                    var internalId = setInterval.apply(null, args);
                    return _internalTimeouts.push(internalId);
                };
                AVM1Globals.prototype.setTimeout = function () {
                    // AVM1 setTimeout silently swallows most things that vaguely look like errors.
                    if (arguments.length < 2 || !AVM1.alIsFunction(arguments[0])) {
                        return undefined;
                    }
                    var args = [];
                    var fn = arguments[0];
                    args.push(fn.toJSFunction());
                    // Unconditionally coerce interval to int, as one would do.
                    args.push(AVM1.alToInteger(this.context, arguments[1]));
                    for (var i = 2; i < arguments.length; i++) {
                        args.push(arguments[i]);
                    }
                    var internalId = setTimeout.apply(null, args);
                    return _internalTimeouts.push(internalId);
                };
                AVM1Globals.prototype.showRedrawRegions = function (enable, color) {
                    // flash.profiler.showRedrawRegions.apply(null, arguments);
                    notImplemented('AVM1Globals.showRedrawRegions');
                };
                AVM1Globals.prototype.trace = function (expression) {
                    this.context.actions.trace(expression);
                };
                AVM1Globals.prototype.updateAfterEvent = function () {
                    this.context.sec.player.requestRendering();
                };
                AVM1Globals.prototype.isFinite = function (n) {
                    return isFinite(AVM1.alToNumber(this.context, n));
                };
                AVM1Globals.prototype.isNaN = function (n) {
                    return isNaN(AVM1.alToNumber(this.context, n));
                };
                AVM1Globals.prototype.parseFloat = function (s) {
                    return parseFloat(AVM1.alToString(this.context, s));
                };
                AVM1Globals.prototype.parseInt = function (s, radix) {
                    return parseInt(AVM1.alToString(this.context, s), AVM1.alToInt32(this.context, radix));
                };
                AVM1Globals.prototype._initBuiltins = function (context) {
                    var builtins = context.builtins;
                    this.Object = builtins.Object;
                    this.Function = builtins.Function;
                    this.Array = builtins.Array;
                    this.Number = builtins.Number;
                    this.Math = builtins.Math;
                    this.Boolean = builtins.Boolean;
                    this.Date = builtins.Date;
                    this.String = builtins.String;
                    this.Error = builtins.Error;
                    this.MovieClip = Lib.AVM1MovieClip.createAVM1Class(context);
                    this.AsBroadcaster = Lib.AVM1Broadcaster.createAVM1Class(context);
                    this.System = Lib.AVM1System.createAVM1Class(context);
                    this.Stage = Lib.AVM1Stage.createAVM1Class(context);
                    this.Button = Lib.AVM1Button.createAVM1Class(context);
                    this.TextField = Lib.AVM1TextField.createAVM1Class(context);
                    this.Color = Lib.AVM1Color.createAVM1Class(context);
                    this.Key = Lib.AVM1Key.createAVM1Class(context);
                    this.Mouse = Lib.AVM1Mouse.createAVM1Class(context);
                    this.MovieClipLoader = Lib.AVM1MovieClipLoader.createAVM1Class(context);
                    this.LoadVars = new Lib.AVM1LoadVarsFunction(context);
                    this.Sound = Lib.AVM1Sound.createAVM1Class(context);
                    this.SharedObject = new Lib.AVM1SharedObjectFunction(context);
                    this.ContextMenu = undefined;
                    // wrapAVM1Builtin(sec.flash.ui.ContextMenu.axClass);
                    this.ContextMenuItem = undefined;
                    // wrapAVM1Builtin(sec.flash.ui.ContextMenuItem.axClass);
                    this.TextFormat = Lib.AVM1TextFormat.createAVM1Class(context);
                    this.XMLNode = new Lib.AVM1XMLNodeFunction(context);
                    this.XML = new Lib.AVM1XMLFunction(context, this.XMLNode);
                    this.BitmapData = Lib.AVM1BitmapData.createAVM1Class(context);
                    this.Matrix = new Lib.AVM1MatrixFunction(context);
                    this.Point = new Lib.AVM1PointFunction(context);
                    this.Rectangle = new Lib.AVM1RectangleFunction(context);
                    this.Transform = Lib.AVM1Transform.createAVM1Class(context);
                    this.ColorTransform = new Lib.AVM1ColorTransformFunction(context);
                    Lib.AVM1Broadcaster.initialize(context, this.Stage);
                    Lib.AVM1Broadcaster.initialize(context, this.Key);
                    Lib.AVM1Broadcaster.initialize(context, this.Mouse);
                };
                AVM1Globals.prototype._initializeFlashObject = function (context) {
                    this.flash = AVM1.alNewObject(context);
                    var display = AVM1.alNewObject(context);
                    display.alPut('BitmapData', this.BitmapData);
                    this.flash.alPut('display', display);
                    var external = AVM1.alNewObject(context);
                    external.alPut('ExternalInterface', Lib.AVM1ExternalInterface.createAVM1Class(context));
                    this.flash.alPut('external', external);
                    var filters = Lib.createFiltersClasses(context);
                    this.flash.alPut('filters', filters);
                    this.filters = filters;
                    var geom = AVM1.alNewObject(context);
                    geom.alPut('ColorTransform', this.ColorTransform);
                    geom.alPut('Matrix', this.Matrix);
                    geom.alPut('Point', this.Point);
                    geom.alPut('Rectangle', this.Rectangle);
                    geom.alPut('Transform', this.Transform);
                    this.flash.alPut('geom', geom);
                    var text = AVM1.alNewObject(context);
                    this.flash.alPut('text', text);
                };
                return AVM1Globals;
            }(AVM1.AVM1Object);
            Lib.AVM1Globals = AVM1Globals;
            var AVM1NativeActions = function () {
                function AVM1NativeActions(context) {
                    this.context = context;    // TODO ?
                }
                AVM1NativeActions.prototype.asfunction = function (link) {
                    notImplemented('AVM1Globals.$asfunction');
                };
                AVM1NativeActions.prototype.call = function (frame) {
                    var nativeTarget = this.context.resolveTarget(null);
                    var as3Object = Lib.getAS3Object(nativeTarget);
                    var frameNum = as3Object._getAbsFrameNumber(frame, null);
                    if (frameNum === undefined) {
                        return;
                    }
                    as3Object.callFrame(frameNum);
                };
                AVM1NativeActions.prototype.chr = function (code) {
                    code = AVM1.alToInteger(this.context, code);
                    if (this.context.swfVersion <= 5) {
                        code &= 255;
                    }
                    return code ? String.fromCharCode(code) : '';
                };
                AVM1NativeActions.prototype.duplicateMovieClip = function (target, newname, depth) {
                    var normalizedDepth = AVM1.alCoerceNumber(this.context, depth) - Lib.DEPTH_OFFSET;
                    var nativeTarget = this.context.resolveTarget(target);
                    nativeTarget.duplicateMovieClip(newname, normalizedDepth, null);
                };
                AVM1NativeActions.prototype.fscommand = function (command, args) {
                    return this.context.sec.flash.system.fscommand.axCall(null, this.context.sec, command, args);
                };
                AVM1NativeActions.prototype.getTimer = function () {
                    return Shumway.AVMX.AS.FlashUtilScript_getTimer(this.context.sec);
                };
                AVM1NativeActions.prototype.getURL = function (url, target, method) {
                    var sec = this.context.sec;
                    var request = new sec.flash.net.URLRequest(String(url));
                    if (method) {
                        request.method = method;
                    }
                    if (typeof target === 'string' && target.indexOf('_level') === 0) {
                        this.loadMovieNum(url, +target.substr(6), method);
                        return;
                    }
                    Shumway.AVMX.AS.FlashNetScript_navigateToURL(sec, request, target);
                };
                AVM1NativeActions.prototype.gotoAndPlay = function (scene, frame) {
                    var nativeTarget = this.context.resolveTarget(null);
                    var as3Object = Lib.getAS3Object(nativeTarget);
                    if (arguments.length < 2) {
                        as3Object.gotoAndPlay(arguments[0]);
                    } else {
                        as3Object.gotoAndPlay(arguments[1], arguments[0]);    // scene and frame are swapped for AS3
                    }
                };
                AVM1NativeActions.prototype.gotoAndStop = function (scene, frame) {
                    var nativeTarget = this.context.resolveTarget(null);
                    var as3Object = Lib.getAS3Object(nativeTarget);
                    if (arguments.length < 2) {
                        as3Object.gotoAndStop(arguments[0]);
                    } else {
                        as3Object.gotoAndStop(arguments[1], arguments[0]);    // scene and frame are swapped for AS3
                    }
                };
                AVM1NativeActions.prototype.ifFrameLoaded = function (scene, frame) {
                    // ignoring scene parameter ?
                    var nativeTarget = this.context.resolveTarget(null);
                    var frameNum = arguments.length < 2 ? arguments[0] : arguments[1];
                    var framesLoaded = nativeTarget.alGet('_framesloaded');
                    var totalFrames = nativeTarget.alGet('_totalframes');
                    // The (0-based) requested frame index is clamped to (the 1-based) totalFrames value.
                    // I.e., asking if frame 20 is loaded in a timline with only 10 frames returns true if all
                    // frames have been loaded.
                    return Math.min(frameNum + 1, totalFrames) <= framesLoaded;
                };
                AVM1NativeActions.prototype.length_ = function (expression) {
                    return ('' + expression).length;    // ASCII Only?
                };
                AVM1NativeActions.prototype.loadMovie = function (url, target, method) {
                    // some swfs are using loadMovie to call fscommmand
                    if (url && url.toLowerCase().indexOf('fscommand:') === 0) {
                        this.fscommand(url.substring('fscommand:'.length), target);
                        return;
                    }
                    var loadLevel = typeof target === 'string' && target.indexOf('_level') === 0;
                    var levelNumber;
                    if (loadLevel) {
                        var levelStr = target.substr(6);
                        levelNumber = parseInt(levelStr, 10);
                        loadLevel = levelNumber.toString() === levelStr;
                    }
                    if (loadLevel) {
                        this.loadMovieNum(url, levelNumber, method);
                    } else {
                        var nativeTarget = this.context.resolveTarget(target);
                        nativeTarget.loadMovie(url, method);
                    }
                };
                AVM1NativeActions.prototype.loadMovieNum = function (url, level, method) {
                    url = AVM1.alCoerceString(this.context, url);
                    level = AVM1.alToInteger(this.context, level);
                    method = AVM1.alCoerceString(this.context, method);
                    // some swfs are using loadMovieNum to call fscommmand
                    if (url && url.toLowerCase().indexOf('fscommand:') === 0) {
                        return this.fscommand(url.substring('fscommand:'.length));
                    }
                    if (level === 0) {
                        release || Shumway.Debug.notImplemented('loadMovieNum at _level0');
                        return;
                    }
                    var avm1LevelHolder = this.context.levelsContainer;
                    var loaderHelper = new Lib.AVM1LoaderHelper(this.context);
                    loaderHelper.load(url, method).then(function () {
                        avm1LevelHolder._addRoot(level, loaderHelper.content);
                    });
                };
                AVM1NativeActions.prototype.loadVariables = function (url, target, method) {
                    if (method === void 0) {
                        method = '';
                    }
                    url = AVM1.alCoerceString(this.context, url);
                    method = AVM1.alCoerceString(this.context, method);
                    var nativeTarget = this.context.resolveTarget(target);
                    if (!nativeTarget) {
                        return;    // target was not found
                    }
                    this._loadVariables(nativeTarget, url, method);
                };
                AVM1NativeActions.prototype.loadVariablesNum = function (url, level, method) {
                    if (method === void 0) {
                        method = '';
                    }
                    url = AVM1.alCoerceString(this.context, url);
                    level = AVM1.alToInteger(this.context, level);
                    method = AVM1.alCoerceString(this.context, method);
                    var nativeTarget = this.context.resolveLevel(level);
                    if (!nativeTarget) {
                        return;    // target was not found
                    }
                    this._loadVariables(nativeTarget, url, method);
                };
                AVM1NativeActions.prototype._loadVariables = function (nativeTarget, url, method) {
                    var context = this.context;
                    var request = new context.sec.flash.net.URLRequest(url);
                    if (method) {
                        request.method = method;
                    }
                    var loader = new context.sec.flash.net.URLLoader(request);
                    loader._ignoreDecodeErrors = true;
                    loader.dataFormat = 'variables';
                    // flash.net.URLLoaderDataFormat.VARIABLES;
                    var completeHandler = context.sec.boxFunction(function (event) {
                        loader.removeEventListener(flash.events.Event.COMPLETE, completeHandler);
                        // If the response data is empty, URLLoader#data contains an empty string.
                        if (loader.data !== '') {
                            release || Shumway.Debug.assert(typeof loader.data === 'object');
                            Shumway.AVMX.forEachPublicProperty(loader.data, function (key, value) {
                                context.utils.setProperty(nativeTarget, key, value);
                            });
                        }
                        if (nativeTarget instanceof Lib.AVM1MovieClip) {
                            Lib.avm1BroadcastEvent(context, nativeTarget, 'onData');
                        }
                    });
                    loader.addEventListener(flash.events.Event.COMPLETE, completeHandler);
                };
                AVM1NativeActions.prototype.mbchr = function (code) {
                    code = AVM1.alToInteger(this.context, code);
                    return code ? String.fromCharCode(code) : '';
                };
                AVM1NativeActions.prototype.mblength = function (expression) {
                    return ('' + expression).length;
                };
                AVM1NativeActions.prototype.mbord = function (character) {
                    return ('' + character).charCodeAt(0);
                };
                AVM1NativeActions.prototype.mbsubstring = function (value, index, count) {
                    if (index !== (0 | index) || count !== (0 | count)) {
                        // index or count are not integers, the result is the empty string.
                        return '';
                    }
                    return ('' + value).substr(index, count);
                };
                AVM1NativeActions.prototype.nextFrame = function () {
                    var nativeTarget = this.context.resolveTarget(null);
                    var as3Object = Lib.getAS3Object(nativeTarget);
                    as3Object.nextFrame();
                };
                AVM1NativeActions.prototype.nextScene = function () {
                    var nativeTarget = this.context.resolveTarget(null);
                    var as3Object = Lib.getAS3Object(nativeTarget);
                    as3Object.nextScene();
                };
                AVM1NativeActions.prototype.ord = function (character) {
                    return ('' + character).charCodeAt(0);    // ASCII only?
                };
                AVM1NativeActions.prototype.play = function () {
                    var nativeTarget = this.context.resolveTarget(null);
                    nativeTarget.play();
                };
                AVM1NativeActions.prototype.prevFrame = function () {
                    var nativeTarget = this.context.resolveTarget(null);
                    var as3Object = Lib.getAS3Object(nativeTarget);
                    as3Object.prevFrame();
                };
                AVM1NativeActions.prototype.prevScene = function () {
                    var nativeTarget = this.context.resolveTarget(null);
                    var as3Object = Lib.getAS3Object(nativeTarget);
                    as3Object.prevScene();
                };
                AVM1NativeActions.prototype.print = function (target, boundingBox) {
                    // flash.printing.PrintJob
                    notImplemented('AVM1Globals.print');
                };
                AVM1NativeActions.prototype.printAsBitmap = function (target, boundingBox) {
                    notImplemented('AVM1Globals.printAsBitmap');
                };
                AVM1NativeActions.prototype.printAsBitmapNum = function (level, boundingBox) {
                    notImplemented('AVM1Globals.printAsBitmapNum');
                };
                AVM1NativeActions.prototype.printNum = function (level, bondingBox) {
                    notImplemented('AVM1Globals.printNum');
                };
                AVM1NativeActions.prototype.random = function (value) {
                    return 0 | Math.random() * (0 | value);
                };
                AVM1NativeActions.prototype.removeMovieClip = function (target) {
                    var nativeTarget = this.context.resolveTarget(target);
                    if (!nativeTarget) {
                        return;
                    }
                    nativeTarget.removeMovieClip();
                };
                AVM1NativeActions.prototype.startDrag = function (target) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    var mc = this.context.resolveTarget(target);
                    mc.startDrag.apply(mc, args);
                };
                AVM1NativeActions.prototype.stop = function () {
                    var nativeTarget = this.context.resolveTarget(null);
                    nativeTarget.stop();
                };
                AVM1NativeActions.prototype.stopAllSounds = function () {
                    this.context.sec.flash.media.SoundMixer.axClass.stopAll();
                };
                AVM1NativeActions.prototype.stopDrag = function () {
                    // Using current draggable instead of current target.
                    var as3CurrentDraggable = this.context.sec.flash.ui.Mouse.axClass.draggableObject;
                    if (as3CurrentDraggable) {
                        var nativeTarget = Lib.getAVM1Object(as3CurrentDraggable, this.context);
                        nativeTarget.stopDrag();
                    }
                };
                AVM1NativeActions.prototype.substring = function (value, index, count) {
                    return this.mbsubstring(value, index, count);    // ASCII Only?
                };
                AVM1NativeActions.prototype.toggleHighQuality = function () {
                    // flash.display.Stage.quality
                    notImplemented('AVM1Globals.toggleHighQuality');
                };
                AVM1NativeActions.prototype.trace = function (expression) {
                    var value;
                    switch (typeof expression) {
                    case 'undefined':
                        // undefined is always 'undefined' for trace (even for SWF6).
                        value = 'undefined';
                        break;
                    case 'string':
                        value = expression;
                        break;
                    default:
                        value = AVM1.alToString(this.context, expression);
                        break;
                    }
                    Shumway.AVMX.AS.Natives.print(this.context.sec, value);
                };
                AVM1NativeActions.prototype.unloadMovie = function (target) {
                    var nativeTarget = this.context.resolveTarget(target);
                    if (!nativeTarget) {
                        return;    // target was not found
                    }
                    nativeTarget.unloadMovie();
                };
                AVM1NativeActions.prototype.unloadMovieNum = function (level) {
                    level = AVM1.alToInt32(this.context, level);
                    if (level === 0) {
                        release || Shumway.Debug.notImplemented('unloadMovieNum at _level0');
                        return;
                    }
                    var avm1MovieHolder = this.context.levelsContainer;
                    avm1MovieHolder._removeRoot(level);
                };
                return AVM1NativeActions;
            }();
            Lib.AVM1NativeActions = AVM1NativeActions;
            function _updateAllSymbolEvents(symbolInstance) {
                if (!Lib.hasAS3ObjectReference(symbolInstance)) {
                    return;
                }
                symbolInstance.updateAllEvents();
            }
            var AVM1Broadcaster = function (_super) {
                __extends(AVM1Broadcaster, _super);
                function AVM1Broadcaster() {
                    _super.apply(this, arguments);
                }
                AVM1Broadcaster.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1Broadcaster, ['initialize'], []);
                };
                AVM1Broadcaster.initialize = function (context, obj) {
                    var desc = new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */, new AVM1.Natives.AVM1ArrayNative(context, []));
                    obj.alSetOwnProperty('_listeners', desc);
                    desc = new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */, new AVM1.AVM1NativeFunction(context, function broadcastMessage(eventName) {
                        var args = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            args[_i - 1] = arguments[_i];
                        }
                        var listenersField = this.alGet('_listeners');
                        if (!(listenersField instanceof AVM1.Natives.AVM1ArrayNative)) {
                            return;
                        }
                        Lib.avm1BroadcastEvent(context, this, eventName, args);
                    }));
                    obj.alSetOwnProperty('broadcastMessage', desc);
                    desc = new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */, new AVM1.AVM1NativeFunction(context, function addListener(listener) {
                        var listenersField = this.alGet('_listeners');
                        if (!(listenersField instanceof AVM1.Natives.AVM1ArrayNative)) {
                            return false;
                        }
                        var listeners = listenersField.value;
                        listeners.push(listener);
                        _updateAllSymbolEvents(this);
                        return true;
                    }));
                    obj.alSetOwnProperty('addListener', desc);
                    desc = new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 1    /* DONT_ENUM */, new AVM1.AVM1NativeFunction(context, function removeListener(listener) {
                        var listenersField = this.alGet('_listeners');
                        if (!(listenersField instanceof AVM1.Natives.AVM1ArrayNative)) {
                            return false;
                        }
                        var listeners = listenersField.value;
                        var i = listeners.indexOf(listener);
                        if (i < 0) {
                            return false;
                        }
                        listeners.splice(i, 1);
                        _updateAllSymbolEvents(this);
                        return true;
                    }));
                    obj.alSetOwnProperty('removeListener', desc);
                };
                return AVM1Broadcaster;
            }(AVM1.AVM1Object);
            Lib.AVM1Broadcaster = AVM1Broadcaster;
            var AVM1Key = function (_super) {
                __extends(AVM1Key, _super);
                function AVM1Key() {
                    _super.apply(this, arguments);
                }
                AVM1Key.createAVM1Class = function (context) {
                    var wrapped = Lib.wrapAVM1NativeClass(context, false, AVM1Key, [
                        'DOWN',
                        'LEFT',
                        'RIGHT',
                        'UP',
                        'isDown',
                        'getCode'
                    ], []);
                    return wrapped;
                };
                AVM1Key.alInitStatic = function (context) {
                    this._keyStates = [];
                    this._lastKeyCode = 0;
                };
                AVM1Key.bindStage = function (context, cls, stage) {
                    stage.addEventListener('keyDown', function (e) {
                        var keyCode = e.axGetPublicProperty('keyCode');
                        var staticState = context.getStaticState(AVM1Key);
                        staticState._lastKeyCode = keyCode;
                        staticState._keyStates[keyCode] = 1;
                        AVM1.alCallProperty(cls, 'broadcastMessage', ['onKeyDown']);
                    }, false);
                    stage.addEventListener('keyUp', function (e) {
                        var keyCode = e.axGetPublicProperty('keyCode');
                        var staticState = context.getStaticState(AVM1Key);
                        staticState._lastKeyCode = keyCode;
                        delete staticState._keyStates[keyCode];
                        AVM1.alCallProperty(cls, 'broadcastMessage', ['onKeyUp']);
                    }, false);
                };
                AVM1Key.isDown = function (context, code) {
                    var staticState = context.getStaticState(AVM1Key);
                    return !!staticState._keyStates[code];
                };
                AVM1Key.getCode = function (context) {
                    var staticState = context.getStaticState(AVM1Key);
                    return staticState._lastKeyCode;
                };
                AVM1Key.DOWN = 40;
                AVM1Key.LEFT = 37;
                AVM1Key.RIGHT = 39;
                AVM1Key.UP = 38;
                return AVM1Key;
            }(AVM1.AVM1Object);
            Lib.AVM1Key = AVM1Key;
            var AVM1Mouse = function (_super) {
                __extends(AVM1Mouse, _super);
                function AVM1Mouse() {
                    _super.apply(this, arguments);
                }
                AVM1Mouse.createAVM1Class = function (context) {
                    var wrapped = Lib.wrapAVM1NativeClass(context, false, AVM1Mouse, [
                        'show',
                        'hide'
                    ], []);
                    return wrapped;
                };
                AVM1Mouse.bindStage = function (context, cls, stage) {
                    stage.addEventListener('mouseDown', function (e) {
                        AVM1.alCallProperty(cls, 'broadcastMessage', ['onMouseDown']);
                    }, false);
                    stage.addEventListener('mouseMove', function (e) {
                        AVM1.alCallProperty(cls, 'broadcastMessage', ['onMouseMove']);
                    }, false);
                    stage.addEventListener('mouseOut', function (e) {
                        AVM1.alCallProperty(cls, 'broadcastMessage', ['onMouseMove']);
                    }, false);
                    stage.addEventListener('mouseUp', function (e) {
                        AVM1.alCallProperty(cls, 'broadcastMessage', ['onMouseUp']);
                    }, false);
                };
                AVM1Mouse.hide = function () {
                };
                AVM1Mouse.show = function () {
                };
                return AVM1Mouse;
            }(AVM1.AVM1Object);
            Lib.AVM1Mouse = AVM1Mouse;
            var AVM1Stage = function (_super) {
                __extends(AVM1Stage, _super);
                function AVM1Stage() {
                    _super.apply(this, arguments);
                }
                AVM1Stage.createAVM1Class = function (context) {
                    var wrapped = new AVM1Stage(context);
                    Lib.wrapAVM1NativeMembers(context, wrapped, AVM1Stage.prototype, [
                        'align#',
                        'displayState#',
                        'fullScreenSourceRect#',
                        'height#',
                        'scaleMode#',
                        'showMenu#',
                        'width#'
                    ], false);
                    return wrapped;
                };
                AVM1Stage.bindStage = function (context, cls, stage) {
                    cls._as3Stage = stage;
                };
                AVM1Stage.prototype.getAlign = function () {
                    return this._as3Stage.align;
                };
                AVM1Stage.prototype.setAlign = function (value) {
                    this._as3Stage.align = value;
                };
                AVM1Stage.prototype.getDisplayState = function () {
                    return this._as3Stage.displayState;
                };
                AVM1Stage.prototype.setDisplayState = function (value) {
                    this._as3Stage.displayState = value;
                };
                AVM1Stage.prototype.getFullScreenSourceRect = function () {
                    return this._as3Stage.fullScreenSourceRect;
                };
                AVM1Stage.prototype.setFullScreenSourceRect = function (value) {
                    this._as3Stage.fullScreenSourceRect = value;
                };
                AVM1Stage.prototype.getHeight = function () {
                    return this._as3Stage.stageHeight;
                };
                AVM1Stage.prototype.getScaleMode = function () {
                    return this._as3Stage.scaleMode;
                };
                AVM1Stage.prototype.setScaleMode = function (value) {
                    this._as3Stage.scaleMode = value;
                };
                AVM1Stage.prototype.getShowMenu = function () {
                    return this._as3Stage.showDefaultContextMenu;
                };
                AVM1Stage.prototype.setShowMenu = function (value) {
                    this._as3Stage.showDefaultContextMenu = value;
                };
                AVM1Stage.prototype.getWidth = function () {
                    return this._as3Stage.stageWidth;
                };
                return AVM1Stage;
            }(AVM1.AVM1Object);
            Lib.AVM1Stage = AVM1Stage;
            var assert = Shumway.Debug.assert;
            var AVM1MovieClipButtonModeEvent = function (_super) {
                __extends(AVM1MovieClipButtonModeEvent, _super);
                function AVM1MovieClipButtonModeEvent(propertyName, eventName, argsConverter) {
                    if (argsConverter === void 0) {
                        argsConverter = null;
                    }
                    _super.call(this, propertyName, eventName, argsConverter);
                    this.propertyName = propertyName;
                    this.eventName = eventName;
                    this.argsConverter = argsConverter;
                }
                AVM1MovieClipButtonModeEvent.prototype.onBind = function (target) {
                    var mc = target;
                    mc._as3Object.buttonMode = true;
                };
                return AVM1MovieClipButtonModeEvent;
            }(Lib.AVM1EventHandler);
            function convertAS3RectangeToBounds(as3Rectange) {
                var result = AVM1.alNewObject(this.context);
                result.alPut('xMin', as3Rectange.axGetPublicProperty('left'));
                result.alPut('yMin', as3Rectange.axGetPublicProperty('top'));
                result.alPut('xMax', as3Rectange.axGetPublicProperty('right'));
                result.alPut('yMax', as3Rectange.axGetPublicProperty('bottom'));
                return result;
            }
            var AVM1MovieClip = function (_super) {
                __extends(AVM1MovieClip, _super);
                function AVM1MovieClip() {
                    _super.apply(this, arguments);
                }
                AVM1MovieClip.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1MovieClip, [], [
                        '$version#',
                        '_alpha#',
                        'attachAudio',
                        'attachBitmap',
                        'attachMovie',
                        'beginFill',
                        'beginBitmapFill',
                        'beginGradientFill',
                        'blendMode#',
                        'cacheAsBitmap#',
                        '_callFrame',
                        'clear',
                        'createEmptyMovieClip',
                        'createTextField',
                        '_currentframe#',
                        'curveTo',
                        '_droptarget#',
                        'duplicateMovieClip',
                        'enabled#',
                        'endFill',
                        'filters#',
                        '_framesloaded#',
                        '_focusrect#',
                        'forceSmoothing#',
                        'getBounds',
                        'getBytesLoaded',
                        'getBytesTotal',
                        'getDepth',
                        'getInstanceAtDepth',
                        'getNextHighestDepth',
                        'getRect',
                        'getSWFVersion',
                        'getTextSnapshot',
                        'getURL',
                        'globalToLocal',
                        'gotoAndPlay',
                        'gotoAndStop',
                        '_height#',
                        '_highquality#',
                        'hitArea#',
                        'hitTest',
                        'lineGradientStyle',
                        'lineStyle',
                        'lineTo',
                        'loadMovie',
                        'loadVariables',
                        'localToGlobal',
                        '_lockroot#',
                        'menu#',
                        'moveTo',
                        '_name#',
                        'nextFrame',
                        'opaqueBackground#',
                        '_parent#',
                        'play',
                        'prevFrame',
                        '_quality#',
                        'removeMovieClip',
                        '_rotation#',
                        'scale9Grid#',
                        'scrollRect#',
                        'setMask',
                        '_soundbuftime#',
                        'startDrag',
                        'stop',
                        'stopDrag',
                        'swapDepths',
                        'tabChildren#',
                        'tabEnabled#',
                        'tabIndex#',
                        '_target#',
                        '_totalframes#',
                        'trackAsMenu#',
                        'transform#',
                        'toString',
                        'unloadMovie',
                        '_url#',
                        'useHandCursor#',
                        '_visible#',
                        '_width#',
                        '_x#',
                        '_xmouse#',
                        '_xscale#',
                        '_y#',
                        '_ymouse#',
                        '_yscale#'
                    ]);
                };
                Object.defineProperty(AVM1MovieClip.prototype, 'graphics', {
                    get: function () {
                        return this._as3Object.graphics;
                    },
                    enumerable: true,
                    configurable: true
                });
                AVM1MovieClip.prototype.initAVM1SymbolInstance = function (context, as3Object) {
                    this._childrenByName = Object.create(null);
                    _super.prototype.initAVM1SymbolInstance.call(this, context, as3Object);
                    this._initEventsHandlers();
                };
                AVM1MovieClip.prototype._lookupChildByName = function (name) {
                    release || assert(AVM1.alIsName(this.context, name));
                    return this._childrenByName[name];
                };
                AVM1MovieClip.prototype._lookupChildInAS3Object = function (name) {
                    var lookupOptions = 2    /* INCLUDE_NON_INITIALIZED */;
                    if (!this.context.isPropertyCaseSensitive) {
                        lookupOptions |= 1    /* IGNORE_CASE */;
                    }
                    var as3Child = this._as3Object._lookupChildByName(name, lookupOptions);
                    return Lib.getAVM1Object(as3Child, this.context);
                };
                Object.defineProperty(AVM1MovieClip.prototype, '__targetPath', {
                    get: function () {
                        var target = this.get_target();
                        var as3Root = this._as3Object.root;
                        release || Shumway.Debug.assert(as3Root);
                        var level = this.context.levelsContainer._getLevelForRoot(as3Root);
                        release || Shumway.Debug.assert(level >= 0);
                        var prefix = '_level' + level;
                        return target != '/' ? prefix + target.replace(/\//g, '.') : prefix;
                    },
                    enumerable: true,
                    configurable: true
                });
                AVM1MovieClip.prototype.attachAudio = function (id) {
                    if (Shumway.isNullOrUndefined(id)) {
                        return;    // ignoring all undefined objects, probably nothing to attach
                    }
                    if (id === false) {
                        return;    // TODO stop playing all attached audio source (when implemented).
                    }
                    // TODO implement NetStream and Microphone objects to make this work.
                    Shumway.Debug.notImplemented('AVM1MovieClip.attachAudio');
                };
                AVM1MovieClip.prototype.attachBitmap = function (bmp, depth, pixelSnapping, smoothing) {
                    if (pixelSnapping === void 0) {
                        pixelSnapping = 'auto';
                    }
                    if (smoothing === void 0) {
                        smoothing = false;
                    }
                    pixelSnapping = AVM1.alCoerceString(this.context, pixelSnapping);
                    smoothing = AVM1.alToBoolean(this.context, smoothing);
                    var as3BitmapData = bmp.as3BitmapData;
                    var bitmap = this.context.sec.flash.display.Bitmap.axClass.axConstruct([
                        as3BitmapData,
                        pixelSnapping,
                        smoothing
                    ]);
                    this._insertChildAtDepth(bitmap, depth);
                };
                AVM1MovieClip.prototype._constructMovieClipSymbol = function (symbolId, name) {
                    symbolId = AVM1.alToString(this.context, symbolId);
                    name = AVM1.alToString(this.context, name);
                    var symbol = this.context.getAsset(symbolId);
                    if (!symbol) {
                        return undefined;
                    }
                    var props = Object.create(symbol.symbolProps);
                    props.avm1Name = name;
                    var mc;
                    mc = Shumway.AVMX.AS.constructClassFromSymbol(props, this.context.sec.flash.display.MovieClip.axClass);
                    return mc;
                };
                AVM1MovieClip.prototype.get$version = function () {
                    return this.context.sec.flash.system.Capabilities.version;
                };
                AVM1MovieClip.prototype.attachMovie = function (symbolId, name, depth, initObject) {
                    var mc = this._constructMovieClipSymbol(symbolId, name);
                    if (!mc) {
                        return undefined;
                    }
                    var as2mc = this._insertChildAtDepth(mc, depth);
                    if (initObject) {
                        as2mc._init(initObject);
                    }
                    return as2mc;
                };
                AVM1MovieClip.prototype.beginFill = function (color, alpha) {
                    if (alpha === void 0) {
                        alpha = 100;
                    }
                    color = AVM1.alToInt32(this.context, color);
                    alpha = AVM1.alToNumber(this.context, alpha);
                    this.graphics.beginFill(color, alpha / 100);
                };
                AVM1MovieClip.prototype.beginBitmapFill = function (bmp, matrix, repeat, smoothing) {
                    if (matrix === void 0) {
                        matrix = null;
                    }
                    if (repeat === void 0) {
                        repeat = false;
                    }
                    if (smoothing === void 0) {
                        smoothing = false;
                    }
                    if (!AVM1.alInstanceOf(this.context, bmp, this.context.globals.BitmapData)) {
                        return;    // skipping operation if first parameter is not a BitmapData.
                    }
                    var bmpNative = Lib.toAS3BitmapData(bmp);
                    var matrixNative = Shumway.isNullOrUndefined(matrix) ? null : Lib.toAS3Matrix(matrix);
                    repeat = AVM1.alToBoolean(this.context, repeat);
                    smoothing = AVM1.alToBoolean(this.context, smoothing);
                    this.graphics.beginBitmapFill(bmpNative, matrixNative, repeat, smoothing);
                };
                AVM1MovieClip.prototype.beginGradientFill = function (fillType, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                    var _this = this;
                    if (spreadMethod === void 0) {
                        spreadMethod = 'pad';
                    }
                    if (interpolationMethod === void 0) {
                        interpolationMethod = 'rgb';
                    }
                    if (focalPointRatio === void 0) {
                        focalPointRatio = 0;
                    }
                    var context = this.context, sec = context.sec;
                    fillType = AVM1.alToString(this.context, fillType);
                    var colorsNative = sec.createArray(AVM1.Natives.AVM1ArrayNative.mapToJSArray(colors, function (item) {
                        return AVM1.alToInt32(_this.context, item);
                    }));
                    var alphasNative = sec.createArray(AVM1.Natives.AVM1ArrayNative.mapToJSArray(alphas, function (item) {
                        return AVM1.alToNumber(_this.context, item) / 100;
                    }));
                    var ratiosNative = sec.createArray(AVM1.Natives.AVM1ArrayNative.mapToJSArray(ratios, function (item) {
                        return AVM1.alToNumber(_this.context, item);
                    }));
                    var matrixNative = null;
                    if (Shumway.isNullOrUndefined(matrix)) {
                        Shumway.Debug.somewhatImplemented('AVM1MovieClip.beginGradientFill');
                    }
                    spreadMethod = AVM1.alToString(this.context, spreadMethod);
                    interpolationMethod = AVM1.alToString(this.context, interpolationMethod);
                    focalPointRatio = AVM1.alToNumber(this.context, focalPointRatio);
                    this.graphics.beginGradientFill(fillType, colorsNative, alphasNative, ratiosNative, matrixNative, spreadMethod, interpolationMethod, focalPointRatio);
                };
                AVM1MovieClip.prototype._callFrame = function (frame) {
                    var nativeAS3Object = this._as3Object;
                    nativeAS3Object._callFrame(frame);
                };
                AVM1MovieClip.prototype.clear = function () {
                    this.graphics.clear();
                };
                AVM1MovieClip.prototype._insertChildAtDepth = function (mc, depth) {
                    var oldChild = this.getInstanceAtDepth(depth);
                    if (oldChild) {
                        var oldAS3Object = oldChild._as3Object;
                        oldAS3Object.parent.removeChild(oldAS3Object);
                    }
                    var symbolDepth = AVM1.alCoerceNumber(this.context, depth) + Lib.DEPTH_OFFSET;
                    var nativeAS3Object = this._as3Object;
                    nativeAS3Object.addTimelineObjectAtDepth(mc, symbolDepth);
                    // Bitmaps aren't reflected in AVM1, so the rest here doesn't apply.
                    if (this.context.sec.flash.display.Bitmap.axIsType(mc)) {
                        return null;
                    }
                    return Lib.getAVM1Object(mc, this.context);
                };
                AVM1MovieClip.prototype._updateChildName = function (child, oldName, newName) {
                    oldName && this._removeChildName(child, oldName);
                    newName && this._addChildName(child, newName);
                };
                AVM1MovieClip.prototype._removeChildName = function (child, name) {
                    release || assert(name);
                    if (!this.context.isPropertyCaseSensitive) {
                        name = name.toLowerCase();
                    }
                    release || assert(this._childrenByName[name]);
                    if (this._childrenByName[name] !== child) {
                        return;
                    }
                    var newChildForName = this._lookupChildInAS3Object(name);
                    if (newChildForName) {
                        this._childrenByName[name] = newChildForName;
                    } else {
                        delete this._childrenByName[name];
                    }
                };
                AVM1MovieClip.prototype._addChildName = function (child, name) {
                    release || assert(name);
                    if (!this.context.isPropertyCaseSensitive) {
                        name = name.toLowerCase();
                    }
                    release || assert(this._childrenByName[name] !== child);
                    var currentChild = this._childrenByName[name];
                    if (!currentChild || currentChild.getDepth() > child.getDepth()) {
                        this._childrenByName[name] = child;
                    }
                };
                AVM1MovieClip.prototype.createEmptyMovieClip = function (name, depth) {
                    name = AVM1.alToString(this.context, name);
                    var mc = new this.context.sec.flash.display.MovieClip();
                    mc.name = name;
                    return this._insertChildAtDepth(mc, depth);
                };
                AVM1MovieClip.prototype.createTextField = function (name, depth, x, y, width, height) {
                    name = AVM1.alToString(this.context, name);
                    var text = new this.context.sec.flash.text.TextField();
                    text.name = name;
                    text.x = x;
                    text.y = y;
                    text.width = width;
                    text.height = height;
                    return this._insertChildAtDepth(text, depth);
                };
                AVM1MovieClip.prototype.get_currentframe = function () {
                    return this._as3Object.currentFrame;
                };
                AVM1MovieClip.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
                    controlX = AVM1.alToNumber(this.context, controlX);
                    controlY = AVM1.alToNumber(this.context, controlY);
                    anchorX = AVM1.alToNumber(this.context, anchorX);
                    anchorY = AVM1.alToNumber(this.context, anchorY);
                    this.graphics.curveTo(controlX, controlY, anchorX, anchorY);
                };
                AVM1MovieClip.prototype.get_droptarget = function () {
                    return this._as3Object.dropTarget;
                };
                AVM1MovieClip.prototype.duplicateMovieClip = function (name, depth, initObject) {
                    name = AVM1.alToString(this.context, name);
                    var parent = this.context.resolveTarget(null);
                    var nativeAS3Object = this._as3Object;
                    var mc;
                    if (nativeAS3Object._symbol) {
                        mc = Shumway.AVMX.AS.constructClassFromSymbol(nativeAS3Object._symbol, nativeAS3Object.axClass);
                    } else {
                        mc = new this.context.sec.flash.display.MovieClip();
                    }
                    mc.name = name;
                    // These are all properties that get copied over when duplicating a movie clip.
                    // Examined by testing.
                    mc.x = nativeAS3Object.x;
                    mc.scaleX = nativeAS3Object.scaleX;
                    mc.y = nativeAS3Object.y;
                    mc.scaleY = nativeAS3Object.scaleY;
                    mc.rotation = nativeAS3Object.rotation;
                    mc.alpha = nativeAS3Object.alpha;
                    mc.blendMode = nativeAS3Object.blendMode;
                    mc.cacheAsBitmap = nativeAS3Object.cacheAsBitmap;
                    mc.opaqueBackground = nativeAS3Object.opaqueBackground;
                    mc.tabChildren = nativeAS3Object.tabChildren;
                    // Not supported yet: _quality, _highquality, _soundbuftime.
                    mc.graphics.copyFrom(nativeAS3Object.graphics);
                    // TODO: Do event listeners get copied?
                    var as2mc = parent._insertChildAtDepth(mc, depth);
                    if (initObject) {
                        as2mc._init(initObject);
                    }
                    return as2mc;
                };
                AVM1MovieClip.prototype.getEnabled = function () {
                    return Lib.getAS3ObjectOrTemplate(this).enabled;
                };
                AVM1MovieClip.prototype.setEnabled = function (value) {
                    Lib.getAS3ObjectOrTemplate(this).enabled = value;
                };
                AVM1MovieClip.prototype.endFill = function () {
                    this.graphics.endFill();
                };
                AVM1MovieClip.prototype.getForceSmoothing = function () {
                    Shumway.Debug.somewhatImplemented('AVM1MovieClip.getForceSmoothing');
                    return false;
                };
                AVM1MovieClip.prototype.setForceSmoothing = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    Shumway.Debug.somewhatImplemented('AVM1MovieClip.setForceSmoothing');
                };
                AVM1MovieClip.prototype.get_framesloaded = function () {
                    return this._as3Object.framesLoaded;
                };
                AVM1MovieClip.prototype.getBounds = function (bounds) {
                    var obj = Lib.getAS3Object(bounds);
                    if (!obj) {
                        return undefined;
                    }
                    return convertAS3RectangeToBounds(this._as3Object.getBounds(obj));
                };
                AVM1MovieClip.prototype.getBytesLoaded = function () {
                    var loaderInfo = this._as3Object.loaderInfo;
                    return loaderInfo.bytesLoaded;
                };
                AVM1MovieClip.prototype.getBytesTotal = function () {
                    var loaderInfo = this._as3Object.loaderInfo;
                    return loaderInfo.bytesTotal;
                };
                AVM1MovieClip.prototype.getInstanceAtDepth = function (depth) {
                    var symbolDepth = AVM1.alCoerceNumber(this.context, depth) + Lib.DEPTH_OFFSET;
                    var nativeObject = this._as3Object;
                    var lookupChildOptions = 2    /* INCLUDE_NON_INITIALIZED */;
                    for (var i = 0, numChildren = nativeObject.numChildren; i < numChildren; i++) {
                        var child = nativeObject._lookupChildByIndex(i, lookupChildOptions);
                        // child is null if it hasn't been constructed yet. This can happen in InitActionBlocks.
                        if (child && child._depth === symbolDepth) {
                            // Somewhat absurdly, this method returns the mc if a bitmap is at the given depth.
                            if (this.context.sec.flash.display.Bitmap.axIsType(child)) {
                                return this;
                            }
                            return Lib.getAVM1Object(child, this.context);
                        }
                    }
                    return undefined;
                };
                AVM1MovieClip.prototype.getNextHighestDepth = function () {
                    var nativeObject = this._as3Object;
                    var maxDepth = Lib.DEPTH_OFFSET;
                    var lookupChildOptions = 2    /* INCLUDE_NON_INITIALIZED */;
                    for (var i = 0, numChildren = nativeObject.numChildren; i < numChildren; i++) {
                        var child = nativeObject._lookupChildByIndex(i, lookupChildOptions);
                        if (child._depth >= maxDepth) {
                            maxDepth = child._depth + 1;
                        }
                    }
                    return maxDepth - Lib.DEPTH_OFFSET;
                };
                AVM1MovieClip.prototype.getRect = function (bounds) {
                    var obj = Lib.getAS3Object(bounds);
                    if (!obj) {
                        return undefined;
                    }
                    return convertAS3RectangeToBounds(this._as3Object.getRect(obj));
                };
                AVM1MovieClip.prototype.getSWFVersion = function () {
                    var loaderInfo = this._as3Object.loaderInfo;
                    return loaderInfo.swfVersion;
                };
                AVM1MovieClip.prototype.getTextSnapshot = function () {
                    Shumway.Debug.notImplemented('AVM1MovieClip.getTextSnapshot');
                };
                AVM1MovieClip.prototype.getURL = function (url, window, method) {
                    var request = new this.context.sec.flash.net.URLRequest(url);
                    if (method) {
                        request.method = method;
                    }
                    Shumway.AVMX.AS.FlashNetScript_navigateToURL(request, window);
                };
                AVM1MovieClip.prototype.globalToLocal = function (pt) {
                    var tmp = this._as3Object.globalToLocal(Lib.toAS3Point(pt));
                    Lib.copyAS3PointTo(tmp, pt);
                };
                AVM1MovieClip.prototype.gotoAndPlay = function (frame) {
                    this._as3Object.gotoAndPlay(frame);
                };
                AVM1MovieClip.prototype.gotoAndStop = function (frame) {
                    this._as3Object.gotoAndStop(frame);
                };
                AVM1MovieClip.prototype.getHitArea = function () {
                    return this._hitArea;
                };
                AVM1MovieClip.prototype.setHitArea = function (value) {
                    // The hitArea getter always returns exactly the value set here, so we have to store that.
                    this._hitArea = value;
                    var obj = value ? Lib.getAS3Object(value) : null;
                    // If the passed-in value isn't a MovieClip, reset the hitArea.
                    if (!this.context.sec.flash.display.MovieClip.axIsType(obj)) {
                        obj = null;
                    }
                    this._as3Object.hitArea = obj;
                };
                AVM1MovieClip.prototype.hitTest = function (x, y, shapeFlag) {
                    if (arguments.length <= 1) {
                        // Alternative method signature: hitTest(target: AVM1Object): boolean
                        var target = arguments[0];
                        if (Shumway.isNullOrUndefined(target) || !Lib.hasAS3ObjectReference(target)) {
                            return false;    // target is undefined or not a AVM1 display object, returning false.
                        }
                        return this._as3Object.hitTestObject(Lib.getAS3Object(target));
                    }
                    x = AVM1.alToNumber(this.context, x);
                    y = AVM1.alToNumber(this.context, y);
                    shapeFlag = AVM1.alToBoolean(this.context, shapeFlag);
                    return this._as3Object.hitTestPoint(x, y, shapeFlag);
                };
                AVM1MovieClip.prototype.lineGradientStyle = function (fillType, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
                    var _this = this;
                    if (spreadMethod === void 0) {
                        spreadMethod = 'pad';
                    }
                    if (interpolationMethod === void 0) {
                        interpolationMethod = 'rgb';
                    }
                    if (focalPointRatio === void 0) {
                        focalPointRatio = 0;
                    }
                    var context = this.context, sec = context.sec;
                    fillType = AVM1.alToString(this.context, fillType);
                    var colorsNative = sec.createArray(AVM1.Natives.AVM1ArrayNative.mapToJSArray(colors, function (item) {
                        return AVM1.alToInt32(_this.context, item);
                    }));
                    var alphasNative = sec.createArray(AVM1.Natives.AVM1ArrayNative.mapToJSArray(alphas, function (item) {
                        return AVM1.alToNumber(_this.context, item) / 100;
                    }));
                    var ratiosNative = sec.createArray(AVM1.Natives.AVM1ArrayNative.mapToJSArray(ratios, function (item) {
                        return AVM1.alToNumber(_this.context, item);
                    }));
                    var matrixNative = null;
                    if (Shumway.isNullOrUndefined(matrix)) {
                        Shumway.Debug.somewhatImplemented('AVM1MovieClip.lineGradientStyle');
                    }
                    spreadMethod = AVM1.alToString(this.context, spreadMethod);
                    interpolationMethod = AVM1.alToString(this.context, interpolationMethod);
                    focalPointRatio = AVM1.alToNumber(this.context, focalPointRatio);
                    this.graphics.lineGradientStyle(fillType, colorsNative, alphasNative, ratiosNative, matrixNative, spreadMethod, interpolationMethod, focalPointRatio);
                };
                AVM1MovieClip.prototype.lineStyle = function (thickness, rgb, alpha, pixelHinting, noScale, capsStyle, jointStyle, miterLimit) {
                    if (thickness === void 0) {
                        thickness = NaN;
                    }
                    if (rgb === void 0) {
                        rgb = 0;
                    }
                    if (alpha === void 0) {
                        alpha = 100;
                    }
                    if (pixelHinting === void 0) {
                        pixelHinting = false;
                    }
                    if (noScale === void 0) {
                        noScale = 'normal';
                    }
                    if (capsStyle === void 0) {
                        capsStyle = 'round';
                    }
                    if (jointStyle === void 0) {
                        jointStyle = 'round';
                    }
                    if (miterLimit === void 0) {
                        miterLimit = 3;
                    }
                    thickness = AVM1.alToNumber(this.context, thickness);
                    rgb = AVM1.alToInt32(this.context, rgb);
                    pixelHinting = AVM1.alToBoolean(this.context, pixelHinting);
                    noScale = AVM1.alToString(this.context, noScale);
                    capsStyle = AVM1.alToString(this.context, capsStyle);
                    jointStyle = AVM1.alToString(this.context, jointStyle);
                    miterLimit = AVM1.alToNumber(this.context, miterLimit);
                    this.graphics.lineStyle(thickness, rgb, alpha / 100, pixelHinting, noScale, capsStyle, jointStyle, miterLimit);
                };
                AVM1MovieClip.prototype.lineTo = function (x, y) {
                    x = AVM1.alToNumber(this.context, x);
                    y = AVM1.alToNumber(this.context, y);
                    this.graphics.lineTo(x, y);
                };
                AVM1MovieClip.prototype.loadMovie = function (url, method) {
                    var loaderHelper = new Lib.AVM1LoaderHelper(this.context);
                    loaderHelper.load(url, method).then(function () {
                        var newChild = loaderHelper.content;
                        // TODO fix newChild name to match target_mc
                        var parent = this._as3Object.parent;
                        var depth = this._as3Object._depth;
                        parent.removeChild(this._as3Object);
                        parent.addTimelineObjectAtDepth(newChild, depth);
                    }.bind(this));
                };
                AVM1MovieClip.prototype.loadVariables = function (url, method) {
                    // REDUX move _loadVariables here?
                    this.context.actions._loadVariables(this, url, method);
                };
                AVM1MovieClip.prototype.localToGlobal = function (pt) {
                    var tmp = this._as3Object.localToGlobal(Lib.toAS3Point(pt));
                    Lib.copyAS3PointTo(tmp, pt);
                };
                AVM1MovieClip.prototype.get_lockroot = function () {
                    return this._lockroot;
                };
                AVM1MovieClip.prototype.set_lockroot = function (value) {
                    Shumway.Debug.somewhatImplemented('AVM1MovieClip._lockroot');
                    this._lockroot = AVM1.alToBoolean(this.context, value);
                };
                AVM1MovieClip.prototype.moveTo = function (x, y) {
                    x = AVM1.alToNumber(this.context, x);
                    y = AVM1.alToNumber(this.context, y);
                    this.graphics.moveTo(x, y);
                };
                AVM1MovieClip.prototype.nextFrame = function () {
                    this._as3Object.nextFrame();
                };
                AVM1MovieClip.prototype.nextScene = function () {
                    this._as3Object.nextScene();
                };
                AVM1MovieClip.prototype.play = function () {
                    this._as3Object.play();
                };
                AVM1MovieClip.prototype.prevFrame = function () {
                    this._as3Object.prevFrame();
                };
                AVM1MovieClip.prototype.prevScene = function () {
                    this._as3Object.prevScene();
                };
                AVM1MovieClip.prototype.removeMovieClip = function () {
                    var as2Parent = this.get_parent();
                    if (!as2Parent) {
                        return;    // let's not remove root symbol
                    }
                    as2Parent._removeChildName(this, this._as3Object.name);
                    as2Parent._as3Object.removeChild(this._as3Object);
                };
                AVM1MovieClip.prototype.setMask = function (mc) {
                    if (mc == null) {
                        // Cancel a mask.
                        this._as3Object.mask = null;
                        return;
                    }
                    var mask = this.context.resolveTarget(mc);
                    if (mask) {
                        this._as3Object.mask = Lib.getAS3Object(mask);
                    }
                };
                AVM1MovieClip.prototype.startDrag = function (lock, left, top, right, bottom) {
                    lock = AVM1.alToBoolean(this.context, lock);
                    var bounds = null;
                    if (arguments.length > 1) {
                        left = AVM1.alToNumber(this.context, left);
                        top = AVM1.alToNumber(this.context, top);
                        right = AVM1.alToNumber(this.context, right);
                        bottom = AVM1.alToNumber(this.context, bottom);
                        bounds = new this.context.sec.flash.geom.Rectangle(left, top, right - left, bottom - top);
                    }
                    this._as3Object.startDrag(lock, bounds);
                };
                AVM1MovieClip.prototype.stop = function () {
                    return this._as3Object.stop();
                };
                AVM1MovieClip.prototype.stopDrag = function () {
                    return this._as3Object.stopDrag();
                };
                AVM1MovieClip.prototype.swapDepths = function (target) {
                    var child1 = this._as3Object;
                    var child2, target_mc;
                    if (typeof target === 'number') {
                        child2 = child1.parent.getTimelineObjectAtDepth(target);
                        if (child2) {
                            // Don't swap if child at depth does not exist.
                            return;
                        }
                        target_mc = Lib.getAVM1Object(child2, this.context);
                    } else {
                        var target_mc = this.context.resolveTarget(target);
                        if (!target_mc) {
                            // Don't swap with non-existent target.
                            return;
                        }
                        child2 = target_mc._as3Object;
                        if (child1.parent !== child2.parent) {
                            return;    // must be the same parent
                        }
                    }
                    child1.parent.swapChildren(child1, child2);
                    var lower;
                    var higher;
                    if (this.getDepth() < target_mc.getDepth()) {
                        lower = this;
                        higher = target_mc;
                    } else {
                        lower = target_mc;
                        higher = this;
                    }
                    var lowerName = Lib.getAS3Object(lower).name;
                    var higherName = Lib.getAS3Object(higher).name;
                    if (this._lookupChildInAS3Object(lowerName) !== lower) {
                        this._removeChildName(lower, lowerName);
                    }
                    if (this._lookupChildInAS3Object(higherName) !== higher) {
                        this._addChildName(higher, higherName);
                    }
                };
                AVM1MovieClip.prototype.getTabChildren = function () {
                    return Lib.getAS3ObjectOrTemplate(this).tabChildren;
                };
                AVM1MovieClip.prototype.setTabChildren = function (value) {
                    Lib.getAS3ObjectOrTemplate(this).tabChildren = AVM1.alToBoolean(this.context, value);
                };
                AVM1MovieClip.prototype.get_totalframes = function () {
                    return this._as3Object.totalFrames;
                };
                AVM1MovieClip.prototype.getTrackAsMenu = function () {
                    return Lib.getAS3ObjectOrTemplate(this).trackAsMenu;
                };
                AVM1MovieClip.prototype.setTrackAsMenu = function (value) {
                    Lib.getAS3ObjectOrTemplate(this).trackAsMenu = AVM1.alToBoolean(this.context, value);
                };
                AVM1MovieClip.prototype.toString = function () {
                    return this.__targetPath;
                };
                AVM1MovieClip.prototype.unloadMovie = function () {
                    var nativeObject = this._as3Object;
                    // TODO remove movie clip content
                    nativeObject.parent.removeChild(nativeObject);
                    nativeObject.stop();
                };
                AVM1MovieClip.prototype.getUseHandCursor = function () {
                    Lib.getAS3ObjectOrTemplate(this).useHandCursor;
                };
                AVM1MovieClip.prototype.setUseHandCursor = function (value) {
                    Lib.getAS3ObjectOrTemplate(this).useHandCursor = value;
                };
                AVM1MovieClip.prototype.setParameters = function (parameters) {
                    for (var paramName in parameters) {
                        if (!this.alHasProperty(paramName)) {
                            this.alPut(paramName, parameters[paramName]);
                        }
                    }
                };
                // Special and children names properties resolutions
                AVM1MovieClip.prototype._resolveLevelNProperty = function (name) {
                    release || assert(AVM1.alIsName(this.context, name));
                    if (name === '_level0') {
                        return this.context.resolveLevel(0);
                    } else if (name === '_root') {
                        return this.context.resolveRoot();
                    } else if (name.indexOf('_level') === 0) {
                        var level = name.substring(6);
                        var levelNum = level | 0;
                        if (levelNum > 0 && level == levelNum) {
                            return this.context.resolveLevel(levelNum);
                        }
                    }
                    return null;
                };
                AVM1MovieClip.prototype._getCachedPropertyResult = function (value) {
                    if (!this._cachedPropertyResult) {
                        this._cachedPropertyResult = {
                            flags: 64    /* DATA */ | 1    /* DONT_ENUM */,
                            value: value
                        };
                    } else {
                        this._cachedPropertyResult.value = value;
                    }
                    return this._cachedPropertyResult;
                };
                AVM1MovieClip.prototype.alGetOwnProperty = function (name) {
                    var desc = _super.prototype.alGetOwnProperty.call(this, name);
                    if (desc) {
                        return desc;
                    }
                    if (name[0] === '_') {
                        if (name[1] === 'l' && name.indexOf('_level') === 0 || name[1] === 'r' && name.indexOf('_root') === 0) {
                            var level = this._resolveLevelNProperty(name);
                            if (level) {
                                return this._getCachedPropertyResult(level);
                            }
                        } else if (name.toLowerCase() in AVM1.MovieClipProperties) {
                            // For MovieClip's properties that start from '_' case does not matter.
                            return _super.prototype.alGetOwnProperty.call(this, name.toLowerCase());
                        }
                    }
                    if (Lib.hasAS3ObjectReference(this)) {
                        var child = this._lookupChildByName(name);
                        if (child) {
                            return this._getCachedPropertyResult(child);
                        }
                    }
                    return undefined;
                };
                AVM1MovieClip.prototype.alGetOwnPropertiesKeys = function () {
                    var keys = _super.prototype.alGetOwnPropertiesKeys.call(this);
                    // if it's a movie listing the children as well
                    if (!Lib.hasAS3ObjectReference(this)) {
                        return keys;    // not initialized yet
                    }
                    var as3MovieClip = this._as3Object;
                    if (as3MovieClip._children.length === 0) {
                        return keys;    // no children
                    }
                    var processed = Object.create(null);
                    for (var i = 0; i < keys.length; i++) {
                        processed[keys[i]] = true;
                    }
                    for (var i = 0, length = as3MovieClip._children.length; i < length; i++) {
                        var child = as3MovieClip._children[i];
                        var name = child.name;
                        var normalizedName = name;
                        // TODO something like this._unescapeProperty(this._escapeProperty(name));
                        processed[normalizedName] = true;
                    }
                    return Object.getOwnPropertyNames(processed);
                };
                AVM1MovieClip.prototype._init = function (initObject) {
                    var _this = this;
                    if (initObject instanceof AVM1.AVM1Object) {
                        AVM1.alForEachProperty(initObject, function (name) {
                            _this.alPut(name, initObject.alGet(name));
                        }, null);
                    }
                };
                AVM1MovieClip.prototype._initEventsHandlers = function () {
                    this.bindEvents([
                        new Lib.AVM1EventHandler('onData', 'data'),
                        new Lib.AVM1EventHandler('onDragOut', 'dragOut'),
                        new Lib.AVM1EventHandler('onDragOver', 'dragOver'),
                        new Lib.AVM1EventHandler('onEnterFrame', 'enterFrame'),
                        new Lib.AVM1EventHandler('onKeyDown', 'keyDown'),
                        new Lib.AVM1EventHandler('onKeyUp', 'keyUp'),
                        new Lib.AVM1EventHandler('onKillFocus', 'focusOut', function (e) {
                            return [e.relatedObject];
                        }),
                        new Lib.AVM1EventHandler('onLoad', 'load'),
                        new Lib.AVM1EventHandler('onMouseDown', 'mouseDown'),
                        new Lib.AVM1EventHandler('onMouseUp', 'mouseUp'),
                        new Lib.AVM1EventHandler('onMouseMove', 'mouseMove'),
                        new AVM1MovieClipButtonModeEvent('onPress', 'mouseDown'),
                        new AVM1MovieClipButtonModeEvent('onRelease', 'mouseUp'),
                        new AVM1MovieClipButtonModeEvent('onReleaseOutside', 'releaseOutside'),
                        new AVM1MovieClipButtonModeEvent('onRollOut', 'mouseOut'),
                        new AVM1MovieClipButtonModeEvent('onRollOver', 'mouseOver'),
                        new Lib.AVM1EventHandler('onSetFocus', 'focusIn', function (e) {
                            return [e.relatedObject];
                        }),
                        new Lib.AVM1EventHandler('onUnload', 'unload')
                    ]);
                };
                return AVM1MovieClip;
            }(Lib.AVM1SymbolBase);
            Lib.AVM1MovieClip = AVM1MovieClip;
            var somewhatImplemented = Shumway.Debug.somewhatImplemented;
            var StateTransitions;
            (function (StateTransitions) {
                StateTransitions[StateTransitions['IdleToOverUp'] = 1] = 'IdleToOverUp';
                StateTransitions[StateTransitions['OverUpToIdle'] = 2] = 'OverUpToIdle';
                StateTransitions[StateTransitions['OverUpToOverDown'] = 4] = 'OverUpToOverDown';
                StateTransitions[StateTransitions['OverDownToOverUp'] = 8] = 'OverDownToOverUp';
                StateTransitions[StateTransitions['OverDownToOutDown'] = 16] = 'OverDownToOutDown';
                StateTransitions[StateTransitions['OutDownToOverDown'] = 32] = 'OutDownToOverDown';
                StateTransitions[StateTransitions['OutDownToIdle'] = 64] = 'OutDownToIdle';
                StateTransitions[StateTransitions['IdleToOverDown'] = 128] = 'IdleToOverDown';
                StateTransitions[StateTransitions['OverDownToIdle'] = 256] = 'OverDownToIdle';    // ???
            }(StateTransitions || (StateTransitions = {})));
            /**
             * Key codes below 32 aren't interpreted as char codes, but are mapped to specific buttons instead.
             * This array uses the key code as the index and KeyboardEvent.keyCode values matching the
             * specific keys as the value.
             * @type {number[]}
             */
            var AVM1KeyCodeMap = [
                -1,
                37,
                39,
                36,
                35,
                45,
                46,
                -1,
                8,
                -1,
                -1,
                -1,
                -1,
                13,
                38,
                40,
                33,
                34,
                9,
                27
            ];
            var AVM1Button = function (_super) {
                __extends(AVM1Button, _super);
                function AVM1Button() {
                    _super.apply(this, arguments);
                }
                AVM1Button.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1Button, [], [
                        '_alpha#',
                        'blendMode#',
                        'cacheAsBitmap#',
                        'enabled#',
                        'filters#',
                        '_focusrect#',
                        'getDepth',
                        '_height#',
                        '_highquality#',
                        'menu#',
                        '_name#',
                        '_parent#',
                        '_quality#',
                        '_rotation#',
                        'scale9Grid#',
                        '_soundbuftime#',
                        'tabEnabled#',
                        'tabIndex#',
                        '_target#',
                        'trackAsMenu#',
                        '_url#',
                        'useHandCursor#',
                        '_visible#',
                        '_width#',
                        '_x#',
                        '_xmouse#',
                        '_xscale#',
                        '_y#',
                        '_ymouse#',
                        '_yscale#'
                    ]);
                };
                AVM1Button.prototype.initAVM1SymbolInstance = function (context, as3Object) {
                    _super.prototype.initAVM1SymbolInstance.call(this, context, as3Object);
                    var nativeButton = this._as3Object;
                    if (!nativeButton._symbol || !nativeButton._symbol.data.buttonActions) {
                        this._initEventsHandlers();
                        return;
                    }
                    nativeButton.buttonMode = true;
                    nativeButton.addEventListener('addedToStage', this._addListeners.bind(this));
                    nativeButton.addEventListener('removedFromStage', this._removeListeners.bind(this));
                    var requiredListeners = this._requiredListeners = Object.create(null);
                    var actions = this._actions = nativeButton._symbol.data.buttonActions;
                    for (var i = 0; i < actions.length; i++) {
                        var action = actions[i];
                        if (!action.actionsBlock) {
                            action.actionsBlock = context.actionsDataFactory.createActionsData(action.actionsData, 's' + nativeButton._symbol.id + 'e' + i);
                        }
                        if (action.keyCode) {
                            requiredListeners['keyDown'] = this._keyDownHandler.bind(this);
                            continue;
                        }
                        var type;
                        switch (action.stateTransitionFlags) {
                        case StateTransitions.OutDownToIdle:
                            type = 'releaseOutside';
                            break;
                        case StateTransitions.IdleToOverUp:
                            type = 'rollOver';
                            break;
                        case StateTransitions.OverUpToIdle:
                            type = 'rollOut';
                            break;
                        case StateTransitions.OverUpToOverDown:
                            type = 'mouseDown';
                            break;
                        case StateTransitions.OverDownToOverUp:
                            type = 'mouseUp';
                            break;
                        case StateTransitions.OverDownToOutDown:
                        case StateTransitions.OutDownToOverDown:
                            somewhatImplemented('AVM1 drag over/out button actions');
                            break;
                        case StateTransitions.IdleToOverDown:
                        case StateTransitions.OverDownToIdle:
                            somewhatImplemented('AVM1 drag trackAsMenu over/out button actions');
                            break;
                        default:
                            context.utils.warn('Unknown AVM1 button action type: ' + action.stateTransitionFlags);
                            continue;
                        }
                        requiredListeners[type] = this._mouseEventHandler.bind(this, action.stateTransitionFlags);
                    }
                    this._initEventsHandlers();
                };
                AVM1Button.prototype.getEnabled = function () {
                    return this._as3Object.enabled;
                };
                AVM1Button.prototype.setEnabled = function (value) {
                    this._as3Object.enabled = AVM1.alToBoolean(this.context, value);
                    ;
                };
                AVM1Button.prototype.getTrackAsMenu = function () {
                    return Lib.getAS3ObjectOrTemplate(this).trackAsMenu;
                };
                AVM1Button.prototype.setTrackAsMenu = function (value) {
                    Lib.getAS3ObjectOrTemplate(this).trackAsMenu = AVM1.alToBoolean(this.context, value);
                };
                AVM1Button.prototype.getUseHandCursor = function () {
                    return Lib.getAS3ObjectOrTemplate(this).useHandCursor;
                };
                AVM1Button.prototype.setUseHandCursor = function (value) {
                    Lib.getAS3ObjectOrTemplate(this).useHandCursor = AVM1.alToBoolean(this.context, value);
                };
                AVM1Button.prototype._addListeners = function () {
                    for (var type in this._requiredListeners) {
                        // on(key) works even if the button doesn't have focus, so we listen on the stage.
                        // TODO: we probably need to filter these events somehow if an AVM1 swf is loaded into
                        // an AVM2 one.
                        var target = type === 'keyDown' ? this._as3Object.stage : this._as3Object;
                        target.addEventListener(type, this._requiredListeners[type]);
                    }
                };
                AVM1Button.prototype._removeListeners = function () {
                    for (var type in this._requiredListeners) {
                        var target = type === 'keyDown' ? this._as3Object.stage : this._as3Object;
                        target.removeEventListener(type, this._requiredListeners[type]);
                    }
                };
                AVM1Button.prototype._keyDownHandler = function (event) {
                    var actions = this._actions;
                    for (var i = 0; i < actions.length; i++) {
                        var action = actions[i];
                        if (!action.keyCode) {
                            continue;
                        }
                        if (action.keyCode < 32 && AVM1KeyCodeMap[action.keyCode] === event.axGetPublicProperty('keyCode') || action.keyCode === event.axGetPublicProperty('charCode')) {
                            this._runAction(action);
                        }
                    }
                };
                AVM1Button.prototype._mouseEventHandler = function (type) {
                    var actions = this._actions;
                    for (var i = 0; i < actions.length; i++) {
                        var action = actions[i];
                        if (action.stateTransitionFlags === type) {
                            this._runAction(action);
                        }
                    }
                };
                AVM1Button.prototype._runAction = function (action) {
                    var avm1Context = this._as3Object.loaderInfo._avm1Context;
                    avm1Context.executeActions(action.actionsBlock, Lib.getAVM1Object(this._as3Object._parent, this.context));
                };
                AVM1Button.prototype._initEventsHandlers = function () {
                    this.bindEvents([
                        new Lib.AVM1EventHandler('onDragOut', 'dragOut'),
                        new Lib.AVM1EventHandler('onDragOver', 'dragOver'),
                        new Lib.AVM1EventHandler('onKeyDown', 'keyDown'),
                        new Lib.AVM1EventHandler('onKeyUp', 'keyUp'),
                        new Lib.AVM1EventHandler('onKillFocus', 'focusOut', function (e) {
                            return [e.relatedObject];
                        }),
                        new Lib.AVM1EventHandler('onLoad', 'load'),
                        new Lib.AVM1EventHandler('onMouseDown', 'mouseDown'),
                        new Lib.AVM1EventHandler('onMouseUp', 'mouseUp'),
                        new Lib.AVM1EventHandler('onPress', 'mouseDown'),
                        new Lib.AVM1EventHandler('onRelease', 'mouseUp'),
                        new Lib.AVM1EventHandler('onReleaseOutside', 'releaseOutside'),
                        new Lib.AVM1EventHandler('onRollOut', 'mouseOut'),
                        new Lib.AVM1EventHandler('onRollOver', 'mouseOver'),
                        new Lib.AVM1EventHandler('onSetFocus', 'focusIn', function (e) {
                            return [e.relatedObject];
                        })
                    ]);
                };
                return AVM1Button;
            }(Lib.AVM1SymbolBase);
            Lib.AVM1Button = AVM1Button;
            var AVM1TextField = function (_super) {
                __extends(AVM1TextField, _super);
                function AVM1TextField() {
                    _super.apply(this, arguments);
                }
                AVM1TextField.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1TextField, [], [
                        '_alpha#',
                        'antiAliasType#',
                        'autoSize#',
                        'background#',
                        'backgroundColor#',
                        'border#',
                        'borderColor#',
                        'bottomScroll#',
                        'condenseWhite#',
                        'embedFonts#',
                        'filters#',
                        'getNewTextFormat',
                        'getTextFormat',
                        'gridFitType#',
                        'getDepth',
                        '_height#',
                        '_highquality#',
                        'hscroll#',
                        'html#',
                        'htmlText#',
                        'length#',
                        'maxChars#',
                        'maxhscroll#',
                        'maxscroll#',
                        'multiline#',
                        '_name#',
                        '_parent#',
                        'password#',
                        '_quality#',
                        '_rotation#',
                        'scroll#',
                        'selectable#',
                        'setNewTextFormat',
                        'setTextFormat',
                        '_soundbuftime#',
                        'tabEnabled#',
                        'tabIndex#',
                        '_target#',
                        'text#',
                        'textColor#',
                        'textHeight#',
                        'textWidth#',
                        'type#',
                        '_url#',
                        'variable#',
                        '_visible#',
                        '_width#',
                        'wordWrap#',
                        '_x#',
                        '_xmouse#',
                        '_xscale#',
                        '_y#',
                        '_ymouse#',
                        '_yscale#'
                    ]);
                };
                AVM1TextField.prototype.initAVM1SymbolInstance = function (context, as3Object) {
                    _super.prototype.initAVM1SymbolInstance.call(this, context, as3Object);
                    this._variable = '';
                    this._html = false;
                    this._exitFrameHandler = null;
                    if (as3Object._symbol) {
                        this.setVariable(as3Object._symbol.variableName || '');
                        this._html = as3Object._symbol.html;
                    }
                    this._initEventsHandlers();
                };
                AVM1TextField.prototype.getAntiAliasType = function () {
                    return this._as3Object.antiAliasType;
                };
                AVM1TextField.prototype.setAntiAliasType = function (value) {
                    value = AVM1.alCoerceString(this.context, value);
                    this._as3Object.antiAliasType = value;
                };
                AVM1TextField.prototype.getAutoSize = function () {
                    return this._as3Object.autoSize;
                };
                AVM1TextField.prototype.setAutoSize = function (value) {
                    // AVM1 treats |true| as "LEFT" and |false| as "NONE".
                    if (value === true) {
                        value = 'left';
                    } else if (value === false) {
                        value = 'none';
                    }
                    value = AVM1.alCoerceString(this.context, value);
                    this._as3Object.autoSize = value;
                };
                AVM1TextField.prototype.getBackground = function () {
                    return this._as3Object.background;
                };
                AVM1TextField.prototype.setBackground = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.background = value;
                };
                AVM1TextField.prototype.getBackgroundColor = function () {
                    return this._as3Object.backgroundColor;
                };
                AVM1TextField.prototype.setBackgroundColor = function (value) {
                    value = AVM1.alToInt32(this.context, value);
                    this._as3Object.backgroundColor = value;
                };
                AVM1TextField.prototype.getBorder = function () {
                    return this._as3Object.border;
                };
                AVM1TextField.prototype.setBorder = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.border = value;
                };
                AVM1TextField.prototype.getBorderColor = function () {
                    return this._as3Object.borderColor;
                };
                AVM1TextField.prototype.setBorderColor = function (value) {
                    value = AVM1.alToInt32(this.context, value);
                    this._as3Object.borderColor = value;
                };
                AVM1TextField.prototype.getBottomScroll = function () {
                    return this._as3Object.bottomScrollV;
                };
                AVM1TextField.prototype.getCondenseWhite = function () {
                    return this._as3Object.condenseWhite;
                };
                AVM1TextField.prototype.setCondenseWhite = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.condenseWhite = value;
                };
                AVM1TextField.prototype.getEmbedFonts = function () {
                    return this._as3Object.embedFonts;
                };
                AVM1TextField.prototype.setEmbedFonts = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.embedFonts = value;
                };
                AVM1TextField.prototype.getNewTextFormat = function () {
                    return Lib.AVM1TextFormat.createFromNative(this.context, this._as3Object.defaultTextFormat);
                };
                AVM1TextField.prototype.getTextFormat = function (beginIndex, endIndex) {
                    if (beginIndex === void 0) {
                        beginIndex = -1;
                    }
                    if (endIndex === void 0) {
                        endIndex = -1;
                    }
                    beginIndex = AVM1.alToInteger(this.context, beginIndex);
                    endIndex = AVM1.alToInteger(this.context, endIndex);
                    var as3TextFormat = this._as3Object.getTextFormat(beginIndex, endIndex);
                    return Lib.AVM1TextFormat.createFromNative(this.context, as3TextFormat);
                };
                AVM1TextField.prototype.getGridFitType = function () {
                    return this._as3Object.gridFitType;
                };
                AVM1TextField.prototype.setGridFitType = function (value) {
                    value = AVM1.alCoerceString(this.context, value);
                    this._as3Object.gridFitType = value;
                };
                AVM1TextField.prototype.getHscroll = function () {
                    return this._as3Object.scrollH;
                };
                AVM1TextField.prototype.setHscroll = function (value) {
                    value = AVM1.alCoerceNumber(this.context, value);
                    this._as3Object.scrollH = value;
                };
                AVM1TextField.prototype.getHtml = function () {
                    return this._html;
                };
                AVM1TextField.prototype.setHtml = function (value) {
                    this._html = !!value;    // Flash doesn't update the displayed text at this point, but the return
                                             // value of `TextField#htmlText` is as though `TextField#htmlText = TextField#text` had
                                             // also been called. For now, we ignore that.
                };
                AVM1TextField.prototype.getHtmlText = function () {
                    return this._html ? this._as3Object.htmlText : this._as3Object.text;
                };
                AVM1TextField.prototype.setHtmlText = function (value) {
                    // alToString turns `undefined` into an empty string, but we really do want "undefined" here.
                    value = value === undefined ? 'undefined' : AVM1.alToString(this.context, value);
                    if (this._html) {
                        this._as3Object.htmlText = value;
                    } else {
                        this._as3Object.text = value;
                    }
                };
                AVM1TextField.prototype.getLength = function () {
                    return this._as3Object.length;
                };
                AVM1TextField.prototype.getMaxChars = function () {
                    return this._as3Object.maxChars;
                };
                AVM1TextField.prototype.setMaxChars = function (value) {
                    value = AVM1.alCoerceNumber(this.context, value);
                    this._as3Object.maxChars = value;
                };
                AVM1TextField.prototype.getMaxhscroll = function () {
                    return this._as3Object.maxScrollH;
                };
                AVM1TextField.prototype.getMaxscroll = function () {
                    return this._as3Object.maxScrollV;
                };
                AVM1TextField.prototype.getMultiline = function () {
                    return this._as3Object.multiline;
                };
                AVM1TextField.prototype.setMultiline = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.multiline = value;
                };
                AVM1TextField.prototype.getPassword = function () {
                    return this._as3Object.displayAsPassword;
                };
                AVM1TextField.prototype.setPassword = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.displayAsPassword = value;
                };
                AVM1TextField.prototype.getScroll = function () {
                    return this._as3Object.scrollV;
                };
                AVM1TextField.prototype.setScroll = function (value) {
                    value = AVM1.alCoerceNumber(this.context, value);
                    this._as3Object.scrollV = value;
                };
                AVM1TextField.prototype.getSelectable = function () {
                    return this._as3Object.selectable;
                };
                AVM1TextField.prototype.setSelectable = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.selectable = value;
                };
                AVM1TextField.prototype.setNewTextFormat = function (value) {
                    var as3TextFormat;
                    if (value instanceof Lib.AVM1TextFormat) {
                        as3TextFormat = value._as3Object;
                    }
                    this._as3Object.defaultTextFormat = as3TextFormat;
                };
                AVM1TextField.prototype.setTextFormat = function () {
                    var beginIndex = -1, endIndex = -1, tf;
                    switch (arguments.length) {
                    case 0:
                        return;
                    // invalid amount of arguments
                    case 1:
                        tf = arguments[0];
                        break;
                    case 2:
                        beginIndex = AVM1.alToNumber(this.context, arguments[0]);
                        tf = arguments[1];
                        break;
                    default:
                        beginIndex = AVM1.alToNumber(this.context, arguments[0]);
                        endIndex = AVM1.alToNumber(this.context, arguments[1]);
                        tf = arguments[2];
                        break;
                    }
                    var as3TextFormat;
                    if (tf instanceof Lib.AVM1TextFormat) {
                        as3TextFormat = tf._as3Object;
                    }
                    this._as3Object.setTextFormat(as3TextFormat, beginIndex, endIndex);
                };
                AVM1TextField.prototype.getText = function () {
                    return this._as3Object.text;
                };
                AVM1TextField.prototype.setText = function (value) {
                    // alToString turns `undefined` into an empty string, but we really do want "undefined" here.
                    value = value === undefined ? 'undefined' : AVM1.alToString(this.context, value);
                    this._as3Object.text = value;
                };
                AVM1TextField.prototype.getTextColor = function () {
                    return this._as3Object.textColor;
                };
                AVM1TextField.prototype.setTextColor = function (value) {
                    value = AVM1.alToInt32(this.context, value);
                    this._as3Object.textColor = value;
                };
                AVM1TextField.prototype.getTextHeight = function () {
                    return this._as3Object.textHeight;
                };
                AVM1TextField.prototype.setTextHeight = function (value) {
                    Shumway.Debug.notImplemented('AVM1TextField.setTextHeight');
                };
                AVM1TextField.prototype.getTextWidth = function () {
                    return this._as3Object.textWidth;
                };
                AVM1TextField.prototype.setTextWidth = function (value) {
                    Shumway.Debug.notImplemented('AVM1TextField.setTextWidth');
                };
                AVM1TextField.prototype.getType = function () {
                    return this._as3Object.type;
                };
                AVM1TextField.prototype.setType = function (value) {
                    value = AVM1.alCoerceString(this.context, value);
                    this._as3Object.type = value;
                };
                AVM1TextField.prototype.getVariable = function () {
                    return this._variable;
                };
                AVM1TextField.prototype.setVariable = function (name) {
                    name = AVM1.alCoerceString(this.context, name);
                    if (name === this._variable) {
                        return;
                    }
                    var instance = this._as3Object;
                    if (this._exitFrameHandler && !name) {
                        instance.removeEventListener('exitFrame', this._exitFrameHandler);
                        this._exitFrameHandler = null;
                    }
                    this._variable = name;
                    if (!this._exitFrameHandler && name) {
                        this._exitFrameHandler = this._onAS3ObjectExitFrame.bind(this);
                        instance.addEventListener('exitFrame', this._exitFrameHandler);
                    }
                };
                AVM1TextField.prototype._onAS3ObjectExitFrame = function () {
                    this._syncTextFieldValue(this._as3Object, this._variable);
                };
                AVM1TextField.prototype._syncTextFieldValue = function (instance, name) {
                    var clip;
                    var hasPath = name.indexOf('.') >= 0 || name.indexOf(':') >= 0;
                    var avm1ContextUtils = this.context.utils;
                    if (hasPath) {
                        var targetPath = name.split(/[.:\/]/g);
                        name = targetPath.pop();
                        if (targetPath[0] == '_root' || targetPath[0] === '') {
                            if (instance.root === null) {
                                return;    // text field is not part of the stage yet
                            }
                            clip = Lib.getAVM1Object(instance.root, this.context);
                            targetPath.shift();
                            if (targetPath[0] === '') {
                                targetPath.shift();
                            }
                        } else {
                            clip = Lib.getAVM1Object(instance._parent, this.context);
                        }
                        while (targetPath.length > 0) {
                            var childName = targetPath.shift();
                            clip = avm1ContextUtils.getProperty(clip, childName);
                            if (!clip) {
                                return;    // cannot find child clip
                            }
                        }
                    } else {
                        clip = Lib.getAVM1Object(instance._parent, this.context);
                    }
                    if (!clip) {
                        avm1ContextUtils.warn('Clip ' + name + ' was not found');
                        return;
                    }
                    // Sets default values as defined in SWF if this property was not found.
                    if (!avm1ContextUtils.hasProperty(clip, name)) {
                        avm1ContextUtils.setProperty(clip, name, instance.text);
                    }
                    instance.text = '' + avm1ContextUtils.getProperty(clip, name);
                };
                AVM1TextField.prototype.getWordWrap = function () {
                    return this._as3Object.wordWrap;
                };
                AVM1TextField.prototype.setWordWrap = function (value) {
                    value = AVM1.alToBoolean(this.context, value);
                    this._as3Object.wordWrap = value;
                };
                AVM1TextField.prototype._initEventsHandlers = function () {
                    this.bindEvents([
                        new Lib.AVM1EventHandler('onDragOut', 'dragOut'),
                        new Lib.AVM1EventHandler('onDragOver', 'dragOver'),
                        new Lib.AVM1EventHandler('onKeyDown', 'keyDown'),
                        new Lib.AVM1EventHandler('onKeyUp', 'keyUp'),
                        new Lib.AVM1EventHandler('onKillFocus', 'focusOut', function (e) {
                            return [e.relatedObject];
                        }),
                        new Lib.AVM1EventHandler('onLoad', 'load'),
                        new Lib.AVM1EventHandler('onMouseDown', 'mouseDown'),
                        new Lib.AVM1EventHandler('onMouseUp', 'mouseUp'),
                        new Lib.AVM1EventHandler('onPress', 'mouseDown'),
                        new Lib.AVM1EventHandler('onRelease', 'mouseUp'),
                        new Lib.AVM1EventHandler('onReleaseOutside', 'releaseOutside'),
                        new Lib.AVM1EventHandler('onRollOut', 'mouseOut'),
                        new Lib.AVM1EventHandler('onRollOver', 'mouseOver'),
                        new Lib.AVM1EventHandler('onSetFocus', 'focusIn', function (e) {
                            return [e.relatedObject];
                        })
                    ]);
                };
                return AVM1TextField;
            }(Lib.AVM1SymbolBase);
            Lib.AVM1TextField = AVM1TextField;
            var AVM1Color = function (_super) {
                __extends(AVM1Color, _super);
                function AVM1Color() {
                    _super.apply(this, arguments);
                }
                AVM1Color.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1Color, [], [
                        'getRGB',
                        'getTransform',
                        'setRGB',
                        'setTransform'
                    ], null, AVM1Color.prototype.avm1Constructor);
                };
                AVM1Color.prototype.avm1Constructor = function (target_mc) {
                    this._target = this.context.resolveTarget(target_mc);
                    this._targetAS3Object = Lib.getAS3Object(this._target);
                };
                AVM1Color.prototype.getRGB = function () {
                    var transform = AVM1Color.prototype.getTransform.call(this);
                    return transform.alGet('rgb');
                };
                AVM1Color.prototype.getTransform = function () {
                    return Lib.AVM1ColorTransform.fromAS3ColorTransform(this.context, this._targetAS3Object.transform.colorTransform);
                };
                AVM1Color.prototype.setRGB = function (offset) {
                    var transform = AVM1Color.prototype.getTransform.call(this);
                    transform.alPut('rgb', offset);
                    AVM1Color.prototype.setTransform.call(this, transform);
                };
                AVM1Color.prototype.setTransform = function (transform) {
                    this._targetAS3Object.transform.colorTransform = Lib.toAS3ColorTransform(transform);
                };
                return AVM1Color;
            }(AVM1.AVM1Object);
            Lib.AVM1Color = AVM1Color;
            function defaultTo(v, defaultValue) {
                return v === undefined ? defaultValue : v;
            }
            function toAS3ColorTransform(v) {
                var context = v.context;
                if (!(v instanceof AVM1.AVM1Object)) {
                    return new context.sec.flash.geom.ColorTransform(1, 1, 1, 1, 0, 0, 0, 0);
                }
                return new context.sec.flash.geom.ColorTransform(AVM1.alCoerceNumber(context, defaultTo(v.alGet('redMultiplier'), 1)), AVM1.alCoerceNumber(context, defaultTo(v.alGet('greenMultiplier'), 1)), AVM1.alCoerceNumber(context, defaultTo(v.alGet('blueMultiplier'), 1)), AVM1.alCoerceNumber(context, defaultTo(v.alGet('alphaMultiplier'), 1)), AVM1.alCoerceNumber(context, defaultTo(v.alGet('redOffset'), 0)), AVM1.alCoerceNumber(context, defaultTo(v.alGet('greenOffset'), 0)), AVM1.alCoerceNumber(context, defaultTo(v.alGet('blueOffset'), 0)), AVM1.alCoerceNumber(context, defaultTo(v.alGet('alphaOffset'), 0)));
            }
            Lib.toAS3ColorTransform = toAS3ColorTransform;
            function copyAS3ColorTransform(t, v) {
                v.alPut('redMultiplier', t.redMultiplier);
                v.alPut('greenMultiplier', t.greenMultiplier);
                v.alPut('blueMultiplier', t.blueMultiplier);
                v.alPut('alphaMultiplier', t.alphaMultiplier);
                v.alPut('redOffset', t.redOffset);
                v.alPut('greenOffset', t.greenOffset);
                v.alPut('blueOffset', t.blueOffset);
                v.alPut('alphaOffset', t.alphaOffset);
            }
            Lib.copyAS3ColorTransform = copyAS3ColorTransform;
            var AVM1ColorTransform = function (_super) {
                __extends(AVM1ColorTransform, _super);
                function AVM1ColorTransform(context, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                    if (redMultiplier === void 0) {
                        redMultiplier = 1;
                    }
                    if (greenMultiplier === void 0) {
                        greenMultiplier = 1;
                    }
                    if (blueMultiplier === void 0) {
                        blueMultiplier = 1;
                    }
                    if (alphaMultiplier === void 0) {
                        alphaMultiplier = 1;
                    }
                    if (redOffset === void 0) {
                        redOffset = 0;
                    }
                    if (greenOffset === void 0) {
                        greenOffset = 0;
                    }
                    if (blueOffset === void 0) {
                        blueOffset = 0;
                    }
                    if (alphaOffset === void 0) {
                        alphaOffset = 0;
                    }
                    _super.call(this, context);
                    this.alPrototype = context.globals.ColorTransform.alGetPrototypeProperty();
                    this.alPut('redMultiplier', redMultiplier);
                    this.alPut('greenMultiplier', greenMultiplier);
                    this.alPut('blueMultiplier', blueMultiplier);
                    this.alPut('alphaMultiplier', alphaMultiplier);
                    this.alPut('redOffset', redOffset);
                    this.alPut('greenOffset', greenOffset);
                    this.alPut('blueOffset', blueOffset);
                    this.alPut('alphaOffset', alphaOffset);
                }
                AVM1ColorTransform.fromAS3ColorTransform = function (context, t) {
                    return new AVM1ColorTransform(context, t.redMultiplier, t.greenMultiplier, t.blueMultiplier, t.alphaMultiplier, t.redOffset, t.greenOffset, t.blueOffset, t.alphaOffset);
                };
                return AVM1ColorTransform;
            }(AVM1.AVM1Object);
            Lib.AVM1ColorTransform = AVM1ColorTransform;
            var AVM1ColorTransformFunction = function (_super) {
                __extends(AVM1ColorTransformFunction, _super);
                function AVM1ColorTransformFunction(context) {
                    _super.call(this, context);
                    AVM1.alDefineObjectProperties(this, { prototype: { value: new AVM1ColorTransformPrototype(context, this) } });
                }
                AVM1ColorTransformFunction.prototype.alConstruct = function (args) {
                    var obj = Object.create(AVM1ColorTransform.prototype);
                    args = args || [];
                    AVM1ColorTransform.apply(obj, [this.context].concat(args));
                    return obj;
                };
                return AVM1ColorTransformFunction;
            }(AVM1.AVM1Function);
            Lib.AVM1ColorTransformFunction = AVM1ColorTransformFunction;
            var AVM1ColorTransformPrototype = function (_super) {
                __extends(AVM1ColorTransformPrototype, _super);
                function AVM1ColorTransformPrototype(context, fn) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        rgb: {
                            get: this.getRgb,
                            set: this.setRgb
                        },
                        concat: {
                            value: this.concat,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        }
                    });
                }
                AVM1ColorTransformPrototype.prototype.getRgb = function () {
                    return toAS3ColorTransform(this).color;
                };
                AVM1ColorTransformPrototype.prototype.setRgb = function (rgb) {
                    var t = toAS3ColorTransform(this);
                    t.color = AVM1.alToInt32(this.context, rgb);
                    copyAS3ColorTransform(t, this);
                };
                AVM1ColorTransformPrototype.prototype.concat = function (second) {
                    var t = toAS3ColorTransform(this);
                    t.concat(toAS3ColorTransform(second));
                    copyAS3ColorTransform(t, this);
                };
                AVM1ColorTransformPrototype.prototype._toString = function () {
                    return toAS3ColorTransform(this).toString();
                };
                return AVM1ColorTransformPrototype;
            }(AVM1.AVM1Object);
            Lib.AVM1ColorTransformPrototype = AVM1ColorTransformPrototype;
            function toAS3Matrix(v) {
                var context = v.context;
                var a, b, c, d, tx, ty;
                if (v instanceof AVM1.AVM1Object) {
                    a = AVM1.alCoerceNumber(context, v.alGet('a'));
                    b = AVM1.alCoerceNumber(context, v.alGet('b'));
                    c = AVM1.alCoerceNumber(context, v.alGet('c'));
                    d = AVM1.alCoerceNumber(context, v.alGet('d'));
                    tx = AVM1.alCoerceNumber(context, v.alGet('tx'));
                    ty = AVM1.alCoerceNumber(context, v.alGet('ty'));
                }
                return new context.sec.flash.geom.Matrix(a, b, c, d, tx, ty);
            }
            Lib.toAS3Matrix = toAS3Matrix;
            function copyAS3MatrixTo(m, v) {
                v.alPut('a', m.a);
                v.alPut('b', m.b);
                v.alPut('c', m.c);
                v.alPut('d', m.d);
                v.alPut('tx', m.tx);
                v.alPut('ty', m.ty);
            }
            Lib.copyAS3MatrixTo = copyAS3MatrixTo;
            var AVM1Matrix = function (_super) {
                __extends(AVM1Matrix, _super);
                function AVM1Matrix(context, a, b, c, d, tx, ty) {
                    if (a === void 0) {
                        a = 1;
                    }
                    if (b === void 0) {
                        b = 0;
                    }
                    if (c === void 0) {
                        c = 0;
                    }
                    if (d === void 0) {
                        d = 1;
                    }
                    if (tx === void 0) {
                        tx = 0;
                    }
                    if (ty === void 0) {
                        ty = 0;
                    }
                    _super.call(this, context);
                    this.alPrototype = context.globals.Matrix.alGetPrototypeProperty();
                    this.alPut('a', a);
                    this.alPut('b', b);
                    this.alPut('c', c);
                    this.alPut('d', d);
                    this.alPut('tx', tx);
                    this.alPut('ty', ty);
                }
                AVM1Matrix.fromAS3Matrix = function (context, m) {
                    return new AVM1Matrix(context, m.a, m.b, m.c, m.d, m.tx, m.ty);
                };
                return AVM1Matrix;
            }(AVM1.AVM1Object);
            Lib.AVM1Matrix = AVM1Matrix;
            var AVM1MatrixFunction = function (_super) {
                __extends(AVM1MatrixFunction, _super);
                function AVM1MatrixFunction(context) {
                    _super.call(this, context);
                    AVM1.alDefineObjectProperties(this, { prototype: { value: new AVM1MatrixPrototype(context, this) } });
                }
                AVM1MatrixFunction.prototype.alConstruct = function (args) {
                    if (args && args.length > 0) {
                        return new AVM1Matrix(this.context, args[0], args[1], args[2], args[3], args[4], args[5]);
                    } else {
                        return new AVM1Matrix(this.context);
                    }
                };
                return AVM1MatrixFunction;
            }(AVM1.AVM1Function);
            Lib.AVM1MatrixFunction = AVM1MatrixFunction;
            var AVM1MatrixPrototype = function (_super) {
                __extends(AVM1MatrixPrototype, _super);
                function AVM1MatrixPrototype(context, fn) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        clone: {
                            value: this.clone,
                            writable: true
                        },
                        concat: {
                            value: this.concat,
                            writable: true
                        },
                        createBox: {
                            value: this.createBox,
                            writable: true
                        },
                        createGradientBox: {
                            value: this.createGradientBox,
                            writable: true
                        },
                        deltaTransformPoint: {
                            value: this.deltaTransformPoint,
                            writable: true
                        },
                        identity: {
                            value: this.identity,
                            writable: true
                        },
                        invert: {
                            value: this.invert,
                            writable: true
                        },
                        rotate: {
                            value: this.rotate,
                            writable: true
                        },
                        scale: {
                            value: this.scale,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        },
                        transformPoint: {
                            value: this.transformPoint,
                            writable: true
                        },
                        translate: {
                            value: this.translate,
                            writable: true
                        }
                    });
                }
                AVM1MatrixPrototype.prototype.clone = function () {
                    var result = new AVM1Matrix(this.context);
                    if (this instanceof AVM1.AVM1Object) {
                        result.alPut('a', this.alGet('a'));
                        result.alPut('b', this.alGet('b'));
                        result.alPut('c', this.alGet('c'));
                        result.alPut('d', this.alGet('d'));
                        result.alPut('tx', this.alGet('tx'));
                        result.alPut('ty', this.alGet('ty'));
                    }
                    return result;
                };
                AVM1MatrixPrototype.prototype.concat = function (other) {
                    var m = toAS3Matrix(this), m2 = toAS3Matrix(other);
                    m.concat(m2);
                    copyAS3MatrixTo(m, this);
                };
                AVM1MatrixPrototype.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
                    if (rotation === void 0) {
                        rotation = 0;
                    }
                    if (tx === void 0) {
                        tx = 0;
                    }
                    if (ty === void 0) {
                        ty = 0;
                    }
                    scaleX = AVM1.alCoerceNumber(this.context, scaleX);
                    scaleY = AVM1.alCoerceNumber(this.context, scaleY);
                    rotation = AVM1.alCoerceNumber(this.context, rotation);
                    tx = AVM1.alCoerceNumber(this.context, tx);
                    ty = AVM1.alCoerceNumber(this.context, ty);
                    var m = toAS3Matrix(this);
                    m.createBox(scaleX, scaleY, rotation, tx, ty);
                    copyAS3MatrixTo(m, this);
                };
                AVM1MatrixPrototype.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
                    if (rotation === void 0) {
                        rotation = 0;
                    }
                    if (tx === void 0) {
                        tx = 0;
                    }
                    if (ty === void 0) {
                        ty = 0;
                    }
                    width = AVM1.alCoerceNumber(this.context, width);
                    height = AVM1.alCoerceNumber(this.context, height);
                    rotation = AVM1.alCoerceNumber(this.context, rotation);
                    tx = AVM1.alCoerceNumber(this.context, tx);
                    ty = AVM1.alCoerceNumber(this.context, ty);
                    var m = toAS3Matrix(this);
                    m.createGradientBox(width, height, rotation, tx, ty);
                    copyAS3MatrixTo(m, this);
                };
                AVM1MatrixPrototype.prototype.deltaTransformPoint = function (pt) {
                    var p = Lib.toAS3Point(pt);
                    var m = toAS3Matrix(this);
                    return Lib.AVM1Point.fromAS3Point(this.context, m.deltaTransformPoint(p));
                };
                AVM1MatrixPrototype.prototype.identity = function () {
                    this.alPut('a', 1);
                    this.alPut('b', 0);
                    this.alPut('c', 0);
                    this.alPut('d', 1);
                    this.alPut('tx', 0);
                    this.alPut('ty', 0);
                };
                AVM1MatrixPrototype.prototype.invert = function () {
                    var m = toAS3Matrix(this);
                    m.invert();
                    copyAS3MatrixTo(m, this);
                };
                AVM1MatrixPrototype.prototype.rotate = function (angle) {
                    angle = AVM1.alCoerceNumber(this.context, angle);
                    var m = toAS3Matrix(this);
                    m.rotate(angle);
                    copyAS3MatrixTo(m, this);
                };
                AVM1MatrixPrototype.prototype.scale = function (sx, sy) {
                    sx = AVM1.alCoerceNumber(this.context, sx);
                    sy = AVM1.alCoerceNumber(this.context, sy);
                    var m = toAS3Matrix(this);
                    m.scale(sx, sy);
                    copyAS3MatrixTo(m, this);
                };
                AVM1MatrixPrototype.prototype._toString = function () {
                    return toAS3Matrix(this).toString();
                };
                AVM1MatrixPrototype.prototype.transformPoint = function (pt) {
                    var p = Lib.toAS3Point(pt);
                    var m = toAS3Matrix(this);
                    return Lib.AVM1Point.fromAS3Point(this.context, m.transformPoint(p));
                };
                AVM1MatrixPrototype.prototype.translate = function (tx, ty) {
                    tx = AVM1.alCoerceNumber(this.context, tx);
                    ty = AVM1.alCoerceNumber(this.context, ty);
                    var m = toAS3Matrix(this);
                    m.translate(tx, ty);
                    copyAS3MatrixTo(m, this);
                };
                return AVM1MatrixPrototype;
            }(AVM1.AVM1Object);
            Lib.AVM1MatrixPrototype = AVM1MatrixPrototype;
            function toAS3Point(v) {
                var context = v.context;
                var x, y;
                if (v instanceof AVM1.AVM1Object) {
                    x = AVM1.alCoerceNumber(context, v.alGet('x'));
                    y = AVM1.alCoerceNumber(context, v.alGet('y'));
                }
                return new context.sec.flash.geom.Point(x, y);
            }
            Lib.toAS3Point = toAS3Point;
            function copyAS3PointTo(p, v) {
                v.alPut('x', p.x);
                v.alPut('y', p.y);
            }
            Lib.copyAS3PointTo = copyAS3PointTo;
            var AVM1Point = function (_super) {
                __extends(AVM1Point, _super);
                function AVM1Point(context, x, y) {
                    _super.call(this, context);
                    this.alPrototype = context.globals.Point.alGetPrototypeProperty();
                    this.alPut('x', x);
                    this.alPut('y', y);
                }
                AVM1Point.fromAS3Point = function (context, p) {
                    return new AVM1Point(context, p.x, p.y);
                };
                return AVM1Point;
            }(AVM1.AVM1Object);
            Lib.AVM1Point = AVM1Point;
            var AVM1PointFunction = function (_super) {
                __extends(AVM1PointFunction, _super);
                function AVM1PointFunction(context) {
                    _super.call(this, context);
                    AVM1.alDefineObjectProperties(this, {
                        prototype: { value: new AVM1PointPrototype(context, this) },
                        distance: {
                            value: this.distance,
                            writable: true
                        },
                        interpolate: {
                            value: this.interpolate,
                            writable: true
                        },
                        polar: {
                            value: this.polar,
                            writable: true
                        }
                    });
                }
                AVM1PointFunction.prototype.alConstruct = function (args) {
                    if (args && args.length > 0) {
                        return new AVM1Point(this.context, args[0], args[1]);
                    } else {
                        return new AVM1Point(this.context, 0, 0);
                    }
                };
                AVM1PointFunction.prototype.distance = function (pt1, pt2) {
                    return this.context.sec.flash.geom.Point.axClass.distance(toAS3Point(pt1), toAS3Point(pt2));
                };
                AVM1PointFunction.prototype.interpolate = function (pt1, pt2, f) {
                    f = AVM1.alToNumber(this.context, f);
                    var p = this.context.sec.flash.geom.Point.axClass.interpolate(toAS3Point(pt1), toAS3Point(pt2), f);
                    return AVM1Point.fromAS3Point(this.context, p);
                };
                AVM1PointFunction.prototype.polar = function (len, angle) {
                    len = AVM1.alToNumber(this.context, len);
                    angle = AVM1.alToNumber(this.context, angle);
                    return AVM1Point.fromAS3Point(this.context, this.context.sec.flash.geom.Point.axClass.polar(len, angle));
                };
                return AVM1PointFunction;
            }(AVM1.AVM1Function);
            Lib.AVM1PointFunction = AVM1PointFunction;
            var AVM1PointPrototype = function (_super) {
                __extends(AVM1PointPrototype, _super);
                function AVM1PointPrototype(context, fn) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        length: { get: this.getLength },
                        add: {
                            value: this.add,
                            writable: true
                        },
                        clone: {
                            value: this.clone,
                            writable: true
                        },
                        equals: {
                            value: this.equals,
                            writable: true
                        },
                        normalize: {
                            value: this.normalize,
                            writable: true
                        },
                        offset: {
                            value: this.offset,
                            writable: true
                        },
                        subtract: {
                            value: this.subtract,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        }
                    });
                }
                AVM1PointPrototype.prototype.getLength = function () {
                    return toAS3Point(this).length;
                };
                AVM1PointPrototype.prototype.add = function (v) {
                    return AVM1Point.fromAS3Point(this.context, toAS3Point(this).add(toAS3Point(v)));
                };
                AVM1PointPrototype.prototype.clone = function () {
                    var result = new AVM1Point(this.context);
                    if (this instanceof AVM1.AVM1Object) {
                        result.alPut('x', this.alGet('x'));
                        result.alPut('y', this.alGet('y'));
                    }
                    return result;
                };
                AVM1PointPrototype.prototype.equals = function (toCompare) {
                    return toAS3Point(this).equals(toAS3Point(toCompare));
                };
                AVM1PointPrototype.prototype.normalize = function (length) {
                    length = AVM1.alToNumber(this.context, length);
                    var p = toAS3Point(this);
                    p.normalize(length);
                    copyAS3PointTo(p, this);
                };
                AVM1PointPrototype.prototype.offset = function (dx, dy) {
                    dx = AVM1.alToNumber(this.context, dx);
                    dy = AVM1.alToNumber(this.context, dy);
                    var p = toAS3Point(this);
                    p.offset(dx, dy);
                    copyAS3PointTo(p, this);
                };
                AVM1PointPrototype.prototype.subtract = function (v) {
                    return AVM1Point.fromAS3Point(this.context, toAS3Point(this).subtract(toAS3Point(v)));
                };
                AVM1PointPrototype.prototype._toString = function () {
                    return '(x=' + this.alGet('x') + ', y=' + this.alGet('y') + ')';
                };
                return AVM1PointPrototype;
            }(AVM1.AVM1Object);
            Lib.AVM1PointPrototype = AVM1PointPrototype;
            function toAS3Rectangle(v) {
                var context = v.context;
                var x, y, width, height;
                if (v instanceof AVM1.AVM1Object) {
                    x = AVM1.alCoerceNumber(context, v.alGet('x'));
                    y = AVM1.alCoerceNumber(context, v.alGet('y'));
                    width = AVM1.alCoerceNumber(context, v.alGet('width'));
                    height = AVM1.alCoerceNumber(context, v.alGet('height'));
                }
                return new context.sec.flash.geom.Rectangle(x, y, width, height);
            }
            Lib.toAS3Rectangle = toAS3Rectangle;
            function copyAS3RectangleTo(r, v) {
                v.alPut('x', r.x);
                v.alPut('y', r.y);
                v.alPut('width', r.width);
                v.alPut('height', r.height);
            }
            Lib.copyAS3RectangleTo = copyAS3RectangleTo;
            var AVM1Rectangle = function (_super) {
                __extends(AVM1Rectangle, _super);
                function AVM1Rectangle(context, x, y, width, height) {
                    _super.call(this, context);
                    this.alPrototype = context.globals.Rectangle.alGetPrototypeProperty();
                    this.alPut('x', x);
                    this.alPut('y', y);
                    this.alPut('width', width);
                    this.alPut('height', height);
                }
                AVM1Rectangle.fromAS3Rectangle = function (context, r) {
                    return new AVM1Rectangle(context, r.x, r.y, r.width, r.height);
                };
                return AVM1Rectangle;
            }(AVM1.AVM1Object);
            Lib.AVM1Rectangle = AVM1Rectangle;
            var AVM1RectangleFunction = function (_super) {
                __extends(AVM1RectangleFunction, _super);
                function AVM1RectangleFunction(context) {
                    _super.call(this, context);
                    AVM1.alDefineObjectProperties(this, { prototype: { value: new AVM1RectanglePrototype(context, this) } });
                }
                AVM1RectangleFunction.prototype.alConstruct = function (args) {
                    if (args && args.length > 0) {
                        return new AVM1Rectangle(this.context, args[0], args[1], args[2], args[3]);
                    } else {
                        return new AVM1Rectangle(this.context, 0, 0, 0, 0);
                    }
                };
                return AVM1RectangleFunction;
            }(AVM1.AVM1Function);
            Lib.AVM1RectangleFunction = AVM1RectangleFunction;
            var AVM1RectanglePrototype = function (_super) {
                __extends(AVM1RectanglePrototype, _super);
                function AVM1RectanglePrototype(context, fn) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        bottom: {
                            get: this.getBottom,
                            set: this.setBottom
                        },
                        bottomRight: {
                            get: this.getBottomRight,
                            set: this.setBottomRight
                        },
                        left: {
                            get: this.getLeft,
                            set: this.setLeft
                        },
                        right: {
                            get: this.getRight,
                            set: this.setRight
                        },
                        size: {
                            get: this.getSize,
                            set: this.setSize
                        },
                        top: {
                            get: this.getTop,
                            set: this.setTop
                        },
                        topLeft: {
                            get: this.getTopLeft,
                            set: this.setTopLeft
                        },
                        clone: {
                            value: this.clone,
                            writable: true
                        },
                        contains: {
                            value: this.contains,
                            writable: true
                        },
                        containsPoint: {
                            value: this.containsPoint,
                            writable: true
                        },
                        containsRectangle: {
                            value: this.containsRectangle,
                            writable: true
                        },
                        equals: {
                            value: this.equals,
                            writable: true
                        },
                        inflate: {
                            value: this.inflate,
                            writable: true
                        },
                        inflatePoint: {
                            value: this.inflatePoint,
                            writable: true
                        },
                        intersection: {
                            value: this.intersection,
                            writable: true
                        },
                        intersects: {
                            value: this.intersects,
                            writable: true
                        },
                        isEmpty: {
                            value: this.isEmpty,
                            writable: true
                        },
                        offset: {
                            value: this.offset,
                            writable: true
                        },
                        offsetPoint: {
                            value: this.offsetPoint,
                            writable: true
                        },
                        setEmpty: {
                            value: this.setEmpty,
                            writable: true
                        },
                        toString: {
                            value: this._toString,
                            writable: true
                        },
                        union: {
                            value: this.union,
                            writable: true
                        }
                    });
                }
                AVM1RectanglePrototype.prototype.getBottom = function () {
                    return AVM1.alToNumber(this.context, this.alGet('y')) + AVM1.alToNumber(this.context, this.alGet('height'));
                };
                AVM1RectanglePrototype.prototype.setBottom = function (value) {
                    this.alPut('height', AVM1.alToNumber(this.context, value) - AVM1.alToNumber(this.context, this.alGet('y')));
                };
                AVM1RectanglePrototype.prototype.getBottomRight = function () {
                    return new Lib.AVM1Point(this.context, AVM1RectanglePrototype.prototype.getRight.call(this), AVM1RectanglePrototype.prototype.getBottom.call(this));
                };
                AVM1RectanglePrototype.prototype.setBottomRight = function (pt) {
                    AVM1RectanglePrototype.prototype.setRight.call(this, pt.alGet('x'));
                    AVM1RectanglePrototype.prototype.setBottom.call(this, pt.alGet('y'));
                };
                AVM1RectanglePrototype.prototype.getLeft = function () {
                    return AVM1.alToNumber(this.context, this.alGet('x'));
                };
                AVM1RectanglePrototype.prototype.setLeft = function (value) {
                    this.alPut('x', AVM1.alToNumber(this.context, value));
                };
                AVM1RectanglePrototype.prototype.getSize = function () {
                    return new Lib.AVM1Point(this.context, this.alGet('width'), this.alGet('height'));
                };
                AVM1RectanglePrototype.prototype.setSize = function (pt) {
                    this.alPut('width', pt.alGet('x'));
                    this.alPut('height', pt.alGet('y'));
                };
                AVM1RectanglePrototype.prototype.getRight = function () {
                    return AVM1.alToNumber(this.context, this.alGet('x')) + AVM1.alToNumber(this.context, this.alGet('width'));
                };
                AVM1RectanglePrototype.prototype.setRight = function (value) {
                    this.alPut('width', AVM1.alToNumber(this.context, value) - AVM1.alToNumber(this.context, this.alGet('x')));
                };
                AVM1RectanglePrototype.prototype.getTop = function () {
                    return AVM1.alToNumber(this.context, this.alGet('y'));
                };
                AVM1RectanglePrototype.prototype.setTop = function (value) {
                    this.alPut('y', AVM1.alToNumber(this.context, value));
                };
                AVM1RectanglePrototype.prototype.getTopLeft = function () {
                    return new Lib.AVM1Point(this.context, AVM1RectanglePrototype.prototype.getLeft.call(this), AVM1RectanglePrototype.prototype.getTop.call(this));
                };
                AVM1RectanglePrototype.prototype.setTopLeft = function (pt) {
                    AVM1RectanglePrototype.prototype.setLeft.call(this, pt.alGet('x'));
                    AVM1RectanglePrototype.prototype.setTop.call(this, pt.alGet('y'));
                };
                AVM1RectanglePrototype.prototype.clone = function () {
                    var result = new AVM1Rectangle(this.context);
                    if (this instanceof AVM1.AVM1Object) {
                        result.alPut('x', this.alGet('x'));
                        result.alPut('y', this.alGet('y'));
                        result.alPut('width', this.alGet('width'));
                        result.alPut('height', this.alGet('height'));
                    }
                    return result;
                };
                AVM1RectanglePrototype.prototype.contains = function (x, y) {
                    x = AVM1.alToNumber(this.context, x);
                    y = AVM1.alToNumber(this.context, y);
                    var r = toAS3Rectangle(this);
                    return r.contains(x, y);
                };
                AVM1RectanglePrototype.prototype.containsPoint = function (pt) {
                    var r = toAS3Rectangle(this), p = Lib.toAS3Point(pt);
                    return r.containsPoint(p);
                };
                AVM1RectanglePrototype.prototype.containsRectangle = function (rect) {
                    var r = toAS3Rectangle(this), other = toAS3Rectangle(rect);
                    return r.containsRect(other);
                };
                AVM1RectanglePrototype.prototype.equals = function (toCompare) {
                    var r = toAS3Rectangle(this), other = toAS3Rectangle(toCompare);
                    return r.equals(other);
                };
                AVM1RectanglePrototype.prototype.inflate = function (dx, dy) {
                    dx = AVM1.alToNumber(this.context, dx);
                    dy = AVM1.alToNumber(this.context, dy);
                    var r = toAS3Rectangle(this);
                    r.inflate(dx, dy);
                    copyAS3RectangleTo(r, this);
                };
                AVM1RectanglePrototype.prototype.inflatePoint = function (pt) {
                    var r = toAS3Rectangle(this), p = Lib.toAS3Point(pt);
                    r.inflatePoint(p);
                    copyAS3RectangleTo(r, this);
                };
                AVM1RectanglePrototype.prototype.intersection = function (toIntersect) {
                    var r = toAS3Rectangle(this), other = toAS3Rectangle(toIntersect);
                    return AVM1Rectangle.fromAS3Rectangle(this.context, r.intersection(other));
                };
                AVM1RectanglePrototype.prototype.intersects = function (toIntersect) {
                    var r = toAS3Rectangle(this), other = toAS3Rectangle(toIntersect);
                    return r.intersects(other);
                };
                AVM1RectanglePrototype.prototype.isEmpty = function () {
                    return toAS3Rectangle(this).isEmpty();
                };
                AVM1RectanglePrototype.prototype.offset = function (dx, dy) {
                    dx = AVM1.alToNumber(this.context, dx);
                    dy = AVM1.alToNumber(this.context, dy);
                    var r = toAS3Rectangle(this);
                    r.offset(dx, dy);
                    copyAS3RectangleTo(r, this);
                };
                AVM1RectanglePrototype.prototype.offsetPoint = function (pt) {
                    var r = toAS3Rectangle(this), p = Lib.toAS3Point(pt);
                    r.offsetPoint(p);
                    copyAS3RectangleTo(r, this);
                };
                AVM1RectanglePrototype.prototype.setEmpty = function () {
                    this.alPut('x', 0);
                    this.alPut('y', 0);
                    this.alPut('width', 0);
                    this.alPut('height', 0);
                };
                AVM1RectanglePrototype.prototype._toString = function () {
                    return '(x=' + this.alGet('x') + ', y=' + this.alGet('y') + ', w=' + this.alGet('width') + ', h=' + this.alGet('height') + ')';
                };
                AVM1RectanglePrototype.prototype.union = function (toUnion) {
                    var r = toAS3Rectangle(this), other = toAS3Rectangle(toUnion);
                    return AVM1Rectangle.fromAS3Rectangle(this.context, r.union(other));
                };
                return AVM1RectanglePrototype;
            }(AVM1.AVM1Object);
            Lib.AVM1RectanglePrototype = AVM1RectanglePrototype;
            var AVM1Transform = function (_super) {
                __extends(AVM1Transform, _super);
                function AVM1Transform() {
                    _super.apply(this, arguments);
                }
                AVM1Transform.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1Transform, [], [
                        'matrix#',
                        'concatenatedMatrix#',
                        'colorTransform#',
                        'pixelBounds#'
                    ], null, AVM1Transform.prototype.avm1Constructor);
                };
                Object.defineProperty(AVM1Transform.prototype, 'as3Transform', {
                    get: function () {
                        return this._targetAS3Object.transform;
                    },
                    enumerable: true,
                    configurable: true
                });
                AVM1Transform.prototype.avm1Constructor = function (target_mc) {
                    this._target = this.context.resolveTarget(target_mc);
                    this._targetAS3Object = Lib.getAS3Object(this._target);
                };
                AVM1Transform.prototype.getMatrix = function () {
                    var transform = this._targetAS3Object.transform;
                    return Lib.AVM1Matrix.fromAS3Matrix(this.context, transform.matrix);
                };
                AVM1Transform.prototype.setMatrix = function (value) {
                    var transform = this._targetAS3Object.transform;
                    transform.matrix = Lib.toAS3Matrix(value);
                };
                AVM1Transform.prototype.getConcatenatedMatrix = function () {
                    var transform = this._targetAS3Object.transform;
                    return Lib.AVM1Matrix.fromAS3Matrix(this.context, transform.concatenatedMatrix);
                };
                AVM1Transform.prototype.getColorTransform = function () {
                    var transform = this._targetAS3Object.transform;
                    return Lib.AVM1ColorTransform.fromAS3ColorTransform(this.context, transform.colorTransform);
                };
                AVM1Transform.prototype.setColorTransform = function (value) {
                    var transform = this._targetAS3Object.transform;
                    transform.colorTransform = Lib.toAS3ColorTransform(value);
                };
                AVM1Transform.prototype.getPixelBounds = function () {
                    var transform = this._targetAS3Object.transform;
                    return Lib.AVM1Rectangle.fromAS3Rectangle(this.context, transform.pixelBounds);
                };
                return AVM1Transform;
            }(AVM1.AVM1Object);
            Lib.AVM1Transform = AVM1Transform;
            var AVM1TextFormat = function (_super) {
                __extends(AVM1TextFormat, _super);
                function AVM1TextFormat() {
                    _super.apply(this, arguments);
                }
                AVM1TextFormat.createAVM1Class = function (context) {
                    var members = [
                        'align#',
                        'blockIndent#',
                        'bold#',
                        'bullet#',
                        'color#',
                        'font#',
                        'getTextExtent',
                        'indent#',
                        'italic#',
                        'kerning#',
                        'leading#',
                        'leftMargin#',
                        'letterSpacing#',
                        'rightMargin#',
                        'size#',
                        'tabStops#',
                        'target#',
                        'underline#',
                        'url#'
                    ];
                    var wrapped = Lib.wrapAVM1NativeClass(context, true, AVM1TextFormat, [], members, null, AVM1TextFormat.prototype.avm1Constructor);
                    var proto = wrapped.alGetPrototypeProperty();
                    members.forEach(function (x) {
                        if (x[x.length - 1] === '#') {
                            x = x.slice(0, -1);
                        }
                        var p = proto.alGetOwnProperty(x);
                        p.flags &= ~1    /* DONT_ENUM */;
                        proto.alSetOwnProperty(x, p);
                    });
                    return wrapped;
                };
                AVM1TextFormat.createFromNative = function (context, as3Object) {
                    var TextFormat = context.globals.TextFormat;
                    var obj = new AVM1TextFormat(context);
                    obj.alPrototype = TextFormat.alGetPrototypeProperty();
                    obj._as3Object = as3Object;
                    return obj;
                };
                AVM1TextFormat.prototype.avm1Constructor = function (font, size, color, bold, italic, underline, url, target, align, leftMargin, rightMargin, indent, leading) {
                    var context = this.context;
                    font = Shumway.isNullOrUndefined(font) ? null : AVM1.alToString(context, font);
                    size = Shumway.isNullOrUndefined(size) ? null : AVM1.alToNumber(context, size);
                    color = Shumway.isNullOrUndefined(color) ? null : AVM1.alToNumber(context, color);
                    bold = Shumway.isNullOrUndefined(bold) ? null : AVM1.alToBoolean(context, bold);
                    italic = Shumway.isNullOrUndefined(italic) ? null : AVM1.alToBoolean(context, italic);
                    underline = Shumway.isNullOrUndefined(underline) ? null : AVM1.alToBoolean(context, underline);
                    url = Shumway.isNullOrUndefined(url) ? null : AVM1.alToString(context, url);
                    target = Shumway.isNullOrUndefined(target) ? null : AVM1.alToString(context, target);
                    align = Shumway.isNullOrUndefined(align) ? null : AVM1.alToString(context, align);
                    leftMargin = Shumway.isNullOrUndefined(leftMargin) ? null : AVM1.alToNumber(context, leftMargin);
                    rightMargin = Shumway.isNullOrUndefined(rightMargin) ? null : AVM1.alToNumber(context, rightMargin);
                    indent = Shumway.isNullOrUndefined(indent) ? null : AVM1.alToNumber(context, indent);
                    leading = Shumway.isNullOrUndefined(leading) ? null : AVM1.alToNumber(context, leading);
                    var as3Object = new this.context.sec.flash.text.TextFormat(font, size, color, bold, italic, underline, url, target, align, leftMargin, rightMargin, indent, leading);
                    this._as3Object = as3Object;
                };
                AVM1TextFormat.alInitStatic = function (context) {
                    // See _measureTextField usage in the getTextExtent() below.
                    var measureTextField = new context.sec.flash.text.TextField();
                    measureTextField.multiline = true;
                    this._measureTextField = measureTextField;
                };
                AVM1TextFormat.prototype.getAlign = function () {
                    return this._as3Object.align;
                };
                AVM1TextFormat.prototype.setAlign = function (value) {
                    this._as3Object.align = AVM1.alToString(this.context, value);
                };
                AVM1TextFormat.prototype.getBlockIndent = function () {
                    return this._as3Object.blockIndent;
                };
                AVM1TextFormat.prototype.setBlockIndent = function (value) {
                    this._as3Object.blockIndent = AVM1.alToNumber(this.context, value);
                };
                AVM1TextFormat.prototype.getBold = function () {
                    return this._as3Object.bold;
                };
                AVM1TextFormat.prototype.setBold = function (value) {
                    this._as3Object.bold = AVM1.alToBoolean(this.context, value);
                };
                AVM1TextFormat.prototype.getBullet = function () {
                    return this._as3Object.bullet;
                };
                AVM1TextFormat.prototype.setBullet = function (value) {
                    this._as3Object.bullet = AVM1.alToBoolean(this.context, value);
                };
                AVM1TextFormat.prototype.getColor = function () {
                    return this._as3Object.color;
                };
                AVM1TextFormat.prototype.setColor = function (value) {
                    this._as3Object.color = AVM1.alToNumber(this.context, value);
                };
                AVM1TextFormat.prototype.getFont = function () {
                    return this._as3Object.font;
                };
                AVM1TextFormat.prototype.setFont = function (value) {
                    this._as3Object.font = AVM1.alToString(this.context, value);
                };
                AVM1TextFormat.prototype.getIndent = function () {
                    return this._as3Object.indent;
                };
                AVM1TextFormat.prototype.setIndent = function (value) {
                    this._as3Object.indent = AVM1.alToNumber(this.context, value);
                };
                AVM1TextFormat.prototype.getItalic = function () {
                    return this._as3Object.italic;
                };
                AVM1TextFormat.prototype.setItalic = function (value) {
                    this._as3Object.italic = AVM1.alToBoolean(this.context, value);
                };
                AVM1TextFormat.prototype.getKerning = function () {
                    return this._as3Object.kerning;
                };
                AVM1TextFormat.prototype.setKerning = function (value) {
                    this._as3Object.kerning = AVM1.alToBoolean(this.context, value);
                };
                AVM1TextFormat.prototype.getLeading = function () {
                    return this._as3Object.leading;
                };
                AVM1TextFormat.prototype.setLeading = function (value) {
                    this._as3Object.leading = AVM1.alToNumber(this.context, value);
                };
                AVM1TextFormat.prototype.getLeftMargin = function () {
                    return this._as3Object.leftMargin;
                };
                AVM1TextFormat.prototype.setLeftMargin = function (value) {
                    this._as3Object.leftMargin = AVM1.alToNumber(this.context, value);
                };
                AVM1TextFormat.prototype.getLetterSpacing = function () {
                    return this._as3Object.letterSpacing;
                };
                AVM1TextFormat.prototype.setLetterSpacing = function (value) {
                    this._as3Object.letterSpacing = AVM1.alToNumber(this.context, value);
                };
                AVM1TextFormat.prototype.getRightMargin = function () {
                    return this._as3Object.rightMargin;
                };
                AVM1TextFormat.prototype.setRightMargin = function (value) {
                    this._as3Object.rightMargin = AVM1.alToNumber(this.context, value);
                };
                AVM1TextFormat.prototype.getSize = function () {
                    return this._as3Object.size;
                };
                AVM1TextFormat.prototype.setSize = function (value) {
                    this._as3Object.size = AVM1.alToNumber(this.context, value);
                };
                AVM1TextFormat.prototype.getTabStops = function () {
                    var tabStops = this._as3Object.tabStops;
                    return tabStops ? tabStops.value : null;
                };
                AVM1TextFormat.prototype.setTabStops = function (value) {
                    if (!(value instanceof AVM1.Natives.AVM1ArrayNative) && !Shumway.isNullOrUndefined(value)) {
                        return;    // TODO
                    }
                    var tabStops = value && this.context.sec.createArray(value);
                    this._as3Object.tabStops = tabStops;
                };
                AVM1TextFormat.prototype.getTarget = function () {
                    return this._as3Object.target;
                };
                AVM1TextFormat.prototype.setTarget = function (value) {
                    this._as3Object.target = AVM1.alToString(this.context, value);
                };
                AVM1TextFormat.prototype.getTextExtent = function (text, width) {
                    text = AVM1.alCoerceString(this.context, text);
                    width = +width;
                    var staticState = this.context.getStaticState(AVM1TextFormat);
                    var measureTextField = staticState._measureTextField;
                    if (!isNaN(width) && width > 0) {
                        measureTextField.width = width + 4;
                        measureTextField.wordWrap = true;
                    } else {
                        measureTextField.wordWrap = false;
                    }
                    measureTextField.defaultTextFormat = this._as3Object;
                    measureTextField.text = text;
                    var result = AVM1.alNewObject(this.context);
                    var textWidth = measureTextField.textWidth;
                    var textHeight = measureTextField.textHeight;
                    result.alPut('width', textWidth);
                    result.alPut('height', textHeight);
                    result.alPut('textFieldWidth', textWidth + 4);
                    result.alPut('textFieldHeight', textHeight + 4);
                    var metrics = measureTextField.getLineMetrics(0);
                    result.alPut('ascent', metrics.axGetPublicProperty('ascent'));
                    result.alPut('descent', metrics.axGetPublicProperty('descent'));
                    return result;
                };
                AVM1TextFormat.prototype.getUnderline = function () {
                    return this._as3Object.underline;
                };
                AVM1TextFormat.prototype.setUnderline = function (value) {
                    this._as3Object.underline = AVM1.alToBoolean(this.context, value);
                };
                AVM1TextFormat.prototype.getUrl = function () {
                    return this._as3Object.url;
                };
                AVM1TextFormat.prototype.setUrl = function (value) {
                    this._as3Object.url = AVM1.alToString(this.context, value);
                };
                return AVM1TextFormat;
            }(AVM1.AVM1Object);
            Lib.AVM1TextFormat = AVM1TextFormat;
            function toAS3BitmapData(as2Object) {
                if (!(as2Object instanceof AVM1BitmapData)) {
                    return null;
                }
                return as2Object.as3BitmapData;
            }
            Lib.toAS3BitmapData = toAS3BitmapData;
            var AVM1BitmapData = function (_super) {
                __extends(AVM1BitmapData, _super);
                function AVM1BitmapData() {
                    _super.apply(this, arguments);
                }
                AVM1BitmapData.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1BitmapData, ['loadBitmap'], [
                        'height#',
                        'rectangle#',
                        'transparent#',
                        'width#',
                        'applyFilter',
                        'clone',
                        'colorTransform',
                        'compare',
                        'copyChannel',
                        'copyPixels',
                        'dispose',
                        'draw',
                        'fillRect',
                        'floodFill',
                        'generateFilterRect',
                        'getColorBoundsRect',
                        'getPixel',
                        'getPixel32',
                        'hitTest',
                        'merge',
                        'noise',
                        'paletteMap',
                        'perlinNoise',
                        'pixelDissolve',
                        'scroll',
                        'setPixel',
                        'setPixel32',
                        'threshold'
                    ], null, AVM1BitmapData.prototype.avm1Constructor);
                };
                Object.defineProperty(AVM1BitmapData.prototype, 'as3BitmapData', {
                    get: function () {
                        return this._as3Object;
                    },
                    enumerable: true,
                    configurable: true
                });
                AVM1BitmapData.prototype.avm1Constructor = function (width, height, transparent, fillColor) {
                    width = AVM1.alToNumber(this.context, width);
                    height = AVM1.alToNumber(this.context, height);
                    transparent = arguments.length < 3 ? true : AVM1.alToBoolean(this.context, transparent);
                    fillColor = arguments.length < 4 ? 4294967295 : AVM1.alToInt32(this.context, fillColor);
                    var as3Object = new this.context.sec.flash.display.BitmapData(width, height, transparent, fillColor);
                    this._as3Object = as3Object;
                };
                AVM1BitmapData.fromAS3BitmapData = function (context, as3Object) {
                    var as2Object = new AVM1BitmapData(context);
                    as2Object.alPrototype = context.globals.BitmapData.alGetPrototypeProperty();
                    as2Object._as3Object = as3Object;
                    return as2Object;
                };
                AVM1BitmapData.loadBitmap = function (context, symbolId) {
                    symbolId = AVM1.alToString(context, symbolId);
                    var symbol = context.getAsset(symbolId);
                    // REDUX verify
                    var symbolClass = symbol.symbolProps.symbolClass;
                    var bitmapClass = context.sec.flash.display.BitmapData.axClass;
                    if (symbol && (bitmapClass === symbolClass || bitmapClass.dPrototype.isPrototypeOf(symbolClass.dPrototype))) {
                        var as3Object = Shumway.AVMX.AS.constructClassFromSymbol(symbol.symbolProps, bitmapClass);
                        var bitmap = new AVM1BitmapData(context);
                        bitmap.alPrototype = context.globals.BitmapData.alGetPrototypeProperty();
                        bitmap._as3Object = as3Object;
                        return bitmap;
                    }
                    return null;
                };
                AVM1BitmapData.prototype.getHeight = function () {
                    return this._as3Object.height;
                };
                AVM1BitmapData.prototype.getRectangle = function () {
                    var rect = this.as3BitmapData;
                    return new Lib.AVM1Rectangle(this.context, 0, 0, rect.width, rect.height);
                };
                AVM1BitmapData.prototype.getTransparent = function () {
                    return this._as3Object.transparent;
                };
                AVM1BitmapData.prototype.getWidth = function () {
                    return this._as3Object.width;
                };
                AVM1BitmapData.prototype.applyFilter = function (sourceBitmap, sourceRect, destPoint, filter) {
                    // TODO handle incorrect arguments
                    var as3BitmapData = sourceBitmap.as3BitmapData;
                    var as3SourceRect = Lib.toAS3Rectangle(sourceRect);
                    var as3DestPoint = Lib.toAS3Point(destPoint);
                    var as3Filter = Lib.convertToAS3Filter(this.context, filter);
                    this.as3BitmapData.applyFilter(as3BitmapData, as3SourceRect, as3DestPoint, as3Filter);
                    return 0;
                };
                AVM1BitmapData.prototype.clone = function () {
                    var bitmap = new AVM1BitmapData(this.context);
                    bitmap.alPrototype = this.context.globals.BitmapData.alGetPrototypeProperty();
                    bitmap._as3Object = this._as3Object.clone();
                    return bitmap;
                };
                AVM1BitmapData.prototype.colorTransform = function (rect, colorTransform) {
                    var as3Rect = Lib.toAS3Rectangle(rect);
                    var as3ColorTransform = Lib.toAS3ColorTransform(colorTransform);
                    this._as3Object.colorTransform(as3Rect, as3ColorTransform);
                };
                AVM1BitmapData.prototype.compare = function (other) {
                    if (!(other instanceof AVM1BitmapData)) {
                        return false;
                    }
                    return this._as3Object.compare(other._as3Object);
                };
                AVM1BitmapData.prototype.copyChannel = function (sourceBitmap, sourceRect, destPoint, sourceChannel, destChannel) {
                    var as3BitmapData = sourceBitmap.as3BitmapData;
                    var as3SourceRect = Lib.toAS3Rectangle(sourceRect);
                    var as3DestPoint = Lib.toAS3Point(destPoint);
                    sourceChannel = AVM1.alCoerceNumber(this.context, sourceChannel);
                    destChannel = AVM1.alCoerceNumber(this.context, destChannel);
                    this.as3BitmapData.copyChannel(as3BitmapData, as3SourceRect, as3DestPoint, sourceChannel, destChannel);
                };
                AVM1BitmapData.prototype.copyPixels = function (sourceBitmap, sourceRect, destPoint, alphaBitmap, alphaPoint, mergeAlpha) {
                    var as3BitmapData = sourceBitmap.as3BitmapData;
                    var as3SourceRect = Lib.toAS3Rectangle(sourceRect);
                    var as3DestPoint = Lib.toAS3Point(destPoint);
                    var as3AlphaData = alphaBitmap ? alphaBitmap.as3BitmapData : null;
                    var as3AlphaPoint = alphaPoint ? Lib.toAS3Point(alphaPoint) : null;
                    mergeAlpha = AVM1.alToBoolean(this.context, mergeAlpha);
                    this.as3BitmapData.copyPixels(as3BitmapData, as3SourceRect, as3DestPoint, as3AlphaData, as3AlphaPoint, mergeAlpha);
                };
                AVM1BitmapData.prototype.dispose = function () {
                    this.as3BitmapData.dispose();
                };
                AVM1BitmapData.prototype.draw = function (source, matrix, colorTransform, blendMode, clipRect, smooth) {
                    var as3BitmapData = source._as3Object;
                    // movies and bitmaps
                    var as3Matrix = matrix ? Lib.toAS3Matrix(matrix) : null;
                    var as3ColorTransform = colorTransform ? Lib.toAS3ColorTransform(colorTransform) : null;
                    var as3ClipRect = clipRect ? Lib.toAS3Rectangle(clipRect) : null;
                    blendMode = typeof blendMode === 'number' ? Lib.BlendModesMap[blendMode] : AVM1.alCoerceString(this.context, blendMode);
                    blendMode = blendMode || null;
                    smooth = AVM1.alToBoolean(this.context, smooth);
                    this.as3BitmapData.draw(as3BitmapData, as3Matrix, as3ColorTransform, blendMode, as3ClipRect, smooth);
                };
                AVM1BitmapData.prototype.fillRect = function (rect, color) {
                    var as3Rect = Lib.toAS3Rectangle(rect);
                    color = AVM1.alToInt32(this.context, color);
                    this.as3BitmapData.fillRect(as3Rect, color);
                };
                AVM1BitmapData.prototype.floodFill = function (x, y, color) {
                    x = AVM1.alCoerceNumber(this.context, x);
                    y = AVM1.alCoerceNumber(this.context, y);
                    color = AVM1.alToInt32(this.context, color);
                    this._as3Object.floodFill(x, y, color);
                };
                AVM1BitmapData.prototype.generateFilterRect = function (sourceRect, filter) {
                    Shumway.Debug.notImplemented('AVM1BitmapData.generateFilterRect');
                    return undefined;
                };
                AVM1BitmapData.prototype.getColorBoundsRect = function (mask, color, findColor) {
                    mask = AVM1.alToInt32(this.context, mask);
                    color = AVM1.alToInt32(this.context, color);
                    findColor = AVM1.alToBoolean(this.context, findColor);
                    var rect = this._as3Object.getColorBoundsRect(mask, color, findColor);
                    return new Lib.AVM1Rectangle(this.context, rect.x, rect.y, rect.width, rect.height);
                };
                AVM1BitmapData.prototype.getPixel = function (x, y) {
                    return this._as3Object.getPixel(x, y);
                };
                AVM1BitmapData.prototype.getPixel32 = function (x, y) {
                    return this._as3Object.getPixel32(x, y);
                };
                AVM1BitmapData.prototype.hitTest = function (firstPoint, firstAlphaThreshold, secondObject, secondBitmapPoint, secondAlphaThreshold) {
                    Shumway.Debug.somewhatImplemented('AVM1BitmapData.hitTest');
                    var as3FirstPoint = Lib.toAS3Point(firstPoint);
                    firstAlphaThreshold = AVM1.alToInt32(this.context, firstAlphaThreshold);
                    // TODO: Check for Rectangle, Point, Bitmap, or BitmapData here. Or whatever AVM1 allows.
                    var as3SecondObject = secondObject._as3Object;
                    // movies and bitmaps
                    if (arguments.length < 4) {
                        return this._as3Object.hitTest(as3FirstPoint, firstAlphaThreshold, as3SecondObject);
                    }
                    var as3SecondBitmapPoint = secondBitmapPoint != null ? Lib.toAS3Point(secondBitmapPoint) : null;
                    if (arguments.length < 4) {
                        return this._as3Object.hitTest(as3FirstPoint, firstAlphaThreshold, as3SecondObject, as3SecondBitmapPoint);
                    }
                    secondAlphaThreshold = AVM1.alToInt32(this.context, secondAlphaThreshold);
                    return this._as3Object.hitTest(as3FirstPoint, firstAlphaThreshold, as3SecondObject, as3SecondBitmapPoint, secondAlphaThreshold);
                };
                AVM1BitmapData.prototype.merge = function (sourceBitmap, sourceRect, destPoint, redMult, greenMult, blueMult, alphaMult) {
                    var as3BitmapData = sourceBitmap.as3BitmapData;
                    var as3SourceRect = Lib.toAS3Rectangle(sourceRect);
                    var as3DestPoint = Lib.toAS3Point(destPoint);
                    redMult = AVM1.alToInt32(this.context, redMult);
                    greenMult = AVM1.alToInt32(this.context, greenMult);
                    blueMult = AVM1.alToInt32(this.context, blueMult);
                    alphaMult = AVM1.alToInt32(this.context, alphaMult);
                    this.as3BitmapData.merge(as3BitmapData, as3SourceRect, as3DestPoint, redMult, greenMult, blueMult, alphaMult);
                };
                AVM1BitmapData.prototype.noise = function (randomSeed, low, high, channelOptions, grayScale) {
                    randomSeed = AVM1.alToInt32(this.context, randomSeed);
                    low = arguments.length < 2 ? 0 : AVM1.alToInt32(this.context, low);
                    high = arguments.length < 3 ? 255 : AVM1.alToInt32(this.context, high);
                    channelOptions = arguments.length < 4 ? 1 | 2 | 4 : AVM1.alToInt32(this.context, channelOptions);
                    grayScale = arguments.length < 5 ? false : AVM1.alToBoolean(this.context, grayScale);
                    this._as3Object.noise(randomSeed, low, high, channelOptions, grayScale);
                };
                AVM1BitmapData.prototype.paletteMap = function (sourceBitmap, sourceRect, destPoint, redArray, greenArray, blueArray, alphaArray) {
                    Shumway.Debug.notImplemented('AVM1BitmapData.paletteMap');
                };
                AVM1BitmapData.prototype.perlinNoise = function (baseX, baseY, numOctaves, randomSeed, stitch, fractalNoise, channelOptions, grayScale, offsets) {
                    var _this = this;
                    baseX = AVM1.alCoerceNumber(this.context, baseX);
                    baseY = AVM1.alCoerceNumber(this.context, baseY);
                    numOctaves = AVM1.alCoerceNumber(this.context, numOctaves);
                    randomSeed = AVM1.alCoerceNumber(this.context, randomSeed);
                    stitch = AVM1.alToBoolean(this.context, stitch);
                    fractalNoise = AVM1.alToBoolean(this.context, fractalNoise);
                    channelOptions = channelOptions === undefined ? 7 : AVM1.alCoerceNumber(this.context, channelOptions);
                    grayScale = AVM1.alToBoolean(this.context, grayScale);
                    var as3Offsets = Shumway.isNullOrUndefined(offsets) ? null : this.context.sec.createArray(AVM1.Natives.AVM1ArrayNative.mapToJSArray(offsets, function (item) {
                        return AVM1.alCoerceNumber(_this.context, item);
                    }, this));
                    this.as3BitmapData.perlinNoise(baseX, baseY, numOctaves, randomSeed, stitch, fractalNoise, channelOptions, grayScale, as3Offsets);
                };
                AVM1BitmapData.prototype.pixelDissolve = function (sourceBitmap, sourceRect, destPoint, randomSeed, numberOfPixels, fillColor) {
                    var as3BitmapData = sourceBitmap.as3BitmapData;
                    var as3SourceRect = Lib.toAS3Rectangle(sourceRect);
                    var as3DestPoint = Lib.toAS3Point(destPoint);
                    randomSeed = arguments.length < 4 ? 0 : AVM1.alToInt32(this.context, randomSeed);
                    numberOfPixels = arguments.length < 5 ? as3SourceRect.width * as3SourceRect.height / 30 : AVM1.alToInt32(this.context, numberOfPixels);
                    fillColor = arguments.length < 6 ? 0 : AVM1.alToInt32(this.context, fillColor);
                    return this.as3BitmapData.pixelDissolve(as3BitmapData, as3SourceRect, as3DestPoint, randomSeed, numberOfPixels, fillColor);
                };
                AVM1BitmapData.prototype.scroll = function (x, y) {
                    x = AVM1.alCoerceNumber(this.context, x);
                    y = AVM1.alCoerceNumber(this.context, y);
                    this._as3Object.scroll(x, y);
                };
                AVM1BitmapData.prototype.setPixel = function (x, y, color) {
                    x = AVM1.alCoerceNumber(this.context, x);
                    y = AVM1.alCoerceNumber(this.context, y);
                    color = AVM1.alToInt32(this.context, color);
                    this._as3Object.setPixel(x, y, color);
                };
                AVM1BitmapData.prototype.setPixel32 = function (x, y, color) {
                    x = AVM1.alCoerceNumber(this.context, x);
                    y = AVM1.alCoerceNumber(this.context, y);
                    color = AVM1.alToInt32(this.context, color);
                    this._as3Object.setPixel32(x, y, color);
                };
                AVM1BitmapData.prototype.threshold = function (sourceBitmap, sourceRect, destPoint, operation, threshold, color, mask, copySource) {
                    var as3BitmapData = sourceBitmap.as3BitmapData;
                    var as3SourceRect = Lib.toAS3Rectangle(sourceRect);
                    var as3DestPoint = Lib.toAS3Point(destPoint);
                    operation = AVM1.alCoerceString(this.context, operation);
                    threshold = AVM1.alToInt32(this.context, threshold);
                    color = arguments.length < 6 ? 0 : AVM1.alToInt32(this.context, color);
                    mask = arguments.length < 7 ? 4294967295 : AVM1.alToInt32(this.context, mask);
                    copySource = arguments.length < 8 ? false : AVM1.alToBoolean(this.context, copySource);
                    return this._as3Object.threshold(as3BitmapData, as3SourceRect, as3DestPoint, operation, threshold, color, mask, copySource);
                };
                return AVM1BitmapData;
            }(AVM1.AVM1Object);
            Lib.AVM1BitmapData = AVM1BitmapData;
            var AVM1ExternalInterface = function (_super) {
                __extends(AVM1ExternalInterface, _super);
                function AVM1ExternalInterface() {
                    _super.apply(this, arguments);
                }
                AVM1ExternalInterface.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1ExternalInterface, [
                        'available#',
                        'addCallback',
                        'call'
                    ], []);
                };
                AVM1ExternalInterface.getAvailable = function (context) {
                    return context.sec.flash.external.ExternalInterface.axClass.available;
                };
                AVM1ExternalInterface.addCallback = function (context, methodName, instance, method) {
                    methodName = AVM1.alCoerceString(context, methodName);
                    if (!AVM1.alIsFunction(method)) {
                        return false;
                    }
                    try {
                        context.sec.flash.external.ExternalInterface.axClass.addCallback(methodName, function () {
                            var args = Array.prototype.slice.call(arguments, 0);
                            var result = context.executeFunction(method, instance, args);
                            return result;
                        });
                        return true;
                    } catch (e) {
                    }
                    return false;
                };
                AVM1ExternalInterface.call = function (context, methodName) {
                    var parameters = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        parameters[_i - 2] = arguments[_i];
                    }
                    var args = [AVM1.alCoerceString(context, methodName)];
                    for (var i = 0; i < parameters.length; i++) {
                        // TODO convert AVM1 objects to AVM2
                        args.push(parameters[i]);
                    }
                    try {
                        var result = context.sec.flash.external.ExternalInterface.axClass.call.apply(context.sec.flash.external.ExternalInterface.axClass, args);
                        // TODO convert AVM2 result to AVM1
                        return result;
                    } catch (e) {
                        return undefined;
                    }
                };
                return AVM1ExternalInterface;
            }(AVM1.AVM1Object);
            Lib.AVM1ExternalInterface = AVM1ExternalInterface;
            var AVM1Sound = function (_super) {
                __extends(AVM1Sound, _super);
                function AVM1Sound() {
                    _super.apply(this, arguments);
                }
                AVM1Sound.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1Sound, [], [
                        'attachSound',
                        'duration#',
                        'getBytesLoaded',
                        'getBytesTotal',
                        'getPan',
                        'setPan',
                        'getTransform',
                        'setTransform',
                        'getVolume',
                        'setVolume',
                        'start',
                        'stop'
                    ], null, AVM1Sound.prototype.avm1Constructor);
                };
                AVM1Sound.prototype.avm1Constructor = function (target_mc) {
                    this._target = this.context.resolveTarget(target_mc);
                    this._sound = null;
                    this._channel = null;
                    this._linkageID = null;
                };
                AVM1Sound.prototype.attachSound = function (id) {
                    var symbol = this.context.getAsset(id);
                    if (!symbol) {
                        return;
                    }
                    var props = Object.create(symbol.symbolProps);
                    var sound = Shumway.AVMX.AS.constructClassFromSymbol(props, this.context.sec.flash.media.Sound.axClass);
                    this._linkageID = id;
                    this._sound = sound;
                };
                AVM1Sound.prototype.loadSound = function (url, isStreaming) {
                };
                AVM1Sound.prototype.getBytesLoaded = function () {
                    return 0;
                };
                AVM1Sound.prototype.getBytesTotal = function () {
                    return 0;
                };
                AVM1Sound.prototype.getDuration = function () {
                    return 0;
                };
                AVM1Sound.prototype.getPan = function () {
                    var transform = this._channel && this._channel.soundTransform;
                    return transform ? transform.axGetPublicProperty('pan') * 100 : 0;
                };
                AVM1Sound.prototype.setPan = function (value) {
                    var transform = this._channel && this._channel.soundTransform;
                    if (transform) {
                        transform.axSetPublicProperty('pan', value / 100);
                        this._channel.soundTransform = transform;
                    }
                };
                AVM1Sound.prototype.getTransform = function () {
                    return null;
                };
                AVM1Sound.prototype.setTransform = function (transformObject) {
                };
                AVM1Sound.prototype.getVolume = function () {
                    var transform = this._channel && this._channel.soundTransform;
                    return transform ? transform.axGetPublicProperty('volume') * 100 : 0;
                };
                AVM1Sound.prototype.setVolume = function (value) {
                    var transform = this._channel && this._channel.soundTransform;
                    if (transform) {
                        transform.axSetPublicProperty('volume', value / 100);
                        this._channel.soundTransform = transform;
                    }
                };
                AVM1Sound.prototype.start = function (secondOffset, loops) {
                    if (!this._sound) {
                        return;
                    }
                    secondOffset = isNaN(secondOffset) || secondOffset < 0 ? 0 : +secondOffset;
                    loops = isNaN(loops) || loops < 1 ? 1 : Math.floor(loops);
                    this._stopSoundChannel();
                    this._channel = this._sound.play(secondOffset, loops - 1);
                };
                AVM1Sound.prototype._stopSoundChannel = function () {
                    if (!this._channel) {
                        return;
                    }
                    this._channel.stop();
                    this._channel = null;
                };
                AVM1Sound.prototype.stop = function (linkageID) {
                    if (!linkageID || linkageID === this._linkageID) {
                        this._stopSoundChannel();
                    }
                };
                return AVM1Sound;
            }(AVM1.AVM1Object);
            Lib.AVM1Sound = AVM1Sound;
            var capabilitiesProperties = [
                'avHardwareDisable',
                'hasAccessibility',
                'hasAudio',
                'hasAudioEncoder',
                'hasEmbeddedVideo',
                'hasIME',
                'hasMP3',
                'hasPrinting',
                'hasScreenBroadcast',
                'hasScreenPlayback',
                'hasStreamingAudio',
                'hasStreamingVideo',
                'hasVideoEncoder',
                'isDebugger',
                'language',
                'localFileReadDisable',
                'manufacturer',
                'os',
                'pixelAspectRatio',
                'playerType',
                'screenColor',
                'screenDPI',
                'screenResolutionX',
                'screenResolutionY',
                'serverString',
                'version'
            ];
            var AVM1Capabilities = function (_super) {
                __extends(AVM1Capabilities, _super);
                function AVM1Capabilities(context) {
                    var _this = this;
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    var as3Capabilities = context.sec.flash.system.Capabilities.axClass;
                    capabilitiesProperties.forEach(function (name) {
                        var getter = {
                            alCall: function () {
                                return as3Capabilities.axGetPublicProperty(name);
                            }
                        };
                        var desc = new AVM1.AVM1PropertyDescriptor(128    /* ACCESSOR */ | 2    /* DONT_DELETE */ | 1    /* DONT_ENUM */, null, getter);
                        _this.alSetOwnProperty(name, desc);
                    }, this);
                }
                return AVM1Capabilities;
            }(AVM1.AVM1Object);
            var AVM1Security = function (_super) {
                __extends(AVM1Security, _super);
                function AVM1Security(context) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        sandboxType: { get: this.getSandboxType },
                        allowDomain: { value: this.allowDomain },
                        allowInsecureDomain: { value: this.allowInsecureDomain },
                        loadPolicyFile: { value: this.loadPolicyFile }
                    });
                }
                AVM1Security.prototype.getSandboxType = function () {
                    return this.context.sec.flash.system.Security.axClass.sandboxType;
                };
                AVM1Security.prototype.allowDomain = function (domain) {
                    domain = AVM1.alCoerceString(this.context, domain);
                    this.context.sec.flash.system.Security.axClass.allowDomain(domain);
                };
                AVM1Security.prototype.allowInsecureDomain = function (domain) {
                    domain = AVM1.alCoerceString(this.context, domain);
                    this.context.sec.flash.system.Security.axClass.allowInsecureDomain(domain);
                };
                AVM1Security.prototype.loadPolicyFile = function (url) {
                    url = AVM1.alCoerceString(this.context, url);
                    this.context.sec.flash.system.Security.axClass.loadPolicyFile(url);
                };
                return AVM1Security;
            }(AVM1.AVM1Object);
            var AVM1System = function (_super) {
                __extends(AVM1System, _super);
                function AVM1System() {
                    _super.apply(this, arguments);
                }
                AVM1System.alInitStatic = function (context) {
                    this._capabilities = new AVM1Capabilities(context);
                    this._security = new AVM1Security(context);
                };
                AVM1System.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, false, AVM1System, [
                        'capabilities#',
                        'security#'
                    ], []);
                };
                AVM1System.getCapabilities = function (context) {
                    var staticState = context.getStaticState(AVM1System);
                    return staticState._capabilities;
                };
                AVM1System.getSecurity = function (context) {
                    var staticState = context.getStaticState(AVM1System);
                    return staticState._security;
                };
                return AVM1System;
            }(AVM1.AVM1Object);
            Lib.AVM1System = AVM1System;
            var AVM1SharedObject = function (_super) {
                __extends(AVM1SharedObject, _super);
                function AVM1SharedObject(context, as3SharedObject) {
                    _super.call(this, context);
                    this.alPrototype = context.globals.SharedObject.alGetPrototypeProperty();
                    this._as3SharedObject = as3SharedObject;
                }
                return AVM1SharedObject;
            }(AVM1.AVM1Object);
            Lib.AVM1SharedObject = AVM1SharedObject;
            var AVM1SharedObjectFunction = function (_super) {
                __extends(AVM1SharedObjectFunction, _super);
                function AVM1SharedObjectFunction(context) {
                    _super.call(this, context);
                    AVM1.alDefineObjectProperties(this, {
                        prototype: { value: new AVM1SharedObjectPrototype(context, this) },
                        getLocal: {
                            value: this.getLocal,
                            writable: true
                        }
                    });
                }
                AVM1SharedObjectFunction.prototype.getLocal = function (name, localPath, secure) {
                    name = AVM1.alCoerceString(this.context, name);
                    localPath = AVM1.alCoerceString(this.context, localPath);
                    secure = AVM1.alToBoolean(this.context, secure);
                    var as3SharedObject = this.context.sec.flash.net.SharedObject.axClass.getLocal(name, localPath, secure);
                    return new AVM1SharedObject(this.context, as3SharedObject);
                };
                return AVM1SharedObjectFunction;
            }(AVM1.AVM1Function);
            Lib.AVM1SharedObjectFunction = AVM1SharedObjectFunction;
            var AVM1SharedObjectPrototype = function (_super) {
                __extends(AVM1SharedObjectPrototype, _super);
                function AVM1SharedObjectPrototype(context, fn) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        data: { get: this.getData },
                        clear: {
                            value: this.clear,
                            writable: true
                        },
                        flush: {
                            value: this.flush,
                            writable: true
                        }
                    });
                }
                AVM1SharedObjectPrototype.prototype.getData = function () {
                    // TODO implement transform from AVM2 -> AVM1 objects
                    Shumway.Debug.somewhatImplemented('AVM1SharedObject.getData');
                    var data = this.__data || (this.__data = AVM1.alNewObject(this.context));
                    return data;
                };
                AVM1SharedObjectPrototype.prototype.clear = function () {
                    this._as3SharedObject.clear();
                };
                AVM1SharedObjectPrototype.prototype.flush = function (minDiskSpace) {
                    minDiskSpace = AVM1.alCoerceNumber(this.context, minDiskSpace);
                    this._as3SharedObject.flush(minDiskSpace);
                    Shumway.Debug.somewhatImplemented('AVM1SharedObject.flush');
                    return false;    // can be a string 'pending' or boolean
                };
                AVM1SharedObjectPrototype.prototype.getSize = function () {
                    Shumway.Debug.somewhatImplemented('AVM1SharedObject.getSize');
                    return this.__data ? 10 : 0;
                };
                AVM1SharedObjectPrototype.prototype.setFps = function (updatesPerSecond) {
                    updatesPerSecond = AVM1.alCoerceNumber(this.context, updatesPerSecond) || 0;
                    this._as3SharedObject.fps = updatesPerSecond;
                    return this._as3SharedObject.fps === updatesPerSecond;
                };
                return AVM1SharedObjectPrototype;
            }(AVM1.AVM1Object);
            Lib.AVM1SharedObjectPrototype = AVM1SharedObjectPrototype;
            var flash = Shumway.AVMX.AS.flash;
            var AVM1MovieClipLoader = function (_super) {
                __extends(AVM1MovieClipLoader, _super);
                function AVM1MovieClipLoader() {
                    _super.apply(this, arguments);
                }
                AVM1MovieClipLoader.createAVM1Class = function (context) {
                    return Lib.wrapAVM1NativeClass(context, true, AVM1MovieClipLoader, [], [
                        'loadClip',
                        'unloadClip',
                        'getProgress'
                    ], null, AVM1MovieClipLoader.prototype.avm1Constructor);
                };
                AVM1MovieClipLoader.prototype.avm1Constructor = function () {
                    Lib.AVM1Broadcaster.initialize(this.context, this);
                };
                AVM1MovieClipLoader.prototype.loadClip = function (url, target) {
                    var loadLevel = typeof target === 'number';
                    var level;
                    var target_mc;
                    if (loadLevel) {
                        level = target;
                        if (level === 0) {
                            release || Shumway.Debug.notImplemented('MovieClipLoader.loadClip at _level0');
                            return false;
                        }
                    } else {
                        target_mc = this.context.resolveTarget(target);
                        if (!target_mc) {
                            return false;    // target was not found -- doing nothing
                        }
                    }
                    var loaderHelper = new Lib.AVM1LoaderHelper(this.context);
                    this._loaderHelper = loaderHelper;
                    this._target = null;
                    var loaderInfo = loaderHelper.loaderInfo;
                    loaderInfo.addEventListener(flash.events.Event.OPEN, this.openHandler.bind(this));
                    loaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, this.progressHandler.bind(this));
                    loaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, this.ioErrorHandler.bind(this));
                    loaderInfo.addEventListener(flash.events.Event.COMPLETE, this.completeHandler.bind(this));
                    loaderInfo.addEventListener(flash.events.Event.INIT, this.initHandler.bind(this));
                    loaderHelper.load(url, null).then(function () {
                        var newChild = loaderHelper.content;
                        this._target = Lib.getAVM1Object(newChild, this.context);
                        if (loadLevel) {
                            var avm1LevelHolder = this.context.levelsContainer;
                            avm1LevelHolder._addRoot(level, newChild);
                        } else {
                            // TODO fix newChild name to match target_mc
                            var parent = target_mc._as3Object.parent;
                            var depth = target_mc._as3Object._depth;
                            parent.removeChild(target_mc._as3Object);
                            parent.addTimelineObjectAtDepth(newChild, depth);
                        }
                    }.bind(this));
                    return true;
                };
                AVM1MovieClipLoader.prototype.unloadClip = function (target) {
                    if (!this._loaderHelper) {
                        return false;    // nothing was loaded by this loader
                    }
                    var loadLevel = typeof target === 'number';
                    var level;
                    var target_mc;
                    var originalLoader = this._loaderHelper.loader;
                    if (loadLevel) {
                        level = target;
                        if (level === 0) {
                            release || Shumway.Debug.notImplemented('MovieClipLoader.unloadClip at _level0');
                            return false;
                        }
                        var avm1LevelHolder = this.context.levelsContainer;
                        if (avm1LevelHolder._getRootForLevel(level) !== originalLoader.content) {
                            return false;    // did not load this root
                        }
                        avm1LevelHolder._removeRoot(level);
                    } else {
                        target_mc = target ? this.context.resolveTarget(target) : undefined;
                        if (!target_mc) {
                            return false;    // target was not found -- doing nothing
                        }
                        if (target_mc._as3Object !== originalLoader.content) {
                            return false;    // did not load this movie clip
                        }
                        target_mc.unloadMovie();
                    }
                    this._target = null;
                    this._loaderHelper = null;
                    // TODO: find out under which conditions unloading a clip can fail
                    return true;
                };
                AVM1MovieClipLoader.prototype.getProgress = function (target) {
                    return this._loaderHelper.loaderInfo.bytesLoaded;
                };
                AVM1MovieClipLoader.prototype._broadcastMessage = function (message, args) {
                    if (args === void 0) {
                        args = null;
                    }
                    Lib.avm1BroadcastEvent(this.context, this, message, args);
                };
                AVM1MovieClipLoader.prototype.openHandler = function (event) {
                    this._broadcastMessage('onLoadStart', [this._target]);
                };
                AVM1MovieClipLoader.prototype.progressHandler = function (event) {
                    this._broadcastMessage('onLoadProgress', [
                        this._target,
                        event.bytesLoaded,
                        event.bytesTotal
                    ]);
                };
                AVM1MovieClipLoader.prototype.ioErrorHandler = function (event) {
                    this._broadcastMessage('onLoadError', [
                        this._target,
                        event.errorID,
                        501
                    ]);
                };
                AVM1MovieClipLoader.prototype.completeHandler = function (event) {
                    this._broadcastMessage('onLoadComplete', [this._target]);
                };
                AVM1MovieClipLoader.prototype.initHandler = function (event) {
                    var exitFrameCallback = function () {
                        targetAS3Object.removeEventListener(flash.events.Event.EXIT_FRAME, exitFrameCallback);
                        this._broadcastMessage('onLoadInit', [this._target]);
                    }.bind(this);
                    // MovieClipLoader's init event is dispatched after all frame scripts of the AVM1 instance
                    // have run for one additional iteration.
                    var targetAS3Object = this._loaderHelper.content;
                    targetAS3Object.addEventListener(flash.events.Event.EXIT_FRAME, exitFrameCallback);
                };
                return AVM1MovieClipLoader;
            }(AVM1.AVM1Object);
            Lib.AVM1MovieClipLoader = AVM1MovieClipLoader;
            // Base class/function for all AVM1 filters.
            var AVM1BitmapFilterFunction = function (_super) {
                __extends(AVM1BitmapFilterFunction, _super);
                function AVM1BitmapFilterFunction(context) {
                    _super.call(this, context);
                    this.alSetOwnPrototypeProperty(new AVM1BitmapFilterPrototype(context, this));
                }
                AVM1BitmapFilterFunction.prototype.alConstruct = function (args) {
                    var obj = new AVM1.AVM1Object(this.context);
                    obj.alPrototype = this.alGetPrototypeProperty();
                    return obj;
                };
                return AVM1BitmapFilterFunction;
            }(AVM1.AVM1Function);
            var AVM1BitmapFilterPrototype = function (_super) {
                __extends(AVM1BitmapFilterPrototype, _super);
                function AVM1BitmapFilterPrototype(context, fn) {
                    _super.call(this, context);
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        clone: {
                            value: this.clone,
                            writable: true
                        }
                    });
                }
                AVM1BitmapFilterPrototype.prototype.clone = function () {
                    var obj = new AVM1.AVM1Object(this.context);
                    obj.alPrototype = this.alGetPrototypeProperty();
                    return obj;
                };
                return AVM1BitmapFilterPrototype;
            }(AVM1.AVM1Object);
            // Automates creation of the AVM1 filter classes.
            function createFilterClass(context, filtersObj, base, name, fields) {
                // Simple constructor for the class function.
                function construct(args) {
                    var as2Object = new AVM1.AVM1Object(context);
                    as2Object.alPrototype = wrappedProto;
                    if (args) {
                        for (var i = 0; i < args.length; i++) {
                            as2Object.alPut(fields[i << 1], args[i]);
                        }
                    }
                    return as2Object;
                }
                function clone() {
                    var as2Object = new AVM1.AVM1Object(context);
                    as2Object.alPrototype = wrappedProto;
                    for (var i = 0; i < fields.length; i += 2) {
                        as2Object.alPut(fields[i], this.alGet(fields[i]));
                    }
                    return as2Object;
                }
                function getAS3Class() {
                    // The AS3 class name shall match
                    return context.sec.flash.filters[name].axClass;
                }
                function toAS3Filter(as2Object) {
                    var as3Object = getAS3Class().axConstruct([]);
                    // Just copying all defined properties.
                    for (var i = 0; i < fields.length; i += 2) {
                        var as2Value = as2Object.alGet(fields[i]);
                        if (as2Value === undefined) {
                            continue;    // skipping undefined
                        }
                        as3Object.axSetPublicProperty(fields[i], convertToAS3Field(context, as2Value, fields[i + 1]));
                    }
                    return as3Object;
                }
                function fromAS3Filter(as3Object) {
                    var as2Object = new AVM1.AVM1Object(context);
                    as2Object.alPrototype = wrappedProto;
                    for (var i = 0; i < fields.length; i += 2) {
                        as2Object.alPut(fields[i], convertFromAS3Field(context, as3Object.axGetPublicProperty(fields[i]), fields[i + 1]));
                    }
                    return as2Object;
                }
                // Creates new prototype object and function for the class.
                var proto = base.alGetPrototypeProperty();
                var wrappedProto = Object.create(AVM1BitmapFilterPrototype.prototype);
                AVM1.AVM1Object.call(wrappedProto, context);
                wrappedProto.alPrototype = proto;
                var wrapped = Object.create(AVM1BitmapFilterFunction.prototype);
                AVM1.AVM1Function.call(wrapped, context);
                wrapped.alSetOwnPrototypeProperty(wrappedProto);
                wrapped.alConstruct = construct;
                AVM1.alDefineObjectProperties(wrappedProto, {
                    constructor: {
                        value: wrapped,
                        writable: true
                    },
                    clone: {
                        value: clone,
                        writable: true
                    }
                });
                // ... and also attaches conversion utility.
                wrappedProto.asFilterConverter = {
                    toAS3Filter: toAS3Filter,
                    fromAS3Filter: fromAS3Filter,
                    getAS3Class: getAS3Class
                };
                filtersObj.alPut(name, wrapped);
            }
            function createFiltersClasses(context) {
                var filters = AVM1.alNewObject(context);
                var base = new AVM1BitmapFilterFunction(context);
                filters.alPut('BitmapFilter', base);
                // TODO make field types non-string
                createFilterClass(context, filters, base, 'BevelFilter', [
                    'distance',
                    'Number',
                    'angle',
                    'Number',
                    'highlightColor',
                    'Number',
                    'highlightAlpha',
                    'Number',
                    'shadowColor',
                    'Number',
                    'shadowAlpha',
                    'Number',
                    'blurX',
                    'Number',
                    'blurY',
                    'Number',
                    'strength',
                    'Number',
                    'quality',
                    'Number',
                    'type',
                    'String',
                    'knockout',
                    'Boolean'
                ]);
                createFilterClass(context, filters, base, 'BlurFilter', [
                    'blurX',
                    'Number',
                    'blurY',
                    'Number',
                    'quality',
                    'Number'
                ]);
                createFilterClass(context, filters, base, 'ColorMatrixFilter', [
                    'matrix',
                    'Numbers'
                ]);
                createFilterClass(context, filters, base, 'ConvolutionFilter', [
                    'matrixX',
                    'Number',
                    'matrixY',
                    'Number',
                    'matrix',
                    'Numbers',
                    'divisor',
                    'Number',
                    'bias',
                    'Number',
                    'preserveAlpha',
                    'Boolean',
                    'clamp',
                    'Boolean',
                    'color',
                    'Number',
                    'alpha',
                    'Number'
                ]);
                createFilterClass(context, filters, base, 'DisplacementMapFilter', [
                    'mapBitmap',
                    'BitmapData',
                    'mapPoint',
                    'Point',
                    'componentX',
                    'Number',
                    'componentY',
                    'Number',
                    'scaleX',
                    'Number',
                    'scaleY',
                    'Number',
                    'mode',
                    'String',
                    'color',
                    'Number',
                    'alpha',
                    'Number'
                ]);
                createFilterClass(context, filters, base, 'DropShadowFilter', [
                    'distance',
                    'Number',
                    'angle',
                    'Number',
                    'color',
                    'Number',
                    'alpha',
                    'Number',
                    'blurX',
                    'Number',
                    'blurY',
                    'Number',
                    'strength',
                    'Number',
                    'quality',
                    'Number',
                    'inner',
                    'Boolean',
                    'knockout',
                    'Boolean',
                    'hideObject',
                    'Boolean'
                ]);
                createFilterClass(context, filters, base, 'GlowFilter', [
                    'color',
                    'Number',
                    'alpha',
                    'Number',
                    'blurX',
                    'Number',
                    'blurY',
                    'Number',
                    'strength',
                    'Number',
                    'quality',
                    'Number',
                    'inner',
                    'Boolean',
                    'knockout',
                    'Boolean'
                ]);
                createFilterClass(context, filters, base, 'GradientBevelFilter', [
                    'distance',
                    'Number',
                    'angle',
                    'Number',
                    'colors',
                    'Numbers',
                    'alphas',
                    'Numbers',
                    'ratios',
                    'Numbers',
                    'blurX',
                    'Number',
                    'blurY',
                    'Number',
                    'strength',
                    'Number',
                    'quality',
                    'Number',
                    'type',
                    'String',
                    'knockout',
                    'Boolean'
                ]);
                createFilterClass(context, filters, base, 'GradientGlowFilter', [
                    'distance',
                    'Number',
                    'angle',
                    'Number',
                    'colors',
                    'Numbers',
                    'alphas',
                    'Numbers',
                    'ratios',
                    'Numbers',
                    'blurX',
                    'Number',
                    'blurY',
                    'Number',
                    'strength',
                    'Number',
                    'quality',
                    'Number',
                    'type',
                    'String',
                    'knockout',
                    'Boolean'
                ]);
                return filters;
            }
            Lib.createFiltersClasses = createFiltersClasses;
            function convertToAS3Field(context, value, type) {
                switch (type) {
                case 'String':
                    return AVM1.alToString(context, value);
                case 'Boolean':
                    return AVM1.alToBoolean(context, value);
                case 'Number':
                    return AVM1.alToNumber(context, value);
                case 'Numbers':
                    var arr = [];
                    if (value) {
                        for (var i = 0, length = value.alGet('length'); i < length; i++) {
                            arr[i] = AVM1.alToNumber(context, value.alGet(i));
                        }
                    }
                    return context.sec.createArray(arr);
                case 'BitmapData':
                    return Lib.toAS3BitmapData(value);
                case 'Point':
                    return Lib.toAS3Point(value);
                default:
                    release || Shumway.Debug.assert(false, 'Unknown convertToAS3Field type: ' + type);
                }
            }
            function convertFromAS3Field(context, value, type) {
                switch (type) {
                case 'String':
                case 'Boolean':
                case 'Number':
                    return value;
                case 'Numbers':
                    var arr = [];
                    if (value) {
                        for (var i = 0, length = value.value.length; i < length; i++) {
                            arr[i] = +value.value[i];
                        }
                    }
                    return new AVM1.Natives.AVM1ArrayNative(context, arr);
                case 'BitmapData':
                    return Lib.AVM1BitmapData.fromAS3BitmapData(context, value);
                case 'Point':
                    return Lib.AVM1Point.fromAS3Point(context, value);
                default:
                    release || Shumway.Debug.assert(false, 'Unknown convertFromAS3Field type: ' + type);
                }
            }
            var knownFilters = [
                'BevelFilter',
                'BlurFilter',
                'ColorMatrixFilter',
                'ConvolutionFilter',
                'DisplacementMapFilter',
                'DropShadowFilter',
                'GlowFilter',
                'GradientBevelFilter',
                'GradientGlowFilter'
            ];
            function convertToAS3Filter(context, as2Filter) {
                var proto = as2Filter ? as2Filter.alPrototype : null;
                while (proto && !proto.asFilterConverter) {
                    proto = proto.alPrototype;
                }
                if (proto) {
                    return proto.asFilterConverter.toAS3Filter(as2Filter);
                }
                return undefined;
            }
            Lib.convertToAS3Filter = convertToAS3Filter;
            function convertToAS3Filters(context, as2Filters) {
                var arr = [];
                if (as2Filters) {
                    for (var i = 0, length = as2Filters.alGet('length'); i < length; i++) {
                        var as3Filter = convertToAS3Filter(context, as2Filters.alGet(i));
                        if (as3Filter) {
                            arr.push(as3Filter);
                        }
                    }
                }
                return context.sec.createArrayUnsafe(arr);
            }
            Lib.convertToAS3Filters = convertToAS3Filters;
            function convertFromAS3Filters(context, as3Filters) {
                var arr = [];
                if (as3Filters) {
                    var classes = context.globals.filters;
                    for (var i = 0, length = as3Filters.axGetPublicProperty('length'); i < length; i++) {
                        var as3Filter = as3Filters.axGetPublicProperty(i);
                        // TODO inefficient search, refactor
                        knownFilters.forEach(function (filterName) {
                            var filterClass = classes.alGet(filterName);
                            var proto = filterClass.alGetPrototypeProperty();
                            if (proto.asFilterConverter && proto.asFilterConverter.getAS3Class().axIsType(as3Filter)) {
                                arr.push(proto.asFilterConverter.fromAS3Filter(as3Filter));
                            }
                        });
                    }
                }
                return new AVM1.Natives.AVM1ArrayNative(context, arr);
            }
            Lib.convertFromAS3Filters = convertFromAS3Filters;
            var flash = Shumway.AVMX.AS.flash;
            function loadAVM1DataObject(context, url, method, contentType, data, target) {
                var request = new context.sec.flash.net.URLRequest(url);
                if (method) {
                    request.method = method;
                }
                if (contentType) {
                    request.contentType = contentType;
                }
                if (data) {
                    release || Shumway.Debug.assert(typeof data === 'string');
                    request.data = data;
                }
                var loader = new context.sec.flash.net.URLLoader(request);
                loader.dataFormat = 'text';
                // flash.net.URLLoaderDataFormat.TEXT;
                var completeHandler = context.sec.boxFunction(function (event) {
                    loader.removeEventListener(flash.events.Event.COMPLETE, completeHandler);
                    release || Shumway.Debug.assert(typeof loader.data === 'string');
                    Lib.avm1BroadcastEvent(context, target, 'onData', [loader.data]);
                });
                loader.addEventListener(flash.events.Event.COMPLETE, completeHandler);
                target._as3Loader = loader;
            }
            Lib.loadAVM1DataObject = loadAVM1DataObject;
            var AVM1LoadVarsFunction = function (_super) {
                __extends(AVM1LoadVarsFunction, _super);
                function AVM1LoadVarsFunction(context) {
                    _super.call(this, context);
                    this.alSetOwnPrototypeProperty(new AVM1LoadVarsPrototype(context, this));
                }
                AVM1LoadVarsFunction.prototype.alConstruct = function (args) {
                    var obj = new AVM1.AVM1Object(this.context);
                    obj.alPrototype = this.alGetPrototypeProperty();
                    obj.isAVM1DataObject = true;
                    return obj;
                };
                AVM1LoadVarsFunction.prototype.alCall = function (thisArg, args) {
                    return this.alConstruct(args);
                };
                return AVM1LoadVarsFunction;
            }(AVM1.AVM1Function);
            Lib.AVM1LoadVarsFunction = AVM1LoadVarsFunction;
            var AVM1LoadVarsPrototype = function (_super) {
                __extends(AVM1LoadVarsPrototype, _super);
                function AVM1LoadVarsPrototype(context, fn) {
                    _super.call(this, context);
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        toString: { value: this._toString },
                        load: { value: this.load },
                        onData: { value: this.defaultOnData },
                        decode: { value: this.decode },
                        send: { value: this.load },
                        sendAndload: { value: this.load }
                    });
                }
                AVM1LoadVarsPrototype.prototype.getBytesLoaded = function () {
                    if (!this._as3Loader) {
                        return undefined;
                    }
                    return this._as3Loader.bytesLoaded;
                };
                AVM1LoadVarsPrototype.prototype.getBytesTotal = function () {
                    if (!this._as3Loader) {
                        return undefined;
                    }
                    return this._as3Loader.bytesTotal;
                };
                AVM1LoadVarsPrototype.prototype.load = function (url) {
                    url = AVM1.alCoerceString(this.context, url);
                    if (!url) {
                        return false;
                    }
                    loadAVM1DataObject(this.context, url, null, null, null, this);
                    return true;
                };
                AVM1LoadVarsPrototype.prototype.defaultOnData = function (src) {
                    if (Shumway.isNullOrUndefined(src)) {
                        Lib.avm1BroadcastEvent(this.context, this, 'onLoad', [false]);
                        return;
                    }
                    AVM1LoadVarsPrototype.prototype.decode.call(this, src);
                    this.alPut('loaded', true);
                    Lib.avm1BroadcastEvent(this.context, this, 'onLoad', [true]);
                };
                AVM1LoadVarsPrototype.prototype.decode = function (queryString) {
                    queryString = AVM1.alCoerceString(this.context, queryString);
                    var as3Variables = new this.context.sec.flash.net.URLVariables();
                    as3Variables._ignoreDecodingErrors = true;
                    as3Variables.decode(queryString);
                    Shumway.AVMX.forEachPublicProperty(as3Variables, function (name, value) {
                        // TODO Are we leaking some AS3 properties/fields here?
                        if (typeof value === 'string') {
                            this.alPut(name, value);
                        }
                    }, this);
                };
                AVM1LoadVarsPrototype.prototype._toString = function () {
                    var context = this.context;
                    var as3Variables = new context.sec.flash.net.URLVariables();
                    AVM1.alForEachProperty(this, function (name) {
                        if (this.alHasOwnProperty(name)) {
                            as3Variables.axSetPublicProperty(name, AVM1.alToString(context, this.alGet(name)));
                        }
                    }, this);
                    return as3Variables.axCallPublicProperty('toString', null);
                };
                AVM1LoadVarsPrototype.prototype.send = function (url, target, method) {
                    url = AVM1.alCoerceString(this.context, url);
                    method = Shumway.isNullOrUndefined(method) ? 'POST' : AVM1.alCoerceString(this.context, method);
                    Shumway.Debug.notImplemented('AVM1LoadVarsPrototype.send');
                    return false;
                };
                AVM1LoadVarsPrototype.prototype.sendAndLoad = function (url, target, method) {
                    url = AVM1.alCoerceString(this.context, url);
                    method = Shumway.isNullOrUndefined(method) ? 'POST' : AVM1.alCoerceString(this.context, method);
                    if (!url || !(target instanceof AVM1.AVM1Object)) {
                        return false;
                    }
                    if (!target.isAVM1DataObject) {
                        return false;
                    }
                    var contentType = this.alGet('contentType');
                    contentType = Shumway.isNullOrUndefined(contentType) ? 'application/x-www-form-urlencoded' : AVM1.alCoerceString(this.context, contentType);
                    var data = AVM1.alToString(this.context, this);
                    loadAVM1DataObject(this.context, url, method, contentType, data, target);
                    return true;
                };
                return AVM1LoadVarsPrototype;
            }(AVM1.AVM1Object);
            Lib.AVM1LoadVarsPrototype = AVM1LoadVarsPrototype;
            var axCoerceString = Shumway.AVMX.axCoerceString;
            var AVM1XMLNodeType;
            (function (AVM1XMLNodeType) {
                AVM1XMLNodeType[AVM1XMLNodeType['ELEMENT_NODE'] = 1] = 'ELEMENT_NODE';
                AVM1XMLNodeType[AVM1XMLNodeType['TEXT_NODE'] = 3] = 'TEXT_NODE';
            }(AVM1XMLNodeType || (AVM1XMLNodeType = {})));
            function toAS3XMLNode(as2Node) {
                if (!(as2Node instanceof AVM1.AVM1Object)) {
                    return null;
                }
                var context = as2Node.context;
                if (!AVM1.alInstanceOf(context, as2Node, context.globals.XMLNode)) {
                    return null;
                }
                release || Shumway.Debug.assert(as2Node.as3XMLNode);
                return as2Node.as3XMLNode;
            }
            function fromAS3XMLNode(context, as3Node) {
                if (Shumway.isNullOrUndefined(as3Node)) {
                    return undefined;
                }
                var as2Node = as3Node._as2Node;
                if (!as2Node) {
                    as2Node = new AVM1.AVM1Object(context);
                    as2Node.alPrototype = context.globals.XMLNode.alGetPrototypeProperty();
                    AVM1XMLNodePrototype.prototype.initializeFromAS3Node.call(as2Node, as3Node);
                } else {
                    release || Shumway.Debug.assert(as2Node.context === context);
                }
                return as2Node;
            }
            var AVM1XMLNodeFunction = function (_super) {
                __extends(AVM1XMLNodeFunction, _super);
                function AVM1XMLNodeFunction(context) {
                    _super.call(this, context);
                    this.alSetOwnPrototypeProperty(new AVM1XMLNodePrototype(context, this));
                }
                AVM1XMLNodeFunction.prototype.alConstruct = function (args) {
                    if (!args && args.length < 2) {
                        Shumway.Debug.notImplemented('Unsupported amount of parameters for AVM1XMLNode constructor');
                        return undefined;
                    }
                    var type = AVM1.alCoerceNumber(this.context, args[0]);
                    var value = AVM1.alCoerceString(this.context, args[1]);
                    if (type !== AVM1XMLNodeType.ELEMENT_NODE && type !== AVM1XMLNodeType.TEXT_NODE) {
                        Shumway.Debug.notImplemented('Unsupported AVM1XMLNode type: ' + type);
                        return undefined;
                    }
                    var obj = new AVM1.AVM1Object(this.context);
                    obj.alPrototype = this.alGetPrototypeProperty();
                    AVM1XMLNodePrototype.prototype.initializeNode.call(obj, type, value);
                    return obj;
                };
                AVM1XMLNodeFunction.prototype.alCall = function (thisArg, args) {
                    return this.alConstruct(args);
                };
                return AVM1XMLNodeFunction;
            }(AVM1.AVM1Function);
            Lib.AVM1XMLNodeFunction = AVM1XMLNodeFunction;
            var AVM1XMLNodeChildNodes = function (_super) {
                __extends(AVM1XMLNodeChildNodes, _super);
                function AVM1XMLNodeChildNodes(context, as3XMLNode) {
                    _super.call(this, context);
                    this._as3XMLNode = as3XMLNode;
                    this._cachedNodePropertyDescriptor = new AVM1.AVM1PropertyDescriptor(64    /* DATA */ | 2    /* DONT_DELETE */ | 4    /* READ_ONLY */, undefined);
                    AVM1.alDefineObjectProperties(this, { length: { get: this.getLength } });
                }
                Object.defineProperty(AVM1XMLNodeChildNodes.prototype, 'as3ChildNodes', {
                    get: function () {
                        return this._as3XMLNode.axGetPublicProperty('childNodes').value;    // TODO .childNodes
                    },
                    enumerable: true,
                    configurable: true
                });
                AVM1XMLNodeChildNodes.prototype.getLength = function () {
                    return this.as3ChildNodes.length;
                };
                AVM1XMLNodeChildNodes.prototype.alGetOwnProperty = function (p) {
                    if (AVM1.alIsIndex(this.context, p)) {
                        var index = AVM1.alToInteger(this.context, p);
                        if (index >= 0 && index < this.as3ChildNodes.length) {
                            this._cachedNodePropertyDescriptor.value = fromAS3XMLNode(this.context, this.as3ChildNodes[index]);
                            return this._cachedNodePropertyDescriptor;
                        }
                    }
                    return _super.prototype.alGetOwnProperty.call(this, p);
                };
                return AVM1XMLNodeChildNodes;
            }(AVM1.AVM1Object);
            var AVM1XMLNodeAttributes = function (_super) {
                __extends(AVM1XMLNodeAttributes, _super);
                function AVM1XMLNodeAttributes(context, as3Attributes) {
                    _super.call(this, context);
                    this.alPrototype = context.builtins.Object.alGetPrototypeProperty();
                    this._as3Attributes = as3Attributes;
                    this._cachedNodePropertyDescriptor = new AVM1.AVM1PropertyDescriptor(64    /* DATA */, undefined);
                }
                AVM1XMLNodeAttributes.prototype.alGetOwnProperty = function (p) {
                    var name = AVM1.alCoerceString(this.context, p);
                    if (this._as3Attributes.axHasPublicProperty(name)) {
                        this._cachedNodePropertyDescriptor.value = this._as3Attributes.axGetPublicProperty(name);
                        return this._cachedNodePropertyDescriptor;
                    }
                    return undefined;
                };
                AVM1XMLNodeAttributes.prototype.alSetOwnProperty = function (p, desc) {
                    var name = AVM1.alCoerceString(this.context, p);
                    if (desc.flags & 64    /* DATA */) {
                        var value = AVM1.alCoerceString(this.context, desc.value);
                        this._as3Attributes.axSetPublicProperty(name, value);
                    }
                };
                AVM1XMLNodeAttributes.prototype.alHasOwnProperty = function (p) {
                    var name = AVM1.alCoerceString(this.context, p);
                    return this._as3Attributes.axHasPublicProperty(name);
                };
                AVM1XMLNodeAttributes.prototype.alDeleteOwnProperty = function (p) {
                    var name = AVM1.alCoerceString(this.context, p);
                    this._as3Attributes.axDeletePublicProperty(name);
                };
                AVM1XMLNodeAttributes.prototype.alGetOwnPropertiesKeys = function () {
                    var as3Keys = this._as3Attributes.axGetEnumerableKeys();
                    return as3Keys.map(function (key) {
                        return axCoerceString(key);
                    });
                };
                return AVM1XMLNodeAttributes;
            }(AVM1.AVM1Object);
            var AVM1XMLNodePrototype = function (_super) {
                __extends(AVM1XMLNodePrototype, _super);
                function AVM1XMLNodePrototype(context, fn) {
                    _super.call(this, context);
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        attributes: {
                            get: this.getAttributes,
                            set: this.setAttributes
                        },
                        childNodes: { get: this.getChildNodes },
                        firstChild: { get: this.getFirstChild },
                        lastChild: { get: this.getLastChild },
                        localName: { get: this.getLocalName },
                        namespaceURI: { get: this.getNamespaceURI },
                        nextSibling: { get: this.getNextSibling },
                        nodeName: {
                            get: this.getNodeName,
                            set: this.setNodeName
                        },
                        nodeType: { get: this.getNodeType },
                        nodeValue: {
                            get: this.getNodeValue,
                            set: this.setNodeValue
                        },
                        parentNode: { get: this.getParentNode },
                        prefix: { get: this.getPrefix },
                        previousSibling: { get: this.getPreviousSibling },
                        appendChild: { value: this.appendChild },
                        cloneNode: { value: this.cloneNode },
                        getNamespaceForPrefix: { value: this.getNamespaceForPrefix },
                        getPrefixForNamespace: { value: this.getPrefixForNamespace },
                        hasChildNodes: { value: this.hasChildNodes },
                        insertBefore: { value: this.insertBefore },
                        removeNode: { value: this.removeNode },
                        toString: { value: this._toString }
                    });
                }
                AVM1XMLNodePrototype.prototype.initializeNode = function (type, value) {
                    this.as3XMLNode = new this.context.sec.flash.xml.XMLNode(type, value);
                    this._attributes = undefined;
                    this._childNodes = undefined;
                    AVM1XMLNodePrototype.addMap(this.as3XMLNode, this);
                };
                AVM1XMLNodePrototype.prototype.initializeFromAS3Node = function (as3XMLNode) {
                    this.as3XMLNode = as3XMLNode;
                    this._attributes = undefined;
                    this._childNodes = undefined;
                    AVM1XMLNodePrototype.addMap(this.as3XMLNode, this);
                };
                AVM1XMLNodePrototype.prototype._toString = function () {
                    return this.as3XMLNode.axCallPublicProperty('toString', null);
                };
                AVM1XMLNodePrototype.prototype.appendChild = function (newChild) {
                    this.as3XMLNode.axCallPublicProperty('appendChild', [toAS3XMLNode(newChild)]);
                };
                AVM1XMLNodePrototype.prototype.getAttributes = function () {
                    var as3Attributes = this.as3XMLNode.axGetPublicProperty('attributes');
                    if (Shumway.isNullOrUndefined(as3Attributes)) {
                        return undefined;
                    }
                    // TODO create a proxy to map AVM2 object stuff to AVM1
                    if (!this._attributes) {
                        this._attributes = new AVM1XMLNodeAttributes(this.context, as3Attributes);
                    }
                    return this._attributes;
                };
                AVM1XMLNodePrototype.prototype.setAttributes = function (value) {
                    var _this = this;
                    if (Shumway.isNullOrUndefined(value)) {
                        this._attributes = undefined;
                        return;
                    }
                    if (value instanceof AVM1XMLNodeAttributes) {
                        this._attributes = value;
                        return;
                    }
                    var context = this.context;
                    var as3Attributes = context.sec.createObject();
                    AVM1.alForEachProperty(value, function (prop) {
                        var name = AVM1.alCoerceString(context, prop);
                        var value = AVM1.alCoerceString(context, _this.alGet(prop));
                        as3Attributes.axSetPublicProperty(name, value);
                    }, this);
                    this._attributes = new AVM1XMLNodeAttributes(context, as3Attributes);
                };
                AVM1XMLNodePrototype.prototype.getChildNodes = function () {
                    if (!this._childNodes) {
                        this._childNodes = new AVM1XMLNodeChildNodes(this.context, this.as3XMLNode);
                    }
                    return this._childNodes;
                };
                AVM1XMLNodePrototype.prototype.cloneNode = function (deepClone) {
                    deepClone = AVM1.alToBoolean(this.context, deepClone);
                    var clone = this.as3XMLNode.axCallPublicProperty('cloneNode', [deepClone]);
                    return fromAS3XMLNode(this.context, clone);
                };
                AVM1XMLNodePrototype.prototype.getFirstChild = function () {
                    return fromAS3XMLNode(this.context, this.as3XMLNode.axGetPublicProperty('firstChild'));
                };
                AVM1XMLNodePrototype.prototype.getNamespaceForPrefix = function (prefix) {
                    return this.as3XMLNode.axCallPublicProperty('getNamespaceForPrefix', [prefix]);
                };
                AVM1XMLNodePrototype.prototype.getPrefixForNamespace = function (nsURI) {
                    return this.as3XMLNode.axCallPublicProperty('getNamespaceForPrefix', [nsURI]);
                };
                AVM1XMLNodePrototype.prototype.hasChildNodes = function () {
                    return this.as3XMLNode.axCallPublicProperty('hasChildNodes', null);
                };
                AVM1XMLNodePrototype.prototype.insertBefore = function (newChild, insertPoint) {
                    this.as3XMLNode.axCallPublicProperty('insertBefore', [
                        toAS3XMLNode(newChild),
                        toAS3XMLNode(insertPoint)
                    ]);
                };
                AVM1XMLNodePrototype.prototype.getLastChild = function () {
                    return fromAS3XMLNode(this.context, this.as3XMLNode.axGetPublicProperty('lastChild'));
                };
                AVM1XMLNodePrototype.prototype.getLocalName = function () {
                    return this.as3XMLNode.axGetPublicProperty('localName');
                };
                AVM1XMLNodePrototype.prototype.getNamespaceURI = function () {
                    return this.as3XMLNode.axGetPublicProperty('namespaceURI');
                };
                AVM1XMLNodePrototype.prototype.getNextSibling = function () {
                    return fromAS3XMLNode(this.context, this.as3XMLNode.axGetPublicProperty('nextSibling'));
                };
                AVM1XMLNodePrototype.prototype.getNodeName = function () {
                    return this.as3XMLNode.axGetPublicProperty('nodeName');
                };
                AVM1XMLNodePrototype.prototype.setNodeName = function (value) {
                    value = AVM1.alCoerceString(this.context, value);
                    this.as3XMLNode.axSetPublicProperty('nodeName', value);
                };
                AVM1XMLNodePrototype.prototype.getNodeType = function () {
                    return this.as3XMLNode.axGetPublicProperty('nodeType');
                };
                AVM1XMLNodePrototype.prototype.getNodeValue = function () {
                    return this.as3XMLNode.axGetPublicProperty('nodeValue');
                };
                AVM1XMLNodePrototype.prototype.setNodeValue = function (value) {
                    value = AVM1.alCoerceString(this.context, value);
                    this.as3XMLNode.axSetPublicProperty('nodeValue', value);
                };
                AVM1XMLNodePrototype.prototype.getParentNode = function () {
                    return fromAS3XMLNode(this.context, this.as3XMLNode.axGetPublicProperty('parentNode'));
                };
                AVM1XMLNodePrototype.prototype.getPrefix = function () {
                    return this.as3XMLNode.axGetPublicProperty('prefix');
                };
                AVM1XMLNodePrototype.prototype.getPreviousSibling = function () {
                    return fromAS3XMLNode(this.context, this.as3XMLNode.axGetPublicProperty('previousSibling'));
                };
                AVM1XMLNodePrototype.prototype.removeNode = function () {
                    this.as3XMLNode.axCallPublicProperty('removeNode', null);
                };
                AVM1XMLNodePrototype.addMap = function (as3Node, as2Node) {
                    release || Shumway.Debug.assert(!as3Node._as2Node);
                    as3Node._as2Node = as2Node;
                };
                return AVM1XMLNodePrototype;
            }(AVM1.AVM1Object);
            var AVM1XMLFunction = function (_super) {
                __extends(AVM1XMLFunction, _super);
                function AVM1XMLFunction(context, xmlNodeClass) {
                    _super.call(this, context);
                    this.alSetOwnPrototypeProperty(new AVM1XMLPrototype(context, this, xmlNodeClass));
                }
                AVM1XMLFunction.prototype.alConstruct = function (args) {
                    var text = args && AVM1.alCoerceString(this.context, args[0]);
                    var obj = new AVM1.AVM1Object(this.context);
                    obj.alPrototype = this.alGetPrototypeProperty();
                    obj.isAVM1DataObject = true;
                    AVM1XMLPrototype.prototype.initializeDocument.call(obj, text);
                    return obj;
                };
                AVM1XMLFunction.prototype.alCall = function (thisArg, args) {
                    return this.alConstruct(args);
                };
                return AVM1XMLFunction;
            }(AVM1.AVM1Function);
            Lib.AVM1XMLFunction = AVM1XMLFunction;
            var AVM1XMLPrototype = function (_super) {
                __extends(AVM1XMLPrototype, _super);
                function AVM1XMLPrototype(context, fn, xmlNodeClass) {
                    _super.call(this, context);
                    this.alPrototype = xmlNodeClass.alGetPrototypeProperty();
                    AVM1.alDefineObjectProperties(this, {
                        constructor: {
                            value: fn,
                            writable: true
                        },
                        addRequestHeader: { value: this.addRequestHeader },
                        createElement: { value: this.createElement },
                        createTextNode: { value: this.createTextNode },
                        getBytesLoaded: { value: this.getBytesLoaded },
                        getBytesTotal: { value: this.getBytesTotal },
                        ignoreWhite: {
                            value: false,
                            writable: true
                        },
                        load: { value: this.load },
                        parseXML: { value: this.parseXML },
                        send: { value: this.send },
                        sendAndLoad: { value: this.sendAndLoad },
                        onData: {
                            value: this.defaultOnData,
                            writable: true
                        }
                    });
                }
                AVM1XMLPrototype.prototype.initializeDocument = function (text) {
                    text = AVM1.alCoerceString(this.context, text) || null;
                    var as3Doc = new this.context.sec.flash.xml.XMLDocument(text);
                    AVM1XMLNodePrototype.prototype.initializeFromAS3Node.call(this, as3Doc);
                    this.as3XMLDocument = as3Doc;
                };
                AVM1XMLPrototype.prototype.addRequestHeader = function (headers, headerValue) {
                    Shumway.Debug.notImplemented('AVM1XMLPrototype.addRequestHeader');
                };
                AVM1XMLPrototype.prototype.createElement = function (name) {
                    name = AVM1.alCoerceString(this.context, name);
                    var as3Node = this.as3XMLDocument.axCallPublicProperty('createElement', [name]);
                    return fromAS3XMLNode(this.context, as3Node);
                };
                AVM1XMLPrototype.prototype.createTextNode = function (value) {
                    value = AVM1.alCoerceString(this.context, value);
                    var as3Node = this.as3XMLDocument.axCallPublicProperty('createTextNode', [value]);
                    return fromAS3XMLNode(this.context, as3Node);
                };
                AVM1XMLPrototype.prototype.getBytesLoaded = function () {
                    if (!this._as3Loader) {
                        return undefined;
                    }
                    return this._as3Loader.bytesLoaded;
                };
                AVM1XMLPrototype.prototype.getBytesTotal = function () {
                    if (!this._as3Loader) {
                        return undefined;
                    }
                    return this._as3Loader.bytesTotal;
                };
                AVM1XMLPrototype.prototype.load = function (url) {
                    url = AVM1.alCoerceString(this.context, url);
                    if (!url) {
                        return false;
                    }
                    Lib.loadAVM1DataObject(this.context, url, null, null, null, this);
                    return true;
                };
                AVM1XMLPrototype.prototype.defaultOnData = function (src) {
                    if (Shumway.isNullOrUndefined(src)) {
                        Lib.avm1BroadcastEvent(this.context, this, 'onLoad', [false]);
                        return;
                    }
                    AVM1XMLPrototype.prototype.parseXML.call(this, src);
                    this.alPut('loaded', true);
                    Lib.avm1BroadcastEvent(this.context, this, 'onLoad', [true]);
                };
                AVM1XMLPrototype.prototype.parseXML = function (value) {
                    value = AVM1.alCoerceString(this.context, value);
                    this.as3XMLDocument.axSetPublicProperty('ignoreWhite', AVM1.alToBoolean(this.context, this.alGet('ignoreWhite')));
                    this.as3XMLDocument.axCallPublicProperty('parseXML', [value]);
                };
                AVM1XMLPrototype.prototype.send = function (url, target, method) {
                    url = AVM1.alCoerceString(this.context, url);
                    target = Shumway.isNullOrUndefined(target) ? undefined : AVM1.alCoerceString(this.context, target);
                    method = Shumway.isNullOrUndefined(method) ? undefined : AVM1.alCoerceString(this.context, method);
                    Shumway.Debug.notImplemented('AVM1XMLPrototype.send');
                    return false;
                };
                AVM1XMLPrototype.prototype.sendAndLoad = function (url, resultXML) {
                    url = AVM1.alCoerceString(this.context, url);
                    if (!url) {
                        return;
                    }
                    if (!resultXML.isAVM1DataObject) {
                        return;
                    }
                    Shumway.Debug.somewhatImplemented('AVM1XMLPrototype.send');
                    // TODO check content types and test
                    var contentType = this.alGet('contentType');
                    contentType = Shumway.isNullOrUndefined(contentType) ? undefined : AVM1.alCoerceString(this.context, contentType);
                    var data = AVM1.alToString(this.context, this);
                    Lib.loadAVM1DataObject(this.context, url, 'POST', contentType, data, resultXML);
                };
                return AVM1XMLPrototype;
            }(AVM1.AVM1Object);
        }(Lib = AVM1.Lib || (AVM1.Lib = {})));
    }(AVM1 = Shumway.AVM1 || (Shumway.AVM1 = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='../../build/ts/avm2.d.ts' />
/// <reference path='flash.d.ts' />
///<reference path='settings.ts' />
///<reference path='stream.ts' />
///<reference path='parser.ts' />
///<reference path='analyze.ts' />
///<reference path='runtime.ts' />
///<reference path='natives.ts' />
///<reference path='context.ts' />
///<reference path='interpreter.ts' />
///<reference path='baseline.ts' />
///<reference path='lib/AVM1Utils.ts' />
///<reference path='lib/AVM1Globals.ts' />
///<reference path='lib/AVM1Broadcaster.ts' />
///<reference path='lib/AVM1Key.ts' />
///<reference path='lib/AVM1Mouse.ts' />
///<reference path='lib/AVM1Stage.ts' />
///<reference path='lib/AVM1MovieClip.ts' />
///<reference path='lib/AVM1Button.ts' />
///<reference path='lib/AVM1TextField.ts' />
///<reference path='lib/AVM1Color.ts' />
///<reference path='lib/AVM1ColorTransform.ts' />
///<reference path='lib/AVM1Matrix.ts' />
///<reference path='lib/AVM1Point.ts' />
///<reference path='lib/AVM1Rectangle.ts' />
///<reference path='lib/AVM1Transform.ts' />
///<reference path='lib/AVM1TextFormat.ts' />
///<reference path='lib/AVM1BitmapData.ts' />
///<reference path='lib/AVM1ExternalInterface.ts' />
///<reference path='lib/AVM1Sound.ts' />
///<reference path='lib/AVM1System.ts' />
///<reference path='lib/AVM1SharedObject.ts' />
///<reference path='lib/AVM1MovieClipLoader.ts' />
///<reference path='lib/AVM1Filters.ts' />
///<reference path='lib/AVM1LoadVars.ts' />
///<reference path='lib/AVM1XML.ts' />
//# sourceMappingURL=avm1.js.map
console.timeEnd('Load AVM1 Dependencies');
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var assert = Shumway.Debug.assert;
        var clamp = Shumway.NumberUtilities.clamp;
        var counter = Shumway.Metrics.Counter.instance;
        GFX.frameCounter = new Shumway.Metrics.Counter(true);
        GFX.traceLevel = 2    /* Verbose */;
        GFX.writer = null;
        function frameCount(name) {
            counter.count(name);
            GFX.frameCounter.count(name);
        }
        GFX.frameCount = frameCount;
        GFX.timelineBuffer = Shumway.Tools ? new Shumway.Tools.Profiler.TimelineBuffer('GFX') : null;
        function enterTimeline(name, data) {
            profile && GFX.timelineBuffer && GFX.timelineBuffer.enter(name, data);
        }
        GFX.enterTimeline = enterTimeline;
        function leaveTimeline(name, data) {
            profile && GFX.timelineBuffer && GFX.timelineBuffer.leave(name, data);
        }
        GFX.leaveTimeline = leaveTimeline;
        var nativeAddColorStop = null;
        var nativeCreateLinearGradient = null;
        var nativeCreateRadialGradient = null;
        /**
         * Transforms a fill or stroke style by the given color matrix.
         */
        function transformStyle(context, style, colorMatrix) {
            if (!polyfillColorTransform || !colorMatrix) {
                return style;
            }
            if (typeof style === 'string') {
                // Parse CSS color styles and transform them.
                var rgba = Shumway.ColorUtilities.cssStyleToRGBA(style);
                return Shumway.ColorUtilities.rgbaToCSSStyle(colorMatrix.transformRGBA(rgba));
            } else if (style instanceof CanvasGradient) {
                if (style._template) {
                    // If gradient style has a template, construct a new gradient style from it whith
                    // its color stops transformed.
                    return style._template.createCanvasGradient(context, colorMatrix);
                }
            }
            return style;    // "#ff69b4"
        }
        /**
         * Whether to polyfill color transforms. This adds a |globalColorMatrix| property on |CanvasRenderingContext2D|
         * that is used to transform all stroke and fill styles before a drawing operation happens.
         */
        var polyfillColorTransform = true;
        /**
         * Gradients are opaque objects and their properties cannot be inspected. Here we hijack gradient style constructors
         * and attach "template" objects on gradients so that we can keep track of their position attributes and color stops.
         * Using these "template" objects, we can clone and transform gradients.
         */
        if (polyfillColorTransform && typeof CanvasRenderingContext2D !== 'undefined') {
            nativeAddColorStop = CanvasGradient.prototype.addColorStop;
            nativeCreateLinearGradient = CanvasRenderingContext2D.prototype.createLinearGradient;
            nativeCreateRadialGradient = CanvasRenderingContext2D.prototype.createRadialGradient;
            CanvasRenderingContext2D.prototype.createLinearGradient = function (x0, y0, x1, y1) {
                var gradient = new CanvasLinearGradient(x0, y0, x1, y1);
                return gradient.createCanvasGradient(this, null);
            };
            CanvasRenderingContext2D.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
                var gradient = new CanvasRadialGradient(x0, y0, r0, x1, y1, r1);
                return gradient.createCanvasGradient(this, null);
            };
            CanvasGradient.prototype.addColorStop = function (offset, color) {
                nativeAddColorStop.call(this, offset, color);
                this._template.addColorStop(offset, color);
            };
        }
        var ColorStop = function () {
            function ColorStop(offset, color) {
                this.offset = offset;
                this.color = color;    // ...
            }
            return ColorStop;
        }();
        /**
         * Template for linear gradients.
         */
        var CanvasLinearGradient = function () {
            function CanvasLinearGradient(x0, y0, x1, y1) {
                this.x0 = x0;
                this.y0 = y0;
                this.x1 = x1;
                this.y1 = y1;
                this.colorStops = [];    // ...
            }
            CanvasLinearGradient.prototype.addColorStop = function (offset, color) {
                this.colorStops.push(new ColorStop(offset, color));
            };
            CanvasLinearGradient.prototype.createCanvasGradient = function (context, colorMatrix) {
                var gradient = nativeCreateLinearGradient.call(context, this.x0, this.y0, this.x1, this.y1);
                var colorStops = this.colorStops;
                for (var i = 0; i < colorStops.length; i++) {
                    var colorStop = colorStops[i];
                    var offset = colorStop.offset;
                    var color = colorStop.color;
                    color = colorMatrix ? transformStyle(context, color, colorMatrix) : color;
                    nativeAddColorStop.call(gradient, offset, color);
                }
                gradient._template = this;
                gradient._transform = this._transform;
                return gradient;
            };
            return CanvasLinearGradient;
        }();
        /**
         * Template for radial gradients.
         */
        var CanvasRadialGradient = function () {
            function CanvasRadialGradient(x0, y0, r0, x1, y1, r1) {
                this.x0 = x0;
                this.y0 = y0;
                this.r0 = r0;
                this.x1 = x1;
                this.y1 = y1;
                this.r1 = r1;
                this.colorStops = [];    // ...
            }
            CanvasRadialGradient.prototype.addColorStop = function (offset, color) {
                this.colorStops.push(new ColorStop(offset, color));
            };
            CanvasRadialGradient.prototype.createCanvasGradient = function (context, colorMatrix) {
                var gradient = nativeCreateRadialGradient.call(context, this.x0, this.y0, this.r0, this.x1, this.y1, this.r1);
                var colorStops = this.colorStops;
                for (var i = 0; i < colorStops.length; i++) {
                    var colorStop = colorStops[i];
                    var offset = colorStop.offset;
                    var color = colorStop.color;
                    color = colorMatrix ? transformStyle(context, color, colorMatrix) : color;
                    nativeAddColorStop.call(gradient, offset, color);
                }
                gradient._template = this;
                gradient._transform = this._transform;
                return gradient;
            };
            return CanvasRadialGradient;
        }();
        var PathCommand;
        (function (PathCommand) {
            PathCommand[PathCommand['ClosePath'] = 1] = 'ClosePath';
            PathCommand[PathCommand['MoveTo'] = 2] = 'MoveTo';
            PathCommand[PathCommand['LineTo'] = 3] = 'LineTo';
            PathCommand[PathCommand['QuadraticCurveTo'] = 4] = 'QuadraticCurveTo';
            PathCommand[PathCommand['BezierCurveTo'] = 5] = 'BezierCurveTo';
            PathCommand[PathCommand['ArcTo'] = 6] = 'ArcTo';
            PathCommand[PathCommand['Rect'] = 7] = 'Rect';
            PathCommand[PathCommand['Arc'] = 8] = 'Arc';
            PathCommand[PathCommand['Save'] = 9] = 'Save';
            PathCommand[PathCommand['Restore'] = 10] = 'Restore';
            PathCommand[PathCommand['Transform'] = 11] = 'Transform';
        }(PathCommand || (PathCommand = {})));
        /**
         * Polyfill for missing |Path2D|. An instance of this class keeps a record of all drawing commands
         * ever called on it.
         */
        var Path = function () {
            function Path(arg) {
                this._commands = new Uint8Array(Path._arrayBufferPool.acquire(8), 0, 8);
                this._commandPosition = 0;
                this._data = new Float64Array(Path._arrayBufferPool.acquire(8 * Float64Array.BYTES_PER_ELEMENT), 0, 8);
                this._dataPosition = 0;
                if (arg instanceof Path) {
                    this.addPath(arg);
                }
            }
            /**
             * Takes a |Path2D| instance and a 2d context to replay the recorded drawing commands.
             */
            Path._apply = function (path, context) {
                var commands = path._commands;
                var d = path._data;
                var i = 0;
                var j = 0;
                context.beginPath();
                var commandPosition = path._commandPosition;
                while (i < commandPosition) {
                    switch (commands[i++]) {
                    case PathCommand.ClosePath:
                        context.closePath();
                        break;
                    case PathCommand.MoveTo:
                        context.moveTo(d[j++], d[j++]);
                        break;
                    case PathCommand.LineTo:
                        context.lineTo(d[j++], d[j++]);
                        break;
                    case PathCommand.QuadraticCurveTo:
                        context.quadraticCurveTo(d[j++], d[j++], d[j++], d[j++]);
                        break;
                    case PathCommand.BezierCurveTo:
                        context.bezierCurveTo(d[j++], d[j++], d[j++], d[j++], d[j++], d[j++]);
                        break;
                    case PathCommand.ArcTo:
                        context.arcTo(d[j++], d[j++], d[j++], d[j++], d[j++]);
                        break;
                    case PathCommand.Rect:
                        context.rect(d[j++], d[j++], d[j++], d[j++]);
                        break;
                    case PathCommand.Arc:
                        context.arc(d[j++], d[j++], d[j++], d[j++], d[j++], !!d[j++]);
                        break;
                    case PathCommand.Save:
                        context.save();
                        break;
                    case PathCommand.Restore:
                        context.restore();
                        break;
                    case PathCommand.Transform:
                        context.transform(d[j++], d[j++], d[j++], d[j++], d[j++], d[j++]);
                        break;
                    }
                }
            };
            Path.prototype._ensureCommandCapacity = function (length) {
                this._commands = Path._arrayBufferPool.ensureUint8ArrayLength(this._commands, length);
            };
            Path.prototype._ensureDataCapacity = function (length) {
                this._data = Path._arrayBufferPool.ensureFloat64ArrayLength(this._data, length);
            };
            Path.prototype._writeCommand = function (command) {
                if (this._commandPosition >= this._commands.length) {
                    this._ensureCommandCapacity(this._commandPosition + 1);
                }
                this._commands[this._commandPosition++] = command;
            };
            Path.prototype._writeData = function (a, b, c, d, e, f) {
                var argc = arguments.length;
                release || assert(argc <= 6 && (argc % 2 === 0 || argc === 5));
                if (this._dataPosition + argc >= this._data.length) {
                    this._ensureDataCapacity(this._dataPosition + argc);
                }
                var data = this._data;
                var p = this._dataPosition;
                data[p] = a;
                data[p + 1] = b;
                if (argc > 2) {
                    data[p + 2] = c;
                    data[p + 3] = d;
                    if (argc > 4) {
                        data[p + 4] = e;
                        if (argc === 6) {
                            data[p + 5] = f;
                        }
                    }
                }
                this._dataPosition += argc;
            };
            Path.prototype.closePath = function () {
                this._writeCommand(PathCommand.ClosePath);
            };
            Path.prototype.moveTo = function (x, y) {
                this._writeCommand(PathCommand.MoveTo);
                this._writeData(x, y);
            };
            Path.prototype.lineTo = function (x, y) {
                this._writeCommand(PathCommand.LineTo);
                this._writeData(x, y);
            };
            Path.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
                this._writeCommand(PathCommand.QuadraticCurveTo);
                this._writeData(cpx, cpy, x, y);
            };
            Path.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
                this._writeCommand(PathCommand.BezierCurveTo);
                this._writeData(cp1x, cp1y, cp2x, cp2y, x, y);
            };
            Path.prototype.arcTo = function (x1, y1, x2, y2, radius) {
                this._writeCommand(PathCommand.ArcTo);
                this._writeData(x1, y1, x2, y2, radius);
            };
            Path.prototype.rect = function (x, y, width, height) {
                this._writeCommand(PathCommand.Rect);
                this._writeData(x, y, width, height);
            };
            Path.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
                this._writeCommand(PathCommand.Arc);
                this._writeData(x, y, radius, startAngle, endAngle, +anticlockwise);
            };
            /**
             * Copies and transforms all drawing commands stored in |path|.
             */
            Path.prototype.addPath = function (path, transformation) {
                if (transformation) {
                    this._writeCommand(PathCommand.Save);
                    this._writeCommand(PathCommand.Transform);
                    this._writeData(transformation.a, transformation.b, transformation.c, transformation.d, transformation.e, transformation.f);
                }
                // Copy commands.
                var newCommandPosition = this._commandPosition + path._commandPosition;
                if (newCommandPosition >= this._commands.length) {
                    this._ensureCommandCapacity(newCommandPosition);
                }
                var commands = this._commands;
                var pathCommands = path._commands;
                for (var i = this._commandPosition, j = 0; i < newCommandPosition; i++) {
                    commands[i] = pathCommands[j++];
                }
                this._commandPosition = newCommandPosition;
                // Copy data.
                var newDataPosition = this._dataPosition + path._dataPosition;
                if (newDataPosition >= this._data.length) {
                    this._ensureDataCapacity(newDataPosition);
                }
                var data = this._data;
                var pathData = path._data;
                for (var i = this._dataPosition, j = 0; i < newDataPosition; i++) {
                    data[i] = pathData[j++];
                }
                this._dataPosition = newDataPosition;
                if (transformation) {
                    this._writeCommand(PathCommand.Restore);
                }
            };
            Path._arrayBufferPool = new Shumway.ArrayBufferPool();
            return Path;
        }();
        GFX.Path = Path;
        // Polyfill |Path2D| if it is not defined or if its |addPath| method doesn't exist. This means that we
        // always need to polyfill this in FF until addPath lands which sucks.
        if (typeof CanvasRenderingContext2D !== 'undefined' && (typeof Path2D === 'undefined' || !Path2D.prototype.addPath)) {
            /**
             * We override all methods of |CanvasRenderingContext2D| that accept a |Path2D| object as one
             * of its arguments, so that we can apply all recorded drawing commands before calling the
             * original function.
             */
            var nativeFill = CanvasRenderingContext2D.prototype.fill;
            CanvasRenderingContext2D.prototype.fill = function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    } else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeFill.call(this, fillRule);
                } else {
                    nativeFill.call(this);
                }
            };
            var nativeStroke = CanvasRenderingContext2D.prototype.stroke;
            CanvasRenderingContext2D.prototype.stroke = function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    } else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeStroke.call(this, fillRule);
                } else {
                    nativeStroke.call(this);
                }
            };
            var nativeClip = CanvasRenderingContext2D.prototype.clip;
            CanvasRenderingContext2D.prototype.clip = function (path, fillRule) {
                if (arguments.length) {
                    if (path instanceof Path) {
                        Path._apply(path, this);
                    } else {
                        fillRule = path;
                    }
                }
                if (fillRule) {
                    nativeClip.call(this, fillRule);
                } else {
                    nativeClip.call(this);
                }
            };
            // Expose our pollyfill to the global object.
            window['Path2D'] = Path;
        }
        if (typeof CanvasPattern !== 'undefined') {
            /**
             * Polyfill |setTransform| on |CanvasPattern| and |CanvasGradient|. Firefox implements this for |CanvasPattern|
             * in Nightly but doesn't for |CanvasGradient| yet.
             *
             * This polyfill uses |Path2D|, which is polyfilled above. You can get a native implementaiton of |Path2D| in
             * Chrome if you enable experimental canvas features in |chrome://flags/|. In Firefox you'll have to wait for
             * https://bugzilla.mozilla.org/show_bug.cgi?id=985801 to land.
             */
            if (Path2D.prototype.addPath) {
                function setTransform(matrix) {
                    this._transform = matrix;
                    if (this._template) {
                        this._template._transform = matrix;
                    }
                }
                if (!CanvasPattern.prototype.setTransform) {
                    CanvasPattern.prototype.setTransform = setTransform;
                }
                if (!CanvasGradient.prototype.setTransform) {
                    CanvasGradient.prototype.setTransform = setTransform;
                }
                var originalFill = CanvasRenderingContext2D.prototype.fill;
                var originalStroke = CanvasRenderingContext2D.prototype.stroke;
                /**
                 * If the current fillStyle is a |CanvasPattern| or |CanvasGradient| that has a SVGMatrix transformed applied to it, we
                 * first apply the pattern's transform to the current context and then draw the path with the
                 * inverse fillStyle transform applied to it so that it is drawn in the expected original location.
                 */
                CanvasRenderingContext2D.prototype.fill = function fill(path, fillRule) {
                    var supportsStyle = this.fillStyle instanceof CanvasPattern || this.fillStyle instanceof CanvasGradient;
                    var hasStyleTransformation = !!this.fillStyle._transform;
                    if (supportsStyle && hasStyleTransformation && path instanceof Path2D) {
                        var m = this.fillStyle._transform;
                        var i;
                        try {
                            i = m.inverse();
                        } catch (e) {
                            i = m = GFX.Geometry.Matrix.createIdentitySVGMatrix();
                        }
                        // Transform the context by the style transform ...
                        this.transform(m.a, m.b, m.c, m.d, m.e, m.f);
                        // transform the path by the inverse of the style transform ...
                        var transformedPath = new Path2D();
                        transformedPath.addPath(path, i);
                        // draw the transformed path, which should render it in its original position but with a transformed style.
                        originalFill.call(this, transformedPath, fillRule);
                        this.transform(i.a, i.b, i.c, i.d, i.e, i.f);
                        return;
                    }
                    if (arguments.length === 0) {
                        originalFill.call(this);
                    } else if (arguments.length === 1) {
                        originalFill.call(this, path);
                    } else if (arguments.length === 2) {
                        originalFill.call(this, path, fillRule);
                    }
                };
                /**
                 * Same as for |fill| above.
                 */
                CanvasRenderingContext2D.prototype.stroke = function stroke(path) {
                    var supportsStyle = this.strokeStyle instanceof CanvasPattern || this.strokeStyle instanceof CanvasGradient;
                    var hasStyleTransformation = !!this.strokeStyle._transform;
                    if (supportsStyle && hasStyleTransformation && path instanceof Path2D) {
                        var m = this.strokeStyle._transform;
                        var i;
                        try {
                            i = m.inverse();
                        } catch (e) {
                            i = m = GFX.Geometry.Matrix.createIdentitySVGMatrix();
                        }
                        // Transform the context by the style transform ...
                        this.transform(m.a, m.b, m.c, m.d, m.e, m.f);
                        // transform the path by the inverse of the style transform ...
                        var transformedPath = new Path2D();
                        transformedPath.addPath(path, i);
                        // Scale the lineWidth down since it will be scaled up by the current transform.
                        var oldLineWidth = this.lineWidth;
                        this.lineWidth *= Math.sqrt((i.a + i.c) * (i.a + i.c) + (i.d + i.b) * (i.d + i.b)) * Math.SQRT1_2;
                        // draw the transformed path, which should render it in its original position but with a transformed style.
                        originalStroke.call(this, transformedPath);
                        this.transform(i.a, i.b, i.c, i.d, i.e, i.f);
                        this.lineWidth = oldLineWidth;
                        return;
                    }
                    if (arguments.length === 0) {
                        originalStroke.call(this);
                    } else if (arguments.length === 1) {
                        originalStroke.call(this, path);
                    }
                };
            }
        }
        if (typeof CanvasRenderingContext2D !== 'undefined') {
            (function () {
                /**
                 * Flash does not go below this number.
                 */
                var MIN_LINE_WIDTH = 1;
                /**
                 * Arbitrarily chosen large number.
                 */
                var MAX_LINE_WIDTH = 1024;
                var hasCurrentTransform = 'currentTransform' in CanvasRenderingContext2D.prototype;
                /**
                 * There's an impedance mismatch between Flash's vector drawing model and that of Canvas2D[1]: Flash applies scaling
                 * of stroke widths once by (depending on settings for the shape) using the concatenated horizontal scaling, vertical
                 * scaling, or a geometric average of the two. The calculated width is then uniformly applied at every point on the
                 * stroke. Canvas2D, OTOH, calculates scaling for each point individually. I.e., horizontal line segments aren't
                 * affected by vertical scaling and vice versa, with non-axis-alined line segments being partly affected.
                 * Additionally, Flash draws all strokes with at least 1px on-stage width, whereas Canvas draws finer-in-appearance
                 * lines by interpolating colors accordingly. To fix both of these, we have to apply any transforms to the geometry
                 * only, not the stroke style. That's only possible by building the untransformed geometry in a Path2D and, each time
                 * we rasterize, adding that with the current concatenated transform applied to a temporary Path2D, which we then draw
                 * in global coordinate space.
                 *
                 * Implements Flash stroking behavior.
                 */
                CanvasRenderingContext2D.prototype.flashStroke = function (path, lineScaleMode) {
                    if (!hasCurrentTransform) {
                        // Chrome doesn't have |currentTransform| yet, so fall back on normal stroking.
                        // |currentTransform| is available only if you enable experimental features.
                        this.stroke(path);
                        return;
                    }
                    var m = this.currentTransform;
                    var transformedPath = new Path2D();
                    // Transform the path by the current transform ...
                    transformedPath.addPath(path, m);
                    var oldLineWidth = this.lineWidth;
                    this.setTransform(1, 0, 0, 1, 0, 0);
                    // We need to scale the |lineWidth| based on the current transform.
                    // If we scale square 1x1 using this transform, it will fit into a
                    // rectangular area, that has sides parallel to the x- and y-axis,
                    // (a + c) x (d + b).
                    switch (lineScaleMode) {
                    case 0    /* None */:
                        break;
                    case 1    /* Normal */:
                        var scale = Math.sqrt((m.a + m.c) * (m.a + m.c) + (m.d + m.b) * (m.d + m.b)) * Math.SQRT1_2;
                        this.lineWidth = clamp(oldLineWidth * scale, MIN_LINE_WIDTH, MAX_LINE_WIDTH);
                        break;
                    case 2    /* Vertical */:
                        var scaleHeight = m.d + m.b;
                        this.lineWidth = clamp(oldLineWidth * scaleHeight, MIN_LINE_WIDTH, MAX_LINE_WIDTH);
                        break;
                    case 3    /* Horizontal */:
                        var scaleWidth = m.a + m.c;
                        this.lineWidth = clamp(oldLineWidth * scaleWidth, MIN_LINE_WIDTH, MAX_LINE_WIDTH);
                        break;
                    }
                    // Stroke and restore the previous matrix.
                    this.stroke(transformedPath);
                    this.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
                    this.lineWidth = oldLineWidth;
                };
                // A complete polyfill of currentTransform isn't feasible: we want to only use it if it gives
                // us a meaningful value. That we can only get if the platform gives us any means at all to
                // get that value. Gecko does so in the form of mozCurrentTransform, most engines don't.
                // For Chrome, at least return whatever transform was set using setTransform to ensure
                // clipping works in our 2D backend.
                if (!hasCurrentTransform) {
                    if ('mozCurrentTransform' in CanvasRenderingContext2D.prototype) {
                        Object.defineProperty(CanvasRenderingContext2D.prototype, 'currentTransform', { get: mozPolyfillCurrentTransform });
                        hasCurrentTransform = true;
                    } else {
                        var nativeSetTransform = CanvasRenderingContext2D.prototype.setTransform;
                        CanvasRenderingContext2D.prototype.setTransform = function setTransform(a, b, c, d, e, f) {
                            var transform = this.currentTransform;
                            transform.a = a;
                            transform.b = b;
                            transform.c = c;
                            transform.d = d;
                            transform.e = e;
                            transform.f = f;
                            nativeSetTransform.call(this, a, b, c, d, e, f);
                        };
                        Object.defineProperty(CanvasRenderingContext2D.prototype, 'currentTransform', {
                            get: function () {
                                return this._currentTransform || (this._currentTransform = GFX.Geometry.Matrix.createIdentitySVGMatrix());
                            }
                        });
                    }
                }
                function mozPolyfillCurrentTransform() {
                    release || assert(this.mozCurrentTransform);
                    return GFX.Geometry.Matrix.createSVGMatrixFromArray(this.mozCurrentTransform);
                }
            }());
        }
        /**
         * Polyfill |globalColorMatrix| on |CanvasRenderingContext2D|.
         */
        if (typeof CanvasRenderingContext2D !== 'undefined' && CanvasRenderingContext2D.prototype.globalColorMatrix === undefined) {
            var previousFill = CanvasRenderingContext2D.prototype.fill;
            var previousStroke = CanvasRenderingContext2D.prototype.stroke;
            var previousFillText = CanvasRenderingContext2D.prototype.fillText;
            var previousStrokeText = CanvasRenderingContext2D.prototype.strokeText;
            Object.defineProperty(CanvasRenderingContext2D.prototype, 'globalColorMatrix', {
                get: function () {
                    if (this._globalColorMatrix) {
                        return this._globalColorMatrix.clone();
                    }
                    return null;
                },
                set: function (matrix) {
                    if (!matrix) {
                        this._globalColorMatrix = null;
                        return;
                    }
                    if (this._globalColorMatrix) {
                        this._globalColorMatrix.set(matrix);
                    } else {
                        this._globalColorMatrix = matrix.clone();
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Intercept calls to |fill| and transform fill style if a |globalColorMatrix| is set.
             */
            CanvasRenderingContext2D.prototype.fill = function (a, b) {
                var oldFillStyle = null;
                if (this._globalColorMatrix) {
                    oldFillStyle = this.fillStyle;
                    this.fillStyle = transformStyle(this, this.fillStyle, this._globalColorMatrix);
                }
                if (arguments.length === 0) {
                    previousFill.call(this);
                } else if (arguments.length === 1) {
                    previousFill.call(this, a);
                } else if (arguments.length === 2) {
                    previousFill.call(this, a, b);
                }
                if (oldFillStyle) {
                    this.fillStyle = oldFillStyle;
                }
            };
            /**
             * Same as |fill| above.
             */
            CanvasRenderingContext2D.prototype.stroke = function (a, b) {
                var oldStrokeStyle = null;
                if (this._globalColorMatrix) {
                    oldStrokeStyle = this.strokeStyle;
                    this.strokeStyle = transformStyle(this, this.strokeStyle, this._globalColorMatrix);
                }
                if (arguments.length === 0) {
                    previousStroke.call(this);
                } else if (arguments.length === 1) {
                    previousStroke.call(this, a);
                }
                if (oldStrokeStyle) {
                    this.strokeStyle = oldStrokeStyle;
                }
            };
            /**
             * Same as |fill| above.
             */
            CanvasRenderingContext2D.prototype.fillText = function (text, x, y, maxWidth) {
                var oldFillStyle = null;
                if (this._globalColorMatrix) {
                    oldFillStyle = this.fillStyle;
                    this.fillStyle = transformStyle(this, this.fillStyle, this._globalColorMatrix);
                }
                if (arguments.length === 3) {
                    previousFillText.call(this, text, x, y);
                } else if (arguments.length === 4) {
                    previousFillText.call(this, text, x, y, maxWidth);
                } else {
                    Shumway.Debug.unexpected();
                }
                if (oldFillStyle) {
                    this.fillStyle = oldFillStyle;
                }
            };
            /**
             * Same as |fill| above.
             */
            CanvasRenderingContext2D.prototype.strokeText = function (text, x, y, maxWidth) {
                var oldStrokeStyle = null;
                if (this._globalColorMatrix) {
                    oldStrokeStyle = this.strokeStyle;
                    this.strokeStyle = transformStyle(this, this.strokeStyle, this._globalColorMatrix);
                }
                if (arguments.length === 3) {
                    previousStrokeText.call(this, text, x, y);
                } else if (arguments.length === 4) {
                    previousStrokeText.call(this, text, x, y, maxWidth);
                } else {
                    Shumway.Debug.unexpected();
                }
                if (oldStrokeStyle) {
                    this.strokeStyle = oldStrokeStyle;
                }
            };
        }
        var ScreenShot = function () {
            function ScreenShot(dataURL, w, h, pixelRatio) {
                this.dataURL = dataURL;
                this.w = w;
                this.h = h;
                this.pixelRatio = pixelRatio;    // ...
            }
            return ScreenShot;
        }();
        GFX.ScreenShot = ScreenShot;
    }(GFX = Shumway.GFX || (Shumway.GFX = {})));
    var assert = Shumway.Debug.assert;
    /**
     * Maintains a LRU doubly-linked list.
     */
    var LRUList = function () {
        function LRUList() {
            this._count = 0;
            this._head = this._tail = null;
        }
        Object.defineProperty(LRUList.prototype, 'count', {
            get: function () {
                return this._count;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LRUList.prototype, 'head', {
            /**
             * Gets the node at the front of the list. Returns |null| if the list is empty.
             */
            get: function () {
                return this._head;
            },
            enumerable: true,
            configurable: true
        });
        LRUList.prototype._unshift = function (node) {
            release || assert(!node.next && !node.previous);
            if (this._count === 0) {
                this._head = this._tail = node;
            } else {
                node.next = this._head;
                node.next.previous = node;
                this._head = node;
            }
            this._count++;
        };
        LRUList.prototype._remove = function (node) {
            release || assert(this._count > 0);
            if (node === this._head && node === this._tail) {
                this._head = this._tail = null;
            } else if (node === this._head) {
                this._head = node.next;
                this._head.previous = null;
            } else if (node == this._tail) {
                this._tail = node.previous;
                this._tail.next = null;
            } else {
                node.previous.next = node.next;
                node.next.previous = node.previous;
            }
            node.previous = node.next = null;
            this._count--;
        };
        /**
         * Adds or moves a node to the front of the list.
         */
        LRUList.prototype.use = function (node) {
            if (this._head === node) {
                return;
            }
            if (node.next || node.previous || this._tail === node) {
                this._remove(node);
            }
            this._unshift(node);
        };
        /**
         * Removes a node from the front of the list.
         */
        LRUList.prototype.pop = function () {
            if (!this._tail) {
                return null;
            }
            var node = this._tail;
            this._remove(node);
            return node;
        };
        /**
         * Visits each node in the list in the forward or reverse direction as long as
         * the callback returns |true|;
         */
        LRUList.prototype.visit = function (callback, forward) {
            if (forward === void 0) {
                forward = true;
            }
            var node = forward ? this._head : this._tail;
            while (node) {
                if (!callback(node)) {
                    break;
                }
                node = forward ? node.next : node.previous;
            }
        };
        return LRUList;
    }();
    Shumway.LRUList = LRUList;
    // Registers a default font to render non-spacing and non-marking glyphs for undefined characters in embedded fonts.
    // Embeds the Adobe Blank web font (https://github.com/adobe-fonts/adobe-blank).
    function registerFallbackFont() {
        var style = document.styleSheets[0];
        var rule = '@font-face{font-family:AdobeBlank;src:url("data:font/opentype;base64,T1RUTwAKAIAAAwAgQ0ZGIDTeCDQAACFkAAAZPERTSUcAAAABAABKqAAAAAhPUy8yAF+xmwAAARAAAABgY21hcCRDbtEAAAdcAAAZ6GhlYWQFl9tDAAAArAAAADZoaGVhB1oD7wAAAOQAAAAkaG10eAPoAHwAADqgAAAQBm1heHAIAVAAAAABCAAAAAZuYW1lIE0HkgAAAXAAAAXrcG9zdP+4ADIAACFEAAAAIAABAAAAAQuFfcPHtV8PPPUAAwPoAAAAANFMRfMAAAAA0UxF8wB8/4gDbANwAAAAAwACAAAAAAAAAAEAAANw/4gAAAPoAHwAfANsAAEAAAAAAAAAAAAAAAAAAAACAABQAAgBAAAAAwPoAZAABQAAAooCWAAAAEsCigJYAAABXgAyANwAAAAAAAAAAAAAAAD3/67/+9///w/gAD8AAAAAQURCTwBAAAD//wNw/4gAAANwAHhgLwH/AAAAAAAAAAAAAAAgAAAAAAARANIAAQAAAAAAAQALAAAAAQAAAAAAAgAHAAsAAQAAAAAAAwAbABIAAQAAAAAABAALAAAAAQAAAAAABQA6AC0AAQAAAAAABgAKAGcAAwABBAkAAACUAHEAAwABBAkAAQAWAQUAAwABBAkAAgAOARsAAwABBAkAAwA2ASkAAwABBAkABAAWAQUAAwABBAkABQB0AV8AAwABBAkABgAUAdMAAwABBAkACAA0AecAAwABBAkACwA0AhsAAwABBAkADQKWAk8AAwABBAkADgA0BOVBZG9iZSBCbGFua1JlZ3VsYXIxLjA0NTtBREJPO0Fkb2JlQmxhbms7QURPQkVWZXJzaW9uIDEuMDQ1O1BTIDEuMDQ1O2hvdGNvbnYgMS4wLjgyO21ha2VvdGYubGliMi41LjYzNDA2QWRvYmVCbGFuawBDAG8AcAB5AHIAaQBnAGgAdAAgAKkAIAAyADAAMQAzACwAIAAyADAAMQA1ACAAQQBkAG8AYgBlACAAUwB5AHMAdABlAG0AcwAgAEkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkACAAKABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwApAC4AQQBkAG8AYgBlACAAQgBsAGEAbgBrAFIAZQBnAHUAbABhAHIAMQAuADAANAA1ADsAQQBEAEIATwA7AEEAZABvAGIAZQBCAGwAYQBuAGsAOwBBAEQATwBCAEUAVgBlAHIAcwBpAG8AbgAgADEALgAwADQANQA7AFAAUwAgADEALgAwADQANQA7AGgAbwB0AGMAbwBuAHYAIAAxAC4AMAAuADgAMgA7AG0AYQBrAGUAbwB0AGYALgBsAGkAYgAyAC4ANQAuADYAMwA0ADAANgBBAGQAbwBiAGUAQgBsAGEAbgBrAEEAZABvAGIAZQAgAFMAeQBzAHQAZQBtAHMAIABJAG4AYwBvAHIAcABvAHIAYQB0AGUAZABoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwB0AHkAcABlAC8AVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAgAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAZABpAHMAdAByAGkAYgB1AHQAZQBkACAAbwBuACAAYQBuACAAIgBBAFMAIABJAFMAIgAgAEIAQQBTAEkAUwAsACAAVwBJAFQASABPAFUAVAAgAFcAQQBSAFIAQQBOAFQASQBFAFMAIABPAFIAIABDAE8ATgBEAEkAVABJAE8ATgBTACAATwBGACAAQQBOAFkAIABLAEkATgBEACwAIABlAGkAdABoAGUAcgAgAGUAeABwAHIAZQBzAHMAIABvAHIAIABpAG0AcABsAGkAZQBkAC4AIABTAGUAZQAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUAIABmAG8AcgAgAHQAaABlACAAcwBwAGUAYwBpAGYAaQBjACAAbABhAG4AZwB1AGEAZwBlACwAIABwAGUAcgBtAGkAcwBzAGkAbwBuAHMAIABhAG4AZAAgAGwAaQBtAGkAdABhAHQAaQBvAG4AcwAgAGcAbwB2AGUAcgBuAGkAbgBnACAAeQBvAHUAcgAgAHUAcwBlACAAbwBmACAAdABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUALgBoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwAAAAABQAAAAMAAAA4AAAABAAAAFgAAQAAAAAALAADAAEAAAA4AAMACgAAAFgABgAMAAAAAAABAAAABAAgAAAABAAEAAEAAAf///8AAAAA//8AAQABAAAAAAAMAAAAABmQAAAAAAAAAiAAAAAAAAAH/wAAAAEAAAgAAAAP/wAAAAEAABAAAAAX/wAAAAEAABgAAAAf/wAAAAEAACAAAAAn/wAAAAEAACgAAAAv/wAAAAEAADAAAAA3/wAAAAEAADgAAAA//wAAAAEAAEAAAABH/wAAAAEAAEgAAABP/wAAAAEAAFAAAABX/wAAAAEAAFgAAABf/wAAAAEAAGAAAABn/wAAAAEAAGgAAABv/wAAAAEAAHAAAAB3/wAAAAEAAHgAAAB//wAAAAEAAIAAAACH/wAAAAEAAIgAAACP/wAAAAEAAJAAAACX/wAAAAEAAJgAAACf/wAAAAEAAKAAAACn/wAAAAEAAKgAAACv/wAAAAEAALAAAAC3/wAAAAEAALgAAAC//wAAAAEAAMAAAADH/wAAAAEAAMgAAADP/wAAAAEAANAAAADX/wAAAAEAAOAAAADn/wAAAAEAAOgAAADv/wAAAAEAAPAAAAD3/wAAAAEAAPgAAAD9zwAAAAEAAP3wAAD//QAABfEAAQAAAAEH/wAAAAEAAQgAAAEP/wAAAAEAARAAAAEX/wAAAAEAARgAAAEf/wAAAAEAASAAAAEn/wAAAAEAASgAAAEv/wAAAAEAATAAAAE3/wAAAAEAATgAAAE//wAAAAEAAUAAAAFH/wAAAAEAAUgAAAFP/wAAAAEAAVAAAAFX/wAAAAEAAVgAAAFf/wAAAAEAAWAAAAFn/wAAAAEAAWgAAAFv/wAAAAEAAXAAAAF3/wAAAAEAAXgAAAF//wAAAAEAAYAAAAGH/wAAAAEAAYgAAAGP/wAAAAEAAZAAAAGX/wAAAAEAAZgAAAGf/wAAAAEAAaAAAAGn/wAAAAEAAagAAAGv/wAAAAEAAbAAAAG3/wAAAAEAAbgAAAG//wAAAAEAAcAAAAHH/wAAAAEAAcgAAAHP/wAAAAEAAdAAAAHX/wAAAAEAAdgAAAHf/wAAAAEAAeAAAAHn/wAAAAEAAegAAAHv/wAAAAEAAfAAAAH3/wAAAAEAAfgAAAH//QAAAAEAAgAAAAIH/wAAAAEAAggAAAIP/wAAAAEAAhAAAAIX/wAAAAEAAhgAAAIf/wAAAAEAAiAAAAIn/wAAAAEAAigAAAIv/wAAAAEAAjAAAAI3/wAAAAEAAjgAAAI//wAAAAEAAkAAAAJH/wAAAAEAAkgAAAJP/wAAAAEAAlAAAAJX/wAAAAEAAlgAAAJf/wAAAAEAAmAAAAJn/wAAAAEAAmgAAAJv/wAAAAEAAnAAAAJ3/wAAAAEAAngAAAJ//wAAAAEAAoAAAAKH/wAAAAEAAogAAAKP/wAAAAEAApAAAAKX/wAAAAEAApgAAAKf/wAAAAEAAqAAAAKn/wAAAAEAAqgAAAKv/wAAAAEAArAAAAK3/wAAAAEAArgAAAK//wAAAAEAAsAAAALH/wAAAAEAAsgAAALP/wAAAAEAAtAAAALX/wAAAAEAAtgAAALf/wAAAAEAAuAAAALn/wAAAAEAAugAAALv/wAAAAEAAvAAAAL3/wAAAAEAAvgAAAL//QAAAAEAAwAAAAMH/wAAAAEAAwgAAAMP/wAAAAEAAxAAAAMX/wAAAAEAAxgAAAMf/wAAAAEAAyAAAAMn/wAAAAEAAygAAAMv/wAAAAEAAzAAAAM3/wAAAAEAAzgAAAM//wAAAAEAA0AAAANH/wAAAAEAA0gAAANP/wAAAAEAA1AAAANX/wAAAAEAA1gAAANf/wAAAAEAA2AAAANn/wAAAAEAA2gAAANv/wAAAAEAA3AAAAN3/wAAAAEAA3gAAAN//wAAAAEAA4AAAAOH/wAAAAEAA4gAAAOP/wAAAAEAA5AAAAOX/wAAAAEAA5gAAAOf/wAAAAEAA6AAAAOn/wAAAAEAA6gAAAOv/wAAAAEAA7AAAAO3/wAAAAEAA7gAAAO//wAAAAEAA8AAAAPH/wAAAAEAA8gAAAPP/wAAAAEAA9AAAAPX/wAAAAEAA9gAAAPf/wAAAAEAA+AAAAPn/wAAAAEAA+gAAAPv/wAAAAEAA/AAAAP3/wAAAAEAA/gAAAP//QAAAAEABAAAAAQH/wAAAAEABAgAAAQP/wAAAAEABBAAAAQX/wAAAAEABBgAAAQf/wAAAAEABCAAAAQn/wAAAAEABCgAAAQv/wAAAAEABDAAAAQ3/wAAAAEABDgAAAQ//wAAAAEABEAAAARH/wAAAAEABEgAAARP/wAAAAEABFAAAARX/wAAAAEABFgAAARf/wAAAAEABGAAAARn/wAAAAEABGgAAARv/wAAAAEABHAAAAR3/wAAAAEABHgAAAR//wAAAAEABIAAAASH/wAAAAEABIgAAASP/wAAAAEABJAAAASX/wAAAAEABJgAAASf/wAAAAEABKAAAASn/wAAAAEABKgAAASv/wAAAAEABLAAAAS3/wAAAAEABLgAAAS//wAAAAEABMAAAATH/wAAAAEABMgAAATP/wAAAAEABNAAAATX/wAAAAEABNgAAATf/wAAAAEABOAAAATn/wAAAAEABOgAAATv/wAAAAEABPAAAAT3/wAAAAEABPgAAAT//QAAAAEABQAAAAUH/wAAAAEABQgAAAUP/wAAAAEABRAAAAUX/wAAAAEABRgAAAUf/wAAAAEABSAAAAUn/wAAAAEABSgAAAUv/wAAAAEABTAAAAU3/wAAAAEABTgAAAU//wAAAAEABUAAAAVH/wAAAAEABUgAAAVP/wAAAAEABVAAAAVX/wAAAAEABVgAAAVf/wAAAAEABWAAAAVn/wAAAAEABWgAAAVv/wAAAAEABXAAAAV3/wAAAAEABXgAAAV//wAAAAEABYAAAAWH/wAAAAEABYgAAAWP/wAAAAEABZAAAAWX/wAAAAEABZgAAAWf/wAAAAEABaAAAAWn/wAAAAEABagAAAWv/wAAAAEABbAAAAW3/wAAAAEABbgAAAW//wAAAAEABcAAAAXH/wAAAAEABcgAAAXP/wAAAAEABdAAAAXX/wAAAAEABdgAAAXf/wAAAAEABeAAAAXn/wAAAAEABegAAAXv/wAAAAEABfAAAAX3/wAAAAEABfgAAAX//QAAAAEABgAAAAYH/wAAAAEABggAAAYP/wAAAAEABhAAAAYX/wAAAAEABhgAAAYf/wAAAAEABiAAAAYn/wAAAAEABigAAAYv/wAAAAEABjAAAAY3/wAAAAEABjgAAAY//wAAAAEABkAAAAZH/wAAAAEABkgAAAZP/wAAAAEABlAAAAZX/wAAAAEABlgAAAZf/wAAAAEABmAAAAZn/wAAAAEABmgAAAZv/wAAAAEABnAAAAZ3/wAAAAEABngAAAZ//wAAAAEABoAAAAaH/wAAAAEABogAAAaP/wAAAAEABpAAAAaX/wAAAAEABpgAAAaf/wAAAAEABqAAAAan/wAAAAEABqgAAAav/wAAAAEABrAAAAa3/wAAAAEABrgAAAa//wAAAAEABsAAAAbH/wAAAAEABsgAAAbP/wAAAAEABtAAAAbX/wAAAAEABtgAAAbf/wAAAAEABuAAAAbn/wAAAAEABugAAAbv/wAAAAEABvAAAAb3/wAAAAEABvgAAAb//QAAAAEABwAAAAcH/wAAAAEABwgAAAcP/wAAAAEABxAAAAcX/wAAAAEABxgAAAcf/wAAAAEAByAAAAcn/wAAAAEABygAAAcv/wAAAAEABzAAAAc3/wAAAAEABzgAAAc//wAAAAEAB0AAAAdH/wAAAAEAB0gAAAdP/wAAAAEAB1AAAAdX/wAAAAEAB1gAAAdf/wAAAAEAB2AAAAdn/wAAAAEAB2gAAAdv/wAAAAEAB3AAAAd3/wAAAAEAB3gAAAd//wAAAAEAB4AAAAeH/wAAAAEAB4gAAAeP/wAAAAEAB5AAAAeX/wAAAAEAB5gAAAef/wAAAAEAB6AAAAen/wAAAAEAB6gAAAev/wAAAAEAB7AAAAe3/wAAAAEAB7gAAAe//wAAAAEAB8AAAAfH/wAAAAEAB8gAAAfP/wAAAAEAB9AAAAfX/wAAAAEAB9gAAAff/wAAAAEAB+AAAAfn/wAAAAEAB+gAAAfv/wAAAAEAB/AAAAf3/wAAAAEAB/gAAAf//QAAAAEACAAAAAgH/wAAAAEACAgAAAgP/wAAAAEACBAAAAgX/wAAAAEACBgAAAgf/wAAAAEACCAAAAgn/wAAAAEACCgAAAgv/wAAAAEACDAAAAg3/wAAAAEACDgAAAg//wAAAAEACEAAAAhH/wAAAAEACEgAAAhP/wAAAAEACFAAAAhX/wAAAAEACFgAAAhf/wAAAAEACGAAAAhn/wAAAAEACGgAAAhv/wAAAAEACHAAAAh3/wAAAAEACHgAAAh//wAAAAEACIAAAAiH/wAAAAEACIgAAAiP/wAAAAEACJAAAAiX/wAAAAEACJgAAAif/wAAAAEACKAAAAin/wAAAAEACKgAAAiv/wAAAAEACLAAAAi3/wAAAAEACLgAAAi//wAAAAEACMAAAAjH/wAAAAEACMgAAAjP/wAAAAEACNAAAAjX/wAAAAEACNgAAAjf/wAAAAEACOAAAAjn/wAAAAEACOgAAAjv/wAAAAEACPAAAAj3/wAAAAEACPgAAAj//QAAAAEACQAAAAkH/wAAAAEACQgAAAkP/wAAAAEACRAAAAkX/wAAAAEACRgAAAkf/wAAAAEACSAAAAkn/wAAAAEACSgAAAkv/wAAAAEACTAAAAk3/wAAAAEACTgAAAk//wAAAAEACUAAAAlH/wAAAAEACUgAAAlP/wAAAAEACVAAAAlX/wAAAAEACVgAAAlf/wAAAAEACWAAAAln/wAAAAEACWgAAAlv/wAAAAEACXAAAAl3/wAAAAEACXgAAAl//wAAAAEACYAAAAmH/wAAAAEACYgAAAmP/wAAAAEACZAAAAmX/wAAAAEACZgAAAmf/wAAAAEACaAAAAmn/wAAAAEACagAAAmv/wAAAAEACbAAAAm3/wAAAAEACbgAAAm//wAAAAEACcAAAAnH/wAAAAEACcgAAAnP/wAAAAEACdAAAAnX/wAAAAEACdgAAAnf/wAAAAEACeAAAAnn/wAAAAEACegAAAnv/wAAAAEACfAAAAn3/wAAAAEACfgAAAn//QAAAAEACgAAAAoH/wAAAAEACggAAAoP/wAAAAEAChAAAAoX/wAAAAEAChgAAAof/wAAAAEACiAAAAon/wAAAAEACigAAAov/wAAAAEACjAAAAo3/wAAAAEACjgAAAo//wAAAAEACkAAAApH/wAAAAEACkgAAApP/wAAAAEAClAAAApX/wAAAAEAClgAAApf/wAAAAEACmAAAApn/wAAAAEACmgAAApv/wAAAAEACnAAAAp3/wAAAAEACngAAAp//wAAAAEACoAAAAqH/wAAAAEACogAAAqP/wAAAAEACpAAAAqX/wAAAAEACpgAAAqf/wAAAAEACqAAAAqn/wAAAAEACqgAAAqv/wAAAAEACrAAAAq3/wAAAAEACrgAAAq//wAAAAEACsAAAArH/wAAAAEACsgAAArP/wAAAAEACtAAAArX/wAAAAEACtgAAArf/wAAAAEACuAAAArn/wAAAAEACugAAArv/wAAAAEACvAAAAr3/wAAAAEACvgAAAr//QAAAAEACwAAAAsH/wAAAAEACwgAAAsP/wAAAAEACxAAAAsX/wAAAAEACxgAAAsf/wAAAAEACyAAAAsn/wAAAAEACygAAAsv/wAAAAEACzAAAAs3/wAAAAEACzgAAAs//wAAAAEAC0AAAAtH/wAAAAEAC0gAAAtP/wAAAAEAC1AAAAtX/wAAAAEAC1gAAAtf/wAAAAEAC2AAAAtn/wAAAAEAC2gAAAtv/wAAAAEAC3AAAAt3/wAAAAEAC3gAAAt//wAAAAEAC4AAAAuH/wAAAAEAC4gAAAuP/wAAAAEAC5AAAAuX/wAAAAEAC5gAAAuf/wAAAAEAC6AAAAun/wAAAAEAC6gAAAuv/wAAAAEAC7AAAAu3/wAAAAEAC7gAAAu//wAAAAEAC8AAAAvH/wAAAAEAC8gAAAvP/wAAAAEAC9AAAAvX/wAAAAEAC9gAAAvf/wAAAAEAC+AAAAvn/wAAAAEAC+gAAAvv/wAAAAEAC/AAAAv3/wAAAAEAC/gAAAv//QAAAAEADAAAAAwH/wAAAAEADAgAAAwP/wAAAAEADBAAAAwX/wAAAAEADBgAAAwf/wAAAAEADCAAAAwn/wAAAAEADCgAAAwv/wAAAAEADDAAAAw3/wAAAAEADDgAAAw//wAAAAEADEAAAAxH/wAAAAEADEgAAAxP/wAAAAEADFAAAAxX/wAAAAEADFgAAAxf/wAAAAEADGAAAAxn/wAAAAEADGgAAAxv/wAAAAEADHAAAAx3/wAAAAEADHgAAAx//wAAAAEADIAAAAyH/wAAAAEADIgAAAyP/wAAAAEADJAAAAyX/wAAAAEADJgAAAyf/wAAAAEADKAAAAyn/wAAAAEADKgAAAyv/wAAAAEADLAAAAy3/wAAAAEADLgAAAy//wAAAAEADMAAAAzH/wAAAAEADMgAAAzP/wAAAAEADNAAAAzX/wAAAAEADNgAAAzf/wAAAAEADOAAAAzn/wAAAAEADOgAAAzv/wAAAAEADPAAAAz3/wAAAAEADPgAAAz//QAAAAEADQAAAA0H/wAAAAEADQgAAA0P/wAAAAEADRAAAA0X/wAAAAEADRgAAA0f/wAAAAEADSAAAA0n/wAAAAEADSgAAA0v/wAAAAEADTAAAA03/wAAAAEADTgAAA0//wAAAAEADUAAAA1H/wAAAAEADUgAAA1P/wAAAAEADVAAAA1X/wAAAAEADVgAAA1f/wAAAAEADWAAAA1n/wAAAAEADWgAAA1v/wAAAAEADXAAAA13/wAAAAEADXgAAA1//wAAAAEADYAAAA2H/wAAAAEADYgAAA2P/wAAAAEADZAAAA2X/wAAAAEADZgAAA2f/wAAAAEADaAAAA2n/wAAAAEADagAAA2v/wAAAAEADbAAAA23/wAAAAEADbgAAA2//wAAAAEADcAAAA3H/wAAAAEADcgAAA3P/wAAAAEADdAAAA3X/wAAAAEADdgAAA3f/wAAAAEADeAAAA3n/wAAAAEADegAAA3v/wAAAAEADfAAAA33/wAAAAEADfgAAA3//QAAAAEADgAAAA4H/wAAAAEADggAAA4P/wAAAAEADhAAAA4X/wAAAAEADhgAAA4f/wAAAAEADiAAAA4n/wAAAAEADigAAA4v/wAAAAEADjAAAA43/wAAAAEADjgAAA4//wAAAAEADkAAAA5H/wAAAAEADkgAAA5P/wAAAAEADlAAAA5X/wAAAAEADlgAAA5f/wAAAAEADmAAAA5n/wAAAAEADmgAAA5v/wAAAAEADnAAAA53/wAAAAEADngAAA5//wAAAAEADoAAAA6H/wAAAAEADogAAA6P/wAAAAEADpAAAA6X/wAAAAEADpgAAA6f/wAAAAEADqAAAA6n/wAAAAEADqgAAA6v/wAAAAEADrAAAA63/wAAAAEADrgAAA6//wAAAAEADsAAAA7H/wAAAAEADsgAAA7P/wAAAAEADtAAAA7X/wAAAAEADtgAAA7f/wAAAAEADuAAAA7n/wAAAAEADugAAA7v/wAAAAEADvAAAA73/wAAAAEADvgAAA7//QAAAAEADwAAAA8H/wAAAAEADwgAAA8P/wAAAAEADxAAAA8X/wAAAAEADxgAAA8f/wAAAAEADyAAAA8n/wAAAAEADygAAA8v/wAAAAEADzAAAA83/wAAAAEADzgAAA8//wAAAAEAD0AAAA9H/wAAAAEAD0gAAA9P/wAAAAEAD1AAAA9X/wAAAAEAD1gAAA9f/wAAAAEAD2AAAA9n/wAAAAEAD2gAAA9v/wAAAAEAD3AAAA93/wAAAAEAD3gAAA9//wAAAAEAD4AAAA+H/wAAAAEAD4gAAA+P/wAAAAEAD5AAAA+X/wAAAAEAD5gAAA+f/wAAAAEAD6AAAA+n/wAAAAEAD6gAAA+v/wAAAAEAD7AAAA+3/wAAAAEAD7gAAA+//wAAAAEAD8AAAA/H/wAAAAEAD8gAAA/P/wAAAAEAD9AAAA/X/wAAAAEAD9gAAA/f/wAAAAEAD+AAAA/n/wAAAAEAD+gAAA/v/wAAAAEAD/AAAA/3/wAAAAEAD/gAAA///QAAAAEAEAAAABAH/wAAAAEAEAgAABAP/wAAAAEAEBAAABAX/wAAAAEAEBgAABAf/wAAAAEAECAAABAn/wAAAAEAECgAABAv/wAAAAEAEDAAABA3/wAAAAEAEDgAABA//wAAAAEAEEAAABBH/wAAAAEAEEgAABBP/wAAAAEAEFAAABBX/wAAAAEAEFgAABBf/wAAAAEAEGAAABBn/wAAAAEAEGgAABBv/wAAAAEAEHAAABB3/wAAAAEAEHgAABB//wAAAAEAEIAAABCH/wAAAAEAEIgAABCP/wAAAAEAEJAAABCX/wAAAAEAEJgAABCf/wAAAAEAEKAAABCn/wAAAAEAEKgAABCv/wAAAAEAELAAABC3/wAAAAEAELgAABC//wAAAAEAEMAAABDH/wAAAAEAEMgAABDP/wAAAAEAENAAABDX/wAAAAEAENgAABDf/wAAAAEAEOAAABDn/wAAAAEAEOgAABDv/wAAAAEAEPAAABD3/wAAAAEAEPgAABD//QAAAAEAAwAAAAAAAP+1ADIAAAAAAAAAAAAAAAAAAAAAAAAAAAEABAIAAQEBC0Fkb2JlQmxhbmsAAQEBMPgb+ByLDB74HQH4HgKL+wz6APoEBR4aBF8MHxwIAQwi91UP92IR91oMJRwZHwwkAAUBAQYOVmFwQWRvYmVJZGVudGl0eUNvcHlyaWdodCAyMDEzLCAyMDE1IEFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkIChodHRwOi8vd3d3LmFkb2JlLmNvbS8pLkFkb2JlIEJsYW5rQWRvYmVCbGFuay0yMDQ5AAACAAEH/wMAAQAAAAgBCAECAAEASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wEAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwI4AjkCOgI7AjwCPQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDogOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DzwPQA9ED0gPTA9QD1QPWA9cD2APZA9oD2wPcA90D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA+8D8APxA/ID8wP0A/UD9gP3A/gD+QP6A/sD/AP9A/4D/wQABAEEAgQDBAQEBQQGBAcECAQJBAoECwQMBA0EDgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmBGcEaARpBGoEawRsBG0EbgRvBHAEcQRyBHMEdAR1BHYEdwR4BHkEegR7BHwEfQR+BH8EgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBJQElQSWBJcEmASZBJoEmwScBJ0EngSfBKAEoQSiBKMEpASlBKYEpwSoBKkEqgSrBKwErQSuBK8EsASxBLIEswS0BLUEtgS3BLgEuQS6BLsEvAS9BL4EvwTABMEEwgTDBMQExQTGBMcEyATJBMoEywTMBM0EzgTPBNAE0QTSBNME1ATVBNYE1wTYBNkE2gTbBNwE3QTeBN8E4AThBOIE4wTkBOUE5gTnBOgE6QTqBOsE7ATtBO4E7wTwBPEE8gTzBPQE9QT2BPcE+AT5BPoE+wT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBQwFDQUOBQ8FEAURBRIFEwUUBRUFFgUXBRgFGQUaBRsFHAUdBR4FHwUgBSEFIgUjBSQFJQUmBScFKAUpBSoFKwUsBS0FLgUvBTAFMQUyBTMFNAU1BTYFNwU4BTkFOgU7BTwFPQU+BT8FQAVBBUIFQwVEBUUFRgVHBUgFSQVKBUsFTAVNBU4FTwVQBVEFUgVTBVQFVQVWBVcFWAVZBVoFWwVcBV0FXgVfBWAFYQViBWMFZAVlBWYFZwVoBWkFagVrBWwFbQVuBW8FcAVxBXIFcwV0BXUFdgV3BXgFeQV6BXsFfAV9BX4FfwWABYEFggWDBYQFhQWGBYcFiAWJBYoFiwWMBY0FjgWPBZAFkQWSBZMFlAWVBZYFlwWYBZkFmgWbBZwFnQWeBZ8FoAWhBaIFowWkBaUFpgWnBagFqQWqBasFrAWtBa4FrwWwBbEFsgWzBbQFtQW2BbcFuAW5BboFuwW8Bb0FvgW/BcAFwQXCBcMFxAXFBcYFxwXIBckFygXLBcwFzQXOBc8F0AXRBdIF0wXUBdUF1gXXBdgF2QXaBdsF3AXdBd4F3wXgBeEF4gXjBeQF5QXmBecF6AXpBeoF6wXsBe0F7gXvBfAF8QXyBfMF9AX1BfYF9wX4BfkF+gX7BfwF/QX+Bf8GAAYBBgIGAwYEBgUGBgYHBggGCQYKBgsGDAYNBg4GDwYQBhEGEgYTBhQGFQYWBhcGGAYZBhoGGwYcBh0GHgYfBiAGIQYiBiMGJAYlBiYGJwYoBikGKgYrBiwGLQYuBi8GMAYxBjIGMwY0BjUGNgY3BjgGOQY6BjsGPAY9Bj4GPwZABkEGQgZDBkQGRQZGBkcGSAZJBkoGSwZMBk0GTgZPBlAGUQZSBlMGVAZVBlYGVwZYBlkGWgZbBlwGXQZeBl8GYAZhBmIGYwZkBmUGZgZnBmgGaQZqBmsGbAZtBm4GbwZwBnEGcgZzBnQGdQZ2BncGeAZ5BnoGewZ8Bn0GfgZ/BoAGgQaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GkAaRBpIGkwaUBpUGlgaXBpgGmQaaBpsGnAadBp4GnwagBqEGogajBqQGpQamBqcGqAapBqoGqwasBq0GrgavBrAGsQayBrMGtAa1BrYGtwa4BrkGuga7BrwGvQa+Br8GwAbBBsIGwwbEBsUGxgbHBsgGyQbKBssGzAbNBs4GzwbQBtEG0gbTBtQG1QbWBtcG2AbZBtoG2wbcBt0G3gbfBuAG4QbiBuMG5AblBuYG5wboBukG6gbrBuwG7QbuBu8G8AbxBvIG8wb0BvUG9gb3BvgG+Qb6BvsG/Ab9Bv4G/wcABwEHAgcDBwQHBQcGBwcHCAcJBwoHCwcMBw0HDgcPBxAHEQcSBxMHFAcVBxYHFwcYBxkHGgcbBxwHHQceBx8HIAchByIHIwckByUHJgcnBygHKQcqBysHLActBy4HLwcwBzEHMgczBzQHNQc2BzcHOAc5BzoHOwc8Bz0HPgc/B0AHQQdCB0MHRAdFB0YHRwdIB0kHSgdLB0wHTQdOB08HUAdRB1IHUwdUB1UHVgdXB1gHWQdaB1sHXAddB14HXwdgB2EHYgdjB2QHZQdmB2cHaAdpB2oHawdsB20HbgdvB3AHcQdyB3MHdAd1B3YHdwd4B3kHegd7B3wHfQd+B38HgAeBB4IHgweEB4UHhgeHB4gHiQeKB4sHjAeNB44HjweQB5EHkgeTB5QHlQeWB5cHmAeZB5oHmwecB50HngefB6AHoQeiB6MHpAelB6YHpweoB6kHqgerB6wHrQeuB68HsAexB7IHswe0B7UHtge3B7gHuQe6B7sHvAe9B74HvwfAB8EHwgfDB8QHxQfGB8cHyAfJB8oHywfMB80HzgfPB9AH0QfSB9MH1AfVB9YH1wfYB9kH2gfbB9wH3QfeB98H4AfhB+IH4wfkB+UH5gfnB+gH6QfqB+sH7AftB+4H7wfwB/EH8gfzB/QH9Qf2B/cH+Af5B/oH+wf8B/0H/gf/CAAIAQgCCAMIBAgFCAYIBwgICAkICggLCAwIDQgOCA8IEAgRCBIIEwgUCBUIFggXCBgIGQgaCBsIHAgdCB4IHwggCCEIIggjCCQIJQgmCCcIKAgpCCoIKwgsCC0ILggvCDAIMQgyCDMINAg1CDYINwg4CDkIOgg7CDwIPQg+CD8IQAhBCEIIQwhECEUIRghHCEgISQhKCEsg+wy3+iS3AfcQt/kstwP3EPoEFf58+YT6fAf9WP4nFfnSB/fF/DMFprAV+8X4NwX49gamYhX90gf7xfgzBXBmFffF/DcF/PYGDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OAAEBAQr4HwwmmhwZLRL7joscBUaLBr0KvQv65xUD6AB8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA==");}';
        style.insertRule(rule, style.cssRules.length);
    }
    Shumway.registerFallbackFont = registerFallbackFont;
    var GFX;
    (function (GFX) {
        var Option = Shumway.Options.Option;
        var OptionSet = Shumway.Options.OptionSet;
        var shumwayOptions = Shumway.Settings.shumwayOptions;
        var rendererOptions = shumwayOptions.register(new OptionSet('Renderer Options'));
        GFX.imageUpdateOption = rendererOptions.register(new Option('', 'imageUpdate', 'boolean', true, 'Enable image updating.'));
        GFX.imageConvertOption = rendererOptions.register(new Option('', 'imageConvert', 'boolean', true, 'Enable image conversion.'));
        GFX.stageOptions = shumwayOptions.register(new OptionSet('Stage Renderer Options'));
        GFX.forcePaint = GFX.stageOptions.register(new Option('', 'forcePaint', 'boolean', false, 'Force repainting.'));
        GFX.ignoreViewport = GFX.stageOptions.register(new Option('', 'ignoreViewport', 'boolean', false, 'Cull elements outside of the viewport.'));
        GFX.viewportLoupeDiameter = GFX.stageOptions.register(new Option('', 'viewportLoupeDiameter', 'number', 256, 'Size of the viewport loupe.', {
            range: {
                min: 1,
                max: 1024,
                step: 1
            }
        }));
        GFX.disableClipping = GFX.stageOptions.register(new Option('', 'disableClipping', 'boolean', false, 'Disable clipping.'));
        GFX.debugClipping = GFX.stageOptions.register(new Option('', 'debugClipping', 'boolean', false, 'Disable clipping.'));
        GFX.hud = GFX.stageOptions.register(new Option('', 'hud', 'boolean', false, 'Enable HUD.'));
        var canvas2DOptions = GFX.stageOptions.register(new OptionSet('Canvas2D Options'));
        GFX.clipDirtyRegions = canvas2DOptions.register(new Option('', 'clipDirtyRegions', 'boolean', false, 'Clip dirty regions.'));
        GFX.clipCanvas = canvas2DOptions.register(new Option('', 'clipCanvas', 'boolean', false, 'Clip Regions.'));
        GFX.cull = canvas2DOptions.register(new Option('', 'cull', 'boolean', false, 'Enable culling.'));
        GFX.snapToDevicePixels = canvas2DOptions.register(new Option('', 'snapToDevicePixels', 'boolean', false, ''));
        GFX.imageSmoothing = canvas2DOptions.register(new Option('', 'imageSmoothing', 'boolean', false, ''));
        GFX.masking = canvas2DOptions.register(new Option('', 'masking', 'boolean', true, 'Composite Mask.'));
        GFX.blending = canvas2DOptions.register(new Option('', 'blending', 'boolean', true, ''));
        GFX.debugLayers = canvas2DOptions.register(new Option('', 'debugLayers', 'boolean', false, ''));
        GFX.filters = canvas2DOptions.register(new Option('', 'filters', 'boolean', true, ''));
        GFX.cacheShapes = canvas2DOptions.register(new Option('', 'cacheShapes', 'boolean', true, ''));
        GFX.cacheShapesMaxSize = canvas2DOptions.register(new Option('', 'cacheShapesMaxSize', 'number', 256, '', {
            range: {
                min: 1,
                max: 1024,
                step: 1
            }
        }));
        GFX.cacheShapesThreshold = canvas2DOptions.register(new Option('', 'cacheShapesThreshold', 'number', 256, '', {
            range: {
                min: 1,
                max: 1024,
                step: 1
            }
        }));
        var Geometry;
        (function (Geometry) {
            var clamp = Shumway.NumberUtilities.clamp;
            var pow2 = Shumway.NumberUtilities.pow2;
            var epsilonEquals = Shumway.NumberUtilities.epsilonEquals;
            var assert = Shumway.Debug.assert;
            function radianToDegrees(r) {
                return r * 180 / Math.PI;
            }
            Geometry.radianToDegrees = radianToDegrees;
            function degreesToRadian(d) {
                return d * Math.PI / 180;
            }
            Geometry.degreesToRadian = degreesToRadian;
            var E = 0.0001;
            function eqFloat(a, b) {
                return Math.abs(a - b) < E;
            }
            var Point = function () {
                function Point(x, y) {
                    this.x = x;
                    this.y = y;
                }
                Point.prototype.setElements = function (x, y) {
                    this.x = x;
                    this.y = y;
                    return this;
                };
                Point.prototype.set = function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    return this;
                };
                Point.prototype.dot = function (other) {
                    return this.x * other.x + this.y * other.y;
                };
                Point.prototype.squaredLength = function () {
                    return this.dot(this);
                };
                Point.prototype.distanceTo = function (other) {
                    return Math.sqrt(this.dot(other));
                };
                Point.prototype.sub = function (other) {
                    this.x -= other.x;
                    this.y -= other.y;
                    return this;
                };
                Point.prototype.mul = function (value) {
                    this.x *= value;
                    this.y *= value;
                    return this;
                };
                Point.prototype.clone = function () {
                    return new Point(this.x, this.y);
                };
                Point.prototype.toString = function (digits) {
                    if (digits === void 0) {
                        digits = 2;
                    }
                    return '{x: ' + this.x.toFixed(digits) + ', y: ' + this.y.toFixed(digits) + '}';
                };
                Point.prototype.inTriangle = function (a, b, c) {
                    var s = a.y * c.x - a.x * c.y + (c.y - a.y) * this.x + (a.x - c.x) * this.y;
                    var t = a.x * b.y - a.y * b.x + (a.y - b.y) * this.x + (b.x - a.x) * this.y;
                    if (s < 0 != t < 0) {
                        return false;
                    }
                    var T = -b.y * c.x + a.y * (c.x - b.x) + a.x * (b.y - c.y) + b.x * c.y;
                    if (T < 0) {
                        s = -s;
                        t = -t;
                        T = -T;
                    }
                    return s > 0 && t > 0 && s + t < T;
                };
                Point.createEmpty = function () {
                    return new Point(0, 0);
                };
                Point.createEmptyPoints = function (count) {
                    var result = [];
                    for (var i = 0; i < count; i++) {
                        result.push(new Point(0, 0));
                    }
                    return result;
                };
                return Point;
            }();
            Geometry.Point = Point;
            var Rectangle = function () {
                function Rectangle(x, y, w, h) {
                    this.setElements(x, y, w, h);
                    Rectangle.allocationCount++;
                }
                Rectangle.prototype.setElements = function (x, y, w, h) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                };
                Rectangle.prototype.set = function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    this.w = other.w;
                    this.h = other.h;
                };
                Rectangle.prototype.contains = function (other) {
                    var r1 = other.x + other.w;
                    var b1 = other.y + other.h;
                    var r2 = this.x + this.w;
                    var b2 = this.y + this.h;
                    return other.x >= this.x && other.x < r2 && other.y >= this.y && other.y < b2 && r1 > this.x && r1 <= r2 && b1 > this.y && b1 <= b2;
                };
                Rectangle.prototype.containsPoint = function (point) {
                    return point.x >= this.x && point.x < this.x + this.w && point.y >= this.y && point.y < this.y + this.h;
                };
                Rectangle.prototype.isContained = function (others) {
                    for (var i = 0; i < others.length; i++) {
                        if (others[i].contains(this)) {
                            return true;
                        }
                    }
                    return false;
                };
                Rectangle.prototype.isSmallerThan = function (other) {
                    return this.w < other.w && this.h < other.h;
                };
                Rectangle.prototype.isLargerThan = function (other) {
                    return this.w > other.w && this.h > other.h;
                };
                Rectangle.prototype.union = function (other) {
                    if (this.isEmpty()) {
                        this.set(other);
                        return;
                    } else if (other.isEmpty()) {
                        return;
                    }
                    var x = this.x, y = this.y;
                    if (this.x > other.x) {
                        x = other.x;
                    }
                    if (this.y > other.y) {
                        y = other.y;
                    }
                    var x0 = this.x + this.w;
                    if (x0 < other.x + other.w) {
                        x0 = other.x + other.w;
                    }
                    var y0 = this.y + this.h;
                    if (y0 < other.y + other.h) {
                        y0 = other.y + other.h;
                    }
                    this.x = x;
                    this.y = y;
                    this.w = x0 - x;
                    this.h = y0 - y;
                };
                Rectangle.prototype.isEmpty = function () {
                    return this.w <= 0 || this.h <= 0;
                };
                Rectangle.prototype.setEmpty = function () {
                    this.x = 0;
                    this.y = 0;
                    this.w = 0;
                    this.h = 0;
                };
                Rectangle.prototype.intersect = function (other) {
                    var result = Rectangle.createEmpty();
                    if (this.isEmpty() || other.isEmpty()) {
                        result.setEmpty();
                        return result;
                    }
                    result.x = Math.max(this.x, other.x);
                    result.y = Math.max(this.y, other.y);
                    result.w = Math.min(this.x + this.w, other.x + other.w) - result.x;
                    result.h = Math.min(this.y + this.h, other.y + other.h) - result.y;
                    if (result.isEmpty()) {
                        result.setEmpty();
                    }
                    this.set(result);
                };
                Rectangle.prototype.intersects = function (other) {
                    if (this.isEmpty() || other.isEmpty()) {
                        return false;
                    }
                    var x = Math.max(this.x, other.x);
                    var y = Math.max(this.y, other.y);
                    var w = Math.min(this.x + this.w, other.x + other.w) - x;
                    var h = Math.min(this.y + this.h, other.y + other.h) - y;
                    return !(w <= 0 || h <= 0);
                };
                /**
                 * Tests if this rectangle intersects the AABB of the given rectangle.
                 */
                Rectangle.prototype.intersectsTransformedAABB = function (other, matrix) {
                    var rectangle = Rectangle._temporary;
                    rectangle.set(other);
                    matrix.transformRectangleAABB(rectangle);
                    return this.intersects(rectangle);
                };
                Rectangle.prototype.intersectsTranslated = function (other, tx, ty) {
                    if (this.isEmpty() || other.isEmpty()) {
                        return false;
                    }
                    var x = Math.max(this.x, other.x + tx);
                    var y = Math.max(this.y, other.y + ty);
                    var w = Math.min(this.x + this.w, other.x + tx + other.w) - x;
                    var h = Math.min(this.y + this.h, other.y + ty + other.h) - y;
                    return !(w <= 0 || h <= 0);
                };
                Rectangle.prototype.area = function () {
                    return this.w * this.h;
                };
                Rectangle.prototype.clone = function () {
                    var rectangle = Rectangle.allocate();
                    rectangle.set(this);
                    return rectangle;
                };
                Rectangle.allocate = function () {
                    var dirtyStack = Rectangle._dirtyStack;
                    if (dirtyStack.length) {
                        return dirtyStack.pop();
                    } else {
                        return new Rectangle(12345, 67890, 12345, 67890);
                    }
                };
                Rectangle.prototype.free = function () {
                    Rectangle._dirtyStack.push(this);
                };
                /**
                 * Snaps the rectangle to pixel boundaries. The computed rectangle covers
                 * the original rectangle.
                 */
                Rectangle.prototype.snap = function () {
                    var x1 = Math.ceil(this.x + this.w);
                    var y1 = Math.ceil(this.y + this.h);
                    this.x = Math.floor(this.x);
                    this.y = Math.floor(this.y);
                    this.w = x1 - this.x;
                    this.h = y1 - this.y;
                    return this;
                };
                Rectangle.prototype.scale = function (x, y) {
                    this.x *= x;
                    this.y *= y;
                    this.w *= x;
                    this.h *= y;
                    return this;
                };
                Rectangle.prototype.offset = function (x, y) {
                    this.x += x;
                    this.y += y;
                    return this;
                };
                Rectangle.prototype.resize = function (w, h) {
                    this.w += w;
                    this.h += h;
                    return this;
                };
                Rectangle.prototype.expand = function (w, h) {
                    this.offset(-w, -h).resize(2 * w, 2 * h);
                    return this;
                };
                Rectangle.prototype.getCenter = function () {
                    return new Point(this.x + this.w / 2, this.y + this.h / 2);
                };
                Rectangle.prototype.getAbsoluteBounds = function () {
                    return new Rectangle(0, 0, this.w, this.h);
                };
                Rectangle.prototype.toString = function (digits) {
                    if (digits === void 0) {
                        digits = 2;
                    }
                    return '{' + this.x.toFixed(digits) + ', ' + this.y.toFixed(digits) + ', ' + this.w.toFixed(digits) + ', ' + this.h.toFixed(digits) + '}';
                };
                Rectangle.createEmpty = function () {
                    var rectangle = Rectangle.allocate();
                    rectangle.setEmpty();
                    return rectangle;
                };
                Rectangle.createSquare = function (size) {
                    return new Rectangle(-size / 2, -size / 2, size, size);
                };
                /**
                 * Creates the maximum rectangle representable by signed 16 bit integers.
                 */
                Rectangle.createMaxI16 = function () {
                    return new Rectangle(-32768    /* MinI16 */, -32768    /* MinI16 */, 65535    /* MaxU16 */, 65535    /* MaxU16 */);
                };
                Rectangle.prototype.setMaxI16 = function () {
                    this.setElements(-32768    /* MinI16 */, -32768    /* MinI16 */, 65535    /* MaxU16 */, 65535    /* MaxU16 */);
                };
                Rectangle.prototype.getCorners = function (points) {
                    points[0].x = this.x;
                    points[0].y = this.y;
                    points[1].x = this.x + this.w;
                    points[1].y = this.y;
                    points[2].x = this.x + this.w;
                    points[2].y = this.y + this.h;
                    points[3].x = this.x;
                    points[3].y = this.y + this.h;
                };
                Rectangle.allocationCount = 0;
                Rectangle._temporary = new Rectangle(0, 0, 0, 0);
                Rectangle._dirtyStack = [];
                return Rectangle;
            }();
            Geometry.Rectangle = Rectangle;
            var OBB = function () {
                function OBB(corners) {
                    this.corners = corners.map(function (corner) {
                        return corner.clone();
                    });
                    this.axes = [
                        corners[1].clone().sub(corners[0]),
                        corners[3].clone().sub(corners[0])
                    ];
                    this.origins = [];
                    for (var i = 0; i < 2; i++) {
                        this.axes[i].mul(1 / this.axes[i].squaredLength());
                        this.origins.push(corners[0].dot(this.axes[i]));
                    }
                }
                OBB.prototype.getBounds = function () {
                    return OBB.getBounds(this.corners);
                };
                OBB.getBounds = function (points) {
                    var min = new Point(Number.MAX_VALUE, Number.MAX_VALUE);
                    var max = new Point(Number.MIN_VALUE, Number.MIN_VALUE);
                    for (var i = 0; i < 4; i++) {
                        var x = points[i].x, y = points[i].y;
                        min.x = Math.min(min.x, x);
                        min.y = Math.min(min.y, y);
                        max.x = Math.max(max.x, x);
                        max.y = Math.max(max.y, y);
                    }
                    return new Rectangle(min.x, min.y, max.x - min.x, max.y - min.y);
                };
                /**
                 * http://www.flipcode.com/archives/2D_OBB_Intersection.shtml
                 */
                OBB.prototype.intersects = function (other) {
                    return this.intersectsOneWay(other) && other.intersectsOneWay(this);
                };
                OBB.prototype.intersectsOneWay = function (other) {
                    for (var i = 0; i < 2; i++) {
                        for (var j = 0; j < 4; j++) {
                            var t = other.corners[j].dot(this.axes[i]);
                            var tMin, tMax;
                            if (j === 0) {
                                tMax = tMin = t;
                            } else {
                                if (t < tMin) {
                                    tMin = t;
                                } else if (t > tMax) {
                                    tMax = t;
                                }
                            }
                        }
                        if (tMin > 1 + this.origins[i] || tMax < this.origins[i]) {
                            return false;
                        }
                    }
                    return true;
                };
                return OBB;
            }();
            Geometry.OBB = OBB;
            var Matrix = function () {
                function Matrix(a, b, c, d, tx, ty) {
                    this._data = new Float64Array(6);
                    this._type = 0    /* Unknown */;
                    this.setElements(a, b, c, d, tx, ty);
                    Matrix.allocationCount++;
                }
                Object.defineProperty(Matrix.prototype, 'a', {
                    get: function () {
                        return this._data[0];
                    },
                    set: function (a) {
                        this._data[0] = a;
                        this._type = 0    /* Unknown */;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, 'b', {
                    get: function () {
                        return this._data[1];
                    },
                    set: function (b) {
                        this._data[1] = b;
                        this._type = 0    /* Unknown */;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, 'c', {
                    get: function () {
                        return this._data[2];
                    },
                    set: function (c) {
                        this._data[2] = c;
                        this._type = 0    /* Unknown */;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, 'd', {
                    get: function () {
                        return this._data[3];
                    },
                    set: function (d) {
                        this._data[3] = d;
                        this._type = 0    /* Unknown */;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, 'tx', {
                    get: function () {
                        return this._data[4];
                    },
                    set: function (tx) {
                        this._data[4] = tx;
                        if (this._type === 1    /* Identity */) {
                            this._type = 2    /* Translation */;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Matrix.prototype, 'ty', {
                    get: function () {
                        return this._data[5];
                    },
                    set: function (ty) {
                        this._data[5] = ty;
                        if (this._type === 1    /* Identity */) {
                            this._type = 2    /* Translation */;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Matrix._createSVGMatrix = function () {
                    if (!Matrix._svg) {
                        Matrix._svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    }
                    return Matrix._svg.createSVGMatrix();
                };
                Matrix.prototype.setElements = function (a, b, c, d, tx, ty) {
                    var m = this._data;
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                    this._type = 0    /* Unknown */;
                };
                Matrix.prototype.set = function (other) {
                    var m = this._data, n = other._data;
                    m[0] = n[0];
                    m[1] = n[1];
                    m[2] = n[2];
                    m[3] = n[3];
                    m[4] = n[4];
                    m[5] = n[5];
                    this._type = other._type;
                };
                /**
                 * Whether the transformed query rectangle is empty after this transform is applied to it.
                 */
                Matrix.prototype.emptyArea = function (query) {
                    var m = this._data;
                    // TODO: Work out the details here.
                    if (m[0] === 0 || m[3] === 0) {
                        return true;
                    }
                    return false;
                };
                /**
                 * Whether the area of transformed query rectangle is infinite after this transform is applied to it.
                 */
                Matrix.prototype.infiniteArea = function (query) {
                    var m = this._data;
                    // TODO: Work out the details here.
                    if (Math.abs(m[0]) === Infinity || Math.abs(m[3]) === Infinity) {
                        return true;
                    }
                    return false;
                };
                Matrix.prototype.isEqual = function (other) {
                    if (this._type === 1    /* Identity */ && other._type === 1    /* Identity */) {
                        return true;
                    }
                    var m = this._data, n = other._data;
                    return m[0] === n[0] && m[1] === n[1] && m[2] === n[2] && m[3] === n[3] && m[4] === n[4] && m[5] === n[5];
                };
                Matrix.prototype.clone = function () {
                    var matrix = Matrix.allocate();
                    matrix.set(this);
                    return matrix;
                };
                Matrix.allocate = function () {
                    var dirtyStack = Matrix._dirtyStack;
                    var matrix = null;
                    if (dirtyStack.length) {
                        return dirtyStack.pop();
                    } else {
                        return new Matrix(12345, 12345, 12345, 12345, 12345, 12345);
                    }
                };
                Matrix.prototype.free = function () {
                    Matrix._dirtyStack.push(this);
                };
                Matrix.prototype.transform = function (a, b, c, d, tx, ty) {
                    var m = this._data;
                    var _a = m[0], _b = m[1], _c = m[2], _d = m[3], _tx = m[4], _ty = m[5];
                    m[0] = _a * a + _c * b;
                    m[1] = _b * a + _d * b;
                    m[2] = _a * c + _c * d;
                    m[3] = _b * c + _d * d;
                    m[4] = _a * tx + _c * ty + _tx;
                    m[5] = _b * tx + _d * ty + _ty;
                    this._type = 0    /* Unknown */;
                    return this;
                };
                Matrix.prototype.transformRectangle = function (rectangle, points) {
                    release || assert(points.length === 4);
                    var m = this._data, a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5];
                    var x = rectangle.x;
                    var y = rectangle.y;
                    var w = rectangle.w;
                    var h = rectangle.h;
                    /*
              
                     0---1
                     | / |
                     3---2
              
                     */
                    points[0].x = a * x + c * y + tx;
                    points[0].y = b * x + d * y + ty;
                    points[1].x = a * (x + w) + c * y + tx;
                    points[1].y = b * (x + w) + d * y + ty;
                    points[2].x = a * (x + w) + c * (y + h) + tx;
                    points[2].y = b * (x + w) + d * (y + h) + ty;
                    points[3].x = a * x + c * (y + h) + tx;
                    points[3].y = b * x + d * (y + h) + ty;
                };
                Matrix.prototype.isTranslationOnly = function () {
                    if (this._type === 2    /* Translation */) {
                        return true;
                    }
                    var m = this._data;
                    if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                        this._type = 2    /* Translation */;
                        return true;
                    } else if (epsilonEquals(m[0], 1) && epsilonEquals(m[1], 0) && epsilonEquals(m[2], 0) && epsilonEquals(m[3], 1)) {
                        this._type = 2    /* Translation */;
                        return true;
                    }
                    return false;
                };
                Matrix.prototype.transformRectangleAABB = function (rectangle) {
                    var m = this._data;
                    if (this._type === 1    /* Identity */) {
                        return;
                    } else if (this._type === 2    /* Translation */) {
                        rectangle.x += m[4];
                        rectangle.y += m[5];
                        return;
                    }
                    var a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5];
                    var x = rectangle.x;
                    var y = rectangle.y;
                    var w = rectangle.w;
                    var h = rectangle.h;
                    /*
              
                     0---1
                     | / |
                     3---2
              
                     */
                    var x0 = a * x + c * y + tx;
                    var y0 = b * x + d * y + ty;
                    var x1 = a * (x + w) + c * y + tx;
                    var y1 = b * (x + w) + d * y + ty;
                    var x2 = a * (x + w) + c * (y + h) + tx;
                    var y2 = b * (x + w) + d * (y + h) + ty;
                    var x3 = a * x + c * (y + h) + tx;
                    var y3 = b * x + d * (y + h) + ty;
                    var tmp = 0;
                    // Manual Min/Max is a lot faster than calling Math.min/max
                    // X Min-Max
                    if (x0 > x1) {
                        tmp = x0;
                        x0 = x1;
                        x1 = tmp;
                    }
                    if (x2 > x3) {
                        tmp = x2;
                        x2 = x3;
                        x3 = tmp;
                    }
                    rectangle.x = x0 < x2 ? x0 : x2;
                    rectangle.w = (x1 > x3 ? x1 : x3) - rectangle.x;
                    // Y Min-Max
                    if (y0 > y1) {
                        tmp = y0;
                        y0 = y1;
                        y1 = tmp;
                    }
                    if (y2 > y3) {
                        tmp = y2;
                        y2 = y3;
                        y3 = tmp;
                    }
                    rectangle.y = y0 < y2 ? y0 : y2;
                    rectangle.h = (y1 > y3 ? y1 : y3) - rectangle.y;
                };
                Matrix.prototype.scale = function (x, y) {
                    var m = this._data;
                    m[0] *= x;
                    m[1] *= y;
                    m[2] *= x;
                    m[3] *= y;
                    m[4] *= x;
                    m[5] *= y;
                    this._type = 0    /* Unknown */;
                    return this;
                };
                Matrix.prototype.scaleClone = function (x, y) {
                    if (x === 1 && y === 1) {
                        return this;
                    }
                    return this.clone().scale(x, y);
                };
                Matrix.prototype.rotate = function (angle) {
                    var m = this._data, a = m[0], b = m[1], c = m[2], d = m[3], tx = m[4], ty = m[5];
                    var cos = Math.cos(angle);
                    var sin = Math.sin(angle);
                    m[0] = cos * a - sin * b;
                    m[1] = sin * a + cos * b;
                    m[2] = cos * c - sin * d;
                    m[3] = sin * c + cos * d;
                    m[4] = cos * tx - sin * ty;
                    m[5] = sin * tx + cos * ty;
                    this._type = 0    /* Unknown */;
                    return this;
                };
                Matrix.prototype.concat = function (other) {
                    if (other._type === 1    /* Identity */) {
                        return this;
                    }
                    var m = this._data, n = other._data;
                    var a = m[0] * n[0];
                    var b = 0;
                    var c = 0;
                    var d = m[3] * n[3];
                    var tx = m[4] * n[0] + n[4];
                    var ty = m[5] * n[3] + n[5];
                    if (m[1] !== 0 || m[2] !== 0 || n[1] !== 0 || n[2] !== 0) {
                        a += m[1] * n[2];
                        d += m[2] * n[1];
                        b += m[0] * n[1] + m[1] * n[3];
                        c += m[2] * n[0] + m[3] * n[2];
                        tx += m[5] * n[2];
                        ty += m[4] * n[1];
                    }
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                    this._type = 0    /* Unknown */;
                    return this;
                };
                Matrix.prototype.concatClone = function (other) {
                    return this.clone().concat(other);
                };
                /**
                 * this = other * this
                 */
                Matrix.prototype.preMultiply = function (other) {
                    var m = this._data, n = other._data;
                    if (other._type === 2    /* Translation */ && this._type & (1    /* Identity */ | 2    /* Translation */)) {
                        m[4] += n[4];
                        m[5] += n[5];
                        this._type = 2    /* Translation */;
                        return;
                    } else if (other._type === 1    /* Identity */) {
                        return;
                    }
                    var a = n[0] * m[0];
                    var b = 0;
                    var c = 0;
                    var d = n[3] * m[3];
                    var tx = n[4] * m[0] + m[4];
                    var ty = n[5] * m[3] + m[5];
                    if (n[1] !== 0 || n[2] !== 0 || m[1] !== 0 || m[2] !== 0) {
                        a += n[1] * m[2];
                        d += n[2] * m[1];
                        b += n[0] * m[1] + n[1] * m[3];
                        c += n[2] * m[0] + n[3] * m[2];
                        tx += n[5] * m[2];
                        ty += n[4] * m[1];
                    }
                    m[0] = a;
                    m[1] = b;
                    m[2] = c;
                    m[3] = d;
                    m[4] = tx;
                    m[5] = ty;
                    this._type = 0    /* Unknown */;
                };
                Matrix.prototype.translate = function (x, y) {
                    var m = this._data;
                    m[4] += x;
                    m[5] += y;
                    if (this._type === 1    /* Identity */) {
                        this._type = 2    /* Translation */;
                    }
                    return this;
                };
                Matrix.prototype.setIdentity = function () {
                    var m = this._data;
                    m[0] = 1;
                    m[1] = 0;
                    m[2] = 0;
                    m[3] = 1;
                    m[4] = 0;
                    m[5] = 0;
                    this._type = 1    /* Identity */;
                };
                Matrix.prototype.isIdentity = function () {
                    if (this._type === 1    /* Identity */) {
                        return true;
                    }
                    var m = this._data;
                    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;
                };
                Matrix.prototype.transformPoint = function (point) {
                    if (this._type === 1    /* Identity */) {
                        return;
                    }
                    var m = this._data;
                    var x = point.x;
                    var y = point.y;
                    point.x = m[0] * x + m[2] * y + m[4];
                    point.y = m[1] * x + m[3] * y + m[5];
                };
                Matrix.prototype.transformPoints = function (points) {
                    if (this._type === 1    /* Identity */) {
                        return;
                    }
                    for (var i = 0; i < points.length; i++) {
                        this.transformPoint(points[i]);
                    }
                };
                Matrix.prototype.deltaTransformPoint = function (point) {
                    if (this._type === 1    /* Identity */) {
                        return;
                    }
                    var m = this._data;
                    var x = point.x;
                    var y = point.y;
                    point.x = m[0] * x + m[2] * y;
                    point.y = m[1] * x + m[3] * y;
                };
                Matrix.prototype.inverse = function (result) {
                    var m = this._data, r = result._data;
                    if (this._type === 1    /* Identity */) {
                        result.setIdentity();
                        return;
                    } else if (this._type === 2    /* Translation */) {
                        r[0] = 1;
                        r[1] = 0;
                        r[2] = 0;
                        r[3] = 1;
                        r[4] = -m[4];
                        r[5] = -m[5];
                        result._type = 2    /* Translation */;
                        return;
                    }
                    var b = m[1];
                    var c = m[2];
                    var tx = m[4];
                    var ty = m[5];
                    if (b === 0 && c === 0) {
                        var a = r[0] = 1 / m[0];
                        var d = r[3] = 1 / m[3];
                        r[1] = 0;
                        r[2] = 0;
                        r[4] = -a * tx;
                        r[5] = -d * ty;
                    } else {
                        var a = m[0];
                        var d = m[3];
                        var determinant = a * d - b * c;
                        if (determinant === 0) {
                            result.setIdentity();
                            return;
                        }
                        determinant = 1 / determinant;
                        r[0] = d * determinant;
                        b = r[1] = -b * determinant;
                        c = r[2] = -c * determinant;
                        d = r[3] = a * determinant;
                        r[4] = -(r[0] * tx + c * ty);
                        r[5] = -(b * tx + d * ty);
                    }
                    result._type = 0    /* Unknown */;
                    return;
                };
                Matrix.prototype.getTranslateX = function () {
                    return this._data[4];
                };
                Matrix.prototype.getTranslateY = function () {
                    return this._data[4];
                };
                Matrix.prototype.getScaleX = function () {
                    var m = this._data;
                    if (m[0] === 1 && m[1] === 0) {
                        return 1;
                    }
                    var result = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
                    return m[0] > 0 ? result : -result;
                };
                Matrix.prototype.getScaleY = function () {
                    var m = this._data;
                    if (m[2] === 0 && m[3] === 1) {
                        return 1;
                    }
                    var result = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
                    return m[3] > 0 ? result : -result;
                };
                Matrix.prototype.getScale = function () {
                    return (this.getScaleX() + this.getScaleY()) / 2;
                };
                Matrix.prototype.getAbsoluteScaleX = function () {
                    return Math.abs(this.getScaleX());
                };
                Matrix.prototype.getAbsoluteScaleY = function () {
                    return Math.abs(this.getScaleY());
                };
                Matrix.prototype.getRotation = function () {
                    var m = this._data;
                    return Math.atan(m[1] / m[0]) * 180 / Math.PI;
                };
                Matrix.prototype.isScaleOrRotation = function () {
                    var m = this._data;
                    return Math.abs(m[0] * m[2] + m[1] * m[3]) < 0.01;
                };
                Matrix.prototype.toString = function (digits) {
                    if (digits === void 0) {
                        digits = 2;
                    }
                    var m = this._data;
                    return '{' + m[0].toFixed(digits) + ', ' + m[1].toFixed(digits) + ', ' + m[2].toFixed(digits) + ', ' + m[3].toFixed(digits) + ', ' + m[4].toFixed(digits) + ', ' + m[5].toFixed(digits) + '}';
                };
                Matrix.prototype.toWebGLMatrix = function () {
                    var m = this._data;
                    return new Float32Array([
                        m[0],
                        m[1],
                        0,
                        m[2],
                        m[3],
                        0,
                        m[4],
                        m[5],
                        1
                    ]);
                };
                Matrix.prototype.toCSSTransform = function () {
                    var m = this._data;
                    return 'matrix(' + m[0] + ', ' + m[1] + ', ' + m[2] + ', ' + m[3] + ', ' + m[4] + ', ' + m[5] + ')';
                };
                Matrix.createIdentity = function () {
                    var matrix = Matrix.allocate();
                    matrix.setIdentity();
                    return matrix;
                };
                Matrix.prototype.toSVGMatrix = function () {
                    var m = this._data;
                    var matrix = Matrix._createSVGMatrix();
                    try {
                        matrix.a = m[0];
                        matrix.b = m[1];
                        matrix.c = m[2];
                        matrix.d = m[3];
                        matrix.e = m[4];
                        matrix.f = m[5];
                    } catch (e) {
                        // The setters on SVGMatrix throw if the assigned value is `NaN`, which we sometimes
                        // produce. In that case, just fall back to an identity matrix for now.
                        return Matrix._createSVGMatrix();
                    }
                    return matrix;
                };
                Matrix.prototype.snap = function () {
                    var m = this._data;
                    if (this.isTranslationOnly()) {
                        m[0] = 1;
                        m[1] = 0;
                        m[2] = 0;
                        m[3] = 1;
                        m[4] = Math.round(m[4]);
                        m[5] = Math.round(m[5]);
                        this._type = 2    /* Translation */;
                        return true;
                    }
                    return false;
                };
                Matrix.createIdentitySVGMatrix = function () {
                    return Matrix._createSVGMatrix();
                };
                Matrix.createSVGMatrixFromArray = function (array) {
                    var matrix = Matrix._createSVGMatrix();
                    matrix.a = array[0];
                    matrix.b = array[1];
                    matrix.c = array[2];
                    matrix.d = array[3];
                    matrix.e = array[4];
                    matrix.f = array[5];
                    return matrix;
                };
                Matrix.allocationCount = 0;
                Matrix._dirtyStack = [];
                Matrix.multiply = function (dst, src) {
                    var n = src._data;
                    dst.transform(n[0], n[1], n[2], n[3], n[4], n[5]);
                };
                return Matrix;
            }();
            Geometry.Matrix = Matrix;
            var DirtyRegion = function () {
                function DirtyRegion(w, h, sizeInBits) {
                    if (sizeInBits === void 0) {
                        sizeInBits = 7;
                    }
                    var size = this.size = 1 << sizeInBits;
                    this.sizeInBits = sizeInBits;
                    this.w = w;
                    this.h = h;
                    this.c = Math.ceil(w / size);
                    this.r = Math.ceil(h / size);
                    this.grid = [];
                    for (var y = 0; y < this.r; y++) {
                        this.grid.push([]);
                        for (var x = 0; x < this.c; x++) {
                            this.grid[y][x] = new DirtyRegion.Cell(new Rectangle(x * size, y * size, size, size));
                        }
                    }
                }
                DirtyRegion.prototype.clear = function () {
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            this.grid[y][x].clear();
                        }
                    }
                };
                DirtyRegion.prototype.getBounds = function () {
                    return new Rectangle(0, 0, this.w, this.h);
                };
                DirtyRegion.prototype.addDirtyRectangle = function (rectangle) {
                    var x = rectangle.x >> this.sizeInBits;
                    var y = rectangle.y >> this.sizeInBits;
                    if (x >= this.c || y >= this.r) {
                        return;
                    }
                    if (x < 0) {
                        x = 0;
                    }
                    if (y < 0) {
                        y = 0;
                    }
                    var cell = this.grid[y][x];
                    rectangle = rectangle.clone();
                    rectangle.snap();
                    if (cell.region.contains(rectangle)) {
                        if (cell.bounds.isEmpty()) {
                            cell.bounds.set(rectangle);
                        } else if (!cell.bounds.contains(rectangle)) {
                            cell.bounds.union(rectangle);
                        }
                    } else {
                        var w = Math.min(this.c, Math.ceil((rectangle.x + rectangle.w) / this.size)) - x;
                        var h = Math.min(this.r, Math.ceil((rectangle.y + rectangle.h) / this.size)) - y;
                        for (var i = 0; i < w; i++) {
                            for (var j = 0; j < h; j++) {
                                var cell = this.grid[y + j][x + i];
                                var intersection = cell.region.clone();
                                intersection.intersect(rectangle);
                                if (!intersection.isEmpty()) {
                                    this.addDirtyRectangle(intersection);
                                }
                            }
                        }
                    }
                };
                DirtyRegion.prototype.gatherRegions = function (regions) {
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            var bounds = this.grid[y][x].bounds;
                            if (!bounds.isEmpty()) {
                                regions.push(this.grid[y][x].bounds);
                            }
                        }
                    }
                };
                DirtyRegion.prototype.gatherOptimizedRegions = function (regions) {
                    this.gatherRegions(regions);
                };
                DirtyRegion.prototype.getDirtyRatio = function () {
                    var totalArea = this.w * this.h;
                    if (totalArea === 0) {
                        return 0;
                    }
                    var dirtyArea = 0;
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            dirtyArea += this.grid[y][x].region.area();
                        }
                    }
                    return dirtyArea / totalArea;
                };
                DirtyRegion.prototype.render = function (context, options) {
                    function drawRectangle(rectangle) {
                        context.rect(rectangle.x, rectangle.y, rectangle.w, rectangle.h);
                    }
                    if (options && options.drawGrid) {
                        context.strokeStyle = 'white';
                        for (var y = 0; y < this.r; y++) {
                            for (var x = 0; x < this.c; x++) {
                                var cell = this.grid[y][x];
                                context.beginPath();
                                drawRectangle(cell.region);
                                context.closePath();
                                context.stroke();
                            }
                        }
                    }
                    context.strokeStyle = '#E0F8D8';
                    for (var y = 0; y < this.r; y++) {
                        for (var x = 0; x < this.c; x++) {
                            var cell = this.grid[y][x];
                            context.beginPath();
                            drawRectangle(cell.bounds);
                            context.closePath();
                            context.stroke();
                        }
                    }    //      context.strokeStyle = "#5856d6";
                         //      var regions = [];
                         //      this.gatherOptimizedRegions(regions);
                         //      for (var i = 0; i < regions.length; i++) {
                         //        context.beginPath();
                         //        drawRectangle(regions[i]);
                         //        context.closePath();
                         //        context.stroke();
                         //      }
                };
                DirtyRegion.tmpRectangle = Rectangle.createEmpty();
                return DirtyRegion;
            }();
            Geometry.DirtyRegion = DirtyRegion;
            var DirtyRegion;
            (function (DirtyRegion) {
                var Cell = function () {
                    function Cell(region) {
                        this.region = region;
                        this.bounds = Rectangle.createEmpty();
                    }
                    Cell.prototype.clear = function () {
                        this.bounds.setEmpty();
                    };
                    return Cell;
                }();
                DirtyRegion.Cell = Cell;
            }(DirtyRegion = Geometry.DirtyRegion || (Geometry.DirtyRegion = {})));
            var Tile = function () {
                function Tile(index, x, y, w, h, scale) {
                    this.index = index;
                    this.x = x;
                    this.y = y;
                    this.scale = scale;
                    this.bounds = new Rectangle(x * w, y * h, w, h);
                }
                Tile.prototype.getOBB = function () {
                    if (this._obb) {
                        return this._obb;
                    }
                    this.bounds.getCorners(Tile.corners);
                    return this._obb = new OBB(Tile.corners);
                };
                Tile.corners = Point.createEmptyPoints(4);
                return Tile;
            }();
            Geometry.Tile = Tile;
            /**
             * A grid data structure that lets you query tiles that intersect a transformed rectangle.
             */
            var TileCache = function () {
                function TileCache(w, h, tileW, tileH, scale) {
                    this.tileW = tileW;
                    this.tileH = tileH;
                    this.scale = scale;
                    this.w = w;
                    this.h = h;
                    this.rows = Math.ceil(h / tileH);
                    this.columns = Math.ceil(w / tileW);
                    release || assert(this.rows < 2048 && this.columns < 2048);
                    this.tiles = [];
                    var index = 0;
                    for (var y = 0; y < this.rows; y++) {
                        for (var x = 0; x < this.columns; x++) {
                            this.tiles.push(new Tile(index++, x, y, tileW, tileH, scale));
                        }
                    }
                }
                /**
                 * Query tiles using a transformed rectangle.
                 * TODO: Fine-tune these heuristics.
                 */
                TileCache.prototype.getTiles = function (query, transform) {
                    if (transform.emptyArea(query)) {
                        return [];
                    } else if (transform.infiniteArea(query)) {
                        return this.tiles;
                    }
                    var tileCount = this.columns * this.rows;
                    // The |getFewTiles| algorithm works better for a few tiles but it can't handle skew transforms.
                    if (tileCount < 40 && transform.isScaleOrRotation()) {
                        var precise = tileCount > 10;
                        return this.getFewTiles(query, transform, precise);
                    } else {
                        return this.getManyTiles(query, transform);
                    }
                };
                /**
                 * Precise indicates that we want to do an exact OBB intersection.
                 */
                TileCache.prototype.getFewTiles = function (query, transform, precise) {
                    if (precise === void 0) {
                        precise = true;
                    }
                    if (transform.isTranslationOnly() && this.tiles.length === 1) {
                        if (this.tiles[0].bounds.intersectsTranslated(query, transform.tx, transform.ty)) {
                            return [this.tiles[0]];
                        }
                        return [];
                    }
                    transform.transformRectangle(query, TileCache._points);
                    var queryOBB;
                    var queryBounds = new Rectangle(0, 0, this.w, this.h);
                    if (precise) {
                        queryOBB = new OBB(TileCache._points);
                    }
                    queryBounds.intersect(OBB.getBounds(TileCache._points));
                    if (queryBounds.isEmpty()) {
                        return [];
                    }
                    var minX = queryBounds.x / this.tileW | 0;
                    var minY = queryBounds.y / this.tileH | 0;
                    var maxX = Math.ceil((queryBounds.x + queryBounds.w) / this.tileW) | 0;
                    var maxY = Math.ceil((queryBounds.y + queryBounds.h) / this.tileH) | 0;
                    minX = clamp(minX, 0, this.columns);
                    maxX = clamp(maxX, 0, this.columns);
                    minY = clamp(minY, 0, this.rows);
                    maxY = clamp(maxY, 0, this.rows);
                    var tiles = [];
                    for (var x = minX; x < maxX; x++) {
                        for (var y = minY; y < maxY; y++) {
                            var tile = this.tiles[y * this.columns + x];
                            if (tile.bounds.intersects(queryBounds) && (precise ? tile.getOBB().intersects(queryOBB) : true)) {
                                tiles.push(tile);
                            }
                        }
                    }
                    return tiles;
                };
                TileCache.prototype.getManyTiles = function (query, transform) {
                    function intersectX(x, p1, p2) {
                        // (x - x1) * (y2 - y1) = (y - y1) * (x2 - x1)
                        return (x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;
                    }
                    function appendTiles(tiles, cache, column, startRow, endRow) {
                        if (column < 0 || column >= cache.columns) {
                            return;
                        }
                        var j1 = clamp(startRow, 0, cache.rows);
                        var j2 = clamp(endRow + 1, 0, cache.rows);
                        for (var j = j1; j < j2; j++) {
                            tiles.push(cache.tiles[j * cache.columns + column]);
                        }
                    }
                    var rectPoints = TileCache._points;
                    transform.transformRectangle(query, rectPoints);
                    // finding minimal-x point, placing at first (and last)
                    var i1 = rectPoints[0].x < rectPoints[1].x ? 0 : 1;
                    var i2 = rectPoints[2].x < rectPoints[3].x ? 2 : 3;
                    var i0 = rectPoints[i1].x < rectPoints[i2].x ? i1 : i2;
                    var lines = [];
                    for (var j = 0; j < 5; j++, i0++) {
                        lines.push(rectPoints[i0 % 4]);
                    }
                    // and keeping points ordered counterclockwise
                    if ((lines[1].x - lines[0].x) * (lines[3].y - lines[0].y) < (lines[1].y - lines[0].y) * (lines[3].x - lines[0].x)) {
                        var tmp = lines[1];
                        lines[1] = lines[3];
                        lines[3] = tmp;
                    }
                    var tiles = [];
                    var lastY1, lastY2;
                    var i = Math.floor(lines[0].x / this.tileW);
                    var nextX = (i + 1) * this.tileW;
                    if (lines[2].x < nextX) {
                        // edge case: all fits into one column
                        lastY1 = Math.min(lines[0].y, lines[1].y, lines[2].y, lines[3].y);
                        lastY2 = Math.max(lines[0].y, lines[1].y, lines[2].y, lines[3].y);
                        var j1 = Math.floor(lastY1 / this.tileH);
                        var j2 = Math.floor(lastY2 / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);
                        return tiles;
                    }
                    var line1 = 0, line2 = 4;
                    var lastSegment1 = false, lastSegment2 = false;
                    if (lines[0].x === lines[1].x || lines[0].x === lines[3].x) {
                        // edge case: first rectangle side parallel to columns
                        if (lines[0].x === lines[1].x) {
                            lastSegment1 = true;
                            line1++;
                        } else {
                            lastSegment2 = true;
                            line2--;
                        }
                        lastY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                        lastY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);
                        var j1 = Math.floor(lines[line1].y / this.tileH);
                        var j2 = Math.floor(lines[line2].y / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);
                        i++;
                    }
                    do {
                        var nextY1, nextY2;
                        var nextSegment1, nextSegment2;
                        if (lines[line1 + 1].x < nextX) {
                            nextY1 = lines[line1 + 1].y;
                            nextSegment1 = true;
                        } else {
                            nextY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                            nextSegment1 = false;
                        }
                        if (lines[line2 - 1].x < nextX) {
                            nextY2 = lines[line2 - 1].y;
                            nextSegment2 = true;
                        } else {
                            nextY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);
                            nextSegment2 = false;
                        }
                        var j1 = Math.floor((lines[line1].y < lines[line1 + 1].y ? lastY1 : nextY1) / this.tileH);
                        var j2 = Math.floor((lines[line2].y > lines[line2 - 1].y ? lastY2 : nextY2) / this.tileH);
                        appendTiles(tiles, this, i, j1, j2);
                        if (nextSegment1 && lastSegment1) {
                            break;
                        }
                        if (nextSegment1) {
                            lastSegment1 = true;
                            line1++;
                            lastY1 = intersectX(nextX, lines[line1], lines[line1 + 1]);
                        } else {
                            lastY1 = nextY1;
                        }
                        if (nextSegment2) {
                            lastSegment2 = true;
                            line2--;
                            lastY2 = intersectX(nextX, lines[line2], lines[line2 - 1]);
                        } else {
                            lastY2 = nextY2;
                        }
                        i++;
                        nextX = (i + 1) * this.tileW;
                    } while (line1 < line2);
                    return tiles;
                };
                TileCache._points = Point.createEmptyPoints(4);
                return TileCache;
            }();
            Geometry.TileCache = TileCache;
            var MIN_CACHE_LEVELS = 5;
            var MAX_CACHE_LEVELS = 3;
            /**
             * Manages tile caches at different scales.
             */
            var RenderableTileCache = function () {
                function RenderableTileCache(source, tileSize, minUntiledSize) {
                    this._cacheLevels = [];
                    this._source = source;
                    this._tileSize = tileSize;
                    this._minUntiledSize = minUntiledSize;
                }
                /**
                 * Gets the tiles covered by the specified |query| rectangle and transformed by the given |transform| matrix.
                 */
                RenderableTileCache.prototype._getTilesAtScale = function (query, transform, scratchBounds) {
                    var transformScale = Math.max(transform.getAbsoluteScaleX(), transform.getAbsoluteScaleY());
                    // Use log2(1 / transformScale) to figure out the tile level.
                    var level = 0;
                    if (transformScale !== 1) {
                        level = clamp(Math.round(Math.log(1 / transformScale) / Math.LN2), -MIN_CACHE_LEVELS, MAX_CACHE_LEVELS);
                    }
                    var scale = pow2(level);
                    // Since we use a single tile for dynamic sources, we've got to make sure that it fits in our surface caches ...
                    if (this._source.hasFlags(256    /* Dynamic */)) {
                        // .. so try a lower scale level until it fits.
                        while (true) {
                            scale = pow2(level);
                            if (scratchBounds.contains(this._source.getBounds().getAbsoluteBounds().clone().scale(scale, scale))) {
                                break;
                            }
                            level--;
                            release || assert(level >= -MIN_CACHE_LEVELS);
                        }
                    }
                    // If the source is not scalable don't cache any tiles at a higher scale factor. However, it may still make
                    // sense to cache at a lower scale factor in case we need to evict larger cached images.
                    if (!this._source.hasFlags(512    /* Scalable */)) {
                        level = clamp(level, -MIN_CACHE_LEVELS, 0);
                    }
                    var scale = pow2(level);
                    var levelIndex = MIN_CACHE_LEVELS + level;
                    var cache = this._cacheLevels[levelIndex];
                    if (!cache) {
                        var bounds = this._source.getBounds().getAbsoluteBounds();
                        var scaledBounds = bounds.clone().scale(scale, scale);
                        var tileW, tileH;
                        if (this._source.hasFlags(256    /* Dynamic */) || !this._source.hasFlags(1024    /* Tileable */) || Math.max(scaledBounds.w, scaledBounds.h) <= this._minUntiledSize) {
                            tileW = scaledBounds.w;
                            tileH = scaledBounds.h;
                        } else {
                            tileW = tileH = this._tileSize;
                        }
                        cache = this._cacheLevels[levelIndex] = new TileCache(scaledBounds.w, scaledBounds.h, tileW, tileH, scale);
                    }
                    return cache.getTiles(query, transform.scaleClone(scale, scale));
                };
                RenderableTileCache.prototype.fetchTiles = function (query, transform, scratchContext, cacheImageCallback) {
                    var scratchBounds = new Rectangle(0, 0, scratchContext.canvas.width, scratchContext.canvas.height);
                    var tiles = this._getTilesAtScale(query, transform, scratchBounds);
                    var uncachedTiles;
                    var source = this._source;
                    for (var i = 0; i < tiles.length; i++) {
                        var tile = tiles[i];
                        if (!tile.cachedSurfaceRegion || !tile.cachedSurfaceRegion.surface || source.hasFlags(256    /* Dynamic */ | 4096    /* Dirty */)) {
                            if (!uncachedTiles) {
                                uncachedTiles = [];
                            }
                            uncachedTiles.push(tile);
                        }
                    }
                    if (uncachedTiles) {
                        this._cacheTiles(scratchContext, uncachedTiles, cacheImageCallback, scratchBounds);
                    }
                    source.removeFlags(4096    /* Dirty */);
                    return tiles;
                };
                RenderableTileCache.prototype._getTileBounds = function (tiles) {
                    var bounds = Rectangle.createEmpty();
                    for (var i = 0; i < tiles.length; i++) {
                        bounds.union(tiles[i].bounds);
                    }
                    return bounds;
                };
                /**
                 * This caches raster versions of the specified |uncachedTiles|. The tiles are generated using a scratch
                 * canvas2D context (|scratchContext|) and then cached via |cacheImageCallback|. Ideally, we want to render
                 * all tiles in one go, but they may not fit in the |scratchContext| in which case we need to render the
                 * source shape several times.
                 *
                 * TODO: Find a good algorithm to do this since it's quite important that we don't repaint too many times.
                 * Spending some time trying to figure out the *optimal* solution may pay-off since painting is soo expensive.
                 */
                RenderableTileCache.prototype._cacheTiles = function (scratchContext, uncachedTiles, cacheImageCallback, scratchBounds, maxRecursionDepth) {
                    if (maxRecursionDepth === void 0) {
                        maxRecursionDepth = 4;
                    }
                    release || assert(maxRecursionDepth > 0, 'Infinite recursion is likely.');
                    var uncachedTileBounds = this._getTileBounds(uncachedTiles);
                    scratchContext.save();
                    scratchContext.setTransform(1, 0, 0, 1, 0, 0);
                    scratchContext.clearRect(0, 0, scratchBounds.w, scratchBounds.h);
                    scratchContext.translate(-uncachedTileBounds.x, -uncachedTileBounds.y);
                    scratchContext.scale(uncachedTiles[0].scale, uncachedTiles[0].scale);
                    // Translate so that the source is drawn at the origin.
                    var sourceBounds = this._source.getBounds();
                    scratchContext.translate(-sourceBounds.x, -sourceBounds.y);
                    profile && GFX.timelineBuffer && GFX.timelineBuffer.enter('renderTiles');
                    GFX.traceLevel >= 2    /* Verbose */ && GFX.writer && GFX.writer.writeLn('Rendering Tiles: ' + uncachedTileBounds);
                    this._source.render(scratchContext, 0);
                    scratchContext.restore();
                    profile && GFX.timelineBuffer && GFX.timelineBuffer.leave('renderTiles');
                    var remainingUncachedTiles = null;
                    for (var i = 0; i < uncachedTiles.length; i++) {
                        var tile = uncachedTiles[i];
                        var region = tile.bounds.clone();
                        region.x -= uncachedTileBounds.x;
                        region.y -= uncachedTileBounds.y;
                        if (!scratchBounds.contains(region)) {
                            if (!remainingUncachedTiles) {
                                remainingUncachedTiles = [];
                            }
                            remainingUncachedTiles.push(tile);
                        }
                        tile.cachedSurfaceRegion = cacheImageCallback(tile.cachedSurfaceRegion, scratchContext, region);
                    }
                    if (remainingUncachedTiles) {
                        // This is really dumb at the moment; if we have some tiles left over, partition the tile set in half and recurse.
                        if (remainingUncachedTiles.length >= 2) {
                            var a = remainingUncachedTiles.slice(0, remainingUncachedTiles.length / 2 | 0);
                            var b = remainingUncachedTiles.slice(a.length);
                            this._cacheTiles(scratchContext, a, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                            this._cacheTiles(scratchContext, b, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                        } else {
                            this._cacheTiles(scratchContext, remainingUncachedTiles, cacheImageCallback, scratchBounds, maxRecursionDepth - 1);
                        }
                    }
                };
                return RenderableTileCache;
            }();
            Geometry.RenderableTileCache = RenderableTileCache;
        }(Geometry = GFX.Geometry || (GFX.Geometry = {})));
    }(GFX = Shumway.GFX || (Shumway.GFX = {})));
}(Shumway || (Shumway = {})));
/**
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    var GFX;
    (function (GFX) {
        var roundToMultipleOfPowerOfTwo = Shumway.IntegerUtilities.roundToMultipleOfPowerOfTwo;
        var assert = Shumway.Debug.assert;
        var Rectangle = GFX.Geometry.Rectangle;
        /**
         * Various 2D rectangular region allocators. These are used to manage
         * areas of surfaces, 2D Canvases or WebGL surfaces. Each allocator
         * implements the |IRegionAllocator| interface and must provied two
         * methods to allocate and free regions.
         *
         * CompactAllocator: Good for tightly packed surface atlases but becomes
         * fragmented easily. Allocation / freeing cost is high and should only
         * be used for long lived regions.
         *
         * GridAllocator: Very fast at allocation and freeing but is not very
         * tightly packed. Space is initially partitioned in equally sized grid
         * cells which may be much larger than the allocated regions. This should
         * be used for fixed size allocation regions.
         *
         * BucketAllocator: Manages a list of GridAllocators with different grid
         * sizes.
         */
        var RegionAllocator;
        (function (RegionAllocator) {
            var Region = function (_super) {
                __extends(Region, _super);
                function Region() {
                    _super.apply(this, arguments);
                }
                return Region;
            }(GFX.Geometry.Rectangle);
            RegionAllocator.Region = Region;
            /**
             * Simple 2D bin-packing algorithm that recursively partitions space along the x and y axis. The binary tree
             * can get quite deep so watch out of deep recursive calls. This algorithm works best when inserting items
             * that are sorted by width and height, from largest to smallest.
             */
            var CompactAllocator = function () {
                function CompactAllocator(w, h) {
                    this._root = new CompactCell(0, 0, w | 0, h | 0, false);
                }
                CompactAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var result = this._root.insert(w, h);
                    if (result) {
                        result.allocator = this;
                        result.allocated = true;
                    }
                    return result;
                };
                CompactAllocator.prototype.free = function (region) {
                    var cell = region;
                    release || assert(cell.allocator === this);
                    cell.clear();
                    region.allocated = false;
                };
                /**
                 * Try out randomizing the orientation of each subdivision, sometimes this can lead to better results.
                 */
                CompactAllocator.RANDOM_ORIENTATION = true;
                CompactAllocator.MAX_DEPTH = 256;
                return CompactAllocator;
            }();
            RegionAllocator.CompactAllocator = CompactAllocator;
            var CompactCell = function (_super) {
                __extends(CompactCell, _super);
                function CompactCell(x, y, w, h, horizontal) {
                    _super.call(this, x, y, w, h);
                    this._children = null;
                    this._horizontal = horizontal;
                    this.allocated = false;
                }
                CompactCell.prototype.clear = function () {
                    this._children = null;
                    this.allocated = false;
                };
                CompactCell.prototype.insert = function (w, h) {
                    return this._insert(w, h, 0);
                };
                CompactCell.prototype._insert = function (w, h, depth) {
                    if (depth > CompactAllocator.MAX_DEPTH) {
                        return;
                    }
                    if (this.allocated) {
                        return;
                    }
                    if (this.w < w || this.h < h) {
                        return;
                    }
                    if (!this._children) {
                        var orientation = !this._horizontal;
                        if (CompactAllocator.RANDOM_ORIENTATION) {
                            orientation = Math.random() >= 0.5;
                        }
                        if (this._horizontal) {
                            this._children = [
                                new CompactCell(this.x, this.y, this.w, h, false),
                                new CompactCell(this.x, this.y + h, this.w, this.h - h, orientation)
                            ];
                        } else {
                            this._children = [
                                new CompactCell(this.x, this.y, w, this.h, true),
                                new CompactCell(this.x + w, this.y, this.w - w, this.h, orientation)
                            ];
                        }
                        var first = this._children[0];
                        if (first.w === w && first.h === h) {
                            first.allocated = true;
                            return first;
                        }
                        return this._insert(w, h, depth + 1);
                    } else {
                        var result;
                        result = this._children[0]._insert(w, h, depth + 1);
                        if (result) {
                            return result;
                        }
                        result = this._children[1]._insert(w, h, depth + 1);
                        if (result) {
                            return result;
                        }
                    }
                };
                return CompactCell;
            }(RegionAllocator.Region);
            /**
             * Simple grid allocator. Starts off with an empty free list and allocates empty cells. Once a cell
             * is freed it's pushed into the free list. It gets poped off the next time a region is allocated.
             */
            var GridAllocator = function () {
                function GridAllocator(w, h, sizeW, sizeH) {
                    this._columns = w / sizeW | 0;
                    this._rows = h / sizeH | 0;
                    this._sizeW = sizeW;
                    this._sizeH = sizeH;
                    this._freeList = [];
                    this._index = 0;
                    this._total = this._columns * this._rows;
                }
                GridAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var sizeW = this._sizeW;
                    var sizeH = this._sizeH;
                    if (w > sizeW || h > sizeH) {
                        return null;
                    }
                    var freeList = this._freeList;
                    var index = this._index;
                    if (freeList.length > 0) {
                        var cell = freeList.pop();
                        release || assert(cell.allocated === false);
                        cell.w = w;
                        cell.h = h;
                        cell.allocated = true;
                        return cell;
                    } else if (index < this._total) {
                        var y = index / this._columns | 0;
                        var x = index - y * this._columns;
                        var cell = new GridCell(x * sizeW, y * sizeH, w, h);
                        cell.index = index;
                        cell.allocator = this;
                        cell.allocated = true;
                        this._index++;
                        return cell;
                    }
                    return null;
                };
                GridAllocator.prototype.free = function (region) {
                    var cell = region;
                    release || assert(cell.allocator === this);
                    cell.allocated = false;
                    this._freeList.push(cell);
                };
                return GridAllocator;
            }();
            RegionAllocator.GridAllocator = GridAllocator;
            var GridCell = function (_super) {
                __extends(GridCell, _super);
                function GridCell(x, y, w, h) {
                    _super.call(this, x, y, w, h);
                    this.index = -1;
                }
                return GridCell;
            }(RegionAllocator.Region);
            RegionAllocator.GridCell = GridCell;
            var Bucket = function () {
                function Bucket(size, region, allocator) {
                    this.size = size;
                    this.region = region;
                    this.allocator = allocator;
                }
                return Bucket;
            }();
            var BucketCell = function (_super) {
                __extends(BucketCell, _super);
                function BucketCell(x, y, w, h, region) {
                    _super.call(this, x, y, w, h);
                    this.region = region;
                }
                return BucketCell;
            }(RegionAllocator.Region);
            RegionAllocator.BucketCell = BucketCell;
            var BucketAllocator = function () {
                function BucketAllocator(w, h) {
                    release || assert(w > 0 && h > 0);
                    this._buckets = [];
                    this._w = w | 0;
                    this._h = h | 0;
                    this._filled = 0;
                }
                /**
                 * Finds the first bucket that is large enough to hold the requested region. If no
                 * such bucket exists, then allocates a new bucket if there is room otherwise
                 * returns null;
                 */
                BucketAllocator.prototype.allocate = function (w, h) {
                    w = Math.ceil(w);
                    h = Math.ceil(h);
                    release || assert(w > 0 && h > 0);
                    var size = Math.max(w, h);
                    if (w > this._w || h > this._h) {
                        // Too big, cannot allocate this.
                        return null;
                    }
                    var region = null;
                    var bucket;
                    var buckets = this._buckets;
                    do {
                        for (var i = 0; i < buckets.length; i++) {
                            if (buckets[i].size >= size) {
                                bucket = buckets[i];
                                region = bucket.allocator.allocate(w, h);
                                if (region) {
                                    break;
                                }
                            }
                        }
                        if (!region) {
                            var remainingSpace = this._h - this._filled;
                            if (remainingSpace < h) {
                                // Couldn't allocate region and there is no more vertical space to allocate
                                // a new bucket that can fit the requested size. So give up.
                                return null;
                            }
                            var gridSize = roundToMultipleOfPowerOfTwo(size, 8);
                            var bucketHeight = gridSize * 2;
                            if (bucketHeight > remainingSpace) {
                                bucketHeight = remainingSpace;
                            }
                            if (bucketHeight < gridSize) {
                                return null;
                            }
                            var bucketRegion = new Rectangle(0, this._filled, this._w, bucketHeight);
                            this._buckets.push(new Bucket(gridSize, bucketRegion, new GridAllocator(bucketRegion.w, bucketRegion.h, gridSize, gridSize)));
                            this._filled += bucketHeight;
                        }
                    } while (!region);
                    return new BucketCell(bucket.region.x + region.x, bucket.region.y + region.y, region.w, region.h, region);
                };
                BucketAllocator.prototype.free = function (region) {
                    region.region.allocator.free(region.region);
                };
                return BucketAllocator;
            }();
            RegionAllocator.BucketAllocator = BucketAllocator;
        }(RegionAllocator = GFX.RegionAllocator || (GFX.RegionAllocator = {})));
        var SurfaceRegionAllocator;
        (function (SurfaceRegionAllocator) {
            var SimpleAllocator = function () {
                function SimpleAllocator(createSurface) {
                    this._createSurface = createSurface;
                    this._surfaces = [];
                }
                Object.defineProperty(SimpleAllocator.prototype, 'surfaces', {
                    get: function () {
                        return this._surfaces;
                    },
                    enumerable: true,
                    configurable: true
                });
                SimpleAllocator.prototype._createNewSurface = function (w, h) {
                    var surface = this._createSurface(w, h);
                    this._surfaces.push(surface);
                    return surface;
                };
                SimpleAllocator.prototype.addSurface = function (surface) {
                    this._surfaces.push(surface);
                };
                SimpleAllocator.prototype.allocate = function (w, h, excludeSurface) {
                    for (var i = 0; i < this._surfaces.length; i++) {
                        var surface = this._surfaces[i];
                        if (surface === excludeSurface) {
                            continue;
                        }
                        var region = surface.allocate(w, h);
                        if (region) {
                            return region;
                        }
                    }
                    return this._createNewSurface(w, h).allocate(w, h);
                };
                SimpleAllocator.prototype.free = function (region) {
                };
                return SimpleAllocator;
            }();
            SurfaceRegionAllocator.SimpleAllocator = SimpleAllocator;
        }(SurfaceRegionAllocator = GFX.SurfaceRegionAllocator || (GFX.SurfaceRegionAllocator = {})));
        var Rectangle = GFX.Geometry.Rectangle;
        var Matrix = GFX.Geometry.Matrix;
        var DirtyRegion = GFX.Geometry.DirtyRegion;
        var assert = Shumway.Debug.assert;
        (function (BlendMode) {
            BlendMode[BlendMode['Normal'] = 1] = 'Normal';
            BlendMode[BlendMode['Layer'] = 2] = 'Layer';
            BlendMode[BlendMode['Multiply'] = 3] = 'Multiply';
            BlendMode[BlendMode['Screen'] = 4] = 'Screen';
            BlendMode[BlendMode['Lighten'] = 5] = 'Lighten';
            BlendMode[BlendMode['Darken'] = 6] = 'Darken';
            BlendMode[BlendMode['Difference'] = 7] = 'Difference';
            BlendMode[BlendMode['Add'] = 8] = 'Add';
            BlendMode[BlendMode['Subtract'] = 9] = 'Subtract';
            BlendMode[BlendMode['Invert'] = 10] = 'Invert';
            BlendMode[BlendMode['Alpha'] = 11] = 'Alpha';
            BlendMode[BlendMode['Erase'] = 12] = 'Erase';
            BlendMode[BlendMode['Overlay'] = 13] = 'Overlay';
            BlendMode[BlendMode['HardLight'] = 14] = 'HardLight';
        }(GFX.BlendMode || (GFX.BlendMode = {})));
        var BlendMode = GFX.BlendMode;
        function getNodeTypeName(nodeType) {
            if (nodeType === 1    /* Node */)
                return 'Node';
            else if (nodeType === 3    /* Shape */)
                return 'Shape';
            else if (nodeType === 5    /* Group */)
                return 'Group';
            else if (nodeType === 13    /* Stage */)
                return 'Stage';
            else if (nodeType === 33    /* Renderable */)
                return 'Renderable';
        }
        /**
         * Basic node visitor. Inherit from this if you want a more sophisticated visitor, for instance all
         * renderers extends this class.
         */
        var NodeVisitor = function () {
            function NodeVisitor() {
            }
            NodeVisitor.prototype.visitNode = function (node, state) {
            };
            NodeVisitor.prototype.visitShape = function (node, state) {
                this.visitNode(node, state);
            };
            NodeVisitor.prototype.visitGroup = function (node, state) {
                this.visitNode(node, state);
                var children = node.getChildren();
                for (var i = 0; i < children.length; i++) {
                    children[i].visit(this, state);
                }
            };
            NodeVisitor.prototype.visitStage = function (node, state) {
                this.visitGroup(node, state);
            };
            NodeVisitor.prototype.visitRenderable = function (node, state) {
                this.visitNode(node, state);
            };
            return NodeVisitor;
        }();
        GFX.NodeVisitor = NodeVisitor;
        /**
         * Nodes that cache transformation state. These are used to thread state when traversing
         * the scene graph. Since they keep track of rendering state, they might as well become
         * scene graph nodes.
         */
        var State = function () {
            function State() {
            }
            return State;
        }();
        GFX.State = State;
        var PreRenderState = function (_super) {
            __extends(PreRenderState, _super);
            function PreRenderState() {
                _super.call(this);
                this.depth = 0;
            }
            return PreRenderState;
        }(State);
        GFX.PreRenderState = PreRenderState;
        /**
         * Helper visitor that checks and resets the dirty bit and calculates stack levels. If the root
         * node is dirty, then we have to repaint the entire node tree.
         */
        var PreRenderVisitor = function (_super) {
            __extends(PreRenderVisitor, _super);
            function PreRenderVisitor() {
                _super.apply(this, arguments);
                this.isDirty = true;
                this._dirtyRegion = null;
                this._depth = 0;
            }
            PreRenderVisitor.prototype.start = function (node, dirtyRegion) {
                this._dirtyRegion = dirtyRegion;
                this._depth = 0;
                node.visit(this, null);
            };
            PreRenderVisitor.prototype.visitGroup = function (node, state) {
                var children = node.getChildren();
                this.visitNode(node, state);
                for (var i = 0; i < children.length; i++) {
                    children[i].visit(this, state);
                }
            };
            PreRenderVisitor.prototype.visitNode = function (node, state) {
                if (node.hasFlags(4096    /* Dirty */)) {
                    this.isDirty = true;
                }
                node.toggleFlags(4096    /* Dirty */, false);
                node.depth = this._depth++;
            };
            return PreRenderVisitor;
        }(NodeVisitor);
        GFX.PreRenderVisitor = PreRenderVisitor;
        /**
         * Debugging visitor.
         */
        var TracingNodeVisitor = function (_super) {
            __extends(TracingNodeVisitor, _super);
            function TracingNodeVisitor(writer) {
                _super.call(this);
                this.writer = writer;
            }
            TracingNodeVisitor.prototype.visitNode = function (node, state) {
            };
            TracingNodeVisitor.prototype.visitShape = function (node, state) {
                this.writer.writeLn(node.toString());
                this.visitNode(node, state);
            };
            TracingNodeVisitor.prototype.visitGroup = function (node, state) {
                this.visitNode(node, state);
                var children = node.getChildren();
                this.writer.enter(node.toString() + ' ' + children.length);
                for (var i = 0; i < children.length; i++) {
                    children[i].visit(this, state);
                }
                this.writer.outdent();
            };
            TracingNodeVisitor.prototype.visitStage = function (node, state) {
                this.visitGroup(node, state);
            };
            return TracingNodeVisitor;
        }(NodeVisitor);
        GFX.TracingNodeVisitor = TracingNodeVisitor;
        /**
         * Base class of all nodes in the scene graph.
         */
        var Node = function () {
            function Node() {
                /**
                 * Number of sibillings to clip.
                 */
                this._clip = -1;
                this._eventListeners = null;
                this._id = Node._nextId++;
                this._type = 1    /* Node */;
                this._index = -1;
                this._parent = null;
                this.reset();
            }
            Object.defineProperty(Node.prototype, 'id', {
                get: function () {
                    return this._id;
                },
                enumerable: true,
                configurable: true
            });
            Node.prototype._dispatchEvent = function (type) {
                if (!this._eventListeners) {
                    return;
                }
                var listeners = this._eventListeners;
                for (var i = 0; i < listeners.length; i++) {
                    var listener = listeners[i];
                    if (listener.type === type) {
                        listener.listener(this, type);
                    }
                }
            };
            /**
             * Adds an event listener.
             */
            Node.prototype.addEventListener = function (type, listener) {
                if (!this._eventListeners) {
                    this._eventListeners = [];
                }
                this._eventListeners.push({
                    type: type,
                    listener: listener
                });
            };
            /**
             * Removes an event listener.
             */
            Node.prototype.removeEventListener = function (type, listener) {
                var listeners = this._eventListeners;
                for (var i = 0; i < listeners.length; i++) {
                    var listenerObject = listeners[i];
                    if (listenerObject.type === type && listenerObject.listener === listener) {
                        listeners.splice(i, 1);
                        return;
                    }
                }
            };
            Object.defineProperty(Node.prototype, 'properties', {
                get: function () {
                    return this._properties || (this._properties = {});
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Resets the Node to its initial state but preserves its identity.
             * It safe to call this on a child without disrupting ownership.
             */
            Node.prototype.reset = function () {
                this._flags = 59393    /* Default */;
                this._bounds = null;
                this._layer = null;
                this._transform = null;
                this._properties = null;
                this.depth = -1;
            };
            Object.defineProperty(Node.prototype, 'clip', {
                get: function () {
                    return this._clip;
                },
                set: function (value) {
                    this._clip = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Node.prototype, 'parent', {
                get: function () {
                    return this._parent;
                },
                enumerable: true,
                configurable: true
            });
            Node.prototype.getTransformedBounds = function (target) {
                var bounds = this.getBounds(true);
                if (target === this || bounds.isEmpty()) {
                } else {
                    var m = this.getTransform().getConcatenatedMatrix();
                    if (target) {
                        var t = target.getTransform().getInvertedConcatenatedMatrix(true);
                        t.preMultiply(m);
                        t.transformRectangleAABB(bounds);
                        t.free();
                    } else {
                        m.transformRectangleAABB(bounds);
                    }
                }
                return bounds;
            };
            Node.prototype._markCurrentBoundsAsDirtyRegion = function () {
                // return;
                var stage = this.getStage();
                if (!stage) {
                    return;
                }
                var bounds = this.getTransformedBounds(stage);
                stage.dirtyRegion.addDirtyRectangle(bounds);
            };
            Node.prototype.getStage = function (withDirtyRegion) {
                if (withDirtyRegion === void 0) {
                    withDirtyRegion = true;
                }
                var node = this._parent;
                while (node) {
                    if (node.isType(13    /* Stage */)) {
                        var stage = node;
                        if (withDirtyRegion) {
                            if (stage.dirtyRegion) {
                                return stage;
                            }
                        } else {
                            return stage;
                        }
                    }
                    node = node._parent;
                }
                return null;
            };
            /**
             * This shouldn't be used on any hot path becuse it allocates.
             */
            Node.prototype.getChildren = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                throw Shumway.Debug.abstractMethod('Node::getChildren');
            };
            Node.prototype.getBounds = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                throw Shumway.Debug.abstractMethod('Node::getBounds');
            };
            /**
             * Can only be set on nodes without the |NodeFlags.BoundsAutoCompute| flag set.
             */
            Node.prototype.setBounds = function (value) {
                release || assert(!(this._flags & 2048    /* BoundsAutoCompute */));
                var bounds = this._bounds || (this._bounds = Rectangle.createEmpty());
                bounds.set(value);
                this.removeFlags(8192    /* InvalidBounds */);
            };
            Node.prototype.clone = function () {
                throw Shumway.Debug.abstractMethod('Node::clone');
            };
            Node.prototype.setFlags = function (flags) {
                this._flags |= flags;
            };
            Node.prototype.hasFlags = function (flags) {
                return (this._flags & flags) === flags;
            };
            Node.prototype.hasAnyFlags = function (flags) {
                return !!(this._flags & flags);
            };
            Node.prototype.removeFlags = function (flags) {
                this._flags &= ~flags;
            };
            Node.prototype.toggleFlags = function (flags, on) {
                if (on) {
                    this._flags |= flags;
                } else {
                    this._flags &= ~flags;
                }
            };
            /**
             * Propagates flags up the tree. Propagation stops if all flags are already set.
             */
            Node.prototype._propagateFlagsUp = function (flags) {
                if (flags === 0    /* None */ || this.hasFlags(flags)) {
                    return;
                }
                if (!this.hasFlags(2048    /* BoundsAutoCompute */)) {
                    flags &= ~8192    /* InvalidBounds */;
                }
                this.setFlags(flags);
                var parent = this._parent;
                if (parent) {
                    parent._propagateFlagsUp(flags);
                }
            };
            /**
             * Propagates flags down the tree. Non-containers just set the flags on themselves.
             */
            Node.prototype._propagateFlagsDown = function (flags) {
                throw Shumway.Debug.abstractMethod('Node::_propagateFlagsDown');
            };
            Node.prototype.isAncestor = function (node) {
                while (node) {
                    if (node === this) {
                        return true;
                    }
                    release || assert(node !== node._parent);
                    node = node._parent;
                }
                return false;
            };
            /**
             * Return's a list of ancestors excluding the |last|, the return list is reused.
             */
            Node._getAncestors = function (node, last) {
                var path = Node._path;
                path.length = 0;
                while (node && node !== last) {
                    release || assert(node !== node._parent);
                    path.push(node);
                    node = node._parent;
                }
                release || assert(node === last, 'Last ancestor is not an ancestor.');
                return path;
            };
            /**
             * Finds the closest ancestor with a given set of flags that are either turned on or off.
             */
            Node.prototype._findClosestAncestor = function (flags, on) {
                var node = this;
                while (node) {
                    if (node.hasFlags(flags) === on) {
                        return node;
                    }
                    release || assert(node !== node._parent);
                    node = node._parent;
                }
                return null;
            };
            /**
             * Type check.
             */
            Node.prototype.isType = function (type) {
                return this._type === type;
            };
            /**
             * Subtype check.
             */
            Node.prototype.isTypeOf = function (type) {
                return (this._type & type) === type;
            };
            Node.prototype.isLeaf = function () {
                return this.isType(33    /* Renderable */) || this.isType(3    /* Shape */);
            };
            Node.prototype.isLinear = function () {
                if (this.isLeaf()) {
                    return true;
                }
                if (this.isType(5    /* Group */)) {
                    var children = this._children;
                    if (children.length === 1 && children[0].isLinear()) {
                        return true;
                    }
                }
                return false;
            };
            Node.prototype.getTransformMatrix = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                return this.getTransform().getMatrix(clone);
            };
            Node.prototype.getTransform = function () {
                if (this._transform === null) {
                    this._transform = new Transform(this);
                }
                return this._transform;
            };
            Node.prototype.getLayer = function () {
                if (this._layer === null) {
                    this._layer = new Layer(this);
                }
                return this._layer;
            };
            Node.prototype.getLayerBounds = function (includeFilters) {
                var bounds = this.getBounds();
                if (includeFilters && this._layer) {
                    this._layer.expandBounds(bounds);
                }
                return bounds;
            };
            //    public getConcatenatedMatrix(clone: boolean = false): Matrix {
            //      var transform: Transform = this.getTransform(false);
            //      if (transform) {
            //        return transform.getConcatenatedMatrix(clone);
            //      }
            //      return Matrix.createIdentity();
            //    }
            /**
             * Dispatch on node types.
             */
            Node.prototype.visit = function (visitor, state) {
                switch (this._type) {
                case 1    /* Node */:
                    visitor.visitNode(this, state);
                    break;
                case 5    /* Group */:
                    visitor.visitGroup(this, state);
                    break;
                case 13    /* Stage */:
                    visitor.visitStage(this, state);
                    break;
                case 3    /* Shape */:
                    visitor.visitShape(this, state);
                    break;
                case 33    /* Renderable */:
                    visitor.visitRenderable(this, state);
                    break;
                default:
                    Shumway.Debug.unexpectedCase();
                }
            };
            Node.prototype.invalidate = function () {
                this._markCurrentBoundsAsDirtyRegion();
                this._propagateFlagsUp(12288    /* UpOnInvalidate */);
            };
            Node.prototype.toString = function (bounds) {
                if (bounds === void 0) {
                    bounds = false;
                }
                var s = getNodeTypeName(this._type) + ' ' + this._id;
                if (bounds) {
                    s += ' ' + this._bounds.toString();
                }
                return s;
            };
            /**
             * Temporary array of nodes to avoid allocations.
             */
            Node._path = [];
            /**
             * Used to give nodes unique ids.
             */
            Node._nextId = 0;
            return Node;
        }();
        GFX.Node = Node;
        /**
         * Nodes that contain other nodes.
         */
        var Group = function (_super) {
            __extends(Group, _super);
            function Group() {
                _super.call(this);
                this._type = 5    /* Group */;
                this._children = [];
            }
            Group.prototype.getChildren = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                if (clone) {
                    return this._children.slice(0);
                }
                return this._children;
            };
            Group.prototype.childAt = function (index) {
                release || assert(index >= 0 && index < this._children.length);
                return this._children[index];
            };
            Object.defineProperty(Group.prototype, 'child', {
                get: function () {
                    release || assert(this._children.length === 1);
                    return this._children[0];
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Group.prototype, 'groupChild', {
                get: function () {
                    release || assert(this._children.length === 1);
                    release || assert(this._children[0] instanceof Group);
                    return this._children[0];
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Adds a node and remove's it from its previous location if it has a parent and propagates
             * flags accordingly.
             */
            Group.prototype.addChild = function (node) {
                release || assert(node);
                release || assert(!node.isAncestor(this));
                if (node._parent) {
                    node._parent.removeChildAt(node._index);
                }
                node._parent = this;
                node._index = this._children.length;
                this._children.push(node);
                this._propagateFlagsUp(12288    /* UpOnAddedOrRemoved */);
                node._propagateFlagsDown(114688    /* DownOnAddedOrRemoved */);
                node._markCurrentBoundsAsDirtyRegion();
            };
            /**
             * Removes a child at the given index and propagates flags accordingly.
             */
            Group.prototype.removeChildAt = function (index) {
                release || assert(index >= 0 && index < this._children.length);
                var node = this._children[index];
                release || assert(index === node._index);
                node._markCurrentBoundsAsDirtyRegion();
                this._children.splice(index, 1);
                node._index = -1;
                node._parent = null;
                this._propagateFlagsUp(12288    /* UpOnAddedOrRemoved */);
                node._propagateFlagsDown(114688    /* DownOnAddedOrRemoved */);
            };
            Group.prototype.clearChildren = function () {
                for (var i = 0; i < this._children.length; i++) {
                    var child = this._children[i];
                    child._markCurrentBoundsAsDirtyRegion();
                    if (child) {
                        child._index = -1;
                        child._parent = null;
                        child._propagateFlagsDown(114688    /* DownOnAddedOrRemoved */);
                    }
                }
                this._children.length = 0;
                this._propagateFlagsUp(12288    /* UpOnAddedOrRemoved */);
            };
            /**
             * Override and propagate flags to all children.
             */
            Group.prototype._propagateFlagsDown = function (flags) {
                if (this.hasFlags(flags)) {
                    return;
                }
                this.setFlags(flags);
                var children = this._children;
                for (var i = 0; i < children.length; i++) {
                    children[i]._propagateFlagsDown(flags);
                }
            };
            /**
             * Takes the union of all child bounds and caches the bounds locally.
             */
            Group.prototype.getBounds = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                var bounds = this._bounds || (this._bounds = Rectangle.createEmpty());
                if (this.hasFlags(8192    /* InvalidBounds */)) {
                    bounds.setEmpty();
                    var children = this._children;
                    var childBounds = Rectangle.allocate();
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        childBounds.set(child.getBounds());
                        child.getTransformMatrix().transformRectangleAABB(childBounds);
                        bounds.union(childBounds);
                    }
                    childBounds.free();
                    this.removeFlags(8192    /* InvalidBounds */);
                }
                if (clone) {
                    return bounds.clone();
                }
                return bounds;
            };
            /**
             * Takes the union of all child bounds, optionaly including filter expansions.
             */
            Group.prototype.getLayerBounds = function (includeFilters) {
                if (!includeFilters) {
                    return this.getBounds();
                }
                var bounds = Rectangle.createEmpty();
                var children = this._children;
                var childBounds = Rectangle.allocate();
                for (var i = 0; i < children.length; i++) {
                    var child = children[i];
                    childBounds.set(child.getLayerBounds(includeFilters));
                    child.getTransformMatrix().transformRectangleAABB(childBounds);
                    bounds.union(childBounds);
                }
                childBounds.free();
                if (includeFilters && this._layer) {
                    this._layer.expandBounds(bounds);
                }
                return bounds;
            };
            return Group;
        }(Node);
        GFX.Group = Group;
        /**
         * Transform associated with a node. This helps to reduce the size of nodes.
         */
        var Transform = function () {
            function Transform(node) {
                this._node = node;
                this._matrix = Matrix.createIdentity();
                // MEMORY: Lazify construction.
                this._colorMatrix = GFX.ColorMatrix.createIdentity();
                // MEMORY: Lazify construction.
                this._concatenatedMatrix = Matrix.createIdentity();
                // MEMORY: Lazify construction.
                this._invertedConcatenatedMatrix = Matrix.createIdentity();
                // MEMORY: Lazify construction.
                this._concatenatedColorMatrix = GFX.ColorMatrix.createIdentity();    // MEMORY: Lazify construction.
            }
            //    public get x(): number {
            //      return this._matrix.tx;
            //    }
            //
            //    public set x(value: number) {
            //      this._matrix.tx = value;
            //      this._node._propagateFlagsUp(NodeFlags.UpOnMoved);
            //      this._node._propagateFlagsDown(NodeFlags.DownOnMoved);
            //    }
            //
            //    public get y(): number {
            //      return this._matrix.ty;
            //    }
            //
            //    public set y(value: number) {
            //      this._matrix.ty = value;
            //      this._node._propagateFlagsUp(NodeFlags.UpOnMoved);
            //      this._node._propagateFlagsDown(NodeFlags.DownOnMoved);
            //    }
            /**
             * Set a node's transform matrix. You should never mutate the matrix object directly.
             */
            Transform.prototype.setMatrix = function (value) {
                if (this._matrix.isEqual(value)) {
                    return;
                }
                this._node._markCurrentBoundsAsDirtyRegion();
                this._matrix.set(value);
                this._node._propagateFlagsUp(12288    /* UpOnMoved */);
                this._node._propagateFlagsDown(49152    /* DownOnMoved */);
                this._node._markCurrentBoundsAsDirtyRegion();
            };
            Transform.prototype.setColorMatrix = function (value) {
                this._colorMatrix.set(value);
                this._node._propagateFlagsUp(4096    /* UpOnColorMatrixChanged */);
                this._node._propagateFlagsDown(65536    /* DownOnColorMatrixChanged */);
                this._node._markCurrentBoundsAsDirtyRegion();
            };
            Transform.prototype.getMatrix = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                if (clone) {
                    return this._matrix.clone();
                }
                return this._matrix;
            };
            Transform.prototype.hasColorMatrix = function () {
                return this._colorMatrix !== null;
            };
            Transform.prototype.getColorMatrix = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                if (this._colorMatrix === null) {
                    this._colorMatrix = GFX.ColorMatrix.createIdentity();
                }
                if (clone) {
                    return this._colorMatrix.clone();
                }
                return this._colorMatrix;
            };
            /**
             * Compute the concatenated transforms for this node and all of its ancestors since we're already doing
             * all the work.
             */
            Transform.prototype.getConcatenatedMatrix = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                if (this._node.hasFlags(16384    /* InvalidConcatenatedMatrix */)) {
                    var ancestor = this._node._findClosestAncestor(16384    /* InvalidConcatenatedMatrix */, false);
                    var path = Node._getAncestors(this._node, ancestor);
                    var m = ancestor ? ancestor.getTransform()._concatenatedMatrix.clone() : Matrix.createIdentity();
                    for (var i = path.length - 1; i >= 0; i--) {
                        var ancestor = path[i];
                        var ancestorTransform = ancestor.getTransform();
                        release || assert(ancestor.hasFlags(16384    /* InvalidConcatenatedMatrix */));
                        m.preMultiply(ancestorTransform._matrix);
                        ancestorTransform._concatenatedMatrix.set(m);
                        ancestor.removeFlags(16384    /* InvalidConcatenatedMatrix */);
                    }
                }
                if (clone) {
                    return this._concatenatedMatrix.clone();
                }
                return this._concatenatedMatrix;
            };
            Transform.prototype.getInvertedConcatenatedMatrix = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                if (this._node.hasFlags(32768    /* InvalidInvertedConcatenatedMatrix */)) {
                    this.getConcatenatedMatrix().inverse(this._invertedConcatenatedMatrix);
                    this._node.removeFlags(32768    /* InvalidInvertedConcatenatedMatrix */);
                }
                if (clone) {
                    return this._invertedConcatenatedMatrix.clone();
                }
                return this._invertedConcatenatedMatrix;
            };
            //    public getConcatenatedColorMatrix(clone: boolean = false): ColorMatrix {
            //      // Compute the concatenated color transforms for this node and all of its ancestors.
            //      if (this.hasFlags(NodeFlags.InvalidConcatenatedColorMatrix)) {
            //        var ancestor = <Transform>this._findClosestAncestor(NodeFlags.InvalidConcatenatedColorMatrix, false);
            //        var path = <Transform []>Node._getAncestors(this, ancestor, NodeType.Transform);
            //        var m = ancestor ? ancestor._concatenatedColorMatrix.clone() : ColorMatrix.createIdentity();
            //        for (var i = path.length - 1; i >= 0; i--) {
            //          var ancestor = path[i];
            //          release || assert (ancestor.hasFlags(NodeFlags.InvalidConcatenatedColorMatrix));
            //          // TODO: Premultiply here.
            //          m.multiply(ancestor._colorMatrix);
            //          ancestor._concatenatedColorMatrix.set(m);
            //          ancestor.removeFlags(NodeFlags.InvalidConcatenatedColorMatrix);
            //        }
            //      }
            //      if (clone) {
            //        return this._concatenatedColorMatrix.clone();
            //      }
            //      return this._concatenatedColorMatrix;
            //    }
            Transform.prototype.toString = function () {
                return this._matrix.toString();
            };
            return Transform;
        }();
        GFX.Transform = Transform;
        /**
         * Layer information associated with a node. This helps to reduce the size of nodes.
         */
        var Layer = function () {
            function Layer(node) {
                this._node = node;
                this._mask = null;
                this._blendMode = BlendMode.Normal;
            }
            Object.defineProperty(Layer.prototype, 'filters', {
                get: function () {
                    return this._filters;
                },
                set: function (value) {
                    this._filters = value;
                    if (value.length) {
                        // TODO: We could avoid invalidating the node if the new filter list contains equal filter objects.
                        this._node.invalidate();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Layer.prototype, 'blendMode', {
                get: function () {
                    return this._blendMode;
                },
                set: function (value) {
                    this._blendMode = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Layer.prototype, 'mask', {
                get: function () {
                    return this._mask;
                },
                set: function (value) {
                    if (this._mask !== value) {
                        this._node.invalidate();
                        if (this._mask) {
                            this._mask.removeFlags(4    /* IsMask */);
                        }
                    }
                    this._mask = value;
                    if (this._mask) {
                        this._mask.setFlags(4    /* IsMask */);
                    }    // TODO: Keep track of masked object so we can propagate flags up.
                },
                enumerable: true,
                configurable: true
            });
            Layer.prototype.toString = function () {
                return BlendMode[this._blendMode];
            };
            Layer.prototype.expandBounds = function (bounds) {
                var filters = this._filters;
                if (filters) {
                    for (var i = 0; i < filters.length; i++) {
                        filters[i].expandBounds(bounds);
                    }
                }
            };
            return Layer;
        }();
        GFX.Layer = Layer;
        /**
         * Shapes are instantiations of Renderables.
         */
        var Shape = function (_super) {
            __extends(Shape, _super);
            function Shape(source) {
                _super.call(this);
                release || assert(source);
                this._source = source;
                this._type = 3    /* Shape */;
                this._ratio = 0;
            }
            Shape.prototype.getBounds = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                var bounds = this._bounds || (this._bounds = Rectangle.createEmpty());
                if (this.hasFlags(8192    /* InvalidBounds */)) {
                    bounds.set(this._source.getBounds());
                    this.removeFlags(8192    /* InvalidBounds */);
                }
                if (clone) {
                    return bounds.clone();
                }
                return bounds;
            };
            Object.defineProperty(Shape.prototype, 'source', {
                get: function () {
                    return this._source;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Shape.prototype, 'ratio', {
                get: function () {
                    return this._ratio;
                },
                set: function (value) {
                    if (value === this._ratio) {
                        return;
                    }
                    this.invalidate();
                    this._ratio = value;
                },
                enumerable: true,
                configurable: true
            });
            Shape.prototype._propagateFlagsDown = function (flags) {
                this.setFlags(flags);
            };
            Shape.prototype.getChildren = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                return [this._source];
            };
            return Shape;
        }(Node);
        GFX.Shape = Shape;
        function getRandomIntInclusive(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        var RendererOptions = function () {
            function RendererOptions() {
                this.debug = false;
                this.paintRenderable = true;
                this.paintBounds = false;
                this.paintDirtyRegion = false;
                this.paintFlashing = false;
                this.paintViewport = false;
                this.clear = true;
            }
            return RendererOptions;
        }();
        GFX.RendererOptions = RendererOptions;
        /**
         * Base class for all renderers.
         */
        var Renderer = function (_super) {
            __extends(Renderer, _super);
            function Renderer(container, stage, options) {
                _super.call(this);
                this._container = container;
                this._stage = stage;
                this._options = options;
                this._viewport = Rectangle.createSquare(1024);
                this._devicePixelRatio = 1;
            }
            Object.defineProperty(Renderer.prototype, 'viewport', {
                set: function (viewport) {
                    this._viewport.set(viewport);
                },
                enumerable: true,
                configurable: true
            });
            Renderer.prototype.render = function () {
                throw Shumway.Debug.abstractMethod('Renderer::render');
            };
            /**
             * Notify renderer that the viewport has changed.
             */
            Renderer.prototype.resize = function () {
                throw Shumway.Debug.abstractMethod('Renderer::resize');
            };
            /**
             * Captures a rectangular region of the easel as a dataURL as specified by |bounds|. |stageContent| indicates if the bounds
             * should be computed by looking at the bounds of the content of the easel rather than the easel itself.
             */
            Renderer.prototype.screenShot = function (bounds, stageContent, disableHidpi) {
                throw Shumway.Debug.abstractMethod('Renderer::screenShot');
            };
            return Renderer;
        }(NodeVisitor);
        GFX.Renderer = Renderer;
        /**
         * Node container that handles Flash style alignment and scale modes.
         */
        var Stage = function (_super) {
            __extends(Stage, _super);
            function Stage(w, h, trackDirtyRegion) {
                if (trackDirtyRegion === void 0) {
                    trackDirtyRegion = false;
                }
                _super.call(this);
                this._preVisitor = new PreRenderVisitor();
                this._flags &= ~2048    /* BoundsAutoCompute */;
                this._type = 13    /* Stage */;
                this._scaleMode = Stage.DEFAULT_SCALE;
                this._align = Stage.DEFAULT_ALIGN;
                this._content = new Group();
                this._content._flags &= ~2048    /* BoundsAutoCompute */;
                this.addChild(this._content);
                this.setFlags(4096    /* Dirty */);
                this.setBounds(new Rectangle(0, 0, w, h));
                if (trackDirtyRegion) {
                    this._dirtyRegion = new DirtyRegion(w, h);
                    this._dirtyRegion.addDirtyRectangle(new Rectangle(0, 0, w, h));
                } else {
                    this._dirtyRegion = null;
                }
                this._updateContentMatrix();
            }
            Object.defineProperty(Stage.prototype, 'dirtyRegion', {
                get: function () {
                    return this._dirtyRegion;
                },
                enumerable: true,
                configurable: true
            });
            Stage.prototype.setBounds = function (value) {
                _super.prototype.setBounds.call(this, value);
                this._updateContentMatrix();
                this._dispatchEvent(1    /* OnStageBoundsChanged */);
                if (this._dirtyRegion) {
                    this._dirtyRegion = new DirtyRegion(value.w, value.h);
                    this._dirtyRegion.addDirtyRectangle(value);
                }
            };
            Object.defineProperty(Stage.prototype, 'content', {
                get: function () {
                    return this._content;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Checks to see if we should render and if so, clears any relevant dirty flags. Returns
             * true if rendering should commence. Flag clearing is made optional here in case there
             * is any code that needs to check if rendering is about to happen.
             */
            Stage.prototype.readyToRender = function () {
                this._preVisitor.isDirty = false;
                this._preVisitor.start(this, this._dirtyRegion);
                if (this._preVisitor.isDirty) {
                    return true;
                }
                return false;
            };
            Object.defineProperty(Stage.prototype, 'align', {
                get: function () {
                    return this._align;
                },
                set: function (value) {
                    this._align = value;
                    this._updateContentMatrix();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Stage.prototype, 'scaleMode', {
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    this._scaleMode = value;
                    this._updateContentMatrix();
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Figure out what the content transform shuold be given the current align and scale modes.
             */
            Stage.prototype._updateContentMatrix = function () {
                if (this._scaleMode === Stage.DEFAULT_SCALE && this._align === Stage.DEFAULT_ALIGN) {
                    // Shortcut and also guard to avoid using targetWidth/targetHeight.
                    // ThetargetWidth/targetHeight normally set in setScaleAndAlign call.
                    this._content.getTransform().setMatrix(new Matrix(1, 0, 0, 1, 0, 0));
                    return;
                }
                var bounds = this.getBounds();
                var contentBounds = this._content.getBounds();
                // Debug.assert(this.targetWidth > 0 && this.targetHeight > 0);
                var wScale = bounds.w / contentBounds.w;
                var hScale = bounds.h / contentBounds.h;
                var scaleX, scaleY;
                switch (this._scaleMode) {
                case 2    /* NoBorder */:
                    scaleX = scaleY = Math.max(wScale, hScale);
                    break;
                case 4    /* NoScale */:
                    scaleX = scaleY = 1;
                    break;
                case 1    /* ExactFit */:
                    scaleX = wScale;
                    scaleY = hScale;
                    break;
                // case StageScaleMode.ShowAll:
                default:
                    scaleX = scaleY = Math.min(wScale, hScale);
                    break;
                }
                var offsetX;
                if (this._align & 4    /* Left */) {
                    offsetX = 0;
                } else if (this._align & 8    /* Right */) {
                    offsetX = bounds.w - contentBounds.w * scaleX;
                } else {
                    offsetX = (bounds.w - contentBounds.w * scaleX) / 2;
                }
                var offsetY;
                if (this._align & 1    /* Top */) {
                    offsetY = 0;
                } else if (this._align & 2    /* Bottom */) {
                    offsetY = bounds.h - contentBounds.h * scaleY;
                } else {
                    offsetY = (bounds.h - contentBounds.h * scaleY) / 2;
                }
                this._content.getTransform().setMatrix(new Matrix(scaleX, 0, 0, scaleY, offsetX, offsetY));
            };
            // Using these constants initially -- they don't require knowing bounds.
            // Notice that this default values are different from ActionScript object values.
            Stage.DEFAULT_SCALE = 4    /* NoScale */;
            Stage.DEFAULT_ALIGN = 4    /* Left */ | 1    /* Top */;
            return Stage;
        }(Group);
        GFX.Stage = Stage;
        var Point = GFX.Geometry.Point;
        var Rectangle = GFX.Geometry.Rectangle;
        var Matrix = GFX.Geometry.Matrix;
        var assertUnreachable = Shumway.Debug.assertUnreachable;
        var assert = Shumway.Debug.assert;
        var indexOf = Shumway.ArrayUtilities.indexOf;
        /**
         * Represents some source renderable content.
         */
        var Renderable = function (_super) {
            __extends(Renderable, _super);
            function Renderable() {
                _super.call(this);
                /**
                 * Back reference to nodes that use this renderable.
                 */
                this._parents = [];
                /**
                 * Back reference to renderables that use this renderable.
                 */
                this._renderableParents = [];
                this._invalidateEventListeners = null;
                this._flags &= ~2048    /* BoundsAutoCompute */;
                this._type = 33    /* Renderable */;
            }
            Object.defineProperty(Renderable.prototype, 'parents', {
                get: function () {
                    return this._parents;
                },
                enumerable: true,
                configurable: true
            });
            Renderable.prototype.addParent = function (frame) {
                release || assert(frame);
                var index = indexOf(this._parents, frame);
                release || assert(index < 0);
                this._parents.push(frame);
            };
            /**
             * Checks if this node will be reached by the renderer.
             */
            Renderable.prototype.willRender = function () {
                var parents = this._parents;
                for (var i = 0; i < parents.length; i++) {
                    var node = parents[i];
                    while (node) {
                        if (node.isType(13    /* Stage */)) {
                            return true;
                        }
                        if (!node.hasFlags(1    /* Visible */)) {
                            break;
                        }
                        node = node._parent;
                    }
                }
                return false;
            };
            Renderable.prototype.addRenderableParent = function (renderable) {
                release || assert(renderable);
                release || assert(this._renderableParents.indexOf(renderable) === -1);
                this._renderableParents.push(renderable);
            };
            /**
             * Returns the first unrooted parent or creates a new parent if none was found.
             */
            Renderable.prototype.wrap = function () {
                var node;
                var parents = this._parents;
                for (var i = 0; i < parents.length; i++) {
                    node = parents[i];
                    if (!node._parent) {
                        return node;
                    }
                }
                node = new GFX.Shape(this);
                this.addParent(node);
                return node;
            };
            Renderable.prototype.invalidate = function () {
                this.setFlags(4096    /* Dirty */);
                var nodes = this._parents;
                for (var i = 0; i < nodes.length; i++) {
                    nodes[i].invalidate();
                }
                var renderables = this._renderableParents;
                for (var i = 0; i < renderables.length; i++) {
                    renderables[i].invalidate();
                }
                var listeners = this._invalidateEventListeners;
                if (listeners) {
                    for (var i = 0; i < listeners.length; i++) {
                        listeners[i](this);
                    }
                }
            };
            Renderable.prototype.addInvalidateEventListener = function (listener) {
                if (!this._invalidateEventListeners) {
                    this._invalidateEventListeners = [];
                }
                var index = indexOf(this._invalidateEventListeners, listener);
                release || assert(index < 0);
                this._invalidateEventListeners.push(listener);
            };
            Renderable.prototype.getBounds = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                if (clone) {
                    return this._bounds.clone();
                }
                return this._bounds;
            };
            Renderable.prototype.getChildren = function (clone) {
                if (clone === void 0) {
                    clone = false;
                }
                return null;
            };
            Renderable.prototype._propagateFlagsUp = function (flags) {
                if (flags === 0    /* None */ || this.hasFlags(flags)) {
                    return;
                }
                for (var i = 0; i < this._parents.length; i++) {
                    this._parents[i]._propagateFlagsUp(flags);
                }
            };
            /**
             * Render source content in the specified |context| or add one or more paths to |clipPath| if specified.
             * If specified, the rectangular |cullBounds| can be used to cull parts of the shape for better performance.
             * If |paintStencil| is |true| then we must not create any alpha values, and also not paint any strokes.
             */
            Renderable.prototype.render = function (context, ratio, cullBounds, clipPath, paintStencil) {
            };
            return Renderable;
        }(GFX.Node);
        GFX.Renderable = Renderable;
        var CustomRenderable = function (_super) {
            __extends(CustomRenderable, _super);
            function CustomRenderable(bounds, render) {
                _super.call(this);
                this.setBounds(bounds);
                this.render = render;
            }
            return CustomRenderable;
        }(Renderable);
        GFX.CustomRenderable = CustomRenderable;
        var RenderableVideo = function (_super) {
            __extends(RenderableVideo, _super);
            function RenderableVideo(assetId, eventSerializer) {
                _super.call(this);
                this._flags = 256    /* Dynamic */ | 4096    /* Dirty */;
                this._lastTimeInvalidated = 0;
                this._lastPausedTime = 0;
                this._seekHappening = false;
                this._pauseHappening = false;
                this._isDOMElement = true;
                this.setBounds(new Rectangle(0, 0, 1, 1));
                this._assetId = assetId;
                this._eventSerializer = eventSerializer;
                var element = document.createElement('video');
                var elementEventHandler = this._handleVideoEvent.bind(this);
                element.preload = 'metadata';
                // for mobile devices
                element.addEventListener('play', elementEventHandler);
                element.addEventListener('pause', elementEventHandler);
                element.addEventListener('ended', elementEventHandler);
                element.addEventListener('loadeddata', elementEventHandler);
                element.addEventListener('progress', elementEventHandler);
                element.addEventListener('suspend', elementEventHandler);
                element.addEventListener('loadedmetadata', elementEventHandler);
                element.addEventListener('error', elementEventHandler);
                element.addEventListener('seeking', elementEventHandler);
                element.addEventListener('seeked', elementEventHandler);
                element.addEventListener('canplay', elementEventHandler);
                element.style.position = 'absolute';
                this._video = element;
                this._videoEventHandler = elementEventHandler;
                RenderableVideo._renderableVideos.push(this);
                if (typeof registerInspectorAsset !== 'undefined') {
                    registerInspectorAsset(-1, -1, this);
                }
                this._state = 1    /* Idle */;
            }
            Object.defineProperty(RenderableVideo.prototype, 'video', {
                get: function () {
                    return this._video;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableVideo.prototype, 'state', {
                get: function () {
                    return this._state;
                },
                enumerable: true,
                configurable: true
            });
            RenderableVideo.prototype.play = function () {
                this._state = 2    /* Playing */;
                this._video.play();
            };
            RenderableVideo.prototype.pause = function () {
                this._state = 3    /* Paused */;
                this._video.pause();
            };
            RenderableVideo.prototype._handleVideoEvent = function (evt) {
                var type;
                var data = null;
                var element = this._video;
                switch (evt.type) {
                case 'play':
                    if (!this._pauseHappening) {
                        return;
                    }
                    type = 7    /* Unpause */;
                    break;
                case 'pause':
                    if (this._state === 2    /* Playing */) {
                        element.play();
                        return;
                    }
                    type = 6    /* Pause */;
                    this._pauseHappening = true;
                    break;
                case 'ended':
                    this._state = 4    /* Ended */;
                    this._notifyNetStream(3    /* PlayStop */, data);
                    type = 4    /* BufferEmpty */;
                    break;
                case 'loadeddata':
                    this._pauseHappening = false;
                    this._notifyNetStream(2    /* PlayStart */, data);
                    this.play();
                    return;
                case 'canplay':
                    if (this._pauseHappening) {
                        return;
                    }
                    type = 5    /* BufferFull */;
                    break;
                case 'progress':
                    type = 10    /* Progress */;
                    break;
                case 'suspend':
                    //          type = VideoPlaybackEvent.BufferEmpty;
                    //          break;
                    return;
                case 'loadedmetadata':
                    type = 1    /* Metadata */;
                    data = {
                        videoWidth: element.videoWidth,
                        videoHeight: element.videoHeight,
                        duration: element.duration
                    };
                    break;
                case 'error':
                    type = 11    /* Error */;
                    data = { code: element.error.code };
                    break;
                case 'seeking':
                    if (!this._seekHappening) {
                        return;
                    }
                    type = 8    /* Seeking */;
                    break;
                case 'seeked':
                    if (!this._seekHappening) {
                        return;
                    }
                    type = 9    /* Seeked */;
                    this._seekHappening = false;
                    break;
                default:
                    return;    // unhandled event
                }
                this._notifyNetStream(type, data);
            };
            RenderableVideo.prototype._notifyNetStream = function (eventType, data) {
                this._eventSerializer.sendVideoPlaybackEvent(this._assetId, eventType, data);
            };
            RenderableVideo.prototype.processControlRequest = function (type, data) {
                var videoElement = this._video;
                var ESTIMATED_VIDEO_SECOND_SIZE = 500;
                switch (type) {
                case 1    /* Init */:
                    videoElement.src = data.url;
                    this.play();
                    this._notifyNetStream(0    /* Initialized */, null);
                    break;
                case 9    /* EnsurePlaying */:
                    if (videoElement.paused) {
                        videoElement.play();
                    }
                    break;
                case 2    /* Pause */:
                    if (videoElement) {
                        if (data.paused && !videoElement.paused) {
                            if (!isNaN(data.time)) {
                                if (videoElement.seekable.length !== 0) {
                                    videoElement.currentTime = data.time;
                                }
                                this._lastPausedTime = data.time;
                            } else {
                                this._lastPausedTime = videoElement.currentTime;
                            }
                            this.pause();
                        } else if (!data.paused && videoElement.paused) {
                            this.play();
                            if (!isNaN(data.time) && this._lastPausedTime !== data.time && videoElement.seekable.length !== 0) {
                                videoElement.currentTime = data.time;
                            }
                        }
                    }
                    return;
                case 3    /* Seek */:
                    if (videoElement && videoElement.seekable.length !== 0) {
                        this._seekHappening = true;
                        videoElement.currentTime = data.time;
                    }
                    return;
                case 4    /* GetTime */:
                    return videoElement ? videoElement.currentTime : 0;
                case 5    /* GetBufferLength */:
                    return videoElement ? videoElement.duration : 0;
                case 6    /* SetSoundLevels */:
                    if (videoElement) {
                        videoElement.volume = data.volume;
                    }
                    return;
                case 7    /* GetBytesLoaded */:
                    if (!videoElement) {
                        return 0;
                    }
                    var bufferedTill = -1;
                    if (videoElement.buffered) {
                        for (var i = 0; i < videoElement.buffered.length; i++) {
                            bufferedTill = Math.max(bufferedTill, videoElement.buffered.end(i));
                        }
                    } else {
                        bufferedTill = videoElement.duration;
                    }
                    return Math.round(bufferedTill * ESTIMATED_VIDEO_SECOND_SIZE);
                case 8    /* GetBytesTotal */:
                    return videoElement ? Math.round(videoElement.duration * ESTIMATED_VIDEO_SECOND_SIZE) : 0;
                }
            };
            RenderableVideo.prototype.checkForUpdate = function () {
                if (this._lastTimeInvalidated !== this._video.currentTime) {
                    // Videos composited using DOM elements don't need to invalidate parents.
                    if (!this._isDOMElement) {
                        this.invalidate();
                    }
                }
                this._lastTimeInvalidated = this._video.currentTime;
            };
            RenderableVideo.checkForVideoUpdates = function () {
                var renderables = RenderableVideo._renderableVideos;
                for (var i = 0; i < renderables.length; i++) {
                    var renderable = renderables[i];
                    // Check if the node will be reached by the renderer.
                    if (renderable.willRender()) {
                        // If the nodes video element isn't already on the video layer, mark the node as invalid to
                        // make sure the video element will be added the next time the renderer reaches it.
                        if (!renderable._video.parentElement) {
                            renderable.invalidate();
                        }
                        renderable._video.style.zIndex = renderable.parents[0].depth + '';
                    } else if (renderable._video.parentElement) {
                        // The nodes video element should be removed if no longer visible.
                        renderable._dispatchEvent(2    /* RemovedFromStage */);
                    }
                    renderables[i].checkForUpdate();
                }
            };
            RenderableVideo.prototype.render = function (context, ratio, cullBounds) {
                GFX.enterTimeline('RenderableVideo.render');
                var videoElement = this._video;
                if (videoElement && videoElement.videoWidth > 0) {
                    context.drawImage(videoElement, 0, 0, videoElement.videoWidth, videoElement.videoHeight, 0, 0, this._bounds.w, this._bounds.h);
                }
                GFX.leaveTimeline('RenderableVideo.render');
            };
            RenderableVideo._renderableVideos = [];
            return RenderableVideo;
        }(Renderable);
        GFX.RenderableVideo = RenderableVideo;
        var RenderableBitmap = function (_super) {
            __extends(RenderableBitmap, _super);
            function RenderableBitmap(source, bounds) {
                _super.call(this);
                this._flags = 256    /* Dynamic */ | 4096    /* Dirty */;
                this.properties = {};
                this.setBounds(bounds);
                if (source instanceof HTMLCanvasElement) {
                    this._initializeSourceCanvas(source);
                } else {
                    this._sourceImage = source;
                }
            }
            RenderableBitmap.FromDataBuffer = function (type, dataBuffer, bounds) {
                GFX.enterTimeline('RenderableBitmap.FromDataBuffer');
                var canvas = document.createElement('canvas');
                canvas.width = bounds.w;
                canvas.height = bounds.h;
                var renderableBitmap = new RenderableBitmap(canvas, bounds);
                renderableBitmap.updateFromDataBuffer(type, dataBuffer);
                GFX.leaveTimeline('RenderableBitmap.FromDataBuffer');
                return renderableBitmap;
            };
            RenderableBitmap.FromNode = function (source, matrix, colorMatrix, blendMode, clipRect) {
                GFX.enterTimeline('RenderableBitmap.FromFrame');
                var canvas = document.createElement('canvas');
                var bounds = source.getBounds();
                canvas.width = bounds.w;
                canvas.height = bounds.h;
                var renderableBitmap = new RenderableBitmap(canvas, bounds);
                renderableBitmap.drawNode(source, matrix, colorMatrix, blendMode, clipRect);
                GFX.leaveTimeline('RenderableBitmap.FromFrame');
                return renderableBitmap;
            };
            /**
             * Returns a RenderableBitmap from an Image element, which it uses as its source.
             *
             * Takes `width` and `height` as arguments so it can deal with non-decoded images,
             * which will only get their data after asynchronous decoding has completed.
             */
            RenderableBitmap.FromImage = function (image, width, height) {
                return new RenderableBitmap(image, new Rectangle(0, 0, width, height));
            };
            RenderableBitmap.prototype.updateFromDataBuffer = function (type, dataBuffer) {
                if (!GFX.imageUpdateOption.value) {
                    return;
                }
                var buffer = dataBuffer.buffer;
                GFX.enterTimeline('RenderableBitmap.updateFromDataBuffer', { length: dataBuffer.length });
                if (type === Shumway.ImageType.JPEG || type === Shumway.ImageType.PNG || type === Shumway.ImageType.GIF) {
                    release || Shumway.Debug.assertUnreachable('Mustn\'t encounter un-decoded images here');
                } else {
                    var bounds = this._bounds;
                    var imageData = this._imageData;
                    if (!imageData || imageData.width !== bounds.w || imageData.height !== bounds.h) {
                        imageData = this._imageData = this._context.createImageData(bounds.w, bounds.h);
                    }
                    if (GFX.imageConvertOption.value) {
                        GFX.enterTimeline('ColorUtilities.convertImage');
                        var pixels = new Int32Array(buffer);
                        var out = new Int32Array(imageData.data.buffer);
                        Shumway.ColorUtilities.convertImage(type, Shumway.ImageType.StraightAlphaRGBA, pixels, out);
                        GFX.leaveTimeline('ColorUtilities.convertImage');
                    }
                    GFX.enterTimeline('putImageData');
                    this._ensureSourceCanvas();
                    this._context.putImageData(imageData, 0, 0);
                    GFX.leaveTimeline('putImageData');
                }
                this.invalidate();
                GFX.leaveTimeline('RenderableBitmap.updateFromDataBuffer');
            };
            /**
             * Writes the image data into the given |output| data buffer.
             */
            RenderableBitmap.prototype.readImageData = function (output) {
                output.writeRawBytes(this.imageData.data);
            };
            RenderableBitmap.prototype.render = function (context, ratio, cullBounds) {
                GFX.enterTimeline('RenderableBitmap.render');
                if (this.renderSource) {
                    context.drawImage(this.renderSource, 0, 0);
                } else {
                    this._renderFallback(context);
                }
                GFX.leaveTimeline('RenderableBitmap.render');
            };
            RenderableBitmap.prototype.drawNode = function (source, matrix, colorMatrix, blendMode, clip) {
                // TODO: Support colorMatrix and blendMode.
                GFX.enterTimeline('RenderableBitmap.drawFrame');
                // TODO: Hack to be able to compile this as part of gfx-base.
                var Canvas2D = GFX.Canvas2D;
                var bounds = this.getBounds();
                // TODO: don't create a new renderer every time.
                var renderer = new Canvas2D.Canvas2DRenderer(this._canvas, null);
                renderer.renderNode(source, clip || bounds, matrix);
                GFX.leaveTimeline('RenderableBitmap.drawFrame');
            };
            RenderableBitmap.prototype.mask = function (alphaValues) {
                var imageData = this.imageData;
                var pixels = new Int32Array(imageData.data.buffer);
                var T = Shumway.ColorUtilities.getUnpremultiplyTable();
                for (var i = 0; i < alphaValues.length; i++) {
                    var a = alphaValues[i];
                    if (a === 0) {
                        pixels[i] = 0;
                        continue;
                    }
                    if (a === 255) {
                        continue;
                    }
                    var pixel = pixels[i];
                    var r = pixel >> 0 & 255;
                    var g = pixel >> 8 & 255;
                    var b = pixel >> 16 & 255;
                    var o = a << 8;
                    r = T[o + Math.min(r, a)];
                    g = T[o + Math.min(g, a)];
                    b = T[o + Math.min(b, a)];
                    pixels[i] = a << 24 | b << 16 | g << 8 | r;
                }
                this._context.putImageData(imageData, 0, 0);
            };
            RenderableBitmap.prototype._initializeSourceCanvas = function (source) {
                this._canvas = source;
                this._context = this._canvas.getContext('2d');
            };
            RenderableBitmap.prototype._ensureSourceCanvas = function () {
                if (this._canvas) {
                    return;
                }
                var canvas = document.createElement('canvas');
                var bounds = this._bounds;
                canvas.width = bounds.w;
                canvas.height = bounds.h;
                this._initializeSourceCanvas(canvas);
            };
            Object.defineProperty(RenderableBitmap.prototype, 'imageData', {
                get: function () {
                    if (!this._canvas) {
                        release || assert(this._sourceImage);
                        this._ensureSourceCanvas();
                        this._context.drawImage(this._sourceImage, 0, 0);
                        this._sourceImage = null;
                    }
                    return this._context.getImageData(0, 0, this._bounds.w, this._bounds.h);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RenderableBitmap.prototype, 'renderSource', {
                get: function () {
                    return this._canvas || this._sourceImage;
                },
                enumerable: true,
                configurable: true
            });
            RenderableBitmap.prototype._renderFallback = function (context) {
                // Only render fallback in debug mode.
                if (release) {
                    return;
                }
                if (!this.fillStyle) {
                    this.fillStyle = Shumway.ColorStyle.randomStyle();
                }
                var bounds = this._bounds;
                context.save();
                context.beginPath();
                context.lineWidth = 2;
                context.fillStyle = this.fillStyle;
                context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                context.restore();
            };
            return RenderableBitmap;
        }(Renderable);
        GFX.RenderableBitmap = RenderableBitmap;
        var StyledPath = function () {
            function StyledPath(type, style, smoothImage, strokeProperties) {
                this.type = type;
                this.style = style;
                this.smoothImage = smoothImage;
                this.strokeProperties = strokeProperties;
                this.path = new Path2D();
                release || assert((type === 1    /* Stroke */ || type === 2    /* StrokeFill */) === !!strokeProperties);
            }
            return StyledPath;
        }();
        GFX.StyledPath = StyledPath;
        var StrokeProperties = function () {
            function StrokeProperties(thickness, scaleMode, capsStyle, jointsStyle, miterLimit) {
                this.thickness = thickness;
                this.scaleMode = scaleMode;
                this.capsStyle = capsStyle;
                this.jointsStyle = jointsStyle;
                this.miterLimit = miterLimit;
            }
            return StrokeProperties;
        }();
        GFX.StrokeProperties = StrokeProperties;
        function morph(start, end, ratio) {
            return start + (end - start) * ratio;
        }
        function morphColor(start, end, ratio) {
            return morph(start >> 24 & 255, end >> 24 & 255, ratio) << 24 | morph(start >> 16 & 255, end >> 16 & 255, ratio) << 16 | morph(start >> 8 & 255, end >> 8 & 255, ratio) << 8 | morph(start & 255, end & 255, ratio);
        }
        var RenderableShape = function (_super) {
            __extends(RenderableShape, _super);
            function RenderableShape(id, pathData, textures, bounds) {
                _super.call(this);
                this._flags = 4096    /* Dirty */ | 512    /* Scalable */ | 1024    /* Tileable */;
                this.properties = {};
                this.setBounds(bounds);
                this._id = id;
                this._pathData = pathData;
                this._textures = textures;
                if (textures.length) {
                    this.setFlags(256    /* Dynamic */);
                }
            }
            RenderableShape.prototype.update = function (pathData, textures, bounds) {
                this.setBounds(bounds);
                this._pathData = pathData;
                this._paths = null;
                this._textures = textures;
                this.setFlags(256    /* Dynamic */);
                this.invalidate();
            };
            /**
             * If |clipPath| is not |null| then we must add all paths to |clipPath| instead of drawing to |context|.
             * We also cannot call |save| or |restore| because those functions reset the current clipping region.
             * It looks like Flash ignores strokes when clipping so we can also ignore stroke paths when computing
             * the clip region.
             *
             * If |paintStencil| is |true| then we must not create any alpha values, and also not paint
             * any strokes.
             */
            RenderableShape.prototype.render = function (context, ratio, cullBounds, clipPath, paintStencil) {
                if (clipPath === void 0) {
                    clipPath = null;
                }
                if (paintStencil === void 0) {
                    paintStencil = false;
                }
                var paintStencilStyle = release ? '#000000' : '#FF4981';
                context.fillStyle = context.strokeStyle = 'transparent';
                var paths = this._deserializePaths(this._pathData, context, ratio);
                release || assert(paths);
                GFX.enterTimeline('RenderableShape.render', this);
                for (var i = 0; i < paths.length; i++) {
                    var path = paths[i];
                    context['mozImageSmoothingEnabled'] = context.msImageSmoothingEnabled = context['imageSmoothingEnabled'] = path.smoothImage;
                    if (path.type === 0    /* Fill */) {
                        if (clipPath) {
                            clipPath.addPath(path.path, context.currentTransform);
                        } else {
                            context.fillStyle = paintStencil ? paintStencilStyle : path.style;
                            context.fill(path.path, 'evenodd');
                            context.fillStyle = 'transparent';
                        }
                    } else if (!clipPath && !paintStencil) {
                        context.strokeStyle = path.style;
                        var lineScaleMode = 1    /* Normal */;
                        if (path.strokeProperties) {
                            lineScaleMode = path.strokeProperties.scaleMode;
                            context.lineWidth = path.strokeProperties.thickness;
                            context.lineCap = path.strokeProperties.capsStyle;
                            context.lineJoin = path.strokeProperties.jointsStyle;
                            context.miterLimit = path.strokeProperties.miterLimit;
                        }
                        // Special-cases 1px and 3px lines by moving the drawing position down/right by 0.5px.
                        // Flash apparently does this to create sharp, non-aliased lines in the normal case of thin
                        // lines drawn on round pixel values.
                        // Our handling doesn't always create the same results: for drawing coordinates with
                        // fractional values, Flash draws blurry lines. We do, too, but we still move the line
                        // down/right. Flash does something slightly different, with the result that a line drawn
                        // on coordinates slightly below round pixels (0.8, say) will be moved up/left.
                        // Properly fixing this would probably have to happen in the rasterizer. Or when replaying
                        // all the drawing commands, which seems expensive.
                        var lineWidth = context.lineWidth;
                        var isSpecialCaseWidth = lineWidth === 1 || lineWidth === 3;
                        if (isSpecialCaseWidth) {
                            context.translate(0.5, 0.5);
                        }
                        context.flashStroke(path.path, lineScaleMode);
                        if (isSpecialCaseWidth) {
                            context.translate(-0.5, -0.5);
                        }
                        context.strokeStyle = 'transparent';
                    }
                }
                GFX.leaveTimeline('RenderableShape.render');
            };
            RenderableShape.prototype._deserializePaths = function (data, context, ratio) {
                release || assert(data ? !this._paths : this._paths);
                GFX.enterTimeline('RenderableShape.deserializePaths');
                // TODO: Optimize path handling to use only one path if possible.
                // If both line and fill style are set at the same time, we don't need to duplicate the
                // geometry.
                if (this._paths) {
                    return this._paths;
                }
                var paths = this._paths = [];
                var fillPath = null;
                var strokePath = null;
                // We have to alway store the last position because Flash keeps the drawing cursor where it
                // was when changing fill or line style, whereas Canvas forgets it on beginning a new path.
                var x = 0;
                var y = 0;
                var cpX;
                var cpY;
                var formOpen = false;
                var formOpenX = 0;
                var formOpenY = 0;
                var commands = data.commands;
                var coordinates = data.coordinates;
                var styles = data.styles;
                styles.position = 0;
                var coordinatesIndex = 0;
                var commandsCount = data.commandsPosition;
                // Description of serialization format can be found in flash.display.Graphics.
                for (var commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                    var command = commands[commandIndex];
                    switch (command) {
                    case 9    /* MoveTo */:
                        release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                        if (formOpen && fillPath) {
                            fillPath.lineTo(formOpenX, formOpenY);
                            strokePath && strokePath.lineTo(formOpenX, formOpenY);
                        }
                        formOpen = true;
                        x = formOpenX = coordinates[coordinatesIndex++] / 20;
                        y = formOpenY = coordinates[coordinatesIndex++] / 20;
                        fillPath && fillPath.moveTo(x, y);
                        strokePath && strokePath.moveTo(x, y);
                        break;
                    case 10    /* LineTo */:
                        release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                        x = coordinates[coordinatesIndex++] / 20;
                        y = coordinates[coordinatesIndex++] / 20;
                        fillPath && fillPath.lineTo(x, y);
                        strokePath && strokePath.lineTo(x, y);
                        break;
                    case 11    /* CurveTo */:
                        release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                        cpX = coordinates[coordinatesIndex++] / 20;
                        cpY = coordinates[coordinatesIndex++] / 20;
                        x = coordinates[coordinatesIndex++] / 20;
                        y = coordinates[coordinatesIndex++] / 20;
                        fillPath && fillPath.quadraticCurveTo(cpX, cpY, x, y);
                        strokePath && strokePath.quadraticCurveTo(cpX, cpY, x, y);
                        break;
                    case 12    /* CubicCurveTo */:
                        release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                        cpX = coordinates[coordinatesIndex++] / 20;
                        cpY = coordinates[coordinatesIndex++] / 20;
                        var cpX2 = coordinates[coordinatesIndex++] / 20;
                        var cpY2 = coordinates[coordinatesIndex++] / 20;
                        x = coordinates[coordinatesIndex++] / 20;
                        y = coordinates[coordinatesIndex++] / 20;
                        fillPath && fillPath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                        strokePath && strokePath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                        break;
                    case 1    /* BeginSolidFill */:
                        release || assert(styles.bytesAvailable >= 4);
                        fillPath = this._createPath(0    /* Fill */, Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt()), false, null, x, y);
                        break;
                    case 3    /* BeginBitmapFill */:
                        var bitmapStyle = this._readBitmap(styles, context);
                        fillPath = this._createPath(0    /* Fill */, bitmapStyle.style, bitmapStyle.smoothImage, null, x, y);
                        break;
                    case 2    /* BeginGradientFill */:
                        fillPath = this._createPath(0    /* Fill */, this._readGradient(styles, context), false, null, x, y);
                        break;
                    case 4    /* EndFill */:
                        fillPath = null;
                        break;
                    case 5    /* LineStyleSolid */:
                        var color = Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt());
                        // Skip pixel hinting.
                        styles.position += 1;
                        var scaleMode = styles.readByte();
                        var capsStyle = RenderableShape.LINE_CAPS_STYLES[styles.readByte()];
                        var jointsStyle = RenderableShape.LINE_JOINTS_STYLES[styles.readByte()];
                        var strokeProperties = new StrokeProperties(coordinates[coordinatesIndex++] / 20, scaleMode, capsStyle, jointsStyle, styles.readByte());
                        // Look ahead at the following command to determine if this is a complex stroke style.
                        if (commands[commandIndex + 1] === 6    /* LineStyleGradient */) {
                            commandIndex++;
                            strokePath = this._createPath(2    /* StrokeFill */, this._readGradient(styles, context), false, strokeProperties, x, y);
                        } else if (commands[commandIndex + 1] === 6    /* LineStyleGradient */) {
                            commandIndex++;
                            var bitmapStyle = this._readBitmap(styles, context);
                            strokePath = this._createPath(2    /* StrokeFill */, bitmapStyle.style, bitmapStyle.smoothImage, strokeProperties, x, y);
                        } else {
                            strokePath = this._createPath(1    /* Stroke */, color, false, strokeProperties, x, y);
                        }
                        break;
                    case 8    /* LineEnd */:
                        strokePath = null;
                        break;
                    default:
                        release || assertUnreachable('Invalid command ' + command + ' encountered at index' + commandIndex + ' of ' + commandsCount);
                    }
                }
                release || assert(styles.bytesAvailable === 0);
                release || assert(commandIndex === commandsCount);
                release || assert(coordinatesIndex === data.coordinatesPosition);
                if (formOpen && fillPath) {
                    fillPath.lineTo(formOpenX, formOpenY);
                    strokePath && strokePath.lineTo(formOpenX, formOpenY);
                }
                this._pathData = null;
                GFX.leaveTimeline('RenderableShape.deserializePaths');
                return paths;
            };
            RenderableShape.prototype._createPath = function (type, style, smoothImage, strokeProperties, x, y) {
                var path = new StyledPath(type, style, smoothImage, strokeProperties);
                this._paths.push(path);
                path.path.moveTo(x, y);
                return path.path;
            };
            RenderableShape.prototype._readMatrix = function (data) {
                return new Matrix(data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat(), data.readFloat());
            };
            RenderableShape.prototype._readGradient = function (styles, context) {
                // Assert at least one color stop.
                release || assert(styles.bytesAvailable >= 1 + 1 + 6 * 4    /* matrix fields as floats */ + 1 + 1 + 4 + 1 + 1);
                var gradientType = styles.readUnsignedByte();
                var focalPoint = styles.readShort() * 2 / 255;
                release || assert(focalPoint >= -1 && focalPoint <= 1);
                var transform = this._readMatrix(styles);
                var gradient = gradientType === 16    /* Linear */ ? context.createLinearGradient(-1, 0, 1, 0) : context.createRadialGradient(focalPoint, 0, 0, 0, 0, 1);
                gradient.setTransform && gradient.setTransform(transform.toSVGMatrix());
                var colorStopsCount = styles.readUnsignedByte();
                for (var i = 0; i < colorStopsCount; i++) {
                    var ratio = styles.readUnsignedByte() / 255;
                    var cssColor = Shumway.ColorUtilities.rgbaToCSSStyle(styles.readUnsignedInt());
                    gradient.addColorStop(ratio, cssColor);
                }
                // Skip spread and interpolation modes for now.
                styles.position += 2;
                return gradient;
            };
            RenderableShape.prototype._readBitmap = function (styles, context) {
                release || assert(styles.bytesAvailable >= 4 + 6 * 4    /* matrix fields as floats */ + 1 + 1);
                var textureIndex = styles.readUnsignedInt();
                var fillTransform = this._readMatrix(styles);
                var repeat = styles.readBoolean() ? 'repeat' : 'no-repeat';
                var smooth = styles.readBoolean();
                var texture = this._textures[textureIndex];
                var fillStyle;
                if (texture) {
                    fillStyle = context.createPattern(texture.renderSource, repeat);
                    fillStyle.setTransform(fillTransform.toSVGMatrix());
                } else {
                    // TODO: Wire up initially-missing textures that become available later.
                    // An invalid SWF can have shape fills refer to images that occur later in the SWF. In that
                    // case, the image only becomes available once that frame is actually reached. Before that
                    // the fill isn't drawn; it is drawn once the image becomes available, though.
                    fillStyle = null;
                }
                return {
                    style: fillStyle,
                    smoothImage: smooth
                };
            };
            RenderableShape.prototype._renderFallback = function (context) {
                if (!this.fillStyle) {
                    this.fillStyle = Shumway.ColorStyle.randomStyle();
                }
                var bounds = this._bounds;
                context.save();
                context.beginPath();
                context.lineWidth = 2;
                context.fillStyle = this.fillStyle;
                context.fillRect(bounds.x, bounds.y, bounds.w, bounds.h);
                //      context.textBaseline = "top";
                //      context.fillStyle = "white";
                //      context.fillText(String(id), bounds.x, bounds.y);
                context.restore();
            };
            RenderableShape.LINE_CAPS_STYLES = [
                'round',
                'butt',
                'square'
            ];
            RenderableShape.LINE_JOINTS_STYLES = [
                'round',
                'bevel',
                'miter'
            ];
            return RenderableShape;
        }(Renderable);
        GFX.RenderableShape = RenderableShape;
        var RenderableMorphShape = function (_super) {
            __extends(RenderableMorphShape, _super);
            function RenderableMorphShape() {
                _super.apply(this, arguments);
                this._flags = 256    /* Dynamic */ | 4096    /* Dirty */ | 512    /* Scalable */ | 1024    /* Tileable */;
                this._morphPaths = Object.create(null);
            }
            RenderableMorphShape.prototype._deserializePaths = function (data, context, ratio) {
                GFX.enterTimeline('RenderableMorphShape.deserializePaths');
                // TODO: Optimize path handling to use only one path if possible.
                // If both line and fill style are set at the same time, we don't need to duplicate the
                // geometry.
                if (this._morphPaths[ratio]) {
                    return this._morphPaths[ratio];
                }
                var paths = this._morphPaths[ratio] = [];
                var fillPath = null;
                var strokePath = null;
                // We have to alway store the last position because Flash keeps the drawing cursor where it
                // was when changing fill or line style, whereas Canvas forgets it on beginning a new path.
                var x = 0;
                var y = 0;
                var cpX;
                var cpY;
                var formOpen = false;
                var formOpenX = 0;
                var formOpenY = 0;
                var commands = data.commands;
                var coordinates = data.coordinates;
                var morphCoordinates = data.morphCoordinates;
                var styles = data.styles;
                var morphStyles = data.morphStyles;
                styles.position = 0;
                morphStyles.position = 0;
                var coordinatesIndex = 0;
                var commandsCount = data.commandsPosition;
                // Description of serialization format can be found in flash.display.Graphics.
                for (var commandIndex = 0; commandIndex < commandsCount; commandIndex++) {
                    var command = commands[commandIndex];
                    switch (command) {
                    case 9    /* MoveTo */:
                        release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                        if (formOpen && fillPath) {
                            fillPath.lineTo(formOpenX, formOpenY);
                            strokePath && strokePath.lineTo(formOpenX, formOpenY);
                        }
                        formOpen = true;
                        x = formOpenX = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        y = formOpenY = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        fillPath && fillPath.moveTo(x, y);
                        strokePath && strokePath.moveTo(x, y);
                        break;
                    case 10    /* LineTo */:
                        release || assert(coordinatesIndex <= data.coordinatesPosition - 2);
                        x = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        y = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        fillPath && fillPath.lineTo(x, y);
                        strokePath && strokePath.lineTo(x, y);
                        break;
                    case 11    /* CurveTo */:
                        release || assert(coordinatesIndex <= data.coordinatesPosition - 4);
                        cpX = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        cpY = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        x = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        y = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        fillPath && fillPath.quadraticCurveTo(cpX, cpY, x, y);
                        strokePath && strokePath.quadraticCurveTo(cpX, cpY, x, y);
                        break;
                    case 12    /* CubicCurveTo */:
                        release || assert(coordinatesIndex <= data.coordinatesPosition - 6);
                        cpX = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        cpY = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        var cpX2 = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        var cpY2 = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        x = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        y = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        fillPath && fillPath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                        strokePath && strokePath.bezierCurveTo(cpX, cpY, cpX2, cpY2, x, y);
                        break;
                    case 1    /* BeginSolidFill */:
                        release || assert(styles.bytesAvailable >= 4);
                        fillPath = this._createMorphPath(0    /* Fill */, ratio, Shumway.ColorUtilities.rgbaToCSSStyle(morphColor(styles.readUnsignedInt(), morphStyles.readUnsignedInt(), ratio)), false, null, x, y);
                        break;
                    case 3    /* BeginBitmapFill */:
                        var bitmapStyle = this._readMorphBitmap(styles, morphStyles, ratio, context);
                        fillPath = this._createMorphPath(0    /* Fill */, ratio, bitmapStyle.style, bitmapStyle.smoothImage, null, x, y);
                        break;
                    case 2    /* BeginGradientFill */:
                        var gradientStyle = this._readMorphGradient(styles, morphStyles, ratio, context);
                        fillPath = this._createMorphPath(0    /* Fill */, ratio, gradientStyle, false, null, x, y);
                        break;
                    case 4    /* EndFill */:
                        fillPath = null;
                        break;
                    case 5    /* LineStyleSolid */:
                        var width = morph(coordinates[coordinatesIndex], morphCoordinates[coordinatesIndex++], ratio) / 20;
                        var color = Shumway.ColorUtilities.rgbaToCSSStyle(morphColor(styles.readUnsignedInt(), morphStyles.readUnsignedInt(), ratio));
                        // Skip pixel hinting.
                        styles.position += 1;
                        var scaleMode = styles.readByte();
                        var capsStyle = RenderableShape.LINE_CAPS_STYLES[styles.readByte()];
                        var jointsStyle = RenderableShape.LINE_JOINTS_STYLES[styles.readByte()];
                        var strokeProperties = new StrokeProperties(width, scaleMode, capsStyle, jointsStyle, styles.readByte());
                        if (strokeProperties.thickness > 0) {
                            strokePath = this._createMorphPath(1    /* Stroke */, ratio, color, false, strokeProperties, x, y);
                        }
                        break;
                    case 6    /* LineStyleGradient */:
                        var gradientStyle = this._readMorphGradient(styles, morphStyles, ratio, context);
                        strokePath = this._createMorphPath(2    /* StrokeFill */, ratio, gradientStyle, false, null, x, y);
                        break;
                    case 7    /* LineStyleBitmap */:
                        var bitmapStyle = this._readMorphBitmap(styles, morphStyles, ratio, context);
                        strokePath = this._createMorphPath(2    /* StrokeFill */, ratio, bitmapStyle.style, bitmapStyle.smoothImage, null, x, y);
                        break;
                    case 8    /* LineEnd */:
                        strokePath = null;
                        break;
                    default:
                        release || assertUnreachable('Invalid command ' + command + ' encountered at index' + commandIndex + ' of ' + commandsCount);
                    }
                }
                release || assert(styles.bytesAvailable === 0);
                release || assert(commandIndex === commandsCount);
                release || assert(coordinatesIndex === data.coordinatesPosition);
                if (formOpen && fillPath) {
                    fillPath.lineTo(formOpenX, formOpenY);
                    strokePath && strokePath.lineTo(formOpenX, formOpenY);
                }
                GFX.leaveTimeline('RenderableMorphShape.deserializPaths');
                return paths;
            };
            RenderableMorphShape.prototype._createMorphPath = function (type, ratio, style, smoothImage, strokeProperties, x, y) {
                var path = new StyledPath(type, style, smoothImage, strokeProperties);
                this._morphPaths[ratio].push(path);
                path.path.moveTo(x, y);
                return path.path;
            };
            RenderableMorphShape.prototype._readMorphMatrix = function (data, morphData, ratio) {
                return new Matrix(morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio), morph(data.readFloat(), morphData.readFloat(), ratio));
            };
            RenderableMorphShape.prototype._readMorphGradient = function (styles, morphStyles, ratio, context) {
                // Assert at least one color stop.
                release || assert(styles.bytesAvailable >= 1 + 1 + 6 * 4    /* matrix fields as floats */ + 1 + 1 + 4 + 1 + 1);
                var gradientType = styles.readUnsignedByte();
                var focalPoint = styles.readShort() * 2 / 255;
                release || assert(focalPoint >= -1 && focalPoint <= 1);
                var transform = this._readMorphMatrix(styles, morphStyles, ratio);
                var gradient = gradientType === 16    /* Linear */ ? context.createLinearGradient(-1, 0, 1, 0) : context.createRadialGradient(focalPoint, 0, 0, 0, 0, 1);
                gradient.setTransform && gradient.setTransform(transform.toSVGMatrix());
                var colorStopsCount = styles.readUnsignedByte();
                for (var i = 0; i < colorStopsCount; i++) {
                    var stop = morph(styles.readUnsignedByte() / 255, morphStyles.readUnsignedByte() / 255, ratio);
                    var color = morphColor(styles.readUnsignedInt(), morphStyles.readUnsignedInt(), ratio);
                    var cssColor = Shumway.ColorUtilities.rgbaToCSSStyle(color);
                    gradient.addColorStop(stop, cssColor);
                }
                // Skip spread and interpolation modes for now.
                styles.position += 2;
                return gradient;
            };
            RenderableMorphShape.prototype._readMorphBitmap = function (styles, morphStyles, ratio, context) {
                release || assert(styles.bytesAvailable >= 4 + 6 * 4    /* matrix fields as floats */ + 1 + 1);
                var textureIndex = styles.readUnsignedInt();
                var fillTransform = this._readMorphMatrix(styles, morphStyles, ratio);
                var repeat = styles.readBoolean() ? 'repeat' : 'no-repeat';
                var smooth = styles.readBoolean();
                var texture = this._textures[textureIndex];
                release || assert(texture._canvas);
                var fillStyle = context.createPattern(texture._canvas, repeat);
                fillStyle.setTransform(fillTransform.toSVGMatrix());
                return {
                    style: fillStyle,
                    smoothImage: smooth
                };
            };
            return RenderableMorphShape;
        }(RenderableShape);
        GFX.RenderableMorphShape = RenderableMorphShape;
        var TextLine = function () {
            function TextLine() {
                this.x = 0;
                this.y = 0;
                this.width = 0;
                this.ascent = 0;
                this.descent = 0;
                this.leading = 0;
                this.align = 0;
                this.runs = [];
            }
            TextLine._getMeasureContext = function () {
                if (!TextLine._measureContext) {
                    TextLine._measureContext = document.createElement('canvas').getContext('2d');
                }
                return TextLine._measureContext;
            };
            TextLine.prototype.addRun = function (font, fillStyle, text, letterSpacing, underline) {
                if (text) {
                    var measureContext = TextLine._getMeasureContext();
                    measureContext.font = font;
                    var width = measureText(measureContext, text, letterSpacing);
                    this.runs.push(new TextRun(font, fillStyle, text, width, letterSpacing, underline));
                    this.width += width;
                }
            };
            TextLine.prototype.wrap = function (maxWidth) {
                var lines = [this];
                var runs = this.runs;
                var currentLine = this;
                currentLine.width = 0;
                currentLine.runs = [];
                var measureContext = TextLine._getMeasureContext();
                for (var i = 0; i < runs.length; i++) {
                    var run = runs[i];
                    var text = run.text;
                    run.text = '';
                    run.width = 0;
                    measureContext.font = run.font;
                    var spaceLeft = maxWidth;
                    var words = text.split(/[\s.-]/);
                    var offset = 0;
                    for (var j = 0; j < words.length; j++) {
                        var word = words[j];
                        var chunk = text.substr(offset, word.length + 1);
                        var letterSpacing = run.letterSpacing;
                        var wordWidth = measureText(measureContext, chunk, letterSpacing);
                        if (wordWidth > spaceLeft) {
                            do {
                                if (run.text) {
                                    currentLine.runs.push(run);
                                    currentLine.width += run.width;
                                    run = new TextRun(run.font, run.fillStyle, '', 0, run.letterSpacing, run.underline);
                                    var newLine = new TextLine();
                                    newLine.y = currentLine.y + currentLine.descent + currentLine.leading + currentLine.ascent | 0;
                                    newLine.ascent = currentLine.ascent;
                                    newLine.descent = currentLine.descent;
                                    newLine.leading = currentLine.leading;
                                    newLine.align = currentLine.align;
                                    lines.push(newLine);
                                    currentLine = newLine;
                                }
                                spaceLeft = maxWidth - wordWidth;
                                if (spaceLeft < 0) {
                                    var k = chunk.length;
                                    var t = chunk;
                                    var w = wordWidth;
                                    while (k > 1) {
                                        k--;
                                        t = chunk.substr(0, k);
                                        w = measureText(measureContext, t, letterSpacing);
                                        if (w <= maxWidth) {
                                            break;
                                        }
                                    }
                                    run.text = t;
                                    run.width = w;
                                    chunk = chunk.substr(k);
                                    wordWidth = measureText(measureContext, chunk, letterSpacing);
                                }
                            } while (chunk && spaceLeft < 0);
                        } else {
                            spaceLeft = spaceLeft - wordWidth;
                        }
                        run.text += chunk;
                        run.width += wordWidth;
                        offset += word.length + 1;
                    }
                    currentLine.runs.push(run);
                    currentLine.width += run.width;
                }
                return lines;
            };
            TextLine.prototype.toString = function () {
                return 'TextLine {x: ' + this.x + ', y: ' + this.y + ', width: ' + this.width + ', height: ' + (this.ascent + this.descent + this.leading) + '}';
            };
            return TextLine;
        }();
        GFX.TextLine = TextLine;
        var TextRun = function () {
            function TextRun(font, fillStyle, text, width, letterSpacing, underline) {
                if (font === void 0) {
                    font = '';
                }
                if (fillStyle === void 0) {
                    fillStyle = '';
                }
                if (text === void 0) {
                    text = '';
                }
                if (width === void 0) {
                    width = 0;
                }
                if (letterSpacing === void 0) {
                    letterSpacing = 0;
                }
                if (underline === void 0) {
                    underline = false;
                }
                this.font = font;
                this.fillStyle = fillStyle;
                this.text = text;
                this.width = width;
                this.letterSpacing = letterSpacing;
                this.underline = underline;
            }
            return TextRun;
        }();
        GFX.TextRun = TextRun;
        function measureText(context, text, letterSpacing) {
            var width = context.measureText(text).width | 0;
            if (letterSpacing > 0) {
                width += text.length * letterSpacing;
            }
            return width;
        }
        var RenderableText = function (_super) {
            __extends(RenderableText, _super);
            function RenderableText(bounds) {
                _super.call(this);
                this._flags = 256    /* Dynamic */ | 4096    /* Dirty */;
                this.properties = {};
                this._textBounds = bounds.clone();
                this._textRunData = null;
                this._plainText = '';
                this._backgroundColor = 0;
                this._borderColor = 0;
                this._matrix = Matrix.createIdentity();
                this._coords = null;
                this._scrollV = 1;
                this._scrollH = 0;
                this.textRect = bounds.clone();
                this.lines = [];
                this.setBounds(bounds);
            }
            RenderableText.prototype.setBounds = function (bounds) {
                _super.prototype.setBounds.call(this, bounds);
                this._textBounds.set(bounds);
                this.textRect.setElements(bounds.x + 2, bounds.y + 2, bounds.w - 2, bounds.h - 2);
            };
            RenderableText.prototype.setContent = function (plainText, textRunData, matrix, coords) {
                this._textRunData = textRunData;
                this._plainText = plainText;
                this._matrix.set(matrix);
                this._coords = coords;
                this.lines = [];
            };
            RenderableText.prototype.setStyle = function (backgroundColor, borderColor, scrollV, scrollH) {
                this._backgroundColor = backgroundColor;
                this._borderColor = borderColor;
                this._scrollV = scrollV;
                this._scrollH = scrollH;
            };
            RenderableText.prototype.reflow = function (autoSize, wordWrap) {
                var textRunData = this._textRunData;
                if (!textRunData) {
                    return;
                }
                var bounds = this._bounds;
                var availableWidth = bounds.w - 4;
                var plainText = this._plainText;
                var lines = this.lines;
                var currentLine = new TextLine();
                var baseLinePos = 0;
                var maxWidth = 0;
                var maxAscent = 0;
                var maxDescent = 0;
                var maxLeading = -4294967295;
                var firstAlign = -1;
                var finishLine = function () {
                    if (!currentLine.runs.length) {
                        baseLinePos += maxAscent + maxDescent + maxLeading;
                        return;
                    }
                    if (lines.length) {
                        baseLinePos += maxLeading;
                    }
                    baseLinePos += maxAscent;
                    currentLine.y = baseLinePos | 0;
                    baseLinePos += maxDescent;
                    currentLine.ascent = maxAscent;
                    currentLine.descent = maxDescent;
                    currentLine.leading = maxLeading;
                    currentLine.align = firstAlign;
                    if (wordWrap && currentLine.width > availableWidth) {
                        var wrappedLines = currentLine.wrap(availableWidth);
                        for (var i = 0; i < wrappedLines.length; i++) {
                            var line = wrappedLines[i];
                            baseLinePos = line.y + line.descent + line.leading;
                            lines.push(line);
                            if (line.width > maxWidth) {
                                maxWidth = line.width;
                            }
                        }
                    } else {
                        lines.push(currentLine);
                        if (currentLine.width > maxWidth) {
                            maxWidth = currentLine.width;
                        }
                    }
                    currentLine = new TextLine();
                };
                GFX.enterTimeline('RenderableText.reflow');
                while (textRunData.position < textRunData.length) {
                    var beginIndex = textRunData.readInt();
                    var endIndex = textRunData.readInt();
                    var size = textRunData.readInt();
                    var fontName = textRunData.readUTF();
                    var ascent = textRunData.readInt();
                    var descent = textRunData.readInt();
                    var leading = textRunData.readInt();
                    if (ascent > maxAscent) {
                        maxAscent = ascent;
                    }
                    if (descent > maxDescent) {
                        maxDescent = descent;
                    }
                    if (leading > maxLeading) {
                        maxLeading = leading;
                    }
                    var bold = textRunData.readBoolean();
                    var italic = textRunData.readBoolean();
                    var boldItalic = '';
                    if (italic) {
                        boldItalic += 'italic ';
                    }
                    if (bold) {
                        boldItalic += 'bold ';
                    }
                    var font = boldItalic + size + 'px ' + fontName + ', AdobeBlank';
                    var color = textRunData.readInt();
                    var fillStyle = Shumway.ColorUtilities.rgbToHex(color);
                    var align = textRunData.readInt();
                    if (firstAlign === -1) {
                        firstAlign = align;
                    }
                    var bullet = textRunData.readBoolean();
                    //var display = textRunData.readInt();
                    var indent = textRunData.readInt();
                    //var blockIndent = textRunData.readInt();
                    var kerning = textRunData.readInt();
                    var leftMargin = textRunData.readInt();
                    var letterSpacing = textRunData.readInt();
                    var rightMargin = textRunData.readInt();
                    //var tabStops = textRunData.readInt();
                    var underline = textRunData.readBoolean();
                    var text = '';
                    var eof = false;
                    for (var i = beginIndex; !eof; i++) {
                        var eof = i >= endIndex - 1;
                        var char = plainText[i];
                        if (char !== '\r' && char !== '\n') {
                            text += char;
                            if (i < plainText.length - 1) {
                                continue;
                            }
                        }
                        currentLine.addRun(font, fillStyle, text, letterSpacing, underline);
                        finishLine();
                        text = '';
                        if (eof) {
                            maxAscent = 0;
                            maxDescent = 0;
                            maxLeading = -4294967295;
                            firstAlign = -1;
                            break;
                        }
                        if (char === '\r' && plainText[i + 1] === '\n') {
                            i++;
                        }
                    }
                    currentLine.addRun(font, fillStyle, text, letterSpacing, underline);
                }
                // Append an additional empty line if we find a line break character at the end of the text.
                var endCharacter = plainText[plainText.length - 1];
                if (endCharacter === '\r' || endCharacter === '\n') {
                    lines.push(currentLine);
                }
                var rect = this.textRect;
                rect.w = maxWidth;
                rect.h = baseLinePos;
                if (autoSize) {
                    if (!wordWrap) {
                        availableWidth = maxWidth;
                        var width = bounds.w;
                        switch (autoSize) {
                        case 1:
                            rect.x = width - (availableWidth + 4) >> 1;
                            break;
                        case 2:
                            break;
                        case 3:
                            rect.x = width - (availableWidth + 4);
                            break;
                        }
                        this._textBounds.setElements(rect.x - 2, rect.y - 2, rect.w + 4, rect.h + 4);
                        bounds.w = availableWidth + 4;
                    }
                    bounds.x = rect.x - 2;
                    bounds.h = baseLinePos + 4;
                } else {
                    this._textBounds = bounds;
                }
                var numLines = lines.length;
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    if (line.width < availableWidth) {
                        switch (line.align) {
                        case 0:
                            break;
                        case 1:
                            line.x = availableWidth - line.width | 0;
                            break;
                        case 2:
                            line.x = (availableWidth - line.width) / 2 | 0;
                            break;
                        }
                    }
                }
                this.invalidate();
                GFX.leaveTimeline('RenderableText.reflow');
            };
            RenderableText.roundBoundPoints = function (points) {
                release || assert(points === RenderableText.absoluteBoundPoints);
                for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    point.x = Math.floor(point.x + 0.1) + 0.5;
                    point.y = Math.floor(point.y + 0.1) + 0.5;
                }
            };
            RenderableText.prototype.render = function (context) {
                GFX.enterTimeline('RenderableText.render');
                context.save();
                var rect = this._textBounds;
                if (this._backgroundColor) {
                    context.fillStyle = Shumway.ColorUtilities.rgbaToCSSStyle(this._backgroundColor);
                    context.fillRect(rect.x, rect.y, rect.w, rect.h);
                }
                if (this._borderColor) {
                    context.strokeStyle = Shumway.ColorUtilities.rgbaToCSSStyle(this._borderColor);
                    context.lineCap = 'square';
                    context.lineWidth = 1;
                    // TextField bounds are always drawn as 1px lines on (global-space) pixel boundaries.
                    // Their rounding is a bit weird, though: fractions below .9 are rounded down.
                    // We can only fully implement this in browsers that support `currentTransform`.
                    var boundPoints = RenderableText.absoluteBoundPoints;
                    var m = context['currentTransform'];
                    if (m) {
                        rect = rect.clone();
                        var matrix = new Matrix(m.a, m.b, m.c, m.d, m.e, m.f);
                        matrix.transformRectangle(rect, boundPoints);
                        context.setTransform(1, 0, 0, 1, 0, 0);
                    } else {
                        boundPoints[0].x = rect.x;
                        boundPoints[0].y = rect.y;
                        boundPoints[1].x = rect.x + rect.w;
                        boundPoints[1].y = rect.y;
                        boundPoints[2].x = rect.x + rect.w;
                        boundPoints[2].y = rect.y + rect.h;
                        boundPoints[3].x = rect.x;
                        boundPoints[3].y = rect.y + rect.h;
                    }
                    RenderableText.roundBoundPoints(boundPoints);
                    var path = new Path2D();
                    path.moveTo(boundPoints[0].x, boundPoints[0].y);
                    path.lineTo(boundPoints[1].x, boundPoints[1].y);
                    path.lineTo(boundPoints[2].x, boundPoints[2].y);
                    path.lineTo(boundPoints[3].x, boundPoints[3].y);
                    path.lineTo(boundPoints[0].x, boundPoints[0].y);
                    context.stroke(path);
                    if (m) {
                        context.setTransform(m.a, m.b, m.c, m.d, m.e, m.f);
                    }
                }
                if (this._coords) {
                    this._renderChars(context);
                } else {
                    this._renderLines(context);
                }
                context.restore();
                GFX.leaveTimeline('RenderableText.render');
            };
            RenderableText.prototype._renderChars = function (context) {
                if (this._matrix) {
                    var m = this._matrix;
                    context.transform(m.a, m.b, m.c, m.d, m.tx, m.ty);
                }
                var lines = this.lines;
                var coords = this._coords;
                coords.position = 0;
                var font = '';
                var fillStyle = '';
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    var runs = line.runs;
                    for (var j = 0; j < runs.length; j++) {
                        var run = runs[j];
                        if (run.font !== font) {
                            context.font = font = run.font;
                        }
                        if (run.fillStyle !== fillStyle) {
                            context.fillStyle = fillStyle = run.fillStyle;
                        }
                        var text = run.text;
                        for (var k = 0; k < text.length; k++) {
                            var x = coords.readInt() / 20;
                            var y = coords.readInt() / 20;
                            context.fillText(text[k], x, y);
                        }
                    }
                }
            };
            RenderableText.prototype._renderLines = function (context) {
                // TODO: Render bullet points.
                var bounds = this._textBounds;
                context.beginPath();
                context.rect(bounds.x + 2, bounds.y + 2, bounds.w - 4, bounds.h - 4);
                context.clip();
                context.translate(bounds.x - this._scrollH + 2, bounds.y + 2);
                var lines = this.lines;
                var scrollV = this._scrollV;
                var scrollY = 0;
                var font = '';
                var fillStyle = '';
                context.textAlign = 'left';
                context.textBaseline = 'alphabetic';
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    var x = line.x;
                    var y = line.y;
                    // Skip lines until we are within the scroll view.
                    if (i + 1 < scrollV) {
                        scrollY = y + line.descent + line.leading;
                        continue;
                    }
                    y -= scrollY;
                    // Flash skips rendering lines that are not fully visible in height (except of the very
                    // first line within the scroll view).
                    if (i + 1 - scrollV && y > bounds.h) {
                        break;
                    }
                    var runs = line.runs;
                    for (var j = 0; j < runs.length; j++) {
                        var run = runs[j];
                        if (run.font !== font) {
                            context.font = font = run.font;
                        }
                        if (run.fillStyle !== fillStyle) {
                            context.fillStyle = fillStyle = run.fillStyle;
                        }
                        if (run.underline) {
                            context.fillRect(x, y + line.descent / 2 | 0, run.width, 1);
                        }
                        context.textAlign = 'left';
                        context.textBaseline = 'alphabetic';
                        if (run.letterSpacing > 0) {
                            var text = run.text;
                            for (var k = 0; k < text.length; k++) {
                                context.fillText(text[k], x, y);
                                x += measureText(context, text[k], run.letterSpacing);
                            }
                        } else {
                            context.fillText(run.text, x, y);
                            x += run.width;
                        }
                    }
                }
            };
            RenderableText.absoluteBoundPoints = [
                new Point(0, 0),
                new Point(0, 0),
                new Point(0, 0),
                new Point(0, 0)
            ];
            return RenderableText;
        }(Renderable);
        GFX.RenderableText = RenderableText;
        var Label = function (_super) {
            __extends(Label, _super);
            function Label(w, h) {
                _super.call(this);
                this._flags = 256    /* Dynamic */ | 512    /* Scalable */;
                this.properties = {};
                this.setBounds(new Rectangle(0, 0, w, h));
            }
            Object.defineProperty(Label.prototype, 'text', {
                get: function () {
                    return this._text;
                },
                set: function (value) {
                    this._text = value;
                },
                enumerable: true,
                configurable: true
            });
            Label.prototype.render = function (context, ratio, cullBounds) {
                context.save();
                context.textBaseline = 'top';
                context.fillStyle = 'white';
                context.fillText(this.text, 0, 0);
                context.restore();
            };
            return Label;
        }(Renderable);
        GFX.Label = Label;
        var clampByte = Shumway.ColorUtilities.clampByte;
        var assert = Shumway.Debug.assert;
        var Filter = function () {
            function Filter() {
            }
            Filter.prototype.expandBounds = function (bounds) {
            };
            return Filter;
        }();
        GFX.Filter = Filter;
        var EPS = 1e-9;
        // Step widths for blur based filters, for quality values 1..15:
        // If we plot the border width added by expandBlurBounds for each blurX (or blurY) value, the
        // step width is the amount of blurX that adds one pixel to the border width. I.e. for quality = 1,
        // the border width increments at blurX = 2, 4, 6, ...
        var blurFilterStepWidths = [
            2,
            1 / 1.05,
            1 / 1.35,
            1 / 1.55,
            1 / 1.75,
            1 / 1.9,
            1 / 2,
            1 / 2.1,
            1 / 2.2,
            1 / 2.3,
            1 / 2.5,
            1 / 3,
            1 / 3,
            1 / 3.5,
            1 / 3.5
        ];
        function expandBlurBounds(bounds, quality, blurX, blurY, isBlurFilter) {
            var stepWidth = blurFilterStepWidths[quality - 1];
            var bx = blurX;
            var by = blurY;
            if (isBlurFilter) {
                // BlurFilter behaves slightly different from other blur based filters:
                // Given ascending blurX/blurY values, a BlurFilter expands the source rect later than with
                // i.e. GlowFilter. The difference appears to be stepWidth / 4 for all quality values.
                var stepWidth4 = stepWidth / 4;
                bx -= stepWidth4;
                by -= stepWidth4;
            }
            // Calculate horizontal and vertical borders:
            // blurX/blurY values <= 1 are always rounded up to 1, which means that we always expand the
            // source rect, even when blurX/blurY is 0.
            var bh = Math.ceil((bx < 1 ? 1 : bx) / (stepWidth - EPS));
            var bv = Math.ceil((by < 1 ? 1 : by) / (stepWidth - EPS));
            bounds.x -= bh;
            bounds.w += bh * 2;
            bounds.y -= bv;
            bounds.h += bv * 2;
        }
        var BlurFilter = function (_super) {
            __extends(BlurFilter, _super);
            function BlurFilter(blurX, blurY, quality) {
                _super.call(this);
                this.blurX = blurX;
                this.blurY = blurY;
                this.quality = quality;
            }
            BlurFilter.prototype.expandBounds = function (bounds) {
                expandBlurBounds(bounds, this.quality, this.blurX, this.blurY, true);
            };
            return BlurFilter;
        }(Filter);
        GFX.BlurFilter = BlurFilter;
        var DropshadowFilter = function (_super) {
            __extends(DropshadowFilter, _super);
            function DropshadowFilter(alpha, angle, blurX, blurY, color, distance, hideObject, inner, knockout, quality, strength) {
                _super.call(this);
                this.alpha = alpha;
                this.angle = angle;
                this.blurX = blurX;
                this.blurY = blurY;
                this.color = color;
                this.distance = distance;
                this.hideObject = hideObject;
                this.inner = inner;
                this.knockout = knockout;
                this.quality = quality;
                this.strength = strength;
            }
            DropshadowFilter.prototype.expandBounds = function (bounds) {
                // TODO: Once we support inset drop shadows, bounds don't expand.
                //       For now, they will be rendered as normal drop shadows.
                // if (this.inner) {
                //   return;
                // }
                expandBlurBounds(bounds, this.quality, this.blurX, this.blurY, false);
                if (this.distance) {
                    var a = this.angle * Math.PI / 180;
                    var dx = Math.cos(a) * this.distance;
                    var dy = Math.sin(a) * this.distance;
                    var xMin = bounds.x + (dx >= 0 ? 0 : Math.floor(dx));
                    var xMax = bounds.x + bounds.w + Math.ceil(Math.abs(dx));
                    var yMin = bounds.y + (dy >= 0 ? 0 : Math.floor(dy));
                    var yMax = bounds.y + bounds.h + Math.ceil(Math.abs(dy));
                    bounds.x = xMin;
                    bounds.w = xMax - xMin;
                    bounds.y = yMin;
                    bounds.h = yMax - yMin;
                }
            };
            return DropshadowFilter;
        }(Filter);
        GFX.DropshadowFilter = DropshadowFilter;
        var GlowFilter = function (_super) {
            __extends(GlowFilter, _super);
            function GlowFilter(alpha, blurX, blurY, color, inner, knockout, quality, strength) {
                _super.call(this);
                this.alpha = alpha;
                this.blurX = blurX;
                this.blurY = blurY;
                this.color = color;
                this.inner = inner;
                this.knockout = knockout;
                this.quality = quality;
                this.strength = strength;
            }
            GlowFilter.prototype.expandBounds = function (bounds) {
                if (!this.inner) {
                    expandBlurBounds(bounds, this.quality, this.blurX, this.blurY, false);
                }
            };
            return GlowFilter;
        }(Filter);
        GFX.GlowFilter = GlowFilter;
        var ColorMatrix = function (_super) {
            __extends(ColorMatrix, _super);
            function ColorMatrix(data) {
                _super.call(this);
                release || assert(data.length === 20);
                this._data = new Float32Array(data);
                this._type = 0    /* Unknown */;
            }
            ColorMatrix.prototype.clone = function () {
                var colorMatrix = new ColorMatrix(this._data);
                colorMatrix._type = this._type;
                return colorMatrix;
            };
            ColorMatrix.prototype.set = function (other) {
                this._data.set(other._data);
                this._type = other._type;
            };
            ColorMatrix.prototype.toWebGLMatrix = function () {
                return new Float32Array(this._data);
            };
            ColorMatrix.prototype.asWebGLMatrix = function () {
                return this._data.subarray(0, 16);
            };
            ColorMatrix.prototype.asWebGLVector = function () {
                return this._data.subarray(16, 20);
            };
            ColorMatrix.prototype.isIdentity = function () {
                if (this._type & 1    /* Identity */) {
                    return true;
                }
                var m = this._data;
                return m[0] == 1 && m[1] == 0 && m[2] == 0 && m[3] == 0 && m[4] == 0 && m[5] == 1 && m[6] == 0 && m[7] == 0 && m[8] == 0 && m[9] == 0 && m[10] == 1 && m[11] == 0 && m[12] == 0 && m[13] == 0 && m[14] == 0 && m[15] == 1 && m[16] == 0 && m[17] == 0 && m[18] == 0 && m[19] == 0;
            };
            ColorMatrix.createIdentity = function () {
                var colorMatrix = new ColorMatrix([
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    0
                ]);
                colorMatrix._type = 1    /* Identity */;
                return colorMatrix;
            };
            ColorMatrix.prototype.setMultipliersAndOffsets = function (redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
                var m = this._data;
                for (var i = 0; i < m.length; i++) {
                    m[i] = 0;
                }
                m[0] = redMultiplier;
                m[5] = greenMultiplier;
                m[10] = blueMultiplier;
                m[15] = alphaMultiplier;
                m[16] = redOffset / 255;
                m[17] = greenOffset / 255;
                m[18] = blueOffset / 255;
                m[19] = alphaOffset / 255;
                this._type = 0    /* Unknown */;
            };
            ColorMatrix.prototype.transformRGBA = function (rgba) {
                var r = rgba >> 24 & 255;
                var g = rgba >> 16 & 255;
                var b = rgba >> 8 & 255;
                var a = rgba & 255;
                var m = this._data;
                var R = clampByte(r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[16] * 255);
                var G = clampByte(r * m[4] + g * m[5] + b * m[6] + a * m[7] + m[17] * 255);
                var B = clampByte(r * m[8] + g * m[9] + b * m[10] + a * m[11] + m[18] * 255);
                var A = clampByte(r * m[12] + g * m[13] + b * m[14] + a * m[15] + m[19] * 255);
                return R << 24 | G << 16 | B << 8 | A;
            };
            ColorMatrix.prototype.multiply = function (other) {
                if (other._type & 1    /* Identity */) {
                    return;
                }
                var a = this._data, b = other._data;
                var a00 = a[0 * 4 + 0];
                var a01 = a[0 * 4 + 1];
                var a02 = a[0 * 4 + 2];
                var a03 = a[0 * 4 + 3];
                var a10 = a[1 * 4 + 0];
                var a11 = a[1 * 4 + 1];
                var a12 = a[1 * 4 + 2];
                var a13 = a[1 * 4 + 3];
                var a20 = a[2 * 4 + 0];
                var a21 = a[2 * 4 + 1];
                var a22 = a[2 * 4 + 2];
                var a23 = a[2 * 4 + 3];
                var a30 = a[3 * 4 + 0];
                var a31 = a[3 * 4 + 1];
                var a32 = a[3 * 4 + 2];
                var a33 = a[3 * 4 + 3];
                var a40 = a[4 * 4 + 0];
                var a41 = a[4 * 4 + 1];
                var a42 = a[4 * 4 + 2];
                var a43 = a[4 * 4 + 3];
                var b00 = b[0 * 4 + 0];
                var b01 = b[0 * 4 + 1];
                var b02 = b[0 * 4 + 2];
                var b03 = b[0 * 4 + 3];
                var b10 = b[1 * 4 + 0];
                var b11 = b[1 * 4 + 1];
                var b12 = b[1 * 4 + 2];
                var b13 = b[1 * 4 + 3];
                var b20 = b[2 * 4 + 0];
                var b21 = b[2 * 4 + 1];
                var b22 = b[2 * 4 + 2];
                var b23 = b[2 * 4 + 3];
                var b30 = b[3 * 4 + 0];
                var b31 = b[3 * 4 + 1];
                var b32 = b[3 * 4 + 2];
                var b33 = b[3 * 4 + 3];
                var b40 = b[4 * 4 + 0];
                var b41 = b[4 * 4 + 1];
                var b42 = b[4 * 4 + 2];
                var b43 = b[4 * 4 + 3];
                a[0 * 4 + 0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
                a[0 * 4 + 1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
                a[0 * 4 + 2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
                a[0 * 4 + 3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
                a[1 * 4 + 0] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
                a[1 * 4 + 1] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
                a[1 * 4 + 2] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
                a[1 * 4 + 3] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
                a[2 * 4 + 0] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
                a[2 * 4 + 1] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
                a[2 * 4 + 2] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
                a[2 * 4 + 3] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
                a[3 * 4 + 0] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
                a[3 * 4 + 1] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
                a[3 * 4 + 2] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
                a[3 * 4 + 3] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
                a[4 * 4 + 0] = a00 * b40 + a10 * b41 + a20 * b42 + a30 * b43 + a40;
                a[4 * 4 + 1] = a01 * b40 + a11 * b41 + a21 * b42 + a31 * b43 + a41;
                a[4 * 4 + 2] = a02 * b40 + a12 * b41 + a22 * b42 + a32 * b43 + a42;
                a[4 * 4 + 3] = a03 * b40 + a13 * b41 + a23 * b42 + a33 * b43 + a43;
                this._type = 0    /* Unknown */;
            };
            Object.defineProperty(ColorMatrix.prototype, 'alphaMultiplier', {
                get: function () {
                    return this._data[15];
                },
                enumerable: true,
                configurable: true
            });
            ColorMatrix.prototype.hasOnlyAlphaMultiplier = function () {
                var m = this._data;
                return m[0] == 1 && m[1] == 0 && m[2] == 0 && m[3] == 0 && m[4] == 0 && m[5] == 1 && m[6] == 0 && m[7] == 0 && m[8] == 0 && m[9] == 0 && m[10] == 1 && m[11] == 0 && m[12] == 0 && m[13] == 0 && m[14] == 0 && m[16] == 0 && m[17] == 0 && m[18] == 0 && m[19] == 0;
            };
            ColorMatrix.prototype.equals = function (other) {
                if (!other) {
                    return false;
                } else if (this._type === other._type && this._type === 1    /* Identity */) {
                    return true;
                }
                var a = this._data;
                var b = other._data;
                for (var i = 0; i < 20; i++) {
                    if (Math.abs(a[i] - b[i]) > 0.001) {
                        return false;
                    }
                }
                return true;
            };
            ColorMatrix.prototype.toSVGFilterMatrix = function () {
                var m = this._data;
                return [
                    m[0],
                    m[4],
                    m[8],
                    m[12],
                    m[16],
                    m[1],
                    m[5],
                    m[9],
                    m[13],
                    m[17],
                    m[2],
                    m[6],
                    m[10],
                    m[14],
                    m[18],
                    m[3],
                    m[7],
                    m[11],
                    m[15],
                    m[19]
                ].join(' ');
            };
            return ColorMatrix;
        }(Filter);
        GFX.ColorMatrix = ColorMatrix;
    }(GFX = Shumway.GFX || (Shumway.GFX = {})));
    var Player;
    (function (Player) {
        Player.timelineBuffer = Shumway.Tools ? new Shumway.Tools.Profiler.TimelineBuffer('Player') : null;
        Player.counter = new Shumway.Metrics.Counter(!release);
        Player.writer = null;
        // new IndentingWriter();
        function enterTimeline(name, data) {
            Player.writer && Player.writer.enter(name);
            profile && Player.timelineBuffer && Player.timelineBuffer.enter(name, data);
        }
        Player.enterTimeline = enterTimeline;
        function leaveTimeline(name, data) {
            Player.writer && Player.writer.leave(name);
            profile && Player.timelineBuffer && Player.timelineBuffer.leave(name, data);
        }
        Player.leaveTimeline = leaveTimeline;
    }(Player = Shumway.Player || (Shumway.Player = {})));
    var OptionSet = Shumway.Options.OptionSet;
    var shumwayOptions = Shumway.Settings.shumwayOptions;
    Shumway.playerOptions = shumwayOptions.register(new OptionSet('Player Options'));
    Shumway.frameEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option('enableFrames', 'Enable Frame Execution', 'boolean', true, 'Enable frame execution.'));
    Shumway.timerEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option('enableTimers', 'Enable Timers', 'boolean', true, 'Enable timer events.'));
    Shumway.pumpEnabledOption = Shumway.playerOptions.register(new Shumway.Options.Option('enablePump', 'Enable Pump', 'boolean', true, 'Enable display tree serialization.'));
    Shumway.pumpRateOption = Shumway.playerOptions.register(new Shumway.Options.Option('pumpRate', 'Pump Rate', 'number', 60, 'Number of times / second that the display list is synchronized.', {
        range: {
            min: 1,
            max: 120,
            step: 1
        }
    }));
    Shumway.frameRateOption = Shumway.playerOptions.register(new Shumway.Options.Option('frameRate', 'Frame Rate', 'number', -1, 'Override a movie\'s frame rate, set to -1 to use the movies default frame rate.', {
        range: {
            min: -1,
            max: 120,
            step: 1
        }
    }));
    Shumway.tracePlayerOption = Shumway.playerOptions.register(new Shumway.Options.Option('tp', 'Trace Player', 'number', 0, 'Trace player every n frames.', {
        range: {
            min: 0,
            max: 512,
            step: 1
        }
    }));
    Shumway.traceMouseEventOption = Shumway.playerOptions.register(new Shumway.Options.Option('tme', 'Trace Mouse Events', 'boolean', false, 'Trace mouse events.'));
    Shumway.frameRateMultiplierOption = Shumway.playerOptions.register(new Shumway.Options.Option('', 'Frame Rate Multiplier', 'number', 1, 'Play frames at a faster rate.', {
        range: {
            min: 1,
            max: 16,
            step: 1
        }
    }));
    Shumway.dontSkipFramesOption = Shumway.playerOptions.register(new Shumway.Options.Option('', 'Disables Frame Skipping', 'boolean', false, 'Play all frames, e.g. no skipping frame during throttle.'));
    Shumway.playAllSymbolsOption = Shumway.playerOptions.register(new Shumway.Options.Option('', 'Play Symbols', 'boolean', false, 'Plays all SWF symbols automatically.'));
    Shumway.playSymbolOption = Shumway.playerOptions.register(new Shumway.Options.Option('', 'Play Symbol Number', 'number', 0, 'Select symbol by Id.', {
        range: {
            min: 0,
            max: 20000,
            step: 1
        }
    }));
    Shumway.playSymbolFrameDurationOption = Shumway.playerOptions.register(new Shumway.Options.Option('', 'Play Symbol Duration', 'number', 0, 'How many frames to play, 0 for all frames of the movie clip.', {
        range: {
            min: 0,
            max: 128,
            step: 1
        }
    }));
    Shumway.playSymbolCountOption = Shumway.playerOptions.register(new Shumway.Options.Option('', 'Play Symbol Count', 'number', -1, 'Select symbol count.', {
        range: {
            min: -1,
            max: 20000,
            step: 1
        }
    }));
    var FrameScheduler = function () {
        function FrameScheduler() {
            this._expectedNextFrameAt = performance.now();
            this._drawStats = [];
            this._drawStatsSum = 0;
            this._drawStarted = 0;
            this._drawsSkipped = 0;
            this._expectedNextFrameAt = performance.now();
            this._onTime = true;
            this._trackDelta = false;
            this._delta = 0;
            this._onTimeDelta = 0;
        }
        Object.defineProperty(FrameScheduler.prototype, 'shallSkipDraw', {
            get: function () {
                if (this._drawsSkipped >= FrameScheduler.MAX_DRAWS_TO_SKIP) {
                    return false;
                }
                var averageDraw = this._drawStats.length < FrameScheduler.STATS_TO_REMEMBER ? 0 : this._drawStatsSum / this._drawStats.length;
                var estimatedDrawEnd = performance.now() + averageDraw;
                return estimatedDrawEnd + FrameScheduler.INTERVAL_PADDING_MS > this._expectedNextFrameAt;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameScheduler.prototype, 'nextFrameIn', {
            get: function () {
                return Math.max(0, this._expectedNextFrameAt - performance.now());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FrameScheduler.prototype, 'isOnTime', {
            get: function () {
                return this._onTime;
            },
            enumerable: true,
            configurable: true
        });
        FrameScheduler.prototype.startFrame = function (frameRate) {
            var interval = 1000 / frameRate;
            var adjustedInterval = interval;
            var delta = this._onTimeDelta + this._delta;
            if (delta !== 0) {
                if (delta < 0) {
                    adjustedInterval *= FrameScheduler.SPEED_ADJUST_RATE;
                } else if (delta > 0) {
                    adjustedInterval /= FrameScheduler.SPEED_ADJUST_RATE;
                }
                this._onTimeDelta += interval - adjustedInterval;
            }
            this._expectedNextFrameAt += adjustedInterval;
            this._onTime = true;
        };
        FrameScheduler.prototype.endFrame = function () {
            var estimatedNextFrameStart = performance.now() + FrameScheduler.INTERVAL_PADDING_MS;
            if (estimatedNextFrameStart > this._expectedNextFrameAt) {
                if (this._trackDelta) {
                    this._onTimeDelta += this._expectedNextFrameAt - estimatedNextFrameStart;
                    console.log(this._onTimeDelta);
                }
                this._expectedNextFrameAt = estimatedNextFrameStart;
                this._onTime = false;
            }
        };
        FrameScheduler.prototype.startDraw = function () {
            this._drawsSkipped = 0;
            this._drawStarted = performance.now();
        };
        FrameScheduler.prototype.endDraw = function () {
            var drawTime = performance.now() - this._drawStarted;
            this._drawStats.push(drawTime);
            this._drawStatsSum += drawTime;
            while (this._drawStats.length > FrameScheduler.STATS_TO_REMEMBER) {
                this._drawStatsSum -= this._drawStats.shift();
            }
        };
        FrameScheduler.prototype.skipDraw = function () {
            this._drawsSkipped++;
        };
        FrameScheduler.prototype.setDelta = function (value) {
            if (!this._trackDelta) {
                return;
            }
            this._delta = value;
        };
        FrameScheduler.prototype.startTrackDelta = function () {
            this._trackDelta = true;
        };
        FrameScheduler.prototype.endTrackDelta = function () {
            if (!this._trackDelta) {
                return;
            }
            this._trackDelta = false;
            this._delta = 0;
            this._onTimeDelta = 0;
        };
        FrameScheduler.STATS_TO_REMEMBER = 50;
        FrameScheduler.MAX_DRAWS_TO_SKIP = 2;
        FrameScheduler.INTERVAL_PADDING_MS = 4;
        FrameScheduler.SPEED_ADJUST_RATE = 0.9;
        return FrameScheduler;
    }();
    Shumway.FrameScheduler = FrameScheduler;
    var Remoting;
    (function (Remoting) {
        var Player;
        (function (Player) {
            var flash = Shumway.AVMX.AS.flash;
            var BlendMode = flash.display.BlendMode;
            var PixelSnapping = flash.display.PixelSnapping;
            var Bounds = Shumway.Bounds;
            var MouseCursor = flash.ui.MouseCursor;
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var assert = Shumway.Debug.assert;
            var writer = Shumway.Player.writer;
            var PlayerChannelSerializer = function () {
                function PlayerChannelSerializer() {
                    this.phase = 0    /* Objects */;
                    this.roots = null;
                    this.output = new DataBuffer();
                    this.outputAssets = [];
                }
                PlayerChannelSerializer.prototype.remoteObjects = function () {
                    this.phase = 0    /* Objects */;
                    var roots = this.roots;
                    for (var i = 0; i < roots.length; i++) {
                        Shumway.Player.enterTimeline('remoting objects');
                        this.writeDirtyDisplayObjects(roots[i], false);
                        Shumway.Player.leaveTimeline('remoting objects');
                    }
                };
                PlayerChannelSerializer.prototype.remoteReferences = function () {
                    this.phase = 1    /* References */;
                    var roots = this.roots;
                    for (var i = 0; i < roots.length; i++) {
                        Shumway.Player.enterTimeline('remoting references');
                        this.writeDirtyDisplayObjects(roots[i], true);
                        Shumway.Player.leaveTimeline('remoting references');
                    }
                };
                PlayerChannelSerializer.prototype.writeEOF = function () {
                    this.output.writeInt(0    /* EOF */);
                };
                /**
                 * Serializes dirty display objects starting at the specified root |displayObject| node.
                 */
                PlayerChannelSerializer.prototype.writeDirtyDisplayObjects = function (displayObject, clearDirtyDescendentsFlag) {
                    var self = this;
                    var roots = this.roots;
                    displayObject.visit(function (displayObject) {
                        if (displayObject._hasAnyDirtyFlags(1023    /* Dirty */)) {
                            self.writeUpdateFrame(displayObject);
                            // Collect more roots?
                            if (roots && displayObject.mask) {
                                var root = displayObject.mask._findFurthestAncestorOrSelf();
                                Shumway.ArrayUtilities.pushUnique(roots, root);
                            }
                        }
                        // TODO: Checking if we need to write assets this way is kinda expensive, do better here.
                        self.writeDirtyAssets(displayObject);
                        var hasDirtyDescendents = displayObject._hasFlags(536870912    /* DirtyDescendents */);
                        if (hasDirtyDescendents) {
                            if (clearDirtyDescendentsFlag) {
                                // We need this flag to make sure we don't clear the flag in the first remoting pass.
                                displayObject._removeFlags(536870912    /* DirtyDescendents */);
                            }
                            return 0    /* Continue */;
                        }
                        // We can skip visiting descendents since they are not dirty.
                        return 2    /* Skip */;
                    }, 0    /* None */);
                };
                PlayerChannelSerializer.prototype.writeStage = function (stage) {
                    if (!stage._isDirty) {
                        return;
                    }
                    writer && writer.writeLn('Sending Stage');
                    var serializer = this;
                    this.output.writeInt(104    /* UpdateStage */);
                    this.output.writeInt(stage._id);
                    this.output.writeInt(stage.color);
                    this._writeRectangle(new Bounds(0, 0, stage.stageWidth * 20, stage.stageHeight * 20));
                    this.output.writeInt(flash.display.StageAlign.toNumber(stage.align));
                    this.output.writeInt(flash.display.StageScaleMode.toNumber(stage.scaleMode));
                    this.output.writeInt(flash.display.StageDisplayState.toNumber(stage.displayState));
                    stage._isDirty = false;
                };
                PlayerChannelSerializer.prototype.writeCurrentMouseTarget = function (stage, currentMouseTarget) {
                    this.output.writeInt(107    /* UpdateCurrentMouseTarget */);
                    var sec = stage.sec;
                    var Mouse = sec.flash.ui.Mouse.axClass;
                    var cursor = Mouse.cursor;
                    if (currentMouseTarget) {
                        var SimpleButton = sec.flash.display.SimpleButton.axClass;
                        var Sprite = sec.flash.display.Sprite.axClass;
                        this.output.writeInt(currentMouseTarget._id);
                        if (cursor === MouseCursor.AUTO) {
                            var node = currentMouseTarget;
                            do {
                                if (SimpleButton.axIsType(node) || Sprite.axIsType(node) && node.buttonMode && currentMouseTarget.useHandCursor) {
                                    cursor = MouseCursor.BUTTON;
                                    break;
                                }
                                node = node._parent;
                            } while (node && node !== stage);
                        }
                    } else {
                        this.output.writeInt(-1);
                    }
                    this.output.writeInt(MouseCursor.toNumber(cursor));
                };
                PlayerChannelSerializer.prototype.writeGraphics = function (graphics) {
                    if (!graphics._isDirty) {
                        return;
                    }
                    var textures = graphics.getUsedTextures();
                    var numTextures = textures.length;
                    for (var i = 0; i < numTextures; i++) {
                        textures[i] && this.writeBitmapData(textures[i]);
                    }
                    this.output.writeInt(101    /* UpdateGraphics */);
                    this.output.writeInt(graphics._id);
                    this.output.writeInt(-1);
                    this._writeRectangle(graphics._getContentBounds());
                    this._writeAsset(graphics.getGraphicsData().toPlainObject());
                    this.output.writeInt(numTextures);
                    for (var i = 0; i < numTextures; i++) {
                        this.output.writeInt(textures[i] ? textures[i]._id : -1);
                    }
                    graphics._isDirty = false;
                };
                PlayerChannelSerializer.prototype.writeNetStream = function (netStream, bounds) {
                    if (!netStream._isDirty) {
                        return;
                    }
                    writer && writer.writeLn('Sending NetStream: ' + netStream._id);
                    this.output.writeInt(105    /* UpdateNetStream */);
                    this.output.writeInt(netStream._id);
                    this._writeRectangle(bounds);
                    netStream._isDirty = false;
                };
                PlayerChannelSerializer.prototype.writeDisplayObjectRoot = function (displayObject) {
                    release || assert(!this.roots);
                    this.roots = [displayObject];
                    this.remoteObjects();
                    this.remoteReferences();
                };
                PlayerChannelSerializer.prototype.writeBitmapData = function (bitmapData) {
                    if (!bitmapData._isDirty) {
                        return;
                    }
                    writer && writer.writeLn('Sending BitmapData: ' + bitmapData._id);
                    this.output.writeInt(102    /* UpdateBitmapData */);
                    this.output.writeInt(bitmapData._id);
                    this.output.writeInt(bitmapData._symbol ? bitmapData._symbol.id : -1);
                    this._writeRectangle(bitmapData._getContentBounds());
                    this.output.writeInt(bitmapData._type);
                    this._writeAsset(bitmapData.getDataBuffer().toPlainObject());
                    bitmapData._isDirty = false;
                };
                PlayerChannelSerializer.prototype.writeTextContent = function (textContent) {
                    if (!(textContent.flags & 15    /* Dirty */)) {
                        return;
                    }
                    writer && writer.writeLn('Sending TextContent: ' + textContent._id);
                    this.output.writeInt(103    /* UpdateTextContent */);
                    this.output.writeInt(textContent._id);
                    this.output.writeInt(-1);
                    this._writeRectangle(textContent.bounds);
                    var identity = textContent.sec.flash.geom.Matrix.axClass.FROZEN_IDENTITY_MATRIX;
                    this._writeMatrix(textContent.matrix || identity);
                    this.output.writeInt(textContent.backgroundColor);
                    this.output.writeInt(textContent.borderColor);
                    this.output.writeInt(textContent.autoSize);
                    this.output.writeBoolean(textContent.wordWrap);
                    this.output.writeInt(textContent.scrollV);
                    this.output.writeInt(textContent.scrollH);
                    this._writeAsset(textContent.plainText);
                    this._writeAsset(textContent.textRunData.toPlainObject());
                    var coords = textContent.coords;
                    if (coords) {
                        var numCoords = coords.length;
                        this.output.writeInt(numCoords);
                        for (var i = 0; i < numCoords; i++) {
                            this.output.writeInt(coords[i]);
                        }
                    } else {
                        this.output.writeInt(0);
                    }
                    textContent.flags &= ~15    /* Dirty */;
                };
                /**
                 * Writes the number of display objects this display object clips.
                 */
                PlayerChannelSerializer.prototype.writeClippedObjectsCount = function (displayObject) {
                    if (displayObject._clipDepth > 0 && displayObject._parent) {
                        // Clips in GFX land don't use absolute clip depth numbers. Instead we need to encode
                        // the number of siblings you want to clip. If children are removed or added, GFX clip
                        // values need to be recomputed.
                        var i = displayObject._parent.getChildIndex(displayObject);
                        var j = displayObject._parent.getClipDepthIndex(displayObject._clipDepth);
                        // An invalid SWF can contain a clipping mask that doesn't clip anything, but pretends to.
                        if (j - i < 0) {
                            this.output.writeInt(-1);
                            return;
                        }
                        for (var k = i + 1; k <= i; k++) {
                        }
                        this.output.writeInt(j - i);
                    } else {
                        this.output.writeInt(-1);
                    }
                };
                PlayerChannelSerializer.prototype.writeUpdateFrame = function (displayObject) {
                    // Write Header
                    this.output.writeInt(100    /* UpdateFrame */);
                    this.output.writeInt(displayObject._id);
                    writer && writer.writeLn('Sending UpdateFrame: ' + displayObject.debugName(true));
                    var hasMask = false;
                    var hasMatrix = displayObject._hasDirtyFlags(1    /* DirtyMatrix */);
                    var hasColorTransform = displayObject._hasDirtyFlags(64    /* DirtyColorTransform */);
                    var hasMiscellaneousProperties = displayObject._hasDirtyFlags(512    /* DirtyMiscellaneousProperties */);
                    var video = null;
                    if (displayObject.sec.flash.media.Video.axClass.axIsType(displayObject)) {
                        video = displayObject;
                    }
                    // Check if any children need to be written. These are remoting children, not just display object children.
                    var hasRemotableChildren = false;
                    if (this.phase === 1    /* References */) {
                        hasRemotableChildren = displayObject._hasAnyDirtyFlags(2    /* DirtyChildren */ | 4    /* DirtyGraphics */ | 16    /* DirtyBitmapData */ | 32    /* DirtyNetStream */ | 8    /* DirtyTextContent */);
                        hasMask = displayObject._hasDirtyFlags(128    /* DirtyMask */);
                    }
                    var bitmap = null;
                    if (displayObject.sec.flash.display.Bitmap.axClass.axIsType(displayObject)) {
                        bitmap = displayObject;
                    }
                    // Checks if the computed clip value needs to be written.
                    var hasClip = displayObject._hasDirtyFlags(256    /* DirtyClipDepth */);
                    // Write Has Bits
                    var hasBits = 0;
                    hasBits |= hasMatrix ? 1    /* HasMatrix */ : 0;
                    hasBits |= hasColorTransform ? 8    /* HasColorTransform */ : 0;
                    hasBits |= hasMask ? 64    /* HasMask */ : 0;
                    hasBits |= hasClip ? 128    /* HasClip */ : 0;
                    hasBits |= hasMiscellaneousProperties ? 32    /* HasMiscellaneousProperties */ : 0;
                    hasBits |= hasRemotableChildren ? 4    /* HasChildren */ : 0;
                    this.output.writeInt(hasBits);
                    // Write Properties
                    if (hasMatrix) {
                        this._writeMatrix(displayObject._getMatrix());
                    }
                    if (hasColorTransform) {
                        this._writeColorTransform(displayObject._colorTransform);
                    }
                    if (hasMask) {
                        this.output.writeInt(displayObject.mask ? displayObject.mask._id : -1);
                    }
                    if (hasClip) {
                        this.writeClippedObjectsCount(displayObject);
                    }
                    if (hasMiscellaneousProperties) {
                        this.output.writeInt(displayObject._ratio);
                        this.output.writeInt(BlendMode.toNumber(displayObject._blendMode));
                        this._writeFilters(displayObject._filters);
                        this.output.writeBoolean(displayObject._hasFlags(1    /* Visible */));
                        this.output.writeBoolean(displayObject.cacheAsBitmap);
                        if (bitmap) {
                            this.output.writeInt(PixelSnapping.toNumber(bitmap.pixelSnapping));
                            this.output.writeInt(bitmap.smoothing ? 1 : 0);
                        } else {
                            // For non-bitmaps, write null-defaults that cause flags not to be set in the GFX backend.
                            this.output.writeInt(PixelSnapping.toNumber(PixelSnapping.NEVER));
                            this.output.writeInt(0);
                        }
                    }
                    var graphics = displayObject._getGraphics();
                    var textContent = displayObject._getTextContent();
                    if (hasRemotableChildren) {
                        writer && writer.enter('Children: {');
                        if (bitmap) {
                            if (bitmap.bitmapData) {
                                this.output.writeInt(1);
                                this.output.writeInt(134217728    /* Asset */ | bitmap.bitmapData._id);
                            } else {
                                this.output.writeInt(0);
                            }
                        } else if (video) {
                            if (video._netStream) {
                                this.output.writeInt(1);
                                this.output.writeInt(134217728    /* Asset */ | video._netStream._id);
                            } else {
                                this.output.writeInt(0);
                            }
                        } else {
                            // Check if we have a graphics or text object and write that as a child first.
                            var count = graphics || textContent ? 1 : 0;
                            var children = displayObject._children;
                            if (children) {
                                count += children.length;
                            }
                            this.output.writeInt(count);
                            if (graphics) {
                                writer && writer.writeLn('Reference Graphics: ' + graphics._id);
                                this.output.writeInt(134217728    /* Asset */ | graphics._id);
                            } else if (textContent) {
                                writer && writer.writeLn('Reference TextContent: ' + textContent._id);
                                this.output.writeInt(134217728    /* Asset */ | textContent._id);
                            }
                            // Write all the display object children.
                            if (children) {
                                for (var i = 0; i < children.length; i++) {
                                    writer && writer.writeLn('Reference DisplayObject: ' + children[i].debugName());
                                    this.output.writeInt(children[i]._id);
                                    // Make sure children with a clip depth are getting visited.
                                    if (children[i]._clipDepth >= 0) {
                                        children[i]._setDirtyFlags(256    /* DirtyClipDepth */);
                                    }
                                }
                            }
                        }
                        writer && writer.leave('}');
                    }
                    if (this.phase === 1    /* References */) {
                        displayObject._removeDirtyFlags(1023    /* Dirty */);
                    }
                };
                /**
                 * Visit remotable child objects that are not otherwise visited.
                 */
                PlayerChannelSerializer.prototype.writeDirtyAssets = function (displayObject) {
                    var graphics = displayObject._getGraphics();
                    if (graphics) {
                        this.writeGraphics(graphics);
                        return;
                    }
                    var textContent = displayObject._getTextContent();
                    if (textContent) {
                        this.writeTextContent(textContent);
                        return;
                    }
                    var bitmap = null;
                    if (displayObject.sec.flash.display.Bitmap.axClass.axIsType(displayObject)) {
                        bitmap = displayObject;
                        if (bitmap.bitmapData) {
                            this.writeBitmapData(bitmap.bitmapData);
                        }
                        return;
                    }
                    var video = null;
                    if (displayObject.sec.flash.media.Video.axClass.axIsType(displayObject)) {
                        video = displayObject;
                        if (video._netStream) {
                            this.writeNetStream(video._netStream, video._getContentBounds());
                        }
                        return;
                    }
                };
                PlayerChannelSerializer.prototype.writeDrawToBitmap = function (bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                    if (matrix === void 0) {
                        matrix = null;
                    }
                    if (colorTransform === void 0) {
                        colorTransform = null;
                    }
                    if (blendMode === void 0) {
                        blendMode = null;
                    }
                    if (clipRect === void 0) {
                        clipRect = null;
                    }
                    if (smoothing === void 0) {
                        smoothing = false;
                    }
                    this.output.writeInt(200    /* DrawToBitmap */);
                    this.output.writeInt(bitmapData._id);
                    if (bitmapData.sec.flash.display.BitmapData.axClass.axIsType(source)) {
                        this.output.writeInt(134217728    /* Asset */ | source._id);
                    } else {
                        this.output.writeInt(source._id);
                    }
                    var hasBits = 0;
                    hasBits |= matrix ? 1    /* HasMatrix */ : 0;
                    hasBits |= colorTransform ? 8    /* HasColorTransform */ : 0;
                    hasBits |= clipRect ? 16    /* HasClipRect */ : 0;
                    this.output.writeInt(hasBits);
                    if (matrix) {
                        this._writeMatrix(matrix);
                    }
                    if (colorTransform) {
                        this._writeColorTransform(colorTransform);
                    }
                    if (clipRect) {
                        this._writeRectangle(Bounds.FromRectangle(clipRect));
                    }
                    this.output.writeInt(BlendMode.toNumber(blendMode));
                    this.output.writeBoolean(smoothing);
                };
                PlayerChannelSerializer.prototype._writeMatrix = function (matrix) {
                    if (matrix.b === 0 && matrix.c === 0) {
                        if (matrix.a === 1 && matrix.d === 1) {
                            this.output.writeInt(0    /* TranslationOnly */);
                            this.output.write2Floats(matrix.tx, matrix.ty);
                        } else {
                            if (matrix.a === matrix.d) {
                                this.output.writeInt(2    /* UniformScaleAndTranslationOnly */);
                                this.output.writeFloat(matrix.a);
                            } else {
                                this.output.writeInt(1    /* ScaleAndTranslationOnly */);
                                this.output.write2Floats(matrix.a, matrix.d);
                            }
                            this.output.write2Floats(matrix.tx, matrix.ty);
                        }
                    } else {
                        this.output.writeInt(3    /* All */);
                        this.output.write6Floats(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
                    }
                };
                PlayerChannelSerializer.prototype._writeRectangle = function (bounds) {
                    var output = this.output;
                    // TODO: check if we should write bounds instead. Depends on what's more useful in GFX-land.
                    output.write4Ints(bounds.xMin, bounds.yMin, bounds.width, bounds.height);
                };
                PlayerChannelSerializer.prototype._writeAsset = function (asset) {
                    this.output.writeInt(this.outputAssets.length);
                    this.outputAssets.push(asset);
                };
                PlayerChannelSerializer.prototype._writeFilters = function (filters) {
                    if (!filters || filters.length === 0) {
                        this.output.writeInt(0);
                        return;
                    }
                    var sec = filters[0].sec;
                    var count = 0;
                    var blurFilterClass = sec.flash.filters.BlurFilter.axClass;
                    var dropShadowFilterClass = sec.flash.filters.DropShadowFilter.axClass;
                    var glowFilterClass = sec.flash.filters.GlowFilter.axClass;
                    var colorMatrixFilterClass = sec.flash.filters.ColorMatrixFilter.axClass;
                    for (var i = 0; i < filters.length; i++) {
                        if (blurFilterClass.axIsType(filters[i]) || dropShadowFilterClass.axIsType(filters[i]) || glowFilterClass.axIsType(filters[i]) || colorMatrixFilterClass.axIsType(filters[i])) {
                            count++;
                        } else {
                            Shumway.Debug.somewhatImplemented(filters[i].toString());
                        }
                    }
                    this.output.writeInt(count);
                    for (var i = 0; i < filters.length; i++) {
                        var filter = filters[i];
                        if (blurFilterClass.axIsType(filter)) {
                            var blurFilter = filter;
                            this.output.writeInt(Remoting.FilterType.Blur);
                            this.output.writeFloat(blurFilter.blurX);
                            this.output.writeFloat(blurFilter.blurY);
                            this.output.writeInt(blurFilter.quality);
                        } else if (dropShadowFilterClass.axIsType(filter)) {
                            var dropShadowFilter = filter;
                            this.output.writeInt(Remoting.FilterType.DropShadow);
                            this.output.writeFloat(dropShadowFilter.alpha);
                            this.output.writeFloat(dropShadowFilter.angle);
                            this.output.writeFloat(dropShadowFilter.blurX);
                            this.output.writeFloat(dropShadowFilter.blurY);
                            this.output.writeInt(dropShadowFilter.color);
                            this.output.writeFloat(dropShadowFilter.distance);
                            this.output.writeBoolean(dropShadowFilter.hideObject);
                            this.output.writeBoolean(dropShadowFilter.inner);
                            this.output.writeBoolean(dropShadowFilter.knockout);
                            this.output.writeInt(dropShadowFilter.quality);
                            this.output.writeFloat(dropShadowFilter.strength);
                        } else if (glowFilterClass.axIsType(filter)) {
                            var glowFilter = filter;
                            this.output.writeInt(Remoting.FilterType.DropShadow);
                            this.output.writeFloat(glowFilter.alpha);
                            this.output.writeFloat(0);
                            // angle
                            this.output.writeFloat(glowFilter.blurX);
                            this.output.writeFloat(glowFilter.blurY);
                            this.output.writeInt(glowFilter.color);
                            this.output.writeFloat(0);
                            // distance
                            this.output.writeBoolean(false);
                            // hideObject
                            this.output.writeBoolean(glowFilter.inner);
                            this.output.writeBoolean(glowFilter.knockout);
                            this.output.writeInt(glowFilter.quality);
                            this.output.writeFloat(glowFilter.strength);
                        } else if (colorMatrixFilterClass.axIsType(filter)) {
                            var matrix = filter.matrix.value;
                            this.output.writeInt(Remoting.FilterType.ColorMatrix);
                            for (var j = 0; j < 20; j++) {
                                this.output.writeFloat(matrix[j]);
                            }
                        }
                    }
                };
                PlayerChannelSerializer.prototype._writeColorTransform = function (colorTransform) {
                    var output = this.output;
                    var rM = colorTransform.redMultiplier;
                    var gM = colorTransform.greenMultiplier;
                    var bM = colorTransform.blueMultiplier;
                    var aM = colorTransform.alphaMultiplier;
                    var rO = colorTransform.redOffset;
                    var gO = colorTransform.greenOffset;
                    var bO = colorTransform.blueOffset;
                    var aO = colorTransform.alphaOffset;
                    var identityOffset = rO === gO && gO === bO && bO === aO && aO === 0;
                    var identityColorMultiplier = rM === gM && gM === bM && bM === 1;
                    if (identityOffset && identityColorMultiplier) {
                        if (aM === 1) {
                            output.writeInt(0    /* Identity */);
                        } else {
                            output.writeInt(1    /* AlphaMultiplierOnly */);
                            output.writeFloat(aM);
                        }
                    } else {
                        var zeroNonAlphaMultipliers = rM === 0 && gM === 0 && bM === 0;
                        if (zeroNonAlphaMultipliers) {
                            output.writeInt(2    /* AlphaMultiplierWithOffsets */);
                            output.writeFloat(aM);
                            output.writeInt(rO);
                            output.writeInt(gO);
                            output.writeInt(bO);
                            output.writeInt(aO);
                        } else {
                            output.writeInt(3    /* All */);
                            output.writeFloat(rM);
                            output.writeFloat(gM);
                            output.writeFloat(bM);
                            output.writeFloat(aM);
                            output.writeInt(rO);
                            output.writeInt(gO);
                            output.writeInt(bO);
                            output.writeInt(aO);
                        }
                    }
                };
                PlayerChannelSerializer.prototype.writeRequestBitmapData = function (bitmapData) {
                    writer && writer.writeLn('Sending BitmapData Request');
                    this.output.writeInt(106    /* RequestBitmapData */);
                    this.output.writeInt(bitmapData._id);
                };
                return PlayerChannelSerializer;
            }();
            Player.PlayerChannelSerializer = PlayerChannelSerializer;
            var PlayerChannelDeserializer = function () {
                function PlayerChannelDeserializer(sec, input, inputAssets) {
                    this.sec = sec;
                    this.input = input;
                    this.inputAssets = inputAssets;    // ..
                }
                PlayerChannelDeserializer.prototype.read = function () {
                    var input = this.input;
                    var tag = input.readInt();
                    switch (tag) {
                    case 300    /* MouseEvent */:
                        return this._readMouseEvent();
                    case 301    /* KeyboardEvent */:
                        return this._readKeyboardEvent();
                    case 302    /* FocusEvent */:
                        return this._readFocusEvent();
                    }
                    release || assert(false, 'Unknown MessageReader tag: ' + tag);
                };
                PlayerChannelDeserializer.prototype._readFocusEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    return {
                        tag: 302    /* FocusEvent */,
                        type: typeId
                    };
                };
                PlayerChannelDeserializer.prototype._readMouseEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    var type = Shumway.Remoting.MouseEventNames[typeId];
                    var pX = input.readFloat();
                    var pY = input.readFloat();
                    var buttons = input.readInt();
                    var flags = input.readInt();
                    return {
                        tag: 300    /* MouseEvent */,
                        type: type,
                        point: new this.sec.flash.geom.Point(pX, pY),
                        ctrlKey: !!(flags & 1    /* CtrlKey */),
                        altKey: !!(flags & 2    /* AltKey */),
                        shiftKey: !!(flags & 4    /* ShiftKey */),
                        buttons: buttons
                    };
                };
                PlayerChannelDeserializer.prototype._readKeyboardEvent = function () {
                    var input = this.input;
                    var typeId = input.readInt();
                    var type = Shumway.Remoting.KeyboardEventNames[typeId];
                    var keyCode = input.readInt();
                    var charCode = input.readInt();
                    var location = input.readInt();
                    var flags = input.readInt();
                    return {
                        tag: 301    /* KeyboardEvent */,
                        type: type,
                        keyCode: keyCode,
                        charCode: charCode,
                        location: location,
                        ctrlKey: !!(flags & 1    /* CtrlKey */),
                        altKey: !!(flags & 2    /* AltKey */),
                        shiftKey: !!(flags & 4    /* ShiftKey */)
                    };
                };
                return PlayerChannelDeserializer;
            }();
            Player.PlayerChannelDeserializer = PlayerChannelDeserializer;
        }(Player = Remoting.Player || (Remoting.Player = {})));
    }(Remoting = Shumway.Remoting || (Shumway.Remoting = {})));
    var Player;
    (function (Player_1) {
        var assert = Shumway.Debug.assert;
        var somewhatImplemented = Shumway.Debug.somewhatImplemented;
        var flash = Shumway.AVMX.AS.flash;
        var Event = flash.events.Event;
        var MouseEventDispatcher = flash.ui.MouseEventDispatcher;
        var KeyboardEventDispatcher = flash.ui.KeyboardEventDispatcher;
        /**
         * Base class implementation of the IGFXServer. The different transports shall
         * inherit this class
         */
        var GFXServiceBase = function () {
            function GFXServiceBase(sec) {
                this._observers = [];
                this.sec = sec;
            }
            GFXServiceBase.prototype.addObserver = function (observer) {
                this._observers.push(observer);
            };
            GFXServiceBase.prototype.removeObserver = function (observer) {
                var i = this._observers.indexOf(observer);
                if (i >= 0) {
                    this._observers.splice(i, 1);
                }
            };
            GFXServiceBase.prototype.update = function (updates, assets) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.updateAndGet = function (updates, assets) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.frame = function () {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.videoControl = function (id, eventType, data) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.registerFont = function (syncId, data) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.registerImage = function (syncId, symbolId, imageType, data, alphaData) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.fscommand = function (command, args) {
                throw new Error('This method is abstract');
            };
            GFXServiceBase.prototype.processUpdates = function (updates, assets) {
                var deserializer = new Shumway.Remoting.Player.PlayerChannelDeserializer(this.sec, updates, assets);
                var message = deserializer.read();
                switch (message.tag) {
                case 301    /* KeyboardEvent */:
                    this._observers.forEach(function (observer) {
                        observer.keyboardEvent(message);
                    });
                    break;
                case 300    /* MouseEvent */:
                    this._observers.forEach(function (observer) {
                        observer.mouseEvent(message);
                    });
                    break;
                case 302    /* FocusEvent */:
                    this._observers.forEach(function (observer) {
                        observer.focusEvent(message);
                    });
                    break;
                }
            };
            GFXServiceBase.prototype.processDisplayParameters = function (displayParameters) {
                this._observers.forEach(function (observer) {
                    observer.displayParameters(displayParameters);
                });
            };
            GFXServiceBase.prototype.processVideoEvent = function (id, eventType, data) {
                this._observers.forEach(function (observer) {
                    observer.videoEvent(id, eventType, data);
                });
            };
            return GFXServiceBase;
        }();
        Player_1.GFXServiceBase = GFXServiceBase;
        /**
         * Helper class to handle GFXService notifications/events and forward them to
         * the Player object.
         */
        var GFXServiceObserver = function () {
            function GFXServiceObserver(player) {
                this._videoEventListeners = [];
                this._player = player;
                this._keyboardEventDispatcher = new KeyboardEventDispatcher();
                this._mouseEventDispatcher = new MouseEventDispatcher();
                this._writer = new Shumway.IndentingWriter();
            }
            GFXServiceObserver.prototype.videoEvent = function (id, eventType, data) {
                var listener = this._videoEventListeners[id];
                Shumway.Debug.assert(listener, 'Video event listener is not found');
                listener(eventType, data);
            };
            GFXServiceObserver.prototype.displayParameters = function (displayParameters) {
                this._player._stage.setStageContainerSize(displayParameters.stageWidth, displayParameters.stageHeight, displayParameters.pixelRatio);
            };
            GFXServiceObserver.prototype.focusEvent = function (data) {
                var message = data;
                var focusType = message.type;
                switch (focusType) {
                case 0    /* DocumentHidden */:
                    this._player._isPageVisible = false;
                    break;
                case 1    /* DocumentVisible */:
                    this._player._isPageVisible = true;
                    break;
                case 2    /* WindowBlur */:
                    // TODO: This is purposely disabled so that applications don't pause when they are out of
                    // focus while the debugging window is open.
                    // EventDispatcher.broadcastEventDispatchQueue.dispatchEvent(Event.getBroadcastInstance(Event.DEACTIVATE));
                    this._player._hasFocus = false;
                    break;
                case 3    /* WindowFocus */:
                    var eventDispatcherClass = this._player.sec.flash.events.EventDispatcher.axClass;
                    var eventClass = this._player.sec.flash.events.Event.axClass;
                    eventDispatcherClass.broadcastEventDispatchQueue.dispatchEvent(eventClass.getBroadcastInstance(Event.ACTIVATE));
                    this._player._hasFocus = true;
                    break;
                }
            };
            GFXServiceObserver.prototype.keyboardEvent = function (data) {
                var message = data;
                // If the stage doesn't have a focus then dispatch events on the stage
                // directly.
                var target = this._player._stage.focus ? this._player._stage.focus : this._player._stage;
                this._keyboardEventDispatcher.target = target;
                this._keyboardEventDispatcher.dispatchKeyboardEvent(message);
            };
            GFXServiceObserver.prototype.mouseEvent = function (data) {
                var message = data;
                this._mouseEventDispatcher.stage = this._player._stage;
                var target = this._mouseEventDispatcher.handleMouseEvent(message);
                if (Shumway.traceMouseEventOption.value) {
                    this._writer.writeLn('Mouse Event: type: ' + message.type + ', point: ' + message.point + ', target: ' + target + (target ? ', name: ' + target._name : ''));
                    if (message.type === 'click' && target) {
                        target.debugTrace();
                    }
                }
                this._player.currentMouseTarget = this._mouseEventDispatcher.currentTarget;
            };
            GFXServiceObserver.prototype.registerEventListener = function (id, listener) {
                this._videoEventListeners[id] = listener;
            };
            return GFXServiceObserver;
        }();
        /**
         * Shumway Player
         *
         * This class brings everything together. Loads the swf, runs the event loop and
         * synchronizes the frame tree with the display list.
         */
        var Player = function () {
            function Player(sec, gfxService) {
                this._framesPlayed = 0;
                /**
                 * Time since the last time we've synchronized the display list.
                 */
                this._lastPumpTime = 0;
                /**
                 * Page Visibility API visible state.
                 */
                this._isPageVisible = true;
                /**
                 * Page focus state.
                 */
                this._hasFocus = true;
                /**
                 * Stage current mouse target.
                 */
                this._currentMouseTarget = null;
                /**
                 * Indicates whether the |currentMouseTarget| has changed since the last time it was synchronized.
                 */
                this._currentMouseTargetIsDirty = true;
                /**
                 * Page URL that hosts SWF.
                 */
                this._pageUrl = null;
                /**
                 * SWF URL.
                 */
                this._swfUrl = null;
                /**
                 * Loader URL, can be different from SWF URL.
                 */
                this._loaderUrl = null;
                this._crossDomainSWFLoadingWhitelist = [];
                this.sec = sec;
                sec.player = this;
                // Freeze in debug builds.
                release || Object.defineProperty(this, 'sec', { value: sec });
                release || Shumway.Debug.assert(gfxService);
                this._writer = new Shumway.IndentingWriter();
                this._gfxService = gfxService;
                this._gfxServiceObserver = new GFXServiceObserver(this);
                this._gfxService.addObserver(this._gfxServiceObserver);
            }
            Object.defineProperty(Player.prototype, 'framesPlayed', {
                get: function () {
                    return this._framesPlayed;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Player.prototype, 'currentMouseTarget', {
                set: function (value) {
                    if (this._currentMouseTarget !== value) {
                        this._currentMouseTargetIsDirty = true;
                    }
                    this._currentMouseTarget = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Player.prototype, 'stage', {
                /**
                 * Movie stage object.
                 */
                get: function () {
                    return this._stage;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Whether we can get away with rendering at a lower rate.
             */
            Player.prototype._shouldThrottleDownRendering = function () {
                return !this._isPageVisible;
            };
            /**
             * Whether we can get away with executing frames at a lower rate.
             */
            Player.prototype._shouldThrottleDownFrameExecution = function () {
                return !this._isPageVisible;
            };
            Object.defineProperty(Player.prototype, 'pageUrl', {
                get: function () {
                    return this._pageUrl;
                },
                set: function (value) {
                    this._pageUrl = value || null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Player.prototype, 'loaderUrl', {
                get: function () {
                    return this._loaderUrl;
                },
                set: function (value) {
                    this._loaderUrl = value || null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Player.prototype, 'swfUrl', {
                get: function () {
                    return this._swfUrl;
                },
                enumerable: true,
                configurable: true
            });
            Player.prototype.load = function (url, buffer) {
                release || assert(!this._loader, 'Can\'t load twice.');
                this._swfUrl = url;
                this._stage = new this.sec.flash.display.Stage();
                var loader = this._loader = this.sec.flash.display.Loader.axClass.getRootLoader();
                var loaderInfo = this._loaderInfo = loader.contentLoaderInfo;
                if (Shumway.playAllSymbolsOption.value) {
                    this._playAllSymbols();
                    loaderInfo._allowCodeExecution = false;
                } else {
                    this._enterRootLoadingLoop();
                }
                var resolvedURL = Shumway.FileLoadingService.instance.resolveUrl(url);
                this.addToSWFLoadingWhitelist(resolvedURL, false, true);
                var context = this.createLoaderContext();
                if (buffer) {
                    var byteArray = new this.sec.flash.utils.ByteArray(buffer);
                    this._loader.loadBytes(byteArray, context);
                    this._loader.contentLoaderInfo._url = resolvedURL;
                } else {
                    this._loader.load(new this.sec.flash.net.URLRequest(url), context);
                }
            };
            Player.prototype.createLoaderContext = function () {
                var loaderContext = new this.sec.flash.system.LoaderContext();
                if (this.movieParams) {
                    var parameters = this.sec.createObject();
                    for (var i in this.movieParams) {
                        parameters.axSetPublicProperty(i, this.movieParams[i]);
                    }
                    loaderContext.parameters = parameters;
                }
                return loaderContext;
            };
            Player.prototype._pumpDisplayListUpdates = function () {
                this.syncDisplayObject(this._stage, true);
            };
            Player.prototype.syncDisplayObject = function (displayObject, async) {
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                if (this.sec.flash.display.Stage.axClass.axIsType(displayObject)) {
                    var stage = displayObject;
                    serializer.writeStage(stage);
                    if (this._currentMouseTargetIsDirty) {
                        serializer.writeCurrentMouseTarget(stage, this._currentMouseTarget);
                        this._currentMouseTargetIsDirty = false;
                    }
                }
                serializer.writeDisplayObjectRoot(displayObject);
                serializer.writeEOF();
                Player_1.enterTimeline('remoting assets');
                var output;
                if (async) {
                    this._gfxService.update(serializer.output, serializer.outputAssets);
                } else {
                    output = this._gfxService.updateAndGet(serializer.output, serializer.outputAssets).clone();
                }
                Player_1.leaveTimeline('remoting assets');
                return output;
            };
            Player.prototype.requestBitmapData = function (bitmapData) {
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                serializer.writeRequestBitmapData(bitmapData);
                serializer.writeEOF();
                return this._gfxService.updateAndGet(serializer.output, serializer.outputAssets).clone();
            };
            Player.prototype.drawToBitmap = function (bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
                if (matrix === void 0) {
                    matrix = null;
                }
                if (colorTransform === void 0) {
                    colorTransform = null;
                }
                if (blendMode === void 0) {
                    blendMode = null;
                }
                if (clipRect === void 0) {
                    clipRect = null;
                }
                if (smoothing === void 0) {
                    smoothing = false;
                }
                var serializer = new Shumway.Remoting.Player.PlayerChannelSerializer();
                serializer.writeBitmapData(bitmapData);
                if (this.sec.flash.display.BitmapData.axClass.axIsType(source)) {
                    serializer.writeBitmapData(source);
                } else {
                    serializer.writeDisplayObjectRoot(source);
                }
                serializer.writeDrawToBitmap(bitmapData, source, matrix, colorTransform, blendMode, clipRect, smoothing);
                serializer.writeEOF();
                Player_1.enterTimeline('sendUpdates');
                this._gfxService.updateAndGet(serializer.output, serializer.outputAssets);
                Player_1.leaveTimeline('sendUpdates');
            };
            Player.prototype.registerEventListener = function (id, listener) {
                this._gfxServiceObserver.registerEventListener(id, listener);
            };
            Player.prototype.notifyVideoControl = function (id, eventType, data) {
                return this._gfxService.videoControl(id, eventType, data);
            };
            Player.prototype.executeFSCommand = function (command, args) {
                switch (command) {
                case 'quit':
                    this._leaveEventLoop();
                    break;
                default:
                    somewhatImplemented('FSCommand ' + command);
                }
                this._gfxService.fscommand(command, args);
            };
            Player.prototype.requestRendering = function () {
                this._pumpDisplayListUpdates();
            };
            /**
             * Update the frame container with the latest changes from the display list.
             */
            Player.prototype._pumpUpdates = function () {
                if (!Shumway.dontSkipFramesOption.value) {
                    if (this._shouldThrottleDownRendering()) {
                        return;
                    }
                    var timeSinceLastPump = performance.now() - this._lastPumpTime;
                    if (timeSinceLastPump < 1000 / Shumway.pumpRateOption.value) {
                        return;
                    }
                }
                Player_1.enterTimeline('pump');
                if (Shumway.pumpEnabledOption.value) {
                    this._pumpDisplayListUpdates();
                    this._lastPumpTime = performance.now();
                }
                Player_1.leaveTimeline('pump');
            };
            Player.prototype._leaveSyncLoop = function () {
                release || assert(this._frameTimeout > -1);
                clearInterval(this._frameTimeout);
            };
            Player.prototype._getFrameInterval = function () {
                var frameRate = Shumway.frameRateOption.value;
                if (frameRate < 0) {
                    frameRate = this._stage.frameRate;
                }
                return Math.floor(1000 / frameRate);
            };
            Player.prototype._enterEventLoop = function () {
                this._eventLoopIsRunning = true;
                var self = this;
                function tick() {
                    // TODO: change this to the mode described in
                    // http://www.craftymind.com/2008/04/18/updated-elastic-racetrack-for-flash-9-and-avm2/
                    self._frameTimeout = setTimeout(tick, self._getFrameInterval());
                    self._eventLoopTick();
                }
                if (!isNaN(this.initStartTime)) {
                    console.info('Time from init start to main event loop start: ' + (Date.now() - this.initStartTime));
                }
                tick();
            };
            Player.prototype._leaveEventLoop = function () {
                release || assert(this._eventLoopIsRunning);
                clearTimeout(this._frameTimeout);
                this._eventLoopIsRunning = false;
            };
            Player.prototype._enterRootLoadingLoop = function () {
                var self = this;
                var rootLoader = this.sec.flash.display.Loader.axClass.getRootLoader();
                rootLoader._setStage(this._stage);
                function rootLoadingLoop() {
                    var loaderInfo = rootLoader.contentLoaderInfo;
                    if (!loaderInfo._file) {
                        setTimeout(rootLoadingLoop, self._getFrameInterval());
                        return;
                    }
                    var stage = self._stage;
                    var bgcolor = self.defaultStageColor !== undefined ? self.defaultStageColor : loaderInfo._file.backgroundColor;
                    stage._loaderInfo = loaderInfo;
                    stage.align = self.stageAlign || '';
                    if (!self.stageScale || flash.display.StageScaleMode.toNumber(self.stageScale) < 0) {
                        stage.scaleMode = flash.display.StageScaleMode.SHOW_ALL;
                    } else {
                        stage.scaleMode = self.stageScale;
                    }
                    stage.frameRate = loaderInfo.frameRate;
                    stage.setStageWidth(loaderInfo.width);
                    stage.setStageHeight(loaderInfo.height);
                    stage.setStageColor(Shumway.ColorUtilities.RGBAToARGB(bgcolor));
                    if (self.displayParameters) {
                        self._gfxServiceObserver.displayParameters(self.displayParameters);
                    }
                    self._enterEventLoop();
                }
                rootLoadingLoop();
            };
            Player.prototype._eventLoopTick = function () {
                var runFrameScripts = !Shumway.playAllSymbolsOption.value;
                var dontSkipFrames = Shumway.dontSkipFramesOption.value;
                if (!dontSkipFrames && (!Shumway.frameEnabledOption.value && runFrameScripts || this._shouldThrottleDownFrameExecution())) {
                    return;
                }
                // The stage is required for frame event cycle processing.
                var displayObjectClass = this.sec.flash.display.DisplayObject.axClass;
                displayObjectClass._stage = this._stage;
                // Until the root SWF is initialized, only process Loader events.
                // Once the root loader's content is created, directly process all events again to avoid
                // further delay in initialization.
                var loaderClass = this.sec.flash.display.Loader.axClass;
                if (!loaderClass.getRootLoader().content) {
                    loaderClass.processEvents();
                    if (!loaderClass.getRootLoader().content) {
                        return;
                    }
                }
                for (var i = 0; i < Shumway.frameRateMultiplierOption.value; i++) {
                    Player_1.enterTimeline('eventLoop');
                    var start = performance.now();
                    displayObjectClass.performFrameNavigation(true, runFrameScripts);
                    Player_1.counter.count('performFrameNavigation', 1, performance.now() - start);
                    loaderClass.processEvents();
                    Player_1.leaveTimeline('eventLoop');
                }
                this._framesPlayed++;
                if (Shumway.tracePlayerOption.value > 0 && this._framesPlayed % Shumway.tracePlayerOption.value === 0) {
                    this._tracePlayer();
                }
                this._stage.render();
                this._pumpUpdates();
                this._gfxService.frame();
            };
            Player.prototype._tracePlayer = function () {
                this._writer.writeLn('Frame: ' + String(this._framesPlayed).padLeft(' ', 4) + ': ' + Shumway.IntegerUtilities.toHEX(this._stage.hashCode()) + ' ' + String(this._stage.getAncestorCount()).padLeft(' ', 4));
            };
            Player.prototype._playAllSymbols = function () {
                var stage = this._stage;
                var loader = this._loader;
                var loaderInfo = this._loaderInfo;
                var self = this;
                loaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, function onProgress() {
                    var root = loader.content;
                    if (!root) {
                        return;
                    }
                    loaderInfo.removeEventListener(flash.events.ProgressEvent.PROGRESS, onProgress);
                    self._enterEventLoop();
                });
                loaderInfo.addEventListener(flash.events.Event.COMPLETE, function onProgress() {
                    stage.setStageWidth(1024);
                    stage.setStageHeight(1024);
                    var symbols = [];
                    loaderInfo._dictionary.forEach(function (symbol, key) {
                        if (symbol instanceof Shumway.Timeline.DisplaySymbol) {
                            symbols.push(symbol);
                        }
                    });
                    function show(symbol) {
                        flash.display.DisplayObject.reset();
                        flash.display.MovieClip.reset();
                        var symbolInstance = symbol.symbolClass.initializeFrom(symbol);
                        symbol.symbolClass.instanceConstructorNoInitialize.call(symbolInstance);
                        if (symbol instanceof flash.display.BitmapSymbol) {
                            symbolInstance = new this.sec.flash.display.Bitmap(symbolInstance);
                        }
                        while (stage.numChildren > 0) {
                            stage.removeChildAt(0);
                        }
                        stage.addChild(symbolInstance);
                    }
                    var nextSymbolIndex = 0;
                    function showNextSymbol() {
                        var symbol;
                        if (Shumway.playSymbolOption.value > 0) {
                            symbol = loaderInfo.getSymbolById(Shumway.playSymbolOption.value);
                            if (symbol instanceof Shumway.Timeline.DisplaySymbol) {
                            } else {
                                symbol = null;
                            }
                        } else {
                            symbol = symbols[nextSymbolIndex++];
                            if (nextSymbolIndex === symbols.length) {
                                nextSymbolIndex = 0;
                            }
                            if (Shumway.playSymbolCountOption.value >= 0 && nextSymbolIndex > Shumway.playSymbolCountOption.value) {
                                nextSymbolIndex = 0;
                            }
                        }
                        var frames = 1;
                        if (symbol && symbol.id > 0) {
                            show(symbol);
                            if (symbol instanceof flash.display.SpriteSymbol) {
                                frames = symbol.numFrames;
                            }
                        }
                        if (Shumway.playSymbolFrameDurationOption.value > 0) {
                            frames = Shumway.playSymbolFrameDurationOption.value;
                        }
                        setTimeout(showNextSymbol, self._getFrameInterval() * frames);
                    }
                    setTimeout(showNextSymbol, self._getFrameInterval());
                });
            };
            Player.prototype.registerFont = function (symbol, data) {
                release || assert(symbol.syncId);
                symbol.resolveAssetPromise = new Shumway.PromiseWrapper();
                // TODO no need for wrapper here, change to Promise
                this._gfxService.registerFont(symbol.syncId, data).then(function (result) {
                    symbol.resolveAssetPromise.resolve(result);
                });
                // Fonts are immediately available in Firefox, so we can just mark the symbol as ready.
                if (inFirefox) {
                    symbol.ready = true;
                } else {
                    symbol.resolveAssetPromise.then(symbol.resolveAssetCallback, null);
                }
            };
            Player.prototype.registerImage = function (symbol, imageType, data, alphaData) {
                release || assert(symbol.syncId);
                symbol.resolveAssetPromise = new Shumway.PromiseWrapper();
                // TODO no need for wrapper here, change to Promise
                this._gfxService.registerImage(symbol.syncId, symbol.id, imageType, data, alphaData).then(function (result) {
                    symbol.resolveAssetPromise.resolve(result);
                });
                symbol.resolveAssetPromise.then(symbol.resolveAssetCallback, null);
            };
            Player.prototype.addToSWFLoadingWhitelist = function (domain, insecure, ownDomain) {
                if (domain.indexOf('/') < 0) {
                    this._crossDomainSWFLoadingWhitelist.push({
                        protocol: 'http:',
                        hostname: domain,
                        insecure: insecure,
                        ownDomain: ownDomain
                    });
                    return;
                }
                try {
                    var url = new window.URL(domain);
                    this._crossDomainSWFLoadingWhitelist.push({
                        protocol: url.protocol,
                        hostname: url.hostname,
                        insecure: insecure,
                        ownDomain: ownDomain
                    });
                } catch (e) {
                }
            };
            Player.prototype.checkDomainForSWFLoading = function (domain) {
                try {
                    var url = new window.URL(domain);
                } catch (e) {
                    return 2    /* Failed */;
                }
                var result = 2    /* Failed */;
                this._crossDomainSWFLoadingWhitelist.some(function (entry) {
                    var success;
                    if (url.hostname !== entry.hostname && entry.hostname !== '*') {
                        success = false;
                    } else if (entry.insecure) {
                        success = true;
                    } else {
                        // The HTTPS SWF has to be more protected than it's whitelisted HTTP equivalent.
                        success = url.protocol === 'https:' || entry.protocol !== 'https:';
                    }
                    if (success) {
                        result = entry.ownDomain ? 0    /* OwnDomain */ : 1    /* Remote */;
                        return true;
                    }
                    return false;
                }, this);
                return result;
            };
            return Player;
        }();
        Player_1.Player = Player;
    }(Player = Shumway.Player || (Shumway.Player = {})));
    var assert = Shumway.Debug.assert;
    (function (AVM2LoadLibrariesFlags) {
        AVM2LoadLibrariesFlags[AVM2LoadLibrariesFlags['Builtin'] = 1] = 'Builtin';
        AVM2LoadLibrariesFlags[AVM2LoadLibrariesFlags['Playerglobal'] = 2] = 'Playerglobal';
        AVM2LoadLibrariesFlags[AVM2LoadLibrariesFlags['Shell'] = 4] = 'Shell';
    }(Shumway.AVM2LoadLibrariesFlags || (Shumway.AVM2LoadLibrariesFlags = {})));
    var AVM2LoadLibrariesFlags = Shumway.AVM2LoadLibrariesFlags;
    function createSecurityDomain(libraries) {
        var result = new Shumway.PromiseWrapper();
        release || assert(!!(libraries & AVM2LoadLibrariesFlags.Builtin));
        Shumway.SWF.enterTimeline('Load builton.abc file');
        Shumway.SystemResourcesLoadingService.instance.load(0    /* BuiltinAbc */).then(function (buffer) {
            var sec = new Shumway.AVMX.AXSecurityDomain();
            var env = {
                url: 'builtin.abc',
                app: sec.system
            };
            var builtinABC = new Shumway.AVMX.ABCFile(env, new Uint8Array(buffer));
            sec.system.loadABC(builtinABC);
            sec.initialize();
            sec.system.executeABC(builtinABC);
            Shumway.SWF.leaveTimeline();
            //// If library is shell.abc, then just go ahead and run it now since
            //// it's not worth doing it lazily given that it is so small.
            //if (!!(libraries & AVM2LoadLibrariesFlags.Shell)) {
            //  var shellABC = new Shumway.AVMX.ABCFile(new Uint8Array(buffer));
            //  sec.system.loadAndExecuteABC(shellABC);
            //  result.resolve(sec);
            //  SystemResourcesLoadingService.instance.load(SystemResourceId.ShellAbc).then(function (buffer) {
            //    var shellABC = new Shumway.AVMX.ABCFile(new Uint8Array(buffer));
            //    sec.system.loadAndExecuteABC(shellABC);
            //    result.resolve(sec);
            //  }, result.reject);
            //  return;
            //}
            if (!!(libraries & AVM2LoadLibrariesFlags.Playerglobal)) {
                Shumway.SWF.enterTimeline('Load playerglobal files');
                return Promise.all([
                    Shumway.SystemResourcesLoadingService.instance.load(1    /* PlayerglobalAbcs */),
                    Shumway.SystemResourcesLoadingService.instance.load(2    /* PlayerglobalManifest */)
                ]).then(function (results) {
                    var catalog = new Shumway.AVMX.ABCCatalog(sec.system, new Uint8Array(results[0]), results[1]);
                    sec.addCatalog(catalog);
                    Shumway.SWF.leaveTimeline();
                    result.resolve(sec);
                }, result.reject);
            }
            result.resolve(sec);
        }, result.reject);
        return result.promise;
    }
    Shumway.createSecurityDomain = createSecurityDomain;
}(Shumway || (Shumway = {})));
/**
 * Copyright 2015 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Shumway;
(function (Shumway) {
    var Player;
    (function (Player) {
        var ShumwayComExternalInterface = function () {
            function ShumwayComExternalInterface() {
            }
            Object.defineProperty(ShumwayComExternalInterface.prototype, 'enabled', {
                get: function () {
                    return true;
                },
                enumerable: true,
                configurable: true
            });
            ShumwayComExternalInterface.prototype.initJS = function (callback) {
                ShumwayCom.externalCom({ action: 'init' });
                ShumwayCom.setExternalCallback(function (call) {
                    return callback(call.functionName, call.args);
                });
                this._externalCallback = callback;
            };
            ShumwayComExternalInterface.prototype.registerCallback = function (functionName) {
                var cmd = {
                    action: 'register',
                    functionName: functionName,
                    remove: false
                };
                ShumwayCom.externalCom(cmd);
            };
            ShumwayComExternalInterface.prototype.unregisterCallback = function (functionName) {
                var cmd = {
                    action: 'register',
                    functionName: functionName,
                    remove: true
                };
                ShumwayCom.externalCom(cmd);
            };
            ShumwayComExternalInterface.prototype.eval = function (expression) {
                var cmd = {
                    action: 'eval',
                    expression: expression
                };
                return ShumwayCom.externalCom(cmd);
            };
            ShumwayComExternalInterface.prototype.call = function (request) {
                var cmd = {
                    action: 'call',
                    request: request
                };
                return ShumwayCom.externalCom(cmd);
            };
            ShumwayComExternalInterface.prototype.getId = function () {
                var cmd = { action: 'getId' };
                return ShumwayCom.externalCom(cmd);
            };
            return ShumwayComExternalInterface;
        }();
        Player.ShumwayComExternalInterface = ShumwayComExternalInterface;
        var ShumwayComFileLoadingService = function () {
            function ShumwayComFileLoadingService() {
                this._baseUrl = null;
                this._nextSessionId = 1;
                // 0 - is reserved
                this._sessions = [];
            }
            ShumwayComFileLoadingService.prototype.init = function (baseUrl) {
                this._baseUrl = baseUrl;
                var service = this;
                ShumwayCom.setLoadFileCallback(function (args) {
                    var session = service._sessions[args.sessionId];
                    if (session) {
                        service._notifySession(session, args);
                    }
                });
            };
            ShumwayComFileLoadingService.prototype._notifySession = function (session, args) {
                var sessionId = args.sessionId;
                switch (args.topic) {
                case 'open':
                    session.onopen();
                    break;
                case 'close':
                    session.onclose();
                    this._sessions[sessionId] = null;
                    console.log('Session #' + sessionId + ': closed');
                    break;
                case 'error':
                    session.onerror && session.onerror(args.error);
                    break;
                case 'progress':
                    console.log('Session #' + sessionId + ': loaded ' + args.loaded + '/' + args.total);
                    var data = args.array;
                    if (!(data instanceof Uint8Array)) {
                        data = new Uint8Array(data);
                    }
                    session.onprogress && session.onprogress(data, {
                        bytesLoaded: args.loaded,
                        bytesTotal: args.total
                    });
                    break;
                }
            };
            ShumwayComFileLoadingService.prototype.createSession = function () {
                var sessionId = this._nextSessionId++;
                var service = this;
                var session = {
                    open: function (request) {
                        var path = service.resolveUrl(request.url);
                        console.log('Session #' + sessionId + ': loading ' + path);
                        ShumwayCom.loadFile({
                            url: path,
                            method: request.method,
                            mimeType: request.mimeType,
                            postData: request.data,
                            checkPolicyFile: request.checkPolicyFile,
                            sessionId: sessionId
                        });
                    },
                    close: function () {
                        if (service._sessions[sessionId]) {
                            ShumwayCom.abortLoad(sessionId);
                        }
                    }
                };
                return this._sessions[sessionId] = session;
            };
            ShumwayComFileLoadingService.prototype.resolveUrl = function (url) {
                return new window.URL(url, this._baseUrl).href;
            };
            ShumwayComFileLoadingService.prototype.navigateTo = function (url, target) {
                ShumwayCom.navigateTo({
                    url: this.resolveUrl(url),
                    target: target
                });
            };
            return ShumwayComFileLoadingService;
        }();
        Player.ShumwayComFileLoadingService = ShumwayComFileLoadingService;
        var ShumwayComClipboardService = function () {
            function ShumwayComClipboardService() {
            }
            ShumwayComClipboardService.prototype.setClipboard = function (data) {
                ShumwayCom.setClipboard(data);
            };
            return ShumwayComClipboardService;
        }();
        Player.ShumwayComClipboardService = ShumwayComClipboardService;
        var ShumwayComTelemetryService = function () {
            function ShumwayComTelemetryService() {
            }
            ShumwayComTelemetryService.prototype.reportTelemetry = function (data) {
                ShumwayCom.reportTelemetry(data);
            };
            return ShumwayComTelemetryService;
        }();
        Player.ShumwayComTelemetryService = ShumwayComTelemetryService;
        var BrowserFileLoadingService = function () {
            function BrowserFileLoadingService() {
            }
            BrowserFileLoadingService.prototype.createSession = function () {
                var service = this;
                var reader;
                return {
                    open: function (request) {
                        var self = this;
                        var path = service.resolveUrl(request.url);
                        console.log('FileLoadingService: loading ' + path + ', data: ' + request.data);
                        reader = new Shumway.BinaryFileReader(path, request.method, request.mimeType, request.data);
                        reader.readChunked(service._fileReadChunkSize, function (data, progress) {
                            self.onprogress(data, {
                                bytesLoaded: progress.loaded,
                                bytesTotal: progress.total
                            });
                        }, function (e) {
                            self.onerror(e);
                        }, self.onopen, self.onclose, self.onhttpstatus);
                    },
                    close: function () {
                        reader.abort();
                        reader = null;
                    }
                };
            };
            BrowserFileLoadingService.prototype.init = function (baseUrl, fileReadChunkSize) {
                if (fileReadChunkSize === void 0) {
                    fileReadChunkSize = 0;
                }
                this._baseUrl = baseUrl;
                this._fileReadChunkSize = fileReadChunkSize;
            };
            BrowserFileLoadingService.prototype.resolveUrl = function (url) {
                return new window.URL(url, this._baseUrl).href;
            };
            BrowserFileLoadingService.prototype.navigateTo = function (url, target) {
                window.open(this.resolveUrl(url), target || '_blank');
            };
            return BrowserFileLoadingService;
        }();
        Player.BrowserFileLoadingService = BrowserFileLoadingService;
        var ShumwayComResourcesLoadingService = function () {
            function ShumwayComResourcesLoadingService(preload) {
                this._pendingPromises = [];
                if (preload) {
                    this.load(0    /* BuiltinAbc */);
                    this.load(1    /* PlayerglobalAbcs */);
                    this.load(2    /* PlayerglobalManifest */);
                }
                ShumwayCom.setSystemResourceCallback(this._onSystemResourceCallback.bind(this));
            }
            ShumwayComResourcesLoadingService.prototype._onSystemResourceCallback = function (id, data) {
                this._pendingPromises[id].resolve(data);
            };
            ShumwayComResourcesLoadingService.prototype.load = function (id) {
                var result = this._pendingPromises[id];
                if (!result) {
                    result = new Shumway.PromiseWrapper();
                    this._pendingPromises[id] = result;
                    ShumwayCom.loadSystemResource(id);
                }
                return result.promise;
            };
            return ShumwayComResourcesLoadingService;
        }();
        Player.ShumwayComResourcesLoadingService = ShumwayComResourcesLoadingService;
        var BrowserSystemResourcesLoadingService = function () {
            function BrowserSystemResourcesLoadingService(builtinPath, viewerPlayerglobalInfo, shellPath) {
                this.builtinPath = builtinPath;
                this.viewerPlayerglobalInfo = viewerPlayerglobalInfo;
                this.shellPath = shellPath;
            }
            BrowserSystemResourcesLoadingService.prototype.load = function (id) {
                switch (id) {
                case 0    /* BuiltinAbc */:
                    return this._promiseFile(this.builtinPath, 'arraybuffer');
                case 1    /* PlayerglobalAbcs */:
                    return this._promiseFile(this.viewerPlayerglobalInfo.abcs, 'arraybuffer');
                case 2    /* PlayerglobalManifest */:
                    return this._promiseFile(this.viewerPlayerglobalInfo.catalog, 'json');
                case 3    /* ShellAbc */:
                    return this._promiseFile(this.shellPath, 'arraybuffer');
                default:
                    return Promise.reject(new Error('Unsupported system resource id: ' + id));
                }
            };
            BrowserSystemResourcesLoadingService.prototype._promiseFile = function (path, responseType) {
                return new Promise(function (resolve, reject) {
                    Shumway.SWF.enterTimeline('Load file', path);
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', path);
                    xhr.responseType = responseType;
                    xhr.onload = function () {
                        Shumway.SWF.leaveTimeline();
                        var response = xhr.response;
                        if (response) {
                            if (responseType === 'json' && xhr.responseType !== 'json') {
                                // some browsers (e.g. Safari) have no idea what json is
                                response = JSON.parse(response);
                            }
                            resolve(response);
                        } else {
                            reject('Unable to load ' + path + ': ' + xhr.statusText);
                        }
                    };
                    xhr.onerror = function () {
                        Shumway.SWF.leaveTimeline();
                        reject('Unable to load: xhr error');
                    };
                    xhr.send();
                });
            };
            return BrowserSystemResourcesLoadingService;
        }();
        Player.BrowserSystemResourcesLoadingService = BrowserSystemResourcesLoadingService;
        function qualifyLocalConnectionName(connectionName, assertNoPrefix) {
            release || Shumway.Debug.assert(typeof connectionName === 'string');
            // Connection names that don't start with "_" must be qualified with a domain prefix,
            // followed by ":". The prefix is supplied automatically based on the currently running
            // script. Only for LocalConnection#send is it allowed to already be contained in the name.
            if (!release && assertNoPrefix) {
                Shumway.Debug.assert(connectionName.indexOf(':') === -1);
            }
            if (connectionName[0] !== '_') {
                if (connectionName.indexOf(':') === -1) {
                    var currentURL = new jsGlobal.URL(Shumway.AVMX.getCurrentABC().env.url);
                    connectionName = currentURL.hostname + ':' + connectionName;
                }
                // Note: for LocalConnection#send, the name can contain an arbitrary number of ":" chars,
                // so no validity check is required.
                if (!release && assertNoPrefix) {
                    Shumway.Debug.assert(connectionName.split(':').length === 2);
                }
            }
            return connectionName;
        }
        /**
         * Creates a proper error object in the given SecurityDomain and fills it with information in
         * a way that makes it resemble the given (probably error) object as closely as possible while
         * at the same time guaranteeing that no code will be executed as a result of reading
         * properties of the object. Additionally, the created object can only be one of the builtin
         * Error classes.
         */
        function createErrorFromUnknownObject(sec, obj, defaultErrorClassName, defaultErrorInfo) {
            if (!obj || typeof obj !== 'object') {
                return sec.createError(defaultErrorClassName, defaultErrorInfo, obj);
            }
            var mn = obj.axClass ? obj.axClass.name : Shumway.AVMX.Multiname.FromFQNString('Error', 0    /* Public */);
            var axClass = sec.system.getProperty(mn, true, true);
            if (!sec.AXClass.axIsType(axClass)) {
                mn = Shumway.AVMX.Multiname.FromFQNString('Error', 0    /* Public */);
                axClass = sec.system.getProperty(mn, true, true);
                release || Shumway.Debug.assert(sec.AXClass.axIsType(axClass));
            }
            var messagePropDesc = Shumway.ObjectUtilities.getPropertyDescriptor(obj, '$Bgmessage');
            var message = messagePropDesc && messagePropDesc.value || '';
            var idPropDesc = Shumway.ObjectUtilities.getPropertyDescriptor(obj, '_errorID');
            var id = idPropDesc && idPropDesc.value || 0;
            return axClass.axConstruct([
                message,
                id
            ]);
        }
        var BaseLocalConnectionService = function () {
            function BaseLocalConnectionService() {
                this._localConnections = Object.create(null);
            }
            BaseLocalConnectionService.prototype.createConnection = function (connectionName, receiver) {
                return undefined;
            };
            BaseLocalConnectionService.prototype.closeConnection = function (connectionName, receiver) {
                return undefined;
            };
            BaseLocalConnectionService.prototype.hasConnection = function (connectionName) {
                return false;
            };
            BaseLocalConnectionService.prototype._sendMessage = function (connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure) {
                return undefined;
            };
            BaseLocalConnectionService.prototype.send = function (connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure) {
                connectionName = qualifyLocalConnectionName(connectionName, false);
                release || Shumway.Debug.assert(typeof methodName === 'string');
                release || Shumway.Debug.assert(argsBuffer instanceof ArrayBuffer);
                var self = this;
                function invokeMessageHandler() {
                    var status = self.hasConnection(connectionName) ? 'status' : 'error';
                    var statusEvent = new sender.sec.flash.events.StatusEvent('status', false, false, null, status);
                    try {
                        sender.dispatchEvent(statusEvent);
                    } catch (e) {
                        console.warn('Exception encountered during statusEvent handling in LocalConnection' + ' sender.', e);
                    }
                    if (status === 'error') {
                        // If no receiver is found for the connectionName, we're done.
                        return;
                    }
                    release || Shumway.Debug.assert(typeof senderDomain === 'string');
                    release || Shumway.Debug.assert(typeof senderIsSecure === 'boolean');
                    self._sendMessage(connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure);
                }
                Promise.resolve(true).then(invokeMessageHandler);
            };
            BaseLocalConnectionService.prototype.allowDomains = function (connectionName, receiver, domains, secure) {
                Shumway.Debug.somewhatImplemented('LocalConnection#allowDomain');
            };
            return BaseLocalConnectionService;
        }();
        Player.BaseLocalConnectionService = BaseLocalConnectionService;
        var ShumwayComLocalConnectionService = function (_super) {
            __extends(ShumwayComLocalConnectionService, _super);
            function ShumwayComLocalConnectionService() {
                _super.apply(this, arguments);
            }
            ShumwayComLocalConnectionService.prototype.createConnection = function (connectionName, receiver) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                release || Shumway.Debug.assert(receiver);
                if (this.hasConnection(connectionName)) {
                    return -2    /* AlreadyTaken */;
                }
                function callback(methodName, argsBuffer) {
                    try {
                        receiver.handleMessage(methodName, argsBuffer);
                        return null;
                    } catch (e) {
                        console.log('error under handleMessage: ', e);
                        return e;
                    }
                }
                var result = ShumwayCom.getLocalConnectionService().createLocalConnection(connectionName, callback);
                if (result !== 0    /* Success */) {
                    return result;
                }
                this._localConnections[connectionName] = receiver;
                return 0    /* Success */;
            };
            ShumwayComLocalConnectionService.prototype.closeConnection = function (connectionName, receiver) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                if (this._localConnections[connectionName] !== receiver) {
                    return -1    /* NotConnected */;
                }
                ShumwayCom.getLocalConnectionService().closeLocalConnection(connectionName);
                delete this._localConnections[connectionName];
                return 0    /* Success */;
            };
            ShumwayComLocalConnectionService.prototype.hasConnection = function (connectionName) {
                return ShumwayCom.getLocalConnectionService().hasLocalConnection(connectionName);
            };
            ShumwayComLocalConnectionService.prototype._sendMessage = function (connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure) {
                var service = ShumwayCom.getLocalConnectionService();
                service.sendLocalConnectionMessage(connectionName, methodName, argsBuffer, sender, senderDomain, senderIsSecure);
            };
            ShumwayComLocalConnectionService.prototype.allowDomains = function (connectionName, receiver, domains, secure) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                if (this._localConnections[connectionName] !== receiver) {
                    console.warn('Trying to allow domains for invalid connection ' + connectionName);
                    return;
                }
                ShumwayCom.getLocalConnectionService().allowDomainsForLocalConnection(connectionName, domains, secure);
            };
            return ShumwayComLocalConnectionService;
        }(BaseLocalConnectionService);
        Player.ShumwayComLocalConnectionService = ShumwayComLocalConnectionService;
        var PlayerInternalLocalConnectionService = function (_super) {
            __extends(PlayerInternalLocalConnectionService, _super);
            function PlayerInternalLocalConnectionService() {
                _super.apply(this, arguments);
            }
            PlayerInternalLocalConnectionService.prototype.createConnection = function (connectionName, receiver) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                release || Shumway.Debug.assert(receiver);
                if (this._localConnections[connectionName]) {
                    return -2    /* AlreadyTaken */;
                }
                this._localConnections[connectionName] = receiver;
                return 0    /* Success */;
            };
            PlayerInternalLocalConnectionService.prototype.closeConnection = function (connectionName, receiver) {
                connectionName = qualifyLocalConnectionName(connectionName, true);
                if (this._localConnections[connectionName] !== receiver) {
                    return -1    /* NotConnected */;
                }
                delete this._localConnections[connectionName];
                return 0    /* Success */;
            };
            PlayerInternalLocalConnectionService.prototype.hasConnection = function (connectionName) {
                return connectionName in this._localConnections;
            };
            PlayerInternalLocalConnectionService.prototype._sendMessage = function (connectionName, methodName, argsBuffer, sender, senderURL) {
                var receiver = this._localConnections[connectionName];
                release || Shumway.Debug.assert(receiver);
                try {
                    receiver.handleMessage(methodName, argsBuffer);
                } catch (e) {
                    Shumway.Debug.warning('Unexpected error encountered while sending LocalConnection message.');
                }
            };
            return PlayerInternalLocalConnectionService;
        }(BaseLocalConnectionService);
        Player.PlayerInternalLocalConnectionService = PlayerInternalLocalConnectionService;
    }(Player = Shumway.Player || (Shumway.Player = {})));
    var Player;
    (function (Player_2) {
        var Window;
        (function (Window) {
            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
            var WindowGFXService = function (_super) {
                __extends(WindowGFXService, _super);
                function WindowGFXService(sec, peer) {
                    _super.call(this, sec);
                    this._peer = peer;
                    this._peer.onAsyncMessage = function (msg) {
                        this.onWindowMessage(msg);
                    }.bind(this);
                    this._assetDecodingRequests = [];
                }
                WindowGFXService.prototype.update = function (updates, assets) {
                    var bytes = updates.getBytes();
                    var message = {
                        type: 'player',
                        updates: bytes,
                        assets: assets,
                        result: undefined
                    };
                    var transferList = [bytes.buffer];
                    this._peer.postAsyncMessage(message, transferList);
                };
                WindowGFXService.prototype.updateAndGet = function (updates, assets) {
                    var bytes = updates.getBytes();
                    var message = {
                        type: 'player',
                        updates: bytes,
                        assets: assets,
                        result: undefined
                    };
                    var result = this._peer.sendSyncMessage(message);
                    return DataBuffer.FromPlainObject(result);
                };
                WindowGFXService.prototype.frame = function () {
                    this._peer.postAsyncMessage({ type: 'frame' });
                };
                WindowGFXService.prototype.videoControl = function (id, eventType, data) {
                    var message = {
                        type: 'videoControl',
                        id: id,
                        eventType: eventType,
                        data: data,
                        result: undefined
                    };
                    return this._peer.sendSyncMessage(message);
                };
                WindowGFXService.prototype.registerFont = function (syncId, data) {
                    var requestId = this._assetDecodingRequests.length;
                    var result = new Shumway.PromiseWrapper();
                    this._assetDecodingRequests[requestId] = result;
                    var message = {
                        type: 'registerFont',
                        syncId: syncId,
                        data: data,
                        requestId: requestId
                    };
                    // Unfortunately we have to make this message synchronously since scripts in the same frame
                    // might rely on it being available in the gfx backend when requesting text measurements.
                    // Just another disadvantage of not doing our our own text shaping.
                    this._peer.sendSyncMessage(message);
                    return result.promise;
                };
                WindowGFXService.prototype.registerImage = function (syncId, symbolId, imageType, data, alphaData) {
                    var requestId = this._assetDecodingRequests.length;
                    var result = new Shumway.PromiseWrapper();
                    this._assetDecodingRequests[requestId] = result;
                    var message = {
                        type: 'registerImage',
                        syncId: syncId,
                        symbolId: symbolId,
                        imageType: imageType,
                        data: data,
                        alphaData: alphaData,
                        requestId: requestId
                    };
                    this._peer.postAsyncMessage(message);
                    return result.promise;
                };
                WindowGFXService.prototype.fscommand = function (command, args) {
                    this._peer.postAsyncMessage({
                        type: 'fscommand',
                        command: command,
                        args: args
                    });
                };
                WindowGFXService.prototype.onWindowMessage = function (data) {
                    if (typeof data === 'object' && data !== null) {
                        switch (data.type) {
                        case 'gfx':
                            var DataBuffer = Shumway.ArrayUtilities.DataBuffer;
                            var updates = DataBuffer.FromArrayBuffer(data.updates.buffer);
                            this.processUpdates(updates, data.assets);
                            break;
                        case 'videoPlayback':
                            this.processVideoEvent(data.id, data.eventType, data.data);
                            break;
                        case 'displayParameters':
                            this.processDisplayParameters(data.params);
                            break;
                        case 'registerFontResponse':
                        case 'registerImageResponse':
                            var request = this._assetDecodingRequests[data.requestId];
                            release || Shumway.Debug.assert(request);
                            delete this._assetDecodingRequests[data.requestId];
                            request.resolve(data.result);
                            break;
                        case 'options':
                            Shumway.Settings.setSettings(data.settings);
                            break;
                        }
                    }
                };
                return WindowGFXService;
            }(Player_2.GFXServiceBase);
            Window.WindowGFXService = WindowGFXService;
        }(Window = Player_2.Window || (Player_2.Window = {})));
    }(Player = Shumway.Player || (Shumway.Player = {})));
}(Shumway || (Shumway = {})));
/*
 * Copyright 2014 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference path='../../build/ts/base.d.ts' />
/// <reference path='../../build/ts/tools.d.ts' />
/// <reference path='../../build/ts/swf.d.ts' />
/// <reference path='../../build/ts/flash.d.ts' />
/// <reference path='../flash/avm1.d.ts' />
///<reference path='module.ts' />
///<reference path='settings.ts' />
///<reference path='frameScheduler.ts' />
///<reference path='remotingPlayer.ts' />
///<reference path='player.ts' />
///<reference path='avmLoader.ts' />
///<reference path='external.ts' />
///<reference path='window/windowPlayer.ts' />
//# sourceMappingURL=player.js.map
console.timeEnd('Load Player Dependencies');